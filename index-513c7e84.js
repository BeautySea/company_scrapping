var XS = Object.defineProperty;
var QS = (t, e, n) => e in t ? XS(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var V = (t, e, n) => (QS(t, typeof e != "symbol" ? e + "" : e, n),
n);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const a of document.querySelectorAll('link[rel="modulepreload"]'))
        r(a);
    new MutationObserver(a => {
        for (const s of a)
            if (s.type === "childList")
                for (const l of s.addedNodes)
                    l.tagName === "LINK" && l.rel === "modulepreload" && r(l)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(a) {
        const s = {};
        return a.integrity && (s.integrity = a.integrity),
        a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy),
        a.crossOrigin === "use-credentials" ? s.credentials = "include" : a.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function r(a) {
        if (a.ep)
            return;
        a.ep = !0;
        const s = n(a);
        fetch(a.href, s)
    }
}
)();
/**
* @vue/shared v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function Mh(t, e) {
    const n = new Set(t.split(","));
    return e ? r => n.has(r.toLowerCase()) : r => n.has(r)
}
const jt = {}
  , zl = []
  , rr = () => {}
  , ZS = () => !1
  , Nd = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97)
  , Oh = t => t.startsWith("onUpdate:")
  , rn = Object.assign
  , Nh = (t, e) => {
    const n = t.indexOf(e);
    n > -1 && t.splice(n, 1)
}
  , e$ = Object.prototype.hasOwnProperty
  , bt = (t, e) => e$.call(t, e)
  , Ge = Array.isArray
  , ql = t => Uo(t) === "[object Map]"
  , xi = t => Uo(t) === "[object Set]"
  , Sv = t => Uo(t) === "[object Date]"
  , et = t => typeof t == "function"
  , Yt = t => typeof t == "string"
  , Ca = t => typeof t == "symbol"
  , It = t => t !== null && typeof t == "object"
  , Py = t => (It(t) || et(t)) && et(t.then) && et(t.catch)
  , Fy = Object.prototype.toString
  , Uo = t => Fy.call(t)
  , t$ = t => Uo(t).slice(8, -1)
  , By = t => Uo(t) === "[object Object]"
  , Dh = t => Yt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t
  , Xi = Mh(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , Dd = t => {
    const e = Object.create(null);
    return n => e[n] || (e[n] = t(n))
}
  , n$ = /-(\w)/g
  , la = Dd(t => t.replace(n$, (e, n) => n ? n.toUpperCase() : ""))
  , r$ = /\B([A-Z])/g
  , fl = Dd(t => t.replace(r$, "-$1").toLowerCase())
  , Pd = Dd(t => t.charAt(0).toUpperCase() + t.slice(1))
  , Bc = Dd(t => t ? `on${Pd(t)}` : "")
  , ms = (t, e) => !Object.is(t, e)
  , Cu = (t, e) => {
    for (let n = 0; n < t.length; n++)
        t[n](e)
}
  , Vy = (t, e, n) => {
    Object.defineProperty(t, e, {
        configurable: !0,
        enumerable: !1,
        value: n
    })
}
  , Lu = t => {
    const e = parseFloat(t);
    return isNaN(e) ? t : e
}
  , a$ = t => {
    const e = Yt(t) ? Number(t) : NaN;
    return isNaN(e) ? t : e
}
;
let $v;
const Iy = () => $v || ($v = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Rt(t) {
    if (Ge(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n]
              , a = Yt(r) ? o$(r) : Rt(r);
            if (a)
                for (const s in a)
                    e[s] = a[s]
        }
        return e
    } else if (Yt(t) || It(t))
        return t
}
const s$ = /;(?![^(]*\))/g
  , l$ = /:([^]+)/
  , i$ = /\/\*[^]*?\*\//g;
function o$(t) {
    const e = {};
    return t.replace(i$, "").split(s$).forEach(n => {
        if (n) {
            const r = n.split(l$);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }
    ),
    e
}
function ye(t) {
    let e = "";
    if (Yt(t))
        e = t;
    else if (Ge(t))
        for (let n = 0; n < t.length; n++) {
            const r = ye(t[n]);
            r && (e += r + " ")
        }
    else if (It(t))
        for (const n in t)
            t[n] && (e += n + " ");
    return e.trim()
}
function ut(t) {
    if (!t)
        return null;
    let {class: e, style: n} = t;
    return e && !Yt(e) && (t.class = ye(e)),
    n && (t.style = Rt(n)),
    t
}
const u$ = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , d$ = Mh(u$);
function Ry(t) {
    return !!t || t === ""
}
function c$(t, e) {
    if (t.length !== e.length)
        return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++)
        n = al(t[r], e[r]);
    return n
}
function al(t, e) {
    if (t === e)
        return !0;
    let n = Sv(t)
      , r = Sv(e);
    if (n || r)
        return n && r ? t.getTime() === e.getTime() : !1;
    if (n = Ca(t),
    r = Ca(e),
    n || r)
        return t === e;
    if (n = Ge(t),
    r = Ge(e),
    n || r)
        return n && r ? c$(t, e) : !1;
    if (n = It(t),
    r = It(e),
    n || r) {
        if (!n || !r)
            return !1;
        const a = Object.keys(t).length
          , s = Object.keys(e).length;
        if (a !== s)
            return !1;
        for (const l in t) {
            const i = t.hasOwnProperty(l)
              , o = e.hasOwnProperty(l);
            if (i && !o || !i && o || !al(t[l], e[l]))
                return !1
        }
    }
    return String(t) === String(e)
}
function Ph(t, e) {
    return t.findIndex(n => al(n, e))
}
const Q = t => Yt(t) ? t : t == null ? "" : Ge(t) || It(t) && (t.toString === Fy || !et(t.toString)) ? JSON.stringify(t, Ly, 2) : String(t)
  , Ly = (t, e) => e && e.__v_isRef ? Ly(t, e.value) : ql(e) ? {
    [`Map(${e.size})`]: [...e.entries()].reduce( (n, [r,a], s) => (n[Vc(r, s) + " =>"] = a,
    n), {})
} : xi(e) ? {
    [`Set(${e.size})`]: [...e.values()].map(n => Vc(n))
} : Ca(e) ? Vc(e) : It(e) && !Ge(e) && !By(e) ? String(e) : e
  , Vc = (t, e="") => {
    var n;
    return Ca(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t
}
;
/**
* @vue/reactivity v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let tr;
class jy {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this.parent = tr,
        !e && tr && (this.index = (tr.scopes || (tr.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = tr;
            try {
                return tr = this,
                e()
            } finally {
                tr = n
            }
        }
    }
    on() {
        tr = this
    }
    off() {
        tr = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0,
            r = this.effects.length; n < r; n++)
                this.effects[n].stop();
            for (n = 0,
            r = this.cleanups.length; n < r; n++)
                this.cleanups[n]();
            if (this.scopes)
                for (n = 0,
                r = this.scopes.length; n < r; n++)
                    this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const a = this.parent.scopes.pop();
                a && a !== this && (this.parent.scopes[this.index] = a,
                a.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function Fd(t) {
    return new jy(t)
}
function f$(t, e=tr) {
    e && e.active && e.effects.push(t)
}
function Ho() {
    return tr
}
function Bd(t) {
    tr && tr.cleanups.push(t)
}
let qs;
class Fh {
    constructor(e, n, r, a) {
        this.fn = e,
        this.trigger = n,
        this.scheduler = r,
        this.active = !0,
        this.deps = [],
        this._dirtyLevel = 4,
        this._trackId = 0,
        this._runnings = 0,
        this._shouldSchedule = !1,
        this._depsLength = 0,
        f$(this, a)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1,
            ws();
            for (let e = 0; e < this._depsLength; e++) {
                const n = this.deps[e];
                if (n.computed && (p$(n.computed),
                this._dirtyLevel >= 4))
                    break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0),
            xs()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(e) {
        this._dirtyLevel = e ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0,
        !this.active)
            return this.fn();
        let e = ss
          , n = qs;
        try {
            return ss = !0,
            qs = this,
            this._runnings++,
            Tv(this),
            this.fn()
        } finally {
            Cv(this),
            this._runnings--,
            qs = n,
            ss = e
        }
    }
    stop() {
        var e;
        this.active && (Tv(this),
        Cv(this),
        (e = this.onStop) == null || e.call(this),
        this.active = !1)
    }
}
function p$(t) {
    return t.value
}
function Tv(t) {
    t._trackId++,
    t._depsLength = 0
}
function Cv(t) {
    if (t.deps.length > t._depsLength) {
        for (let e = t._depsLength; e < t.deps.length; e++)
            Uy(t.deps[e], t);
        t.deps.length = t._depsLength
    }
}
function Uy(t, e) {
    const n = t.get(e);
    n !== void 0 && e._trackId !== n && (t.delete(e),
    t.size === 0 && t.cleanup())
}
let ss = !0
  , ep = 0;
const Hy = [];
function ws() {
    Hy.push(ss),
    ss = !1
}
function xs() {
    const t = Hy.pop();
    ss = t === void 0 ? !0 : t
}
function Bh() {
    ep++
}
function Vh() {
    for (ep--; !ep && tp.length; )
        tp.shift()()
}
function Ky(t, e, n) {
    if (e.get(t) !== t._trackId) {
        e.set(t, t._trackId);
        const r = t.deps[t._depsLength];
        r !== e ? (r && Uy(r, t),
        t.deps[t._depsLength++] = e) : t._depsLength++
    }
}
const tp = [];
function zy(t, e, n) {
    Bh();
    for (const r of t.keys()) {
        let a;
        r._dirtyLevel < e && (a ?? (a = t.get(r) === r._trackId)) && (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0),
        r._dirtyLevel = e),
        r._shouldSchedule && (a ?? (a = t.get(r) === r._trackId)) && (r.trigger(),
        (!r._runnings || r.allowRecurse) && r._dirtyLevel !== 2 && (r._shouldSchedule = !1,
        r.scheduler && tp.push(r.scheduler)))
    }
    Vh()
}
const qy = (t, e) => {
    const n = new Map;
    return n.cleanup = t,
    n.computed = e,
    n
}
  , ju = new WeakMap
  , Ws = Symbol("")
  , np = Symbol("");
function Zn(t, e, n) {
    if (ss && qs) {
        let r = ju.get(t);
        r || ju.set(t, r = new Map);
        let a = r.get(n);
        a || r.set(n, a = qy( () => r.delete(n))),
        Ky(qs, a)
    }
}
function $a(t, e, n, r, a, s) {
    const l = ju.get(t);
    if (!l)
        return;
    let i = [];
    if (e === "clear")
        i = [...l.values()];
    else if (n === "length" && Ge(t)) {
        const o = Number(r);
        l.forEach( (u, d) => {
            (d === "length" || !Ca(d) && d >= o) && i.push(u)
        }
        )
    } else
        switch (n !== void 0 && i.push(l.get(n)),
        e) {
        case "add":
            Ge(t) ? Dh(n) && i.push(l.get("length")) : (i.push(l.get(Ws)),
            ql(t) && i.push(l.get(np)));
            break;
        case "delete":
            Ge(t) || (i.push(l.get(Ws)),
            ql(t) && i.push(l.get(np)));
            break;
        case "set":
            ql(t) && i.push(l.get(Ws));
            break
        }
    Bh();
    for (const o of i)
        o && zy(o, 4);
    Vh()
}
function h$(t, e) {
    var n;
    return (n = ju.get(t)) == null ? void 0 : n.get(e)
}
const m$ = Mh("__proto__,__v_isRef,__isVue")
  , Wy = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(Ca))
  , Ev = v$();
function v$() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...n) {
            const r = vt(this);
            for (let s = 0, l = this.length; s < l; s++)
                Zn(r, "get", s + "");
            const a = r[e](...n);
            return a === -1 || a === !1 ? r[e](...n.map(vt)) : a
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...n) {
            ws(),
            Bh();
            const r = vt(this)[e].apply(this, n);
            return Vh(),
            xs(),
            r
        }
    }
    ),
    t
}
function g$(t) {
    Ca(t) || (t = String(t));
    const e = vt(this);
    return Zn(e, "has", t),
    e.hasOwnProperty(t)
}
class Gy {
    constructor(e=!1, n=!1) {
        this._isReadonly = e,
        this._isShallow = n
    }
    get(e, n, r) {
        const a = this._isReadonly
          , s = this._isShallow;
        if (n === "__v_isReactive")
            return !a;
        if (n === "__v_isReadonly")
            return a;
        if (n === "__v_isShallow")
            return s;
        if (n === "__v_raw")
            return r === (a ? s ? e1 : Zy : s ? Qy : Xy).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
        const l = Ge(e);
        if (!a) {
            if (l && bt(Ev, n))
                return Reflect.get(Ev, n, r);
            if (n === "hasOwnProperty")
                return g$
        }
        const i = Reflect.get(e, n, r);
        return (Ca(n) ? Wy.has(n) : m$(n)) || (a || Zn(e, "get", n),
        s) ? i : Kt(i) ? l && Dh(n) ? i : i.value : It(i) ? a ? Hn(i) : Fn(i) : i
    }
}
class Yy extends Gy {
    constructor(e=!1) {
        super(!1, e)
    }
    set(e, n, r, a) {
        let s = e[n];
        if (!this._isShallow) {
            const o = go(s);
            if (!Uu(r) && !go(r) && (s = vt(s),
            r = vt(r)),
            !Ge(e) && Kt(s) && !Kt(r))
                return o ? !1 : (s.value = r,
                !0)
        }
        const l = Ge(e) && Dh(n) ? Number(n) < e.length : bt(e, n)
          , i = Reflect.set(e, n, r, a);
        return e === vt(a) && (l ? ms(r, s) && $a(e, "set", n, r) : $a(e, "add", n, r)),
        i
    }
    deleteProperty(e, n) {
        const r = bt(e, n);
        e[n];
        const a = Reflect.deleteProperty(e, n);
        return a && r && $a(e, "delete", n, void 0),
        a
    }
    has(e, n) {
        const r = Reflect.has(e, n);
        return (!Ca(n) || !Wy.has(n)) && Zn(e, "has", n),
        r
    }
    ownKeys(e) {
        return Zn(e, "iterate", Ge(e) ? "length" : Ws),
        Reflect.ownKeys(e)
    }
}
class Jy extends Gy {
    constructor(e=!1) {
        super(!0, e)
    }
    set(e, n) {
        return !0
    }
    deleteProperty(e, n) {
        return !0
    }
}
const b$ = new Yy
  , y$ = new Jy
  , k$ = new Yy(!0)
  , _$ = new Jy(!0)
  , Ih = t => t
  , Vd = t => Reflect.getPrototypeOf(t);
function lu(t, e, n=!1, r=!1) {
    t = t.__v_raw;
    const a = vt(t)
      , s = vt(e);
    n || (ms(e, s) && Zn(a, "get", e),
    Zn(a, "get", s));
    const {has: l} = Vd(a)
      , i = r ? Ih : n ? Rh : bo;
    if (l.call(a, e))
        return i(t.get(e));
    if (l.call(a, s))
        return i(t.get(s));
    t !== a && t.get(e)
}
function iu(t, e=!1) {
    const n = this.__v_raw
      , r = vt(n)
      , a = vt(t);
    return e || (ms(t, a) && Zn(r, "has", t),
    Zn(r, "has", a)),
    t === a ? n.has(t) : n.has(t) || n.has(a)
}
function ou(t, e=!1) {
    return t = t.__v_raw,
    !e && Zn(vt(t), "iterate", Ws),
    Reflect.get(t, "size", t)
}
function Av(t) {
    t = vt(t);
    const e = vt(this);
    return Vd(e).has.call(e, t) || (e.add(t),
    $a(e, "add", t, t)),
    this
}
function Mv(t, e) {
    e = vt(e);
    const n = vt(this)
      , {has: r, get: a} = Vd(n);
    let s = r.call(n, t);
    s || (t = vt(t),
    s = r.call(n, t));
    const l = a.call(n, t);
    return n.set(t, e),
    s ? ms(e, l) && $a(n, "set", t, e) : $a(n, "add", t, e),
    this
}
function Ov(t) {
    const e = vt(this)
      , {has: n, get: r} = Vd(e);
    let a = n.call(e, t);
    a || (t = vt(t),
    a = n.call(e, t)),
    r && r.call(e, t);
    const s = e.delete(t);
    return a && $a(e, "delete", t, void 0),
    s
}
function Nv() {
    const t = vt(this)
      , e = t.size !== 0
      , n = t.clear();
    return e && $a(t, "clear", void 0, void 0),
    n
}
function uu(t, e) {
    return function(r, a) {
        const s = this
          , l = s.__v_raw
          , i = vt(l)
          , o = e ? Ih : t ? Rh : bo;
        return !t && Zn(i, "iterate", Ws),
        l.forEach( (u, d) => r.call(a, o(u), o(d), s))
    }
}
function du(t, e, n) {
    return function(...r) {
        const a = this.__v_raw
          , s = vt(a)
          , l = ql(s)
          , i = t === "entries" || t === Symbol.iterator && l
          , o = t === "keys" && l
          , u = a[t](...r)
          , d = n ? Ih : e ? Rh : bo;
        return !e && Zn(s, "iterate", o ? np : Ws),
        {
            next() {
                const {value: f, done: p} = u.next();
                return p ? {
                    value: f,
                    done: p
                } : {
                    value: i ? [d(f[0]), d(f[1])] : d(f),
                    done: p
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function Va(t) {
    return function(...e) {
        return t === "delete" ? !1 : t === "clear" ? void 0 : this
    }
}
function w$() {
    const t = {
        get(s) {
            return lu(this, s)
        },
        get size() {
            return ou(this)
        },
        has: iu,
        add: Av,
        set: Mv,
        delete: Ov,
        clear: Nv,
        forEach: uu(!1, !1)
    }
      , e = {
        get(s) {
            return lu(this, s, !1, !0)
        },
        get size() {
            return ou(this)
        },
        has: iu,
        add: Av,
        set: Mv,
        delete: Ov,
        clear: Nv,
        forEach: uu(!1, !0)
    }
      , n = {
        get(s) {
            return lu(this, s, !0)
        },
        get size() {
            return ou(this, !0)
        },
        has(s) {
            return iu.call(this, s, !0)
        },
        add: Va("add"),
        set: Va("set"),
        delete: Va("delete"),
        clear: Va("clear"),
        forEach: uu(!0, !1)
    }
      , r = {
        get(s) {
            return lu(this, s, !0, !0)
        },
        get size() {
            return ou(this, !0)
        },
        has(s) {
            return iu.call(this, s, !0)
        },
        add: Va("add"),
        set: Va("set"),
        delete: Va("delete"),
        clear: Va("clear"),
        forEach: uu(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = du(s, !1, !1),
        n[s] = du(s, !0, !1),
        e[s] = du(s, !1, !0),
        r[s] = du(s, !0, !0)
    }
    ),
    [t, n, e, r]
}
const [x$,S$,$$,T$] = w$();
function Id(t, e) {
    const n = e ? t ? T$ : $$ : t ? S$ : x$;
    return (r, a, s) => a === "__v_isReactive" ? !t : a === "__v_isReadonly" ? t : a === "__v_raw" ? r : Reflect.get(bt(n, a) && a in r ? n : r, a, s)
}
const C$ = {
    get: Id(!1, !1)
}
  , E$ = {
    get: Id(!1, !0)
}
  , A$ = {
    get: Id(!0, !1)
}
  , M$ = {
    get: Id(!0, !0)
}
  , Xy = new WeakMap
  , Qy = new WeakMap
  , Zy = new WeakMap
  , e1 = new WeakMap;
function O$(t) {
    switch (t) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function N$(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : O$(t$(t))
}
function Fn(t) {
    return go(t) ? t : Rd(t, !1, b$, C$, Xy)
}
function t1(t) {
    return Rd(t, !1, k$, E$, Qy)
}
function Hn(t) {
    return Rd(t, !0, y$, A$, Zy)
}
function Tl(t) {
    return Rd(t, !0, _$, M$, e1)
}
function Rd(t, e, n, r, a) {
    if (!It(t) || t.__v_raw && !(e && t.__v_isReactive))
        return t;
    const s = a.get(t);
    if (s)
        return s;
    const l = N$(t);
    if (l === 0)
        return t;
    const i = new Proxy(t,l === 2 ? r : n);
    return a.set(t, i),
    i
}
function Gs(t) {
    return go(t) ? Gs(t.__v_raw) : !!(t && t.__v_isReactive)
}
function go(t) {
    return !!(t && t.__v_isReadonly)
}
function Uu(t) {
    return !!(t && t.__v_isShallow)
}
function n1(t) {
    return t ? !!t.__v_raw : !1
}
function vt(t) {
    const e = t && t.__v_raw;
    return e ? vt(e) : t
}
function Ld(t) {
    return Object.isExtensible(t) && Vy(t, "__v_skip", !0),
    t
}
const bo = t => It(t) ? Fn(t) : t
  , Rh = t => It(t) ? Hn(t) : t;
class r1 {
    constructor(e, n, r, a) {
        this.getter = e,
        this._setter = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this.__v_isReadonly = !1,
        this.effect = new Fh( () => e(this._value), () => Qi(this, this.effect._dirtyLevel === 2 ? 2 : 3)),
        this.effect.computed = this,
        this.effect.active = this._cacheable = !a,
        this.__v_isReadonly = r
    }
    get value() {
        const e = vt(this);
        return (!e._cacheable || e.effect.dirty) && ms(e._value, e._value = e.effect.run()) && Qi(e, 4),
        Lh(e),
        e.effect._dirtyLevel >= 2 && Qi(e, 2),
        e._value
    }
    set value(e) {
        this._setter(e)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(e) {
        this.effect.dirty = e
    }
}
function D$(t, e, n=!1) {
    let r, a;
    const s = et(t);
    return s ? (r = t,
    a = rr) : (r = t.get,
    a = t.set),
    new r1(r,a,s || !a,n)
}
function Lh(t) {
    var e;
    ss && qs && (t = vt(t),
    Ky(qs, (e = t.dep) != null ? e : t.dep = qy( () => t.dep = void 0, t instanceof r1 ? t : void 0)))
}
function Qi(t, e=4, n) {
    t = vt(t);
    const r = t.dep;
    r && zy(r, e)
}
function Kt(t) {
    return !!(t && t.__v_isRef === !0)
}
function me(t) {
    return a1(t, !1)
}
function jh(t) {
    return a1(t, !0)
}
function a1(t, e) {
    return Kt(t) ? t : new P$(t,e)
}
class P$ {
    constructor(e, n) {
        this.__v_isShallow = n,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = n ? e : vt(e),
        this._value = n ? e : bo(e)
    }
    get value() {
        return Lh(this),
        this._value
    }
    set value(e) {
        const n = this.__v_isShallow || Uu(e) || go(e);
        e = n ? e : vt(e),
        ms(e, this._rawValue) && (this._rawValue = e,
        this._value = n ? e : bo(e),
        Qi(this, 4))
    }
}
function A(t) {
    return Kt(t) ? t.value : t
}
function ca(t) {
    return et(t) ? t() : A(t)
}
const F$ = {
    get: (t, e, n) => A(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const a = t[e];
        return Kt(a) && !Kt(n) ? (a.value = n,
        !0) : Reflect.set(t, e, n, r)
    }
};
function s1(t) {
    return Gs(t) ? t : new Proxy(t,F$)
}
class B$ {
    constructor(e) {
        this.dep = void 0,
        this.__v_isRef = !0;
        const {get: n, set: r} = e( () => Lh(this), () => Qi(this));
        this._get = n,
        this._set = r
    }
    get value() {
        return this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function l1(t) {
    return new B$(t)
}
function V$(t) {
    const e = Ge(t) ? new Array(t.length) : {};
    for (const n in t)
        e[n] = i1(t, n);
    return e
}
class I$ {
    constructor(e, n, r) {
        this._object = e,
        this._key = n,
        this._defaultValue = r,
        this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return h$(vt(this._object), this._key)
    }
}
class R$ {
    constructor(e) {
        this._getter = e,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}
function _e(t, e, n) {
    return Kt(t) ? t : et(t) ? new R$(t) : It(t) && arguments.length > 1 ? i1(t, e, n) : me(t)
}
function i1(t, e, n) {
    const r = t[e];
    return Kt(r) ? r : new I$(t,e,n)
}
/**
* @vue/runtime-core v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ls(t, e, n, r) {
    try {
        return r ? t(...r) : t()
    } catch (a) {
        jd(a, e, n)
    }
}
function br(t, e, n, r) {
    if (et(t)) {
        const a = ls(t, e, n, r);
        return a && Py(a) && a.catch(s => {
            jd(s, e, n)
        }
        ),
        a
    }
    if (Ge(t)) {
        const a = [];
        for (let s = 0; s < t.length; s++)
            a.push(br(t[s], e, n, r));
        return a
    }
}
function jd(t, e, n, r=!0) {
    const a = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const l = e.proxy
          , i = `https://vuejs.org/error-reference/#runtime-${n}`;
        for (; s; ) {
            const u = s.ec;
            if (u) {
                for (let d = 0; d < u.length; d++)
                    if (u[d](t, l, i) === !1)
                        return
            }
            s = s.parent
        }
        const o = e.appContext.config.errorHandler;
        if (o) {
            ws(),
            ls(o, null, 10, [t, l, i]),
            xs();
            return
        }
    }
    L$(t, n, a, r)
}
function L$(t, e, n, r=!0) {
    console.error(t)
}
let yo = !1
  , rp = !1;
const Dn = [];
let Yr = 0;
const Wl = [];
let za = null
  , Bs = 0;
const o1 = Promise.resolve();
let Uh = null;
function Ot(t) {
    const e = Uh || o1;
    return t ? e.then(this ? t.bind(this) : t) : e
}
function j$(t) {
    let e = Yr + 1
      , n = Dn.length;
    for (; e < n; ) {
        const r = e + n >>> 1
          , a = Dn[r]
          , s = ko(a);
        s < t || s === t && a.pre ? e = r + 1 : n = r
    }
    return e
}
function Hh(t) {
    (!Dn.length || !Dn.includes(t, yo && t.allowRecurse ? Yr + 1 : Yr)) && (t.id == null ? Dn.push(t) : Dn.splice(j$(t.id), 0, t),
    u1())
}
function u1() {
    !yo && !rp && (rp = !0,
    Uh = o1.then(c1))
}
function U$(t) {
    const e = Dn.indexOf(t);
    e > Yr && Dn.splice(e, 1)
}
function H$(t) {
    Ge(t) ? Wl.push(...t) : (!za || !za.includes(t, t.allowRecurse ? Bs + 1 : Bs)) && Wl.push(t),
    u1()
}
function Dv(t, e, n=yo ? Yr + 1 : 0) {
    for (; n < Dn.length; n++) {
        const r = Dn[n];
        if (r && r.pre) {
            if (t && r.id !== t.uid)
                continue;
            Dn.splice(n, 1),
            n--,
            r()
        }
    }
}
function d1(t) {
    if (Wl.length) {
        const e = [...new Set(Wl)].sort( (n, r) => ko(n) - ko(r));
        if (Wl.length = 0,
        za) {
            za.push(...e);
            return
        }
        for (za = e,
        Bs = 0; Bs < za.length; Bs++)
            za[Bs]();
        za = null,
        Bs = 0
    }
}
const ko = t => t.id == null ? 1 / 0 : t.id
  , K$ = (t, e) => {
    const n = ko(t) - ko(e);
    if (n === 0) {
        if (t.pre && !e.pre)
            return -1;
        if (e.pre && !t.pre)
            return 1
    }
    return n
}
;
function c1(t) {
    rp = !1,
    yo = !0,
    Dn.sort(K$);
    const e = rr;
    try {
        for (Yr = 0; Yr < Dn.length; Yr++) {
            const n = Dn[Yr];
            n && n.active !== !1 && ls(n, null, 14)
        }
    } finally {
        Yr = 0,
        Dn.length = 0,
        d1(),
        yo = !1,
        Uh = null,
        (Dn.length || Wl.length) && c1()
    }
}
function z$(t, e, ...n) {
    if (t.isUnmounted)
        return;
    const r = t.vnode.props || jt;
    let a = n;
    const s = e.startsWith("update:")
      , l = s && e.slice(7);
    if (l && l in r) {
        const d = `${l === "modelValue" ? "model" : l}Modifiers`
          , {number: f, trim: p} = r[d] || jt;
        p && (a = n.map(h => Yt(h) ? h.trim() : h)),
        f && (a = n.map(Lu))
    }
    let i, o = r[i = Bc(e)] || r[i = Bc(la(e))];
    !o && s && (o = r[i = Bc(fl(e))]),
    o && br(o, t, 6, a);
    const u = r[i + "Once"];
    if (u) {
        if (!t.emitted)
            t.emitted = {};
        else if (t.emitted[i])
            return;
        t.emitted[i] = !0,
        br(u, t, 6, a)
    }
}
function f1(t, e, n=!1) {
    const r = e.emitsCache
      , a = r.get(t);
    if (a !== void 0)
        return a;
    const s = t.emits;
    let l = {}
      , i = !1;
    if (!et(t)) {
        const o = u => {
            const d = f1(u, e, !0);
            d && (i = !0,
            rn(l, d))
        }
        ;
        !n && e.mixins.length && e.mixins.forEach(o),
        t.extends && o(t.extends),
        t.mixins && t.mixins.forEach(o)
    }
    return !s && !i ? (It(t) && r.set(t, null),
    null) : (Ge(s) ? s.forEach(o => l[o] = null) : rn(l, s),
    It(t) && r.set(t, l),
    l)
}
function Ud(t, e) {
    return !t || !Nd(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
    bt(t, e[0].toLowerCase() + e.slice(1)) || bt(t, fl(e)) || bt(t, e))
}
let ln = null
  , Hd = null;
function Hu(t) {
    const e = ln;
    return ln = t,
    Hd = t && t.type.__scopeId || null,
    e
}
function $t(t) {
    Hd = t
}
function Tt() {
    Hd = null
}
function N(t, e=ln, n) {
    if (!e || t._n)
        return t;
    const r = (...a) => {
        r._d && Wv(-1);
        const s = Hu(e);
        let l;
        try {
            l = t(...a)
        } finally {
            Hu(s),
            r._d && Wv(1)
        }
        return l
    }
    ;
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function Ic(t) {
    const {type: e, vnode: n, proxy: r, withProxy: a, propsOptions: [s], slots: l, attrs: i, emit: o, render: u, renderCache: d, props: f, data: p, setupState: h, ctx: v, inheritAttrs: y} = t
      , k = Hu(t);
    let w, $;
    try {
        if (n.shapeFlag & 4) {
            const S = a || r
              , T = S;
            w = Gr(u.call(T, S, d, f, h, p, v)),
            $ = i
        } else {
            const S = e;
            w = Gr(S.length > 1 ? S(f, {
                attrs: i,
                slots: l,
                emit: o
            }) : S(f, null)),
            $ = e.props ? i : q$(i)
        }
    } catch (S) {
        no.length = 0,
        jd(S, t, 1),
        w = x(yr)
    }
    let M = w;
    if ($ && y !== !1) {
        const S = Object.keys($)
          , {shapeFlag: T} = M;
        S.length && T & 7 && (s && S.some(Oh) && ($ = W$($, s)),
        M = vs(M, $))
    }
    return n.dirs && (M = vs(M),
    M.dirs = M.dirs ? M.dirs.concat(n.dirs) : n.dirs),
    n.transition && (M.transition = n.transition),
    w = M,
    Hu(k),
    w
}
const q$ = t => {
    let e;
    for (const n in t)
        (n === "class" || n === "style" || Nd(n)) && ((e || (e = {}))[n] = t[n]);
    return e
}
  , W$ = (t, e) => {
    const n = {};
    for (const r in t)
        (!Oh(r) || !(r.slice(9)in e)) && (n[r] = t[r]);
    return n
}
;
function G$(t, e, n) {
    const {props: r, children: a, component: s} = t
      , {props: l, children: i, patchFlag: o} = e
      , u = s.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (n && o >= 0) {
        if (o & 1024)
            return !0;
        if (o & 16)
            return r ? Pv(r, l, u) : !!l;
        if (o & 8) {
            const d = e.dynamicProps;
            for (let f = 0; f < d.length; f++) {
                const p = d[f];
                if (l[p] !== r[p] && !Ud(u, p))
                    return !0
            }
        }
    } else
        return (a || i) && (!i || !i.$stable) ? !0 : r === l ? !1 : r ? l ? Pv(r, l, u) : !0 : !!l;
    return !1
}
function Pv(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length)
        return !0;
    for (let a = 0; a < r.length; a++) {
        const s = r[a];
        if (e[s] !== t[s] && !Ud(n, s))
            return !0
    }
    return !1
}
function Y$({vnode: t, parent: e}, n) {
    for (; e; ) {
        const r = e.subTree;
        if (r.suspense && r.suspense.activeBranch === t && (r.el = t.el),
        r === t)
            (t = e.vnode).el = n,
            e = e.parent;
        else
            break
    }
}
const Kh = "components"
  , J$ = "directives";
function ue(t, e) {
    return zh(Kh, t, !0, e) || t
}
const p1 = Symbol.for("v-ndc");
function qe(t) {
    return Yt(t) ? zh(Kh, t, !1) || t : t || p1
}
function X$(t) {
    return zh(J$, t)
}
function zh(t, e, n=!0, r=!1) {
    const a = ln || vn;
    if (a) {
        const s = a.type;
        if (t === Kh) {
            const i = jT(s, !1);
            if (i && (i === e || i === la(e) || i === Pd(la(e))))
                return s
        }
        const l = Fv(a[t] || s[t], e) || Fv(a.appContext[t], e);
        return !l && r ? s : l
    }
}
function Fv(t, e) {
    return t && (t[e] || t[la(e)] || t[Pd(la(e))])
}
const Q$ = t => t.__isSuspense;
function Z$(t, e) {
    e && e.pendingBranch ? Ge(t) ? e.effects.push(...t) : e.effects.push(t) : H$(t)
}
const eT = Symbol.for("v-scx")
  , tT = () => Gt(eT);
function Si(t, e) {
    return qh(t, null, e)
}
const cu = {};
function Ke(t, e, n) {
    return qh(t, e, n)
}
function qh(t, e, {immediate: n, deep: r, flush: a, once: s, onTrack: l, onTrigger: i}=jt) {
    if (e && s) {
        const E = e;
        e = (...O) => {
            E(...O),
            T()
        }
    }
    const o = vn
      , u = E => r === !0 ? E : Ls(E, r === !1 ? 1 : void 0);
    let d, f = !1, p = !1;
    if (Kt(t) ? (d = () => t.value,
    f = Uu(t)) : Gs(t) ? (d = () => u(t),
    f = !0) : Ge(t) ? (p = !0,
    f = t.some(E => Gs(E) || Uu(E)),
    d = () => t.map(E => {
        if (Kt(E))
            return E.value;
        if (Gs(E))
            return u(E);
        if (et(E))
            return ls(E, o, 2)
    }
    )) : et(t) ? e ? d = () => ls(t, o, 2) : d = () => (h && h(),
    br(t, o, 3, [v])) : d = rr,
    e && r) {
        const E = d;
        d = () => Ls(E())
    }
    let h, v = E => {
        h = M.onStop = () => {
            ls(E, o, 4),
            h = M.onStop = void 0
        }
    }
    , y;
    if (Wd)
        if (v = rr,
        e ? n && br(e, o, 3, [d(), p ? [] : void 0, v]) : d(),
        a === "sync") {
            const E = tT();
            y = E.__watcherHandles || (E.__watcherHandles = [])
        } else
            return rr;
    let k = p ? new Array(t.length).fill(cu) : cu;
    const w = () => {
        if (!(!M.active || !M.dirty))
            if (e) {
                const E = M.run();
                (r || f || (p ? E.some( (O, U) => ms(O, k[U])) : ms(E, k))) && (h && h(),
                br(e, o, 3, [E, k === cu ? void 0 : p && k[0] === cu ? [] : k, v]),
                k = E)
            } else
                M.run()
    }
    ;
    w.allowRecurse = !!e;
    let $;
    a === "sync" ? $ = w : a === "post" ? $ = () => Jn(w, o && o.suspense) : (w.pre = !0,
    o && (w.id = o.uid),
    $ = () => Hh(w));
    const M = new Fh(d,rr,$)
      , S = Ho()
      , T = () => {
        M.stop(),
        S && Nh(S.effects, M)
    }
    ;
    return e ? n ? w() : k = M.run() : a === "post" ? Jn(M.run.bind(M), o && o.suspense) : M.run(),
    y && y.push(T),
    T
}
function nT(t, e, n) {
    const r = this.proxy
      , a = Yt(t) ? t.includes(".") ? h1(r, t) : () => r[t] : t.bind(r, r);
    let s;
    et(e) ? s = e : (s = e.handler,
    n = e);
    const l = zo(this)
      , i = qh(a, s.bind(r), n);
    return l(),
    i
}
function h1(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let a = 0; a < n.length && r; a++)
            r = r[n[a]];
        return r
    }
}
function Ls(t, e, n=0, r) {
    if (!It(t) || t.__v_skip)
        return t;
    if (e && e > 0) {
        if (n >= e)
            return t;
        n++
    }
    if (r = r || new Set,
    r.has(t))
        return t;
    if (r.add(t),
    Kt(t))
        Ls(t.value, e, n, r);
    else if (Ge(t))
        for (let a = 0; a < t.length; a++)
            Ls(t[a], e, n, r);
    else if (xi(t) || ql(t))
        t.forEach(a => {
            Ls(a, e, n, r)
        }
        );
    else if (By(t))
        for (const a in t)
            Ls(t[a], e, n, r);
    return t
}
function ft(t, e) {
    if (ln === null)
        return t;
    const n = Gd(ln) || ln.proxy
      , r = t.dirs || (t.dirs = []);
    for (let a = 0; a < e.length; a++) {
        let[s,l,i,o=jt] = e[a];
        s && (et(s) && (s = {
            mounted: s,
            updated: s
        }),
        s.deep && Ls(l),
        r.push({
            dir: s,
            instance: n,
            value: l,
            oldValue: void 0,
            arg: i,
            modifiers: o
        }))
    }
    return t
}
function Os(t, e, n, r) {
    const a = t.dirs
      , s = e && e.dirs;
    for (let l = 0; l < a.length; l++) {
        const i = a[l];
        s && (i.oldValue = s[l].value);
        let o = i.dir[r];
        o && (ws(),
        br(o, n, 8, [t.el, i, t, e]),
        xs())
    }
}
const qa = Symbol("_leaveCb")
  , fu = Symbol("_enterCb");
function m1() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Zt( () => {
        t.isMounted = !0
    }
    ),
    $i( () => {
        t.isUnmounting = !0
    }
    ),
    t
}
const cr = [Function, Array]
  , v1 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: cr,
    onEnter: cr,
    onAfterEnter: cr,
    onEnterCancelled: cr,
    onBeforeLeave: cr,
    onLeave: cr,
    onAfterLeave: cr,
    onLeaveCancelled: cr,
    onBeforeAppear: cr,
    onAppear: cr,
    onAfterAppear: cr,
    onAppearCancelled: cr
}
  , rT = {
    name: "BaseTransition",
    props: v1,
    setup(t, {slots: e}) {
        const n = pl()
          , r = m1();
        return () => {
            const a = e.default && Wh(e.default(), !0);
            if (!a || !a.length)
                return;
            let s = a[0];
            if (a.length > 1) {
                for (const p of a)
                    if (p.type !== yr) {
                        s = p;
                        break
                    }
            }
            const l = vt(t)
              , {mode: i} = l;
            if (r.isLeaving)
                return Rc(s);
            const o = Bv(s);
            if (!o)
                return Rc(s);
            const u = _o(o, l, r, n);
            wo(o, u);
            const d = n.subTree
              , f = d && Bv(d);
            if (f && f.type !== yr && !Vs(o, f)) {
                const p = _o(f, l, r, n);
                if (wo(f, p),
                i === "out-in")
                    return r.isLeaving = !0,
                    p.afterLeave = () => {
                        r.isLeaving = !1,
                        n.update.active !== !1 && (n.effect.dirty = !0,
                        n.update())
                    }
                    ,
                    Rc(s);
                i === "in-out" && o.type !== yr && (p.delayLeave = (h, v, y) => {
                    const k = g1(r, f);
                    k[String(f.key)] = f,
                    h[qa] = () => {
                        v(),
                        h[qa] = void 0,
                        delete u.delayedLeave
                    }
                    ,
                    u.delayedLeave = y
                }
                )
            }
            return s
        }
    }
}
  , aT = rT;
function g1(t, e) {
    const {leavingVNodes: n} = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null),
    n.set(e.type, r)),
    r
}
function _o(t, e, n, r) {
    const {appear: a, mode: s, persisted: l=!1, onBeforeEnter: i, onEnter: o, onAfterEnter: u, onEnterCancelled: d, onBeforeLeave: f, onLeave: p, onAfterLeave: h, onLeaveCancelled: v, onBeforeAppear: y, onAppear: k, onAfterAppear: w, onAppearCancelled: $} = e
      , M = String(t.key)
      , S = g1(n, t)
      , T = (U, L) => {
        U && br(U, r, 9, L)
    }
      , E = (U, L) => {
        const C = L[1];
        T(U, L),
        Ge(U) ? U.every(W => W.length <= 1) && C() : U.length <= 1 && C()
    }
      , O = {
        mode: s,
        persisted: l,
        beforeEnter(U) {
            let L = i;
            if (!n.isMounted)
                if (a)
                    L = y || i;
                else
                    return;
            U[qa] && U[qa](!0);
            const C = S[M];
            C && Vs(t, C) && C.el[qa] && C.el[qa](),
            T(L, [U])
        },
        enter(U) {
            let L = o
              , C = u
              , W = d;
            if (!n.isMounted)
                if (a)
                    L = k || o,
                    C = w || u,
                    W = $ || d;
                else
                    return;
            let R = !1;
            const G = U[fu] = te => {
                R || (R = !0,
                te ? T(W, [U]) : T(C, [U]),
                O.delayedLeave && O.delayedLeave(),
                U[fu] = void 0)
            }
            ;
            L ? E(L, [U, G]) : G()
        },
        leave(U, L) {
            const C = String(t.key);
            if (U[fu] && U[fu](!0),
            n.isUnmounting)
                return L();
            T(f, [U]);
            let W = !1;
            const R = U[qa] = G => {
                W || (W = !0,
                L(),
                G ? T(v, [U]) : T(h, [U]),
                U[qa] = void 0,
                S[C] === t && delete S[C])
            }
            ;
            S[C] = t,
            p ? E(p, [U, R]) : R()
        },
        clone(U) {
            return _o(U, e, n, r)
        }
    };
    return O
}
function Rc(t) {
    if (Kd(t))
        return t = vs(t),
        t.children = null,
        t
}
function Bv(t) {
    if (!Kd(t))
        return t;
    const {shapeFlag: e, children: n} = t;
    if (n) {
        if (e & 16)
            return n[0];
        if (e & 32 && et(n.default))
            return n.default()
    }
}
function wo(t, e) {
    t.shapeFlag & 6 && t.component ? wo(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent),
    t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}
function Wh(t, e=!1, n) {
    let r = []
      , a = 0;
    for (let s = 0; s < t.length; s++) {
        let l = t[s];
        const i = n == null ? l.key : String(n) + String(l.key != null ? l.key : s);
        l.type === we ? (l.patchFlag & 128 && a++,
        r = r.concat(Wh(l.children, e, i))) : (e || l.type !== yr) && r.push(i != null ? vs(l, {
            key: i
        }) : l)
    }
    if (a > 1)
        for (let s = 0; s < r.length; s++)
            r[s].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function Se(t, e) {
    return et(t) ? ( () => rn({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
const Zi = t => !!t.type.__asyncLoader
  , Kd = t => t.type.__isKeepAlive;
function b1(t, e) {
    y1(t, "a", e)
}
function sT(t, e) {
    y1(t, "da", e)
}
function y1(t, e, n=vn) {
    const r = t.__wdc || (t.__wdc = () => {
        let a = n;
        for (; a; ) {
            if (a.isDeactivated)
                return;
            a = a.parent
        }
        return t()
    }
    );
    if (zd(e, r, n),
    n) {
        let a = n.parent;
        for (; a && a.parent; )
            Kd(a.parent.vnode) && lT(r, e, n, a),
            a = a.parent
    }
}
function lT(t, e, n, r) {
    const a = zd(e, t, r, !0);
    Ko( () => {
        Nh(r[e], a)
    }
    , n)
}
function zd(t, e, n=vn, r=!1) {
    if (n) {
        const a = n[t] || (n[t] = [])
          , s = e.__weh || (e.__weh = (...l) => {
            if (n.isUnmounted)
                return;
            ws();
            const i = zo(n)
              , o = br(e, n, t, l);
            return i(),
            xs(),
            o
        }
        );
        return r ? a.unshift(s) : a.push(s),
        s
    }
}
const Ma = t => (e, n=vn) => (!Wd || t === "sp") && zd(t, (...r) => e(...r), n)
  , iT = Ma("bm")
  , Zt = Ma("m")
  , k1 = Ma("bu")
  , _1 = Ma("u")
  , $i = Ma("bum")
  , Ko = Ma("um")
  , oT = Ma("sp")
  , uT = Ma("rtg")
  , dT = Ma("rtc");
function cT(t, e=vn) {
    zd("ec", t, e)
}
function Ne(t, e, n, r) {
    let a;
    const s = n && n[r];
    if (Ge(t) || Yt(t)) {
        a = new Array(t.length);
        for (let l = 0, i = t.length; l < i; l++)
            a[l] = e(t[l], l, void 0, s && s[l])
    } else if (typeof t == "number") {
        a = new Array(t);
        for (let l = 0; l < t; l++)
            a[l] = e(l + 1, l, void 0, s && s[l])
    } else if (It(t))
        if (t[Symbol.iterator])
            a = Array.from(t, (l, i) => e(l, i, void 0, s && s[i]));
        else {
            const l = Object.keys(t);
            a = new Array(l.length);
            for (let i = 0, o = l.length; i < o; i++) {
                const u = l[i];
                a[i] = e(t[u], u, i, s && s[i])
            }
        }
    else
        a = [];
    return n && (n[r] = a),
    a
}
function gn(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (Ge(r))
            for (let a = 0; a < r.length; a++)
                t[r[a].name] = r[a].fn;
        else
            r && (t[r.name] = r.key ? (...a) => {
                const s = r.fn(...a);
                return s && (s.key = r.key),
                s
            }
            : r.fn)
    }
    return t
}
function Z(t, e, n={}, r, a) {
    if (ln.isCE || ln.parent && Zi(ln.parent) && ln.parent.isCE)
        return e !== "default" && (n.name = e),
        x("slot", n, r && r());
    let s = t[e];
    s && s._c && (s._d = !1),
    g();
    const l = s && w1(s(n))
      , i = de(we, {
        key: n.key || l && l.key || `_${e}`
    }, l || (r ? r() : []), l && t._ === 1 ? 64 : -2);
    return !a && i.scopeId && (i.slotScopeIds = [i.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    i
}
function w1(t) {
    return t.some(e => zu(e) ? !(e.type === yr || e.type === we && !w1(e.children)) : !0) ? t : null
}
const ap = t => t ? R1(t) ? Gd(t) || t.proxy : ap(t.parent) : null
  , eo = rn(Object.create(null), {
    $: t => t,
    $el: t => t.vnode.el,
    $data: t => t.data,
    $props: t => t.props,
    $attrs: t => t.attrs,
    $slots: t => t.slots,
    $refs: t => t.refs,
    $parent: t => ap(t.parent),
    $root: t => ap(t.root),
    $emit: t => t.emit,
    $options: t => Gh(t),
    $forceUpdate: t => t.f || (t.f = () => {
        t.effect.dirty = !0,
        Hh(t.update)
    }
    ),
    $nextTick: t => t.n || (t.n = Ot.bind(t.proxy)),
    $watch: t => nT.bind(t)
})
  , Lc = (t, e) => t !== jt && !t.__isScriptSetup && bt(t, e)
  , fT = {
    get({_: t}, e) {
        if (e === "__v_skip")
            return !0;
        const {ctx: n, setupState: r, data: a, props: s, accessCache: l, type: i, appContext: o} = t;
        let u;
        if (e[0] !== "$") {
            const h = l[e];
            if (h !== void 0)
                switch (h) {
                case 1:
                    return r[e];
                case 2:
                    return a[e];
                case 4:
                    return n[e];
                case 3:
                    return s[e]
                }
            else {
                if (Lc(r, e))
                    return l[e] = 1,
                    r[e];
                if (a !== jt && bt(a, e))
                    return l[e] = 2,
                    a[e];
                if ((u = t.propsOptions[0]) && bt(u, e))
                    return l[e] = 3,
                    s[e];
                if (n !== jt && bt(n, e))
                    return l[e] = 4,
                    n[e];
                sp && (l[e] = 0)
            }
        }
        const d = eo[e];
        let f, p;
        if (d)
            return e === "$attrs" && Zn(t.attrs, "get", ""),
            d(t);
        if ((f = i.__cssModules) && (f = f[e]))
            return f;
        if (n !== jt && bt(n, e))
            return l[e] = 4,
            n[e];
        if (p = o.config.globalProperties,
        bt(p, e))
            return p[e]
    },
    set({_: t}, e, n) {
        const {data: r, setupState: a, ctx: s} = t;
        return Lc(a, e) ? (a[e] = n,
        !0) : r !== jt && bt(r, e) ? (r[e] = n,
        !0) : bt(t.props, e) || e[0] === "$" && e.slice(1)in t ? !1 : (s[e] = n,
        !0)
    },
    has({_: {data: t, setupState: e, accessCache: n, ctx: r, appContext: a, propsOptions: s}}, l) {
        let i;
        return !!n[l] || t !== jt && bt(t, l) || Lc(e, l) || (i = s[0]) && bt(i, l) || bt(r, l) || bt(eo, l) || bt(a.config.globalProperties, l)
    },
    defineProperty(t, e, n) {
        return n.get != null ? t._.accessCache[e] = 0 : bt(n, "value") && this.set(t, e, n.value, null),
        Reflect.defineProperty(t, e, n)
    }
};
function en() {
    return S1().slots
}
function x1() {
    return S1().attrs
}
function S1() {
    const t = pl();
    return t.setupContext || (t.setupContext = j1(t))
}
function Vv(t) {
    return Ge(t) ? t.reduce( (e, n) => (e[n] = null,
    e), {}) : t
}
let sp = !0;
function pT(t) {
    const e = Gh(t)
      , n = t.proxy
      , r = t.ctx;
    sp = !1,
    e.beforeCreate && Iv(e.beforeCreate, t, "bc");
    const {data: a, computed: s, methods: l, watch: i, provide: o, inject: u, created: d, beforeMount: f, mounted: p, beforeUpdate: h, updated: v, activated: y, deactivated: k, beforeDestroy: w, beforeUnmount: $, destroyed: M, unmounted: S, render: T, renderTracked: E, renderTriggered: O, errorCaptured: U, serverPrefetch: L, expose: C, inheritAttrs: W, components: R, directives: G, filters: te} = e;
    if (u && hT(u, r, null),
    l)
        for (const oe in l) {
            const ne = l[oe];
            et(ne) && (r[oe] = ne.bind(n))
        }
    if (a) {
        const oe = a.call(n, n);
        It(oe) && (t.data = Fn(oe))
    }
    if (sp = !0,
    s)
        for (const oe in s) {
            const ne = s[oe]
              , I = et(ne) ? ne.bind(n, n) : et(ne.get) ? ne.get.bind(n, n) : rr
              , j = !et(ne) && et(ne.set) ? ne.set.bind(n) : rr
              , re = K({
                get: I,
                set: j
            });
            Object.defineProperty(r, oe, {
                enumerable: !0,
                configurable: !0,
                get: () => re.value,
                set: le => re.value = le
            })
        }
    if (i)
        for (const oe in i)
            $1(i[oe], r, n, oe);
    if (o) {
        const oe = et(o) ? o.call(n) : o;
        Reflect.ownKeys(oe).forEach(ne => {
            zn(ne, oe[ne])
        }
        )
    }
    d && Iv(d, t, "c");
    function ae(oe, ne) {
        Ge(ne) ? ne.forEach(I => oe(I.bind(n))) : ne && oe(ne.bind(n))
    }
    if (ae(iT, f),
    ae(Zt, p),
    ae(k1, h),
    ae(_1, v),
    ae(b1, y),
    ae(sT, k),
    ae(cT, U),
    ae(dT, E),
    ae(uT, O),
    ae($i, $),
    ae(Ko, S),
    ae(oT, L),
    Ge(C))
        if (C.length) {
            const oe = t.exposed || (t.exposed = {});
            C.forEach(ne => {
                Object.defineProperty(oe, ne, {
                    get: () => n[ne],
                    set: I => n[ne] = I
                })
            }
            )
        } else
            t.exposed || (t.exposed = {});
    T && t.render === rr && (t.render = T),
    W != null && (t.inheritAttrs = W),
    R && (t.components = R),
    G && (t.directives = G)
}
function hT(t, e, n=rr) {
    Ge(t) && (t = lp(t));
    for (const r in t) {
        const a = t[r];
        let s;
        It(a) ? "default"in a ? s = Gt(a.from || r, a.default, !0) : s = Gt(a.from || r) : s = Gt(a),
        Kt(s) ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: l => s.value = l
        }) : e[r] = s
    }
}
function Iv(t, e, n) {
    br(Ge(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}
function $1(t, e, n, r) {
    const a = r.includes(".") ? h1(n, r) : () => n[r];
    if (Yt(t)) {
        const s = e[t];
        et(s) && Ke(a, s)
    } else if (et(t))
        Ke(a, t.bind(n));
    else if (It(t))
        if (Ge(t))
            t.forEach(s => $1(s, e, n, r));
        else {
            const s = et(t.handler) ? t.handler.bind(n) : e[t.handler];
            et(s) && Ke(a, s, t)
        }
}
function Gh(t) {
    const e = t.type
      , {mixins: n, extends: r} = e
      , {mixins: a, optionsCache: s, config: {optionMergeStrategies: l}} = t.appContext
      , i = s.get(e);
    let o;
    return i ? o = i : !a.length && !n && !r ? o = e : (o = {},
    a.length && a.forEach(u => Ku(o, u, l, !0)),
    Ku(o, e, l)),
    It(e) && s.set(e, o),
    o
}
function Ku(t, e, n, r=!1) {
    const {mixins: a, extends: s} = e;
    s && Ku(t, s, n, !0),
    a && a.forEach(l => Ku(t, l, n, !0));
    for (const l in e)
        if (!(r && l === "expose")) {
            const i = mT[l] || n && n[l];
            t[l] = i ? i(t[l], e[l]) : e[l]
        }
    return t
}
const mT = {
    data: Rv,
    props: Lv,
    emits: Lv,
    methods: Ki,
    computed: Ki,
    beforeCreate: Ln,
    created: Ln,
    beforeMount: Ln,
    mounted: Ln,
    beforeUpdate: Ln,
    updated: Ln,
    beforeDestroy: Ln,
    beforeUnmount: Ln,
    destroyed: Ln,
    unmounted: Ln,
    activated: Ln,
    deactivated: Ln,
    errorCaptured: Ln,
    serverPrefetch: Ln,
    components: Ki,
    directives: Ki,
    watch: gT,
    provide: Rv,
    inject: vT
};
function Rv(t, e) {
    return e ? t ? function() {
        return rn(et(t) ? t.call(this, this) : t, et(e) ? e.call(this, this) : e)
    }
    : e : t
}
function vT(t, e) {
    return Ki(lp(t), lp(e))
}
function lp(t) {
    if (Ge(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++)
            e[t[n]] = t[n];
        return e
    }
    return t
}
function Ln(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}
function Ki(t, e) {
    return t ? rn(Object.create(null), t, e) : e
}
function Lv(t, e) {
    return t ? Ge(t) && Ge(e) ? [...new Set([...t, ...e])] : rn(Object.create(null), Vv(t), Vv(e ?? {})) : e
}
function gT(t, e) {
    if (!t)
        return e;
    if (!e)
        return t;
    const n = rn(Object.create(null), t);
    for (const r in e)
        n[r] = Ln(t[r], e[r]);
    return n
}
function T1() {
    return {
        app: null,
        config: {
            isNativeTag: ZS,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let bT = 0;
function yT(t, e) {
    return function(r, a=null) {
        et(r) || (r = rn({}, r)),
        a != null && !It(a) && (a = null);
        const s = T1()
          , l = new WeakSet;
        let i = !1;
        const o = s.app = {
            _uid: bT++,
            _component: r,
            _props: a,
            _container: null,
            _context: s,
            _instance: null,
            version: HT,
            get config() {
                return s.config
            },
            set config(u) {},
            use(u, ...d) {
                return l.has(u) || (u && et(u.install) ? (l.add(u),
                u.install(o, ...d)) : et(u) && (l.add(u),
                u(o, ...d))),
                o
            },
            mixin(u) {
                return s.mixins.includes(u) || s.mixins.push(u),
                o
            },
            component(u, d) {
                return d ? (s.components[u] = d,
                o) : s.components[u]
            },
            directive(u, d) {
                return d ? (s.directives[u] = d,
                o) : s.directives[u]
            },
            mount(u, d, f) {
                if (!i) {
                    const p = x(r, a);
                    return p.appContext = s,
                    f === !0 ? f = "svg" : f === !1 && (f = void 0),
                    d && e ? e(p, u) : t(p, u, f),
                    i = !0,
                    o._container = u,
                    u.__vue_app__ = o,
                    Gd(p.component) || p.component.proxy
                }
            },
            unmount() {
                i && (t(null, o._container),
                delete o._container.__vue_app__)
            },
            provide(u, d) {
                return s.provides[u] = d,
                o
            },
            runWithContext(u) {
                const d = Gl;
                Gl = o;
                try {
                    return u()
                } finally {
                    Gl = d
                }
            }
        };
        return o
    }
}
let Gl = null;
function zn(t, e) {
    if (vn) {
        let n = vn.provides;
        const r = vn.parent && vn.parent.provides;
        r === n && (n = vn.provides = Object.create(r)),
        n[t] = e
    }
}
function Gt(t, e, n=!1) {
    const r = vn || ln;
    if (r || Gl) {
        const a = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Gl._context.provides;
        if (a && t in a)
            return a[t];
        if (arguments.length > 1)
            return n && et(e) ? e.call(r && r.proxy) : e
    }
}
function kT() {
    return !!(vn || ln || Gl)
}
const C1 = {}
  , E1 = () => Object.create(C1)
  , A1 = t => Object.getPrototypeOf(t) === C1;
function _T(t, e, n, r=!1) {
    const a = {}
      , s = E1();
    t.propsDefaults = Object.create(null),
    M1(t, e, a, s);
    for (const l in t.propsOptions[0])
        l in a || (a[l] = void 0);
    n ? t.props = r ? a : t1(a) : t.type.props ? t.props = a : t.props = s,
    t.attrs = s
}
function wT(t, e, n, r) {
    const {props: a, attrs: s, vnode: {patchFlag: l}} = t
      , i = vt(a)
      , [o] = t.propsOptions;
    let u = !1;
    if ((r || l > 0) && !(l & 16)) {
        if (l & 8) {
            const d = t.vnode.dynamicProps;
            for (let f = 0; f < d.length; f++) {
                let p = d[f];
                if (Ud(t.emitsOptions, p))
                    continue;
                const h = e[p];
                if (o)
                    if (bt(s, p))
                        h !== s[p] && (s[p] = h,
                        u = !0);
                    else {
                        const v = la(p);
                        a[v] = ip(o, i, v, h, t, !1)
                    }
                else
                    h !== s[p] && (s[p] = h,
                    u = !0)
            }
        }
    } else {
        M1(t, e, a, s) && (u = !0);
        let d;
        for (const f in i)
            (!e || !bt(e, f) && ((d = fl(f)) === f || !bt(e, d))) && (o ? n && (n[f] !== void 0 || n[d] !== void 0) && (a[f] = ip(o, i, f, void 0, t, !0)) : delete a[f]);
        if (s !== i)
            for (const f in s)
                (!e || !bt(e, f)) && (delete s[f],
                u = !0)
    }
    u && $a(t.attrs, "set", "")
}
function M1(t, e, n, r) {
    const [a,s] = t.propsOptions;
    let l = !1, i;
    if (e)
        for (let o in e) {
            if (Xi(o))
                continue;
            const u = e[o];
            let d;
            a && bt(a, d = la(o)) ? !s || !s.includes(d) ? n[d] = u : (i || (i = {}))[d] = u : Ud(t.emitsOptions, o) || (!(o in r) || u !== r[o]) && (r[o] = u,
            l = !0)
        }
    if (s) {
        const o = vt(n)
          , u = i || jt;
        for (let d = 0; d < s.length; d++) {
            const f = s[d];
            n[f] = ip(a, o, f, u[f], t, !bt(u, f))
        }
    }
    return l
}
function ip(t, e, n, r, a, s) {
    const l = t[n];
    if (l != null) {
        const i = bt(l, "default");
        if (i && r === void 0) {
            const o = l.default;
            if (l.type !== Function && !l.skipFactory && et(o)) {
                const {propsDefaults: u} = a;
                if (n in u)
                    r = u[n];
                else {
                    const d = zo(a);
                    r = u[n] = o.call(null, e),
                    d()
                }
            } else
                r = o
        }
        l[0] && (s && !i ? r = !1 : l[1] && (r === "" || r === fl(n)) && (r = !0))
    }
    return r
}
function O1(t, e, n=!1) {
    const r = e.propsCache
      , a = r.get(t);
    if (a)
        return a;
    const s = t.props
      , l = {}
      , i = [];
    let o = !1;
    if (!et(t)) {
        const d = f => {
            o = !0;
            const [p,h] = O1(f, e, !0);
            rn(l, p),
            h && i.push(...h)
        }
        ;
        !n && e.mixins.length && e.mixins.forEach(d),
        t.extends && d(t.extends),
        t.mixins && t.mixins.forEach(d)
    }
    if (!s && !o)
        return It(t) && r.set(t, zl),
        zl;
    if (Ge(s))
        for (let d = 0; d < s.length; d++) {
            const f = la(s[d]);
            jv(f) && (l[f] = jt)
        }
    else if (s)
        for (const d in s) {
            const f = la(d);
            if (jv(f)) {
                const p = s[d]
                  , h = l[f] = Ge(p) || et(p) ? {
                    type: p
                } : rn({}, p);
                if (h) {
                    const v = Kv(Boolean, h.type)
                      , y = Kv(String, h.type);
                    h[0] = v > -1,
                    h[1] = y < 0 || v < y,
                    (v > -1 || bt(h, "default")) && i.push(f)
                }
            }
        }
    const u = [l, i];
    return It(t) && r.set(t, u),
    u
}
function jv(t) {
    return t[0] !== "$" && !Xi(t)
}
function Uv(t) {
    return t === null ? "null" : typeof t == "function" ? t.name || "" : typeof t == "object" && t.constructor && t.constructor.name || ""
}
function Hv(t, e) {
    return Uv(t) === Uv(e)
}
function Kv(t, e) {
    return Ge(e) ? e.findIndex(n => Hv(n, t)) : et(e) && Hv(e, t) ? 0 : -1
}
const N1 = t => t[0] === "_" || t === "$stable"
  , Yh = t => Ge(t) ? t.map(Gr) : [Gr(t)]
  , xT = (t, e, n) => {
    if (e._n)
        return e;
    const r = N( (...a) => Yh(e(...a)), n);
    return r._c = !1,
    r
}
  , D1 = (t, e, n) => {
    const r = t._ctx;
    for (const a in t) {
        if (N1(a))
            continue;
        const s = t[a];
        if (et(s))
            e[a] = xT(a, s, r);
        else if (s != null) {
            const l = Yh(s);
            e[a] = () => l
        }
    }
}
  , P1 = (t, e) => {
    const n = Yh(e);
    t.slots.default = () => n
}
  , ST = (t, e) => {
    const n = t.slots = E1();
    if (t.vnode.shapeFlag & 32) {
        const r = e._;
        r ? (rn(n, e),
        Vy(n, "_", r)) : D1(e, n)
    } else
        e && P1(t, e)
}
  , $T = (t, e, n) => {
    const {vnode: r, slots: a} = t;
    let s = !0
      , l = jt;
    if (r.shapeFlag & 32) {
        const i = e._;
        i ? n && i === 1 ? s = !1 : (rn(a, e),
        !n && i === 1 && delete a._) : (s = !e.$stable,
        D1(e, a)),
        l = e
    } else
        e && (P1(t, e),
        l = {
            default: 1
        });
    if (s)
        for (const i in a)
            !N1(i) && l[i] == null && delete a[i]
}
;
function op(t, e, n, r, a=!1) {
    if (Ge(t)) {
        t.forEach( (p, h) => op(p, e && (Ge(e) ? e[h] : e), n, r, a));
        return
    }
    if (Zi(r) && !a)
        return;
    const s = r.shapeFlag & 4 ? Gd(r.component) || r.component.proxy : r.el
      , l = a ? null : s
      , {i, r: o} = t
      , u = e && e.r
      , d = i.refs === jt ? i.refs = {} : i.refs
      , f = i.setupState;
    if (u != null && u !== o && (Yt(u) ? (d[u] = null,
    bt(f, u) && (f[u] = null)) : Kt(u) && (u.value = null)),
    et(o))
        ls(o, i, 12, [l, d]);
    else {
        const p = Yt(o)
          , h = Kt(o);
        if (p || h) {
            const v = () => {
                if (t.f) {
                    const y = p ? bt(f, o) ? f[o] : d[o] : o.value;
                    a ? Ge(y) && Nh(y, s) : Ge(y) ? y.includes(s) || y.push(s) : p ? (d[o] = [s],
                    bt(f, o) && (f[o] = d[o])) : (o.value = [s],
                    t.k && (d[t.k] = o.value))
                } else
                    p ? (d[o] = l,
                    bt(f, o) && (f[o] = l)) : h && (o.value = l,
                    t.k && (d[t.k] = l))
            }
            ;
            l ? (v.id = -1,
            Jn(v, n)) : v()
        }
    }
}
const Jn = Z$;
function TT(t) {
    return CT(t)
}
function CT(t, e) {
    const n = Iy();
    n.__VUE__ = !0;
    const {insert: r, remove: a, patchProp: s, createElement: l, createText: i, createComment: o, setText: u, setElementText: d, parentNode: f, nextSibling: p, setScopeId: h=rr, insertStaticContent: v} = t
      , y = (F, z, ge, Te=null, ke=null, Ee=null, Fe=void 0, Oe=null, De=!!z.dynamicChildren) => {
        if (F === z)
            return;
        F && !Vs(F, z) && (Te = ee(F),
        le(F, ke, Ee, !0),
        F = null),
        z.patchFlag === -2 && (De = !1,
        z.dynamicChildren = null);
        const {type: Ce, ref: Be, shapeFlag: ze} = z;
        switch (Ce) {
        case qd:
            k(F, z, ge, Te);
            break;
        case yr:
            w(F, z, ge, Te);
            break;
        case Eu:
            F == null && $(z, ge, Te, Fe);
            break;
        case we:
            R(F, z, ge, Te, ke, Ee, Fe, Oe, De);
            break;
        default:
            ze & 1 ? T(F, z, ge, Te, ke, Ee, Fe, Oe, De) : ze & 6 ? G(F, z, ge, Te, ke, Ee, Fe, Oe, De) : (ze & 64 || ze & 128) && Ce.process(F, z, ge, Te, ke, Ee, Fe, Oe, De, pe)
        }
        Be != null && ke && op(Be, F && F.ref, Ee, z || F, !z)
    }
      , k = (F, z, ge, Te) => {
        if (F == null)
            r(z.el = i(z.children), ge, Te);
        else {
            const ke = z.el = F.el;
            z.children !== F.children && u(ke, z.children)
        }
    }
      , w = (F, z, ge, Te) => {
        F == null ? r(z.el = o(z.children || ""), ge, Te) : z.el = F.el
    }
      , $ = (F, z, ge, Te) => {
        [F.el,F.anchor] = v(F.children, z, ge, Te, F.el, F.anchor)
    }
      , M = ({el: F, anchor: z}, ge, Te) => {
        let ke;
        for (; F && F !== z; )
            ke = p(F),
            r(F, ge, Te),
            F = ke;
        r(z, ge, Te)
    }
      , S = ({el: F, anchor: z}) => {
        let ge;
        for (; F && F !== z; )
            ge = p(F),
            a(F),
            F = ge;
        a(z)
    }
      , T = (F, z, ge, Te, ke, Ee, Fe, Oe, De) => {
        z.type === "svg" ? Fe = "svg" : z.type === "math" && (Fe = "mathml"),
        F == null ? E(z, ge, Te, ke, Ee, Fe, Oe, De) : L(F, z, ke, Ee, Fe, Oe, De)
    }
      , E = (F, z, ge, Te, ke, Ee, Fe, Oe) => {
        let De, Ce;
        const {props: Be, shapeFlag: ze, transition: Le, dirs: Ye} = F;
        if (De = F.el = l(F.type, Ee, Be && Be.is, Be),
        ze & 8 ? d(De, F.children) : ze & 16 && U(F.children, De, null, Te, ke, jc(F, Ee), Fe, Oe),
        Ye && Os(F, null, Te, "created"),
        O(De, F, F.scopeId, Fe, Te),
        Be) {
            for (const m in Be)
                m !== "value" && !Xi(m) && s(De, m, null, Be[m], Ee, F.children, Te, ke, be);
            "value"in Be && s(De, "value", null, Be.value, Ee),
            (Ce = Be.onVnodeBeforeMount) && Kr(Ce, Te, F)
        }
        Ye && Os(F, null, Te, "beforeMount");
        const D = ET(ke, Le);
        D && Le.beforeEnter(De),
        r(De, z, ge),
        ((Ce = Be && Be.onVnodeMounted) || D || Ye) && Jn( () => {
            Ce && Kr(Ce, Te, F),
            D && Le.enter(De),
            Ye && Os(F, null, Te, "mounted")
        }
        , ke)
    }
      , O = (F, z, ge, Te, ke) => {
        if (ge && h(F, ge),
        Te)
            for (let Ee = 0; Ee < Te.length; Ee++)
                h(F, Te[Ee]);
        if (ke) {
            let Ee = ke.subTree;
            if (z === Ee) {
                const Fe = ke.vnode;
                O(F, Fe, Fe.scopeId, Fe.slotScopeIds, ke.parent)
            }
        }
    }
      , U = (F, z, ge, Te, ke, Ee, Fe, Oe, De=0) => {
        for (let Ce = De; Ce < F.length; Ce++) {
            const Be = F[Ce] = Oe ? Wa(F[Ce]) : Gr(F[Ce]);
            y(null, Be, z, ge, Te, ke, Ee, Fe, Oe)
        }
    }
      , L = (F, z, ge, Te, ke, Ee, Fe) => {
        const Oe = z.el = F.el;
        let {patchFlag: De, dynamicChildren: Ce, dirs: Be} = z;
        De |= F.patchFlag & 16;
        const ze = F.props || jt
          , Le = z.props || jt;
        let Ye;
        if (ge && Ns(ge, !1),
        (Ye = Le.onVnodeBeforeUpdate) && Kr(Ye, ge, z, F),
        Be && Os(z, F, ge, "beforeUpdate"),
        ge && Ns(ge, !0),
        Ce ? C(F.dynamicChildren, Ce, Oe, ge, Te, jc(z, ke), Ee) : Fe || ne(F, z, Oe, null, ge, Te, jc(z, ke), Ee, !1),
        De > 0) {
            if (De & 16)
                W(Oe, z, ze, Le, ge, Te, ke);
            else if (De & 2 && ze.class !== Le.class && s(Oe, "class", null, Le.class, ke),
            De & 4 && s(Oe, "style", ze.style, Le.style, ke),
            De & 8) {
                const D = z.dynamicProps;
                for (let m = 0; m < D.length; m++) {
                    const b = D[m]
                      , P = ze[b]
                      , Y = Le[b];
                    (Y !== P || b === "value") && s(Oe, b, P, Y, ke, F.children, ge, Te, be)
                }
            }
            De & 1 && F.children !== z.children && d(Oe, z.children)
        } else
            !Fe && Ce == null && W(Oe, z, ze, Le, ge, Te, ke);
        ((Ye = Le.onVnodeUpdated) || Be) && Jn( () => {
            Ye && Kr(Ye, ge, z, F),
            Be && Os(z, F, ge, "updated")
        }
        , Te)
    }
      , C = (F, z, ge, Te, ke, Ee, Fe) => {
        for (let Oe = 0; Oe < z.length; Oe++) {
            const De = F[Oe]
              , Ce = z[Oe]
              , Be = De.el && (De.type === we || !Vs(De, Ce) || De.shapeFlag & 70) ? f(De.el) : ge;
            y(De, Ce, Be, null, Te, ke, Ee, Fe, !0)
        }
    }
      , W = (F, z, ge, Te, ke, Ee, Fe) => {
        if (ge !== Te) {
            if (ge !== jt)
                for (const Oe in ge)
                    !Xi(Oe) && !(Oe in Te) && s(F, Oe, ge[Oe], null, Fe, z.children, ke, Ee, be);
            for (const Oe in Te) {
                if (Xi(Oe))
                    continue;
                const De = Te[Oe]
                  , Ce = ge[Oe];
                De !== Ce && Oe !== "value" && s(F, Oe, Ce, De, Fe, z.children, ke, Ee, be)
            }
            "value"in Te && s(F, "value", ge.value, Te.value, Fe)
        }
    }
      , R = (F, z, ge, Te, ke, Ee, Fe, Oe, De) => {
        const Ce = z.el = F ? F.el : i("")
          , Be = z.anchor = F ? F.anchor : i("");
        let {patchFlag: ze, dynamicChildren: Le, slotScopeIds: Ye} = z;
        Ye && (Oe = Oe ? Oe.concat(Ye) : Ye),
        F == null ? (r(Ce, ge, Te),
        r(Be, ge, Te),
        U(z.children || [], ge, Be, ke, Ee, Fe, Oe, De)) : ze > 0 && ze & 64 && Le && F.dynamicChildren ? (C(F.dynamicChildren, Le, ge, ke, Ee, Fe, Oe),
        (z.key != null || ke && z === ke.subTree) && Jh(F, z, !0)) : ne(F, z, ge, Be, ke, Ee, Fe, Oe, De)
    }
      , G = (F, z, ge, Te, ke, Ee, Fe, Oe, De) => {
        z.slotScopeIds = Oe,
        F == null ? z.shapeFlag & 512 ? ke.ctx.activate(z, ge, Te, Fe, De) : te(z, ge, Te, ke, Ee, Fe, De) : J(F, z, De)
    }
      , te = (F, z, ge, Te, ke, Ee, Fe) => {
        const Oe = F.component = VT(F, Te, ke);
        if (Kd(F) && (Oe.ctx.renderer = pe),
        IT(Oe),
        Oe.asyncDep) {
            if (ke && ke.registerDep(Oe, ae),
            !F.el) {
                const De = Oe.subTree = x(yr);
                w(null, De, z, ge)
            }
        } else
            ae(Oe, F, z, ge, ke, Ee, Fe)
    }
      , J = (F, z, ge) => {
        const Te = z.component = F.component;
        if (G$(F, z, ge))
            if (Te.asyncDep && !Te.asyncResolved) {
                oe(Te, z, ge);
                return
            } else
                Te.next = z,
                U$(Te.update),
                Te.effect.dirty = !0,
                Te.update();
        else
            z.el = F.el,
            Te.vnode = z
    }
      , ae = (F, z, ge, Te, ke, Ee, Fe) => {
        const Oe = () => {
            if (F.isMounted) {
                let {next: Be, bu: ze, u: Le, parent: Ye, vnode: D} = F;
                {
                    const he = F1(F);
                    if (he) {
                        Be && (Be.el = D.el,
                        oe(F, Be, Fe)),
                        he.asyncDep.then( () => {
                            F.isUnmounted || Oe()
                        }
                        );
                        return
                    }
                }
                let m = Be, b;
                Ns(F, !1),
                Be ? (Be.el = D.el,
                oe(F, Be, Fe)) : Be = D,
                ze && Cu(ze),
                (b = Be.props && Be.props.onVnodeBeforeUpdate) && Kr(b, Ye, Be, D),
                Ns(F, !0);
                const P = Ic(F)
                  , Y = F.subTree;
                F.subTree = P,
                y(Y, P, f(Y.el), ee(Y), F, ke, Ee),
                Be.el = P.el,
                m === null && Y$(F, P.el),
                Le && Jn(Le, ke),
                (b = Be.props && Be.props.onVnodeUpdated) && Jn( () => Kr(b, Ye, Be, D), ke)
            } else {
                let Be;
                const {el: ze, props: Le} = z
                  , {bm: Ye, m: D, parent: m} = F
                  , b = Zi(z);
                if (Ns(F, !1),
                Ye && Cu(Ye),
                !b && (Be = Le && Le.onVnodeBeforeMount) && Kr(Be, m, z),
                Ns(F, !0),
                ze && fe) {
                    const P = () => {
                        F.subTree = Ic(F),
                        fe(ze, F.subTree, F, ke, null)
                    }
                    ;
                    b ? z.type.__asyncLoader().then( () => !F.isUnmounted && P()) : P()
                } else {
                    const P = F.subTree = Ic(F);
                    y(null, P, ge, Te, F, ke, Ee),
                    z.el = P.el
                }
                if (D && Jn(D, ke),
                !b && (Be = Le && Le.onVnodeMounted)) {
                    const P = z;
                    Jn( () => Kr(Be, m, P), ke)
                }
                (z.shapeFlag & 256 || m && Zi(m.vnode) && m.vnode.shapeFlag & 256) && F.a && Jn(F.a, ke),
                F.isMounted = !0,
                z = ge = Te = null
            }
        }
          , De = F.effect = new Fh(Oe,rr, () => Hh(Ce),F.scope)
          , Ce = F.update = () => {
            De.dirty && De.run()
        }
        ;
        Ce.id = F.uid,
        Ns(F, !0),
        Ce()
    }
      , oe = (F, z, ge) => {
        z.component = F;
        const Te = F.vnode.props;
        F.vnode = z,
        F.next = null,
        wT(F, z.props, Te, ge),
        $T(F, z.children, ge),
        ws(),
        Dv(F),
        xs()
    }
      , ne = (F, z, ge, Te, ke, Ee, Fe, Oe, De=!1) => {
        const Ce = F && F.children
          , Be = F ? F.shapeFlag : 0
          , ze = z.children
          , {patchFlag: Le, shapeFlag: Ye} = z;
        if (Le > 0) {
            if (Le & 128) {
                j(Ce, ze, ge, Te, ke, Ee, Fe, Oe, De);
                return
            } else if (Le & 256) {
                I(Ce, ze, ge, Te, ke, Ee, Fe, Oe, De);
                return
            }
        }
        Ye & 8 ? (Be & 16 && be(Ce, ke, Ee),
        ze !== Ce && d(ge, ze)) : Be & 16 ? Ye & 16 ? j(Ce, ze, ge, Te, ke, Ee, Fe, Oe, De) : be(Ce, ke, Ee, !0) : (Be & 8 && d(ge, ""),
        Ye & 16 && U(ze, ge, Te, ke, Ee, Fe, Oe, De))
    }
      , I = (F, z, ge, Te, ke, Ee, Fe, Oe, De) => {
        F = F || zl,
        z = z || zl;
        const Ce = F.length
          , Be = z.length
          , ze = Math.min(Ce, Be);
        let Le;
        for (Le = 0; Le < ze; Le++) {
            const Ye = z[Le] = De ? Wa(z[Le]) : Gr(z[Le]);
            y(F[Le], Ye, ge, null, ke, Ee, Fe, Oe, De)
        }
        Ce > Be ? be(F, ke, Ee, !0, !1, ze) : U(z, ge, Te, ke, Ee, Fe, Oe, De, ze)
    }
      , j = (F, z, ge, Te, ke, Ee, Fe, Oe, De) => {
        let Ce = 0;
        const Be = z.length;
        let ze = F.length - 1
          , Le = Be - 1;
        for (; Ce <= ze && Ce <= Le; ) {
            const Ye = F[Ce]
              , D = z[Ce] = De ? Wa(z[Ce]) : Gr(z[Ce]);
            if (Vs(Ye, D))
                y(Ye, D, ge, null, ke, Ee, Fe, Oe, De);
            else
                break;
            Ce++
        }
        for (; Ce <= ze && Ce <= Le; ) {
            const Ye = F[ze]
              , D = z[Le] = De ? Wa(z[Le]) : Gr(z[Le]);
            if (Vs(Ye, D))
                y(Ye, D, ge, null, ke, Ee, Fe, Oe, De);
            else
                break;
            ze--,
            Le--
        }
        if (Ce > ze) {
            if (Ce <= Le) {
                const Ye = Le + 1
                  , D = Ye < Be ? z[Ye].el : Te;
                for (; Ce <= Le; )
                    y(null, z[Ce] = De ? Wa(z[Ce]) : Gr(z[Ce]), ge, D, ke, Ee, Fe, Oe, De),
                    Ce++
            }
        } else if (Ce > Le)
            for (; Ce <= ze; )
                le(F[Ce], ke, Ee, !0),
                Ce++;
        else {
            const Ye = Ce
              , D = Ce
              , m = new Map;
            for (Ce = D; Ce <= Le; Ce++) {
                const tt = z[Ce] = De ? Wa(z[Ce]) : Gr(z[Ce]);
                tt.key != null && m.set(tt.key, Ce)
            }
            let b, P = 0;
            const Y = Le - D + 1;
            let he = !1
              , $e = 0;
            const Je = new Array(Y);
            for (Ce = 0; Ce < Y; Ce++)
                Je[Ce] = 0;
            for (Ce = Ye; Ce <= ze; Ce++) {
                const tt = F[Ce];
                if (P >= Y) {
                    le(tt, ke, Ee, !0);
                    continue
                }
                let it;
                if (tt.key != null)
                    it = m.get(tt.key);
                else
                    for (b = D; b <= Le; b++)
                        if (Je[b - D] === 0 && Vs(tt, z[b])) {
                            it = b;
                            break
                        }
                it === void 0 ? le(tt, ke, Ee, !0) : (Je[it - D] = Ce + 1,
                it >= $e ? $e = it : he = !0,
                y(tt, z[it], ge, null, ke, Ee, Fe, Oe, De),
                P++)
            }
            const wt = he ? AT(Je) : zl;
            for (b = wt.length - 1,
            Ce = Y - 1; Ce >= 0; Ce--) {
                const tt = D + Ce
                  , it = z[tt]
                  , ot = tt + 1 < Be ? z[tt + 1].el : Te;
                Je[Ce] === 0 ? y(null, it, ge, ot, ke, Ee, Fe, Oe, De) : he && (b < 0 || Ce !== wt[b] ? re(it, ge, ot, 2) : b--)
            }
        }
    }
      , re = (F, z, ge, Te, ke=null) => {
        const {el: Ee, type: Fe, transition: Oe, children: De, shapeFlag: Ce} = F;
        if (Ce & 6) {
            re(F.component.subTree, z, ge, Te);
            return
        }
        if (Ce & 128) {
            F.suspense.move(z, ge, Te);
            return
        }
        if (Ce & 64) {
            Fe.move(F, z, ge, pe);
            return
        }
        if (Fe === we) {
            r(Ee, z, ge);
            for (let ze = 0; ze < De.length; ze++)
                re(De[ze], z, ge, Te);
            r(F.anchor, z, ge);
            return
        }
        if (Fe === Eu) {
            M(F, z, ge);
            return
        }
        if (Te !== 2 && Ce & 1 && Oe)
            if (Te === 0)
                Oe.beforeEnter(Ee),
                r(Ee, z, ge),
                Jn( () => Oe.enter(Ee), ke);
            else {
                const {leave: ze, delayLeave: Le, afterLeave: Ye} = Oe
                  , D = () => r(Ee, z, ge)
                  , m = () => {
                    ze(Ee, () => {
                        D(),
                        Ye && Ye()
                    }
                    )
                }
                ;
                Le ? Le(Ee, D, m) : m()
            }
        else
            r(Ee, z, ge)
    }
      , le = (F, z, ge, Te=!1, ke=!1) => {
        const {type: Ee, props: Fe, ref: Oe, children: De, dynamicChildren: Ce, shapeFlag: Be, patchFlag: ze, dirs: Le} = F;
        if (Oe != null && op(Oe, null, ge, F, !0),
        Be & 256) {
            z.ctx.deactivate(F);
            return
        }
        const Ye = Be & 1 && Le
          , D = !Zi(F);
        let m;
        if (D && (m = Fe && Fe.onVnodeBeforeUnmount) && Kr(m, z, F),
        Be & 6)
            X(F.component, ge, Te);
        else {
            if (Be & 128) {
                F.suspense.unmount(ge, Te);
                return
            }
            Ye && Os(F, null, z, "beforeUnmount"),
            Be & 64 ? F.type.remove(F, z, ge, ke, pe, Te) : Ce && (Ee !== we || ze > 0 && ze & 64) ? be(Ce, z, ge, !1, !0) : (Ee === we && ze & 384 || !ke && Be & 16) && be(De, z, ge),
            Te && ce(F)
        }
        (D && (m = Fe && Fe.onVnodeUnmounted) || Ye) && Jn( () => {
            m && Kr(m, z, F),
            Ye && Os(F, null, z, "unmounted")
        }
        , ge)
    }
      , ce = F => {
        const {type: z, el: ge, anchor: Te, transition: ke} = F;
        if (z === we) {
            xe(ge, Te);
            return
        }
        if (z === Eu) {
            S(F);
            return
        }
        const Ee = () => {
            a(ge),
            ke && !ke.persisted && ke.afterLeave && ke.afterLeave()
        }
        ;
        if (F.shapeFlag & 1 && ke && !ke.persisted) {
            const {leave: Fe, delayLeave: Oe} = ke
              , De = () => Fe(ge, Ee);
            Oe ? Oe(F.el, Ee, De) : De()
        } else
            Ee()
    }
      , xe = (F, z) => {
        let ge;
        for (; F !== z; )
            ge = p(F),
            a(F),
            F = ge;
        a(z)
    }
      , X = (F, z, ge) => {
        const {bum: Te, scope: ke, update: Ee, subTree: Fe, um: Oe} = F;
        Te && Cu(Te),
        ke.stop(),
        Ee && (Ee.active = !1,
        le(Fe, F, z, ge)),
        Oe && Jn(Oe, z),
        Jn( () => {
            F.isUnmounted = !0
        }
        , z),
        z && z.pendingBranch && !z.isUnmounted && F.asyncDep && !F.asyncResolved && F.suspenseId === z.pendingId && (z.deps--,
        z.deps === 0 && z.resolve())
    }
      , be = (F, z, ge, Te=!1, ke=!1, Ee=0) => {
        for (let Fe = Ee; Fe < F.length; Fe++)
            le(F[Fe], z, ge, Te, ke)
    }
      , ee = F => F.shapeFlag & 6 ? ee(F.component.subTree) : F.shapeFlag & 128 ? F.suspense.next() : p(F.anchor || F.el);
    let B = !1;
    const se = (F, z, ge) => {
        F == null ? z._vnode && le(z._vnode, null, null, !0) : y(z._vnode || null, F, z, null, null, null, ge),
        B || (B = !0,
        Dv(),
        d1(),
        B = !1),
        z._vnode = F
    }
      , pe = {
        p: y,
        um: le,
        m: re,
        r: ce,
        mt: te,
        mc: U,
        pc: ne,
        pbc: C,
        n: ee,
        o: t
    };
    let ie, fe;
    return e && ([ie,fe] = e(pe)),
    {
        render: se,
        hydrate: ie,
        createApp: yT(se, ie)
    }
}
function jc({type: t, props: e}, n) {
    return n === "svg" && t === "foreignObject" || n === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n
}
function Ns({effect: t, update: e}, n) {
    t.allowRecurse = e.allowRecurse = n
}
function ET(t, e) {
    return (!t || t && !t.pendingBranch) && e && !e.persisted
}
function Jh(t, e, n=!1) {
    const r = t.children
      , a = e.children;
    if (Ge(r) && Ge(a))
        for (let s = 0; s < r.length; s++) {
            const l = r[s];
            let i = a[s];
            i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = a[s] = Wa(a[s]),
            i.el = l.el),
            n || Jh(l, i)),
            i.type === qd && (i.el = l.el)
        }
}
function AT(t) {
    const e = t.slice()
      , n = [0];
    let r, a, s, l, i;
    const o = t.length;
    for (r = 0; r < o; r++) {
        const u = t[r];
        if (u !== 0) {
            if (a = n[n.length - 1],
            t[a] < u) {
                e[r] = a,
                n.push(r);
                continue
            }
            for (s = 0,
            l = n.length - 1; s < l; )
                i = s + l >> 1,
                t[n[i]] < u ? s = i + 1 : l = i;
            u < t[n[s]] && (s > 0 && (e[r] = n[s - 1]),
            n[s] = r)
        }
    }
    for (s = n.length,
    l = n[s - 1]; s-- > 0; )
        n[s] = l,
        l = e[l];
    return n
}
function F1(t) {
    const e = t.subTree.component;
    if (e)
        return e.asyncDep && !e.asyncResolved ? e : F1(e)
}
const MT = t => t.__isTeleport
  , to = t => t && (t.disabled || t.disabled === "")
  , zv = t => typeof SVGElement < "u" && t instanceof SVGElement
  , qv = t => typeof MathMLElement == "function" && t instanceof MathMLElement
  , up = (t, e) => {
    const n = t && t.to;
    return Yt(n) ? e ? e(n) : null : n
}
  , OT = {
    name: "Teleport",
    __isTeleport: !0,
    process(t, e, n, r, a, s, l, i, o, u) {
        const {mc: d, pc: f, pbc: p, o: {insert: h, querySelector: v, createText: y, createComment: k}} = u
          , w = to(e.props);
        let {shapeFlag: $, children: M, dynamicChildren: S} = e;
        if (t == null) {
            const T = e.el = y("")
              , E = e.anchor = y("");
            h(T, n, r),
            h(E, n, r);
            const O = e.target = up(e.props, v)
              , U = e.targetAnchor = y("");
            O && (h(U, O),
            l === "svg" || zv(O) ? l = "svg" : (l === "mathml" || qv(O)) && (l = "mathml"));
            const L = (C, W) => {
                $ & 16 && d(M, C, W, a, s, l, i, o)
            }
            ;
            w ? L(n, E) : O && L(O, U)
        } else {
            e.el = t.el;
            const T = e.anchor = t.anchor
              , E = e.target = t.target
              , O = e.targetAnchor = t.targetAnchor
              , U = to(t.props)
              , L = U ? n : E
              , C = U ? T : O;
            if (l === "svg" || zv(E) ? l = "svg" : (l === "mathml" || qv(E)) && (l = "mathml"),
            S ? (p(t.dynamicChildren, S, L, a, s, l, i),
            Jh(t, e, !0)) : o || f(t, e, L, C, a, s, l, i, !1),
            w)
                U ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : pu(e, n, T, u, 1);
            else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                const W = e.target = up(e.props, v);
                W && pu(e, W, null, u, 0)
            } else
                U && pu(e, E, O, u, 1)
        }
        B1(e)
    },
    remove(t, e, n, r, {um: a, o: {remove: s}}, l) {
        const {shapeFlag: i, children: o, anchor: u, targetAnchor: d, target: f, props: p} = t;
        if (f && s(d),
        l && s(u),
        i & 16) {
            const h = l || !to(p);
            for (let v = 0; v < o.length; v++) {
                const y = o[v];
                a(y, e, n, h, !!y.dynamicChildren)
            }
        }
    },
    move: pu,
    hydrate: NT
};
function pu(t, e, n, {o: {insert: r}, m: a}, s=2) {
    s === 0 && r(t.targetAnchor, e, n);
    const {el: l, anchor: i, shapeFlag: o, children: u, props: d} = t
      , f = s === 2;
    if (f && r(l, e, n),
    (!f || to(d)) && o & 16)
        for (let p = 0; p < u.length; p++)
            a(u[p], e, n, 2);
    f && r(i, e, n)
}
function NT(t, e, n, r, a, s, {o: {nextSibling: l, parentNode: i, querySelector: o}}, u) {
    const d = e.target = up(e.props, o);
    if (d) {
        const f = d._lpa || d.firstChild;
        if (e.shapeFlag & 16)
            if (to(e.props))
                e.anchor = u(l(t), e, i(t), n, r, a, s),
                e.targetAnchor = f;
            else {
                e.anchor = l(t);
                let p = f;
                for (; p; )
                    if (p = l(p),
                    p && p.nodeType === 8 && p.data === "teleport anchor") {
                        e.targetAnchor = p,
                        d._lpa = e.targetAnchor && l(e.targetAnchor);
                        break
                    }
                u(f, e, d, n, r, a, s)
            }
        B1(e)
    }
    return e.anchor && l(e.anchor)
}
const Ti = OT;
function B1(t) {
    const e = t.ctx;
    if (e && e.ut) {
        let n = t.children[0].el;
        for (; n && n !== t.targetAnchor; )
            n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid),
            n = n.nextSibling;
        e.ut()
    }
}
const we = Symbol.for("v-fgt")
  , qd = Symbol.for("v-txt")
  , yr = Symbol.for("v-cmt")
  , Eu = Symbol.for("v-stc")
  , no = [];
let Or = null;
function g(t=!1) {
    no.push(Or = t ? null : [])
}
function DT() {
    no.pop(),
    Or = no[no.length - 1] || null
}
let xo = 1;
function Wv(t) {
    xo += t
}
function V1(t) {
    return t.dynamicChildren = xo > 0 ? Or || zl : null,
    DT(),
    xo > 0 && Or && Or.push(t),
    t
}
function _(t, e, n, r, a, s) {
    return V1(c(t, e, n, r, a, s, !0))
}
function de(t, e, n, r, a) {
    return V1(x(t, e, n, r, a, !0))
}
function zu(t) {
    return t ? t.__v_isVNode === !0 : !1
}
function Vs(t, e) {
    return t.type === e.type && t.key === e.key
}
const I1 = ({key: t}) => t ?? null
  , Au = ({ref: t, ref_key: e, ref_for: n}) => (typeof t == "number" && (t = "" + t),
t != null ? Yt(t) || Kt(t) || et(t) ? {
    i: ln,
    r: t,
    k: e,
    f: !!n
} : t : null);
function c(t, e=null, n=null, r=0, a=null, s=t === we ? 0 : 1, l=!1, i=!1) {
    const o = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && I1(e),
        ref: e && Au(e),
        scopeId: Hd,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: a,
        dynamicChildren: null,
        appContext: null,
        ctx: ln
    };
    return i ? (Xh(o, n),
    s & 128 && t.normalize(o)) : n && (o.shapeFlag |= Yt(n) ? 8 : 16),
    xo > 0 && !l && Or && (o.patchFlag > 0 || s & 6) && o.patchFlag !== 32 && Or.push(o),
    o
}
const x = PT;
function PT(t, e=null, n=null, r=0, a=null, s=!1) {
    if ((!t || t === p1) && (t = yr),
    zu(t)) {
        const i = vs(t, e, !0);
        return n && Xh(i, n),
        xo > 0 && !s && Or && (i.shapeFlag & 6 ? Or[Or.indexOf(t)] = i : Or.push(i)),
        i.patchFlag |= -2,
        i
    }
    if (UT(t) && (t = t.__vccOpts),
    e) {
        e = Vt(e);
        let {class: i, style: o} = e;
        i && !Yt(i) && (e.class = ye(i)),
        It(o) && (n1(o) && !Ge(o) && (o = rn({}, o)),
        e.style = Rt(o))
    }
    const l = Yt(t) ? 1 : Q$(t) ? 128 : MT(t) ? 64 : It(t) ? 4 : et(t) ? 2 : 0;
    return c(t, e, n, r, a, l, s, !0)
}
function Vt(t) {
    return t ? n1(t) || A1(t) ? rn({}, t) : t : null
}
function vs(t, e, n=!1) {
    const {props: r, ref: a, patchFlag: s, children: l} = t
      , i = e ? Ve(r || {}, e) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: i,
        key: i && I1(i),
        ref: e && e.ref ? n && a ? Ge(a) ? a.concat(Au(e)) : [a, Au(e)] : Au(e) : a,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: l,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== we ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && vs(t.ssContent),
        ssFallback: t.ssFallback && vs(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
    }
}
function ve(t=" ", e=0) {
    return x(qd, null, t, e)
}
function Ci(t, e) {
    const n = x(Eu, null, t);
    return n.staticCount = e,
    n
}
function q(t="", e=!1) {
    return e ? (g(),
    de(yr, null, t)) : x(yr, null, t)
}
function Gr(t) {
    return t == null || typeof t == "boolean" ? x(yr) : Ge(t) ? x(we, null, t.slice()) : typeof t == "object" ? Wa(t) : x(qd, null, String(t))
}
function Wa(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : vs(t)
}
function Xh(t, e) {
    let n = 0;
    const {shapeFlag: r} = t;
    if (e == null)
        e = null;
    else if (Ge(e))
        n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const a = e.default;
            a && (a._c && (a._d = !1),
            Xh(t, a()),
            a._c && (a._d = !0));
            return
        } else {
            n = 32;
            const a = e._;
            !a && !A1(e) ? e._ctx = ln : a === 3 && ln && (ln.slots._ === 1 ? e._ = 1 : (e._ = 2,
            t.patchFlag |= 1024))
        }
    else
        et(e) ? (e = {
            default: e,
            _ctx: ln
        },
        n = 32) : (e = String(e),
        r & 64 ? (n = 16,
        e = [ve(e)]) : n = 8);
    t.children = e,
    t.shapeFlag |= n
}
function Ve(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const a in r)
            if (a === "class")
                e.class !== r.class && (e.class = ye([e.class, r.class]));
            else if (a === "style")
                e.style = Rt([e.style, r.style]);
            else if (Nd(a)) {
                const s = e[a]
                  , l = r[a];
                l && s !== l && !(Ge(s) && s.includes(l)) && (e[a] = s ? [].concat(s, l) : l)
            } else
                a !== "" && (e[a] = r[a])
    }
    return e
}
function Kr(t, e, n, r=null) {
    br(t, e, 7, [n, r])
}
const FT = T1();
let BT = 0;
function VT(t, e, n) {
    const r = t.type
      , a = (e ? e.appContext : t.appContext) || FT
      , s = {
        uid: BT++,
        vnode: t,
        type: r,
        parent: e,
        appContext: a,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new jy(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(a.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: O1(r, a),
        emitsOptions: f1(r, a),
        emit: null,
        emitted: null,
        propsDefaults: jt,
        inheritAttrs: r.inheritAttrs,
        ctx: jt,
        data: jt,
        props: jt,
        attrs: jt,
        slots: jt,
        refs: jt,
        setupState: jt,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        suspense: n,
        suspenseId: n ? n.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = e ? e.root : s,
    s.emit = z$.bind(null, s),
    t.ce && t.ce(s),
    s
}
let vn = null;
const pl = () => vn || ln;
let qu, dp;
{
    const t = Iy()
      , e = (n, r) => {
        let a;
        return (a = t[n]) || (a = t[n] = []),
        a.push(r),
        s => {
            a.length > 1 ? a.forEach(l => l(s)) : a[0](s)
        }
    }
    ;
    qu = e("__VUE_INSTANCE_SETTERS__", n => vn = n),
    dp = e("__VUE_SSR_SETTERS__", n => Wd = n)
}
const zo = t => {
    const e = vn;
    return qu(t),
    t.scope.on(),
    () => {
        t.scope.off(),
        qu(e)
    }
}
  , Gv = () => {
    vn && vn.scope.off(),
    qu(null)
}
;
function R1(t) {
    return t.vnode.shapeFlag & 4
}
let Wd = !1;
function IT(t, e=!1) {
    e && dp(e);
    const {props: n, children: r} = t.vnode
      , a = R1(t);
    _T(t, n, a, e),
    ST(t, r);
    const s = a ? RT(t, e) : void 0;
    return e && dp(!1),
    s
}
function RT(t, e) {
    const n = t.type;
    t.accessCache = Object.create(null),
    t.proxy = new Proxy(t.ctx,fT);
    const {setup: r} = n;
    if (r) {
        const a = t.setupContext = r.length > 1 ? j1(t) : null
          , s = zo(t);
        ws();
        const l = ls(r, t, 0, [t.props, a]);
        if (xs(),
        s(),
        Py(l)) {
            if (l.then(Gv, Gv),
            e)
                return l.then(i => {
                    Yv(t, i, e)
                }
                ).catch(i => {
                    jd(i, t, 0)
                }
                );
            t.asyncDep = l
        } else
            Yv(t, l, e)
    } else
        L1(t, e)
}
function Yv(t, e, n) {
    et(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : It(e) && (t.setupState = s1(e)),
    L1(t, n)
}
let Jv;
function L1(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && Jv && !r.render) {
            const a = r.template || Gh(t).template;
            if (a) {
                const {isCustomElement: s, compilerOptions: l} = t.appContext.config
                  , {delimiters: i, compilerOptions: o} = r
                  , u = rn(rn({
                    isCustomElement: s,
                    delimiters: i
                }, l), o);
                r.render = Jv(a, u)
            }
        }
        t.render = r.render || rr
    }
    {
        const a = zo(t);
        ws();
        try {
            pT(t)
        } finally {
            xs(),
            a()
        }
    }
}
const LT = {
    get(t, e) {
        return Zn(t, "get", ""),
        t[e]
    }
};
function j1(t) {
    const e = n => {
        t.exposed = n || {}
    }
    ;
    return {
        attrs: new Proxy(t.attrs,LT),
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}
function Gd(t) {
    if (t.exposed)
        return t.exposeProxy || (t.exposeProxy = new Proxy(s1(Ld(t.exposed)),{
            get(e, n) {
                if (n in e)
                    return e[n];
                if (n in eo)
                    return eo[n](t)
            },
            has(e, n) {
                return n in e || n in eo
            }
        }))
}
function jT(t, e=!0) {
    return et(t) ? t.displayName || t.name : t.name || e && t.__name
}
function UT(t) {
    return et(t) && "__vccOpts"in t
}
const K = (t, e) => D$(t, e, Wd);
function st(t, e, n) {
    const r = arguments.length;
    return r === 2 ? It(e) && !Ge(e) ? zu(e) ? x(t, null, [e]) : x(t, e) : x(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && zu(n) && (n = [n]),
    x(t, e, n))
}
const HT = "3.4.25";
/**
* @vue/runtime-dom v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const KT = "http://www.w3.org/2000/svg"
  , zT = "http://www.w3.org/1998/Math/MathML"
  , Ga = typeof document < "u" ? document : null
  , Xv = Ga && Ga.createElement("template")
  , qT = {
    insert: (t, e, n) => {
        e.insertBefore(t, n || null)
    }
    ,
    remove: t => {
        const e = t.parentNode;
        e && e.removeChild(t)
    }
    ,
    createElement: (t, e, n, r) => {
        const a = e === "svg" ? Ga.createElementNS(KT, t) : e === "mathml" ? Ga.createElementNS(zT, t) : Ga.createElement(t, n ? {
            is: n
        } : void 0);
        return t === "select" && r && r.multiple != null && a.setAttribute("multiple", r.multiple),
        a
    }
    ,
    createText: t => Ga.createTextNode(t),
    createComment: t => Ga.createComment(t),
    setText: (t, e) => {
        t.nodeValue = e
    }
    ,
    setElementText: (t, e) => {
        t.textContent = e
    }
    ,
    parentNode: t => t.parentNode,
    nextSibling: t => t.nextSibling,
    querySelector: t => Ga.querySelector(t),
    setScopeId(t, e) {
        t.setAttribute(e, "")
    },
    insertStaticContent(t, e, n, r, a, s) {
        const l = n ? n.previousSibling : e.lastChild;
        if (a && (a === s || a.nextSibling))
            for (; e.insertBefore(a.cloneNode(!0), n),
            !(a === s || !(a = a.nextSibling)); )
                ;
        else {
            Xv.innerHTML = r === "svg" ? `<svg>${t}</svg>` : r === "mathml" ? `<math>${t}</math>` : t;
            const i = Xv.content;
            if (r === "svg" || r === "mathml") {
                const o = i.firstChild;
                for (; o.firstChild; )
                    i.appendChild(o.firstChild);
                i.removeChild(o)
            }
            e.insertBefore(i, n)
        }
        return [l ? l.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
    }
}
  , Ia = "transition"
  , Pi = "animation"
  , ti = Symbol("_vtc")
  , fa = (t, {slots: e}) => st(aT, H1(t), e);
fa.displayName = "Transition";
const U1 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , WT = fa.props = rn({}, v1, U1)
  , Ds = (t, e=[]) => {
    Ge(t) ? t.forEach(n => n(...e)) : t && t(...e)
}
  , Qv = t => t ? Ge(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;
function H1(t) {
    const e = {};
    for (const R in t)
        R in U1 || (e[R] = t[R]);
    if (t.css === !1)
        return e;
    const {name: n="v", type: r, duration: a, enterFromClass: s=`${n}-enter-from`, enterActiveClass: l=`${n}-enter-active`, enterToClass: i=`${n}-enter-to`, appearFromClass: o=s, appearActiveClass: u=l, appearToClass: d=i, leaveFromClass: f=`${n}-leave-from`, leaveActiveClass: p=`${n}-leave-active`, leaveToClass: h=`${n}-leave-to`} = t
      , v = GT(a)
      , y = v && v[0]
      , k = v && v[1]
      , {onBeforeEnter: w, onEnter: $, onEnterCancelled: M, onLeave: S, onLeaveCancelled: T, onBeforeAppear: E=w, onAppear: O=$, onAppearCancelled: U=M} = e
      , L = (R, G, te) => {
        Ua(R, G ? d : i),
        Ua(R, G ? u : l),
        te && te()
    }
      , C = (R, G) => {
        R._isLeaving = !1,
        Ua(R, f),
        Ua(R, h),
        Ua(R, p),
        G && G()
    }
      , W = R => (G, te) => {
        const J = R ? O : $
          , ae = () => L(G, R, te);
        Ds(J, [G, ae]),
        Zv( () => {
            Ua(G, R ? o : s),
            ya(G, R ? d : i),
            Qv(J) || eg(G, r, y, ae)
        }
        )
    }
    ;
    return rn(e, {
        onBeforeEnter(R) {
            Ds(w, [R]),
            ya(R, s),
            ya(R, l)
        },
        onBeforeAppear(R) {
            Ds(E, [R]),
            ya(R, o),
            ya(R, u)
        },
        onEnter: W(!1),
        onAppear: W(!0),
        onLeave(R, G) {
            R._isLeaving = !0;
            const te = () => C(R, G);
            ya(R, f),
            ya(R, p),
            z1(),
            Zv( () => {
                R._isLeaving && (Ua(R, f),
                ya(R, h),
                Qv(S) || eg(R, r, k, te))
            }
            ),
            Ds(S, [R, te])
        },
        onEnterCancelled(R) {
            L(R, !1),
            Ds(M, [R])
        },
        onAppearCancelled(R) {
            L(R, !0),
            Ds(U, [R])
        },
        onLeaveCancelled(R) {
            C(R),
            Ds(T, [R])
        }
    })
}
function GT(t) {
    if (t == null)
        return null;
    if (It(t))
        return [Uc(t.enter), Uc(t.leave)];
    {
        const e = Uc(t);
        return [e, e]
    }
}
function Uc(t) {
    return a$(t)
}
function ya(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)),
    (t[ti] || (t[ti] = new Set)).add(e)
}
function Ua(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const n = t[ti];
    n && (n.delete(e),
    n.size || (t[ti] = void 0))
}
function Zv(t) {
    requestAnimationFrame( () => {
        requestAnimationFrame(t)
    }
    )
}
let YT = 0;
function eg(t, e, n, r) {
    const a = t._endId = ++YT
      , s = () => {
        a === t._endId && r()
    }
    ;
    if (n)
        return setTimeout(s, n);
    const {type: l, timeout: i, propCount: o} = K1(t, e);
    if (!l)
        return r();
    const u = l + "end";
    let d = 0;
    const f = () => {
        t.removeEventListener(u, p),
        s()
    }
      , p = h => {
        h.target === t && ++d >= o && f()
    }
    ;
    setTimeout( () => {
        d < o && f()
    }
    , i + 1),
    t.addEventListener(u, p)
}
function K1(t, e) {
    const n = window.getComputedStyle(t)
      , r = v => (n[v] || "").split(", ")
      , a = r(`${Ia}Delay`)
      , s = r(`${Ia}Duration`)
      , l = tg(a, s)
      , i = r(`${Pi}Delay`)
      , o = r(`${Pi}Duration`)
      , u = tg(i, o);
    let d = null
      , f = 0
      , p = 0;
    e === Ia ? l > 0 && (d = Ia,
    f = l,
    p = s.length) : e === Pi ? u > 0 && (d = Pi,
    f = u,
    p = o.length) : (f = Math.max(l, u),
    d = f > 0 ? l > u ? Ia : Pi : null,
    p = d ? d === Ia ? s.length : o.length : 0);
    const h = d === Ia && /\b(transform|all)(,|$)/.test(r(`${Ia}Property`).toString());
    return {
        type: d,
        timeout: f,
        propCount: p,
        hasTransform: h
    }
}
function tg(t, e) {
    for (; t.length < e.length; )
        t = t.concat(t);
    return Math.max(...e.map( (n, r) => ng(n) + ng(t[r])))
}
function ng(t) {
    return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3
}
function z1() {
    return document.body.offsetHeight
}
function JT(t, e, n) {
    const r = t[ti];
    r && (e = (e ? [e, ...r] : [...r]).join(" ")),
    e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}
const Wu = Symbol("_vod")
  , q1 = Symbol("_vsh")
  , jn = {
    beforeMount(t, {value: e}, {transition: n}) {
        t[Wu] = t.style.display === "none" ? "" : t.style.display,
        n && e ? n.beforeEnter(t) : Fi(t, e)
    },
    mounted(t, {value: e}, {transition: n}) {
        n && e && n.enter(t)
    },
    updated(t, {value: e, oldValue: n}, {transition: r}) {
        !e != !n && (r ? e ? (r.beforeEnter(t),
        Fi(t, !0),
        r.enter(t)) : r.leave(t, () => {
            Fi(t, !1)
        }
        ) : Fi(t, e))
    },
    beforeUnmount(t, {value: e}) {
        Fi(t, e)
    }
};
function Fi(t, e) {
    t.style.display = e ? t[Wu] : "none",
    t[q1] = !e
}
const XT = Symbol("")
  , QT = /(^|;)\s*display\s*:/;
function ZT(t, e, n) {
    const r = t.style
      , a = Yt(n);
    let s = !1;
    if (n && !a) {
        if (e)
            if (Yt(e))
                for (const l of e.split(";")) {
                    const i = l.slice(0, l.indexOf(":")).trim();
                    n[i] == null && Mu(r, i, "")
                }
            else
                for (const l in e)
                    n[l] == null && Mu(r, l, "");
        for (const l in n)
            l === "display" && (s = !0),
            Mu(r, l, n[l])
    } else if (a) {
        if (e !== n) {
            const l = r[XT];
            l && (n += ";" + l),
            r.cssText = n,
            s = QT.test(n)
        }
    } else
        e && t.removeAttribute("style");
    Wu in t && (t[Wu] = s ? r.display : "",
    t[q1] && (r.display = "none"))
}
const rg = /\s*!important$/;
function Mu(t, e, n) {
    if (Ge(n))
        n.forEach(r => Mu(t, e, r));
    else if (n == null && (n = ""),
    e.startsWith("--"))
        t.setProperty(e, n);
    else {
        const r = e2(t, e);
        rg.test(n) ? t.setProperty(fl(r), n.replace(rg, ""), "important") : t[r] = n
    }
}
const ag = ["Webkit", "Moz", "ms"]
  , Hc = {};
function e2(t, e) {
    const n = Hc[e];
    if (n)
        return n;
    let r = la(e);
    if (r !== "filter" && r in t)
        return Hc[e] = r;
    r = Pd(r);
    for (let a = 0; a < ag.length; a++) {
        const s = ag[a] + r;
        if (s in t)
            return Hc[e] = s
    }
    return e
}
const sg = "http://www.w3.org/1999/xlink";
function t2(t, e, n, r, a) {
    if (r && e.startsWith("xlink:"))
        n == null ? t.removeAttributeNS(sg, e.slice(6, e.length)) : t.setAttributeNS(sg, e, n);
    else {
        const s = d$(e);
        n == null || s && !Ry(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : n)
    }
}
function n2(t, e, n, r, a, s, l) {
    if (e === "innerHTML" || e === "textContent") {
        r && l(r, a, s),
        t[e] = n ?? "";
        return
    }
    const i = t.tagName;
    if (e === "value" && i !== "PROGRESS" && !i.includes("-")) {
        const u = i === "OPTION" ? t.getAttribute("value") || "" : t.value
          , d = n ?? "";
        (u !== d || !("_value"in t)) && (t.value = d),
        n == null && t.removeAttribute(e),
        t._value = n;
        return
    }
    let o = !1;
    if (n === "" || n == null) {
        const u = typeof t[e];
        u === "boolean" ? n = Ry(n) : n == null && u === "string" ? (n = "",
        o = !0) : u === "number" && (n = 0,
        o = !0)
    }
    try {
        t[e] = n
    } catch {}
    o && t.removeAttribute(e)
}
function _a(t, e, n, r) {
    t.addEventListener(e, n, r)
}
function r2(t, e, n, r) {
    t.removeEventListener(e, n, r)
}
const lg = Symbol("_vei");
function a2(t, e, n, r, a=null) {
    const s = t[lg] || (t[lg] = {})
      , l = s[e];
    if (r && l)
        l.value = r;
    else {
        const [i,o] = s2(e);
        if (r) {
            const u = s[e] = o2(r, a);
            _a(t, i, u, o)
        } else
            l && (r2(t, i, l, o),
            s[e] = void 0)
    }
}
const ig = /(?:Once|Passive|Capture)$/;
function s2(t) {
    let e;
    if (ig.test(t)) {
        e = {};
        let r;
        for (; r = t.match(ig); )
            t = t.slice(0, t.length - r[0].length),
            e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : fl(t.slice(2)), e]
}
let Kc = 0;
const l2 = Promise.resolve()
  , i2 = () => Kc || (l2.then( () => Kc = 0),
Kc = Date.now());
function o2(t, e) {
    const n = r => {
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= n.attached)
            return;
        br(u2(r, n.value), e, 5, [r])
    }
    ;
    return n.value = t,
    n.attached = i2(),
    n
}
function u2(t, e) {
    if (Ge(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t),
            t._stopped = !0
        }
        ,
        e.map(r => a => !a._stopped && r && r(a))
    } else
        return e
}
const og = t => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123
  , d2 = (t, e, n, r, a, s, l, i, o) => {
    const u = a === "svg";
    e === "class" ? JT(t, r, u) : e === "style" ? ZT(t, n, r) : Nd(e) ? Oh(e) || a2(t, e, n, r, l) : (e[0] === "." ? (e = e.slice(1),
    !0) : e[0] === "^" ? (e = e.slice(1),
    !1) : c2(t, e, r, u)) ? n2(t, e, r, s, l, i, o) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r),
    t2(t, e, r, u))
}
;
function c2(t, e, n, r) {
    if (r)
        return !!(e === "innerHTML" || e === "textContent" || e in t && og(e) && et(n));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA")
        return !1;
    if (e === "width" || e === "height") {
        const a = t.tagName;
        if (a === "IMG" || a === "VIDEO" || a === "CANVAS" || a === "SOURCE")
            return !1
    }
    return og(e) && Yt(n) ? !1 : e in t
}
const W1 = new WeakMap
  , G1 = new WeakMap
  , Gu = Symbol("_moveCb")
  , ug = Symbol("_enterCb")
  , Y1 = {
    name: "TransitionGroup",
    props: rn({}, WT, {
        tag: String,
        moveClass: String
    }),
    setup(t, {slots: e}) {
        const n = pl()
          , r = m1();
        let a, s;
        return _1( () => {
            if (!a.length)
                return;
            const l = t.moveClass || `${t.name || "v"}-move`;
            if (!g2(a[0].el, n.vnode.el, l))
                return;
            a.forEach(h2),
            a.forEach(m2);
            const i = a.filter(v2);
            z1(),
            i.forEach(o => {
                const u = o.el
                  , d = u.style;
                ya(u, l),
                d.transform = d.webkitTransform = d.transitionDuration = "";
                const f = u[Gu] = p => {
                    p && p.target !== u || (!p || /transform$/.test(p.propertyName)) && (u.removeEventListener("transitionend", f),
                    u[Gu] = null,
                    Ua(u, l))
                }
                ;
                u.addEventListener("transitionend", f)
            }
            )
        }
        ),
        () => {
            const l = vt(t)
              , i = H1(l);
            let o = l.tag || we;
            if (a = [],
            s)
                for (let u = 0; u < s.length; u++) {
                    const d = s[u];
                    d.el && d.el instanceof Element && (a.push(d),
                    wo(d, _o(d, i, r, n)),
                    W1.set(d, d.el.getBoundingClientRect()))
                }
            s = e.default ? Wh(e.default()) : [];
            for (let u = 0; u < s.length; u++) {
                const d = s[u];
                d.key != null && wo(d, _o(d, i, r, n))
            }
            return x(o, null, s)
        }
    }
}
  , f2 = t => delete t.mode;
Y1.props;
const p2 = Y1;
function h2(t) {
    const e = t.el;
    e[Gu] && e[Gu](),
    e[ug] && e[ug]()
}
function m2(t) {
    G1.set(t, t.el.getBoundingClientRect())
}
function v2(t) {
    const e = W1.get(t)
      , n = G1.get(t)
      , r = e.left - n.left
      , a = e.top - n.top;
    if (r || a) {
        const s = t.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${a}px)`,
        s.transitionDuration = "0s",
        t
    }
}
function g2(t, e, n) {
    const r = t.cloneNode()
      , a = t[ti];
    a && a.forEach(i => {
        i.split(/\s+/).forEach(o => o && r.classList.remove(o))
    }
    ),
    n.split(/\s+/).forEach(i => i && r.classList.add(i)),
    r.style.display = "none";
    const s = e.nodeType === 1 ? e : e.parentNode;
    s.appendChild(r);
    const {hasTransform: l} = K1(r);
    return s.removeChild(r),
    l
}
const gs = t => {
    const e = t.props["onUpdate:modelValue"] || !1;
    return Ge(e) ? n => Cu(e, n) : e
}
;
function b2(t) {
    t.target.composing = !0
}
function dg(t) {
    const e = t.target;
    e.composing && (e.composing = !1,
    e.dispatchEvent(new Event("input")))
}
const kr = Symbol("_assign")
  , cg = {
    created(t, {modifiers: {lazy: e, trim: n, number: r}}, a) {
        t[kr] = gs(a);
        const s = r || a.props && a.props.type === "number";
        _a(t, e ? "change" : "input", l => {
            if (l.target.composing)
                return;
            let i = t.value;
            n && (i = i.trim()),
            s && (i = Lu(i)),
            t[kr](i)
        }
        ),
        n && _a(t, "change", () => {
            t.value = t.value.trim()
        }
        ),
        e || (_a(t, "compositionstart", b2),
        _a(t, "compositionend", dg),
        _a(t, "change", dg))
    },
    mounted(t, {value: e}) {
        t.value = e ?? ""
    },
    beforeUpdate(t, {value: e, modifiers: {lazy: n, trim: r, number: a}}, s) {
        if (t[kr] = gs(s),
        t.composing)
            return;
        const l = (a || t.type === "number") && !/^0\d/.test(t.value) ? Lu(t.value) : t.value
          , i = e ?? "";
        l !== i && (document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === i) || (t.value = i))
    }
}
  , y2 = {
    deep: !0,
    created(t, e, n) {
        t[kr] = gs(n),
        _a(t, "change", () => {
            const r = t._modelValue
              , a = ni(t)
              , s = t.checked
              , l = t[kr];
            if (Ge(r)) {
                const i = Ph(r, a)
                  , o = i !== -1;
                if (s && !o)
                    l(r.concat(a));
                else if (!s && o) {
                    const u = [...r];
                    u.splice(i, 1),
                    l(u)
                }
            } else if (xi(r)) {
                const i = new Set(r);
                s ? i.add(a) : i.delete(a),
                l(i)
            } else
                l(J1(t, s))
        }
        )
    },
    mounted: fg,
    beforeUpdate(t, e, n) {
        t[kr] = gs(n),
        fg(t, e, n)
    }
};
function fg(t, {value: e, oldValue: n}, r) {
    t._modelValue = e,
    Ge(e) ? t.checked = Ph(e, r.props.value) > -1 : xi(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = al(e, J1(t, !0)))
}
const k2 = {
    created(t, {value: e}, n) {
        t.checked = al(e, n.props.value),
        t[kr] = gs(n),
        _a(t, "change", () => {
            t[kr](ni(t))
        }
        )
    },
    beforeUpdate(t, {value: e, oldValue: n}, r) {
        t[kr] = gs(r),
        e !== n && (t.checked = al(e, r.props.value))
    }
}
  , Xn = {
    deep: !0,
    created(t, {value: e, modifiers: {number: n}}, r) {
        const a = xi(e);
        _a(t, "change", () => {
            const s = Array.prototype.filter.call(t.options, l => l.selected).map(l => n ? Lu(ni(l)) : ni(l));
            t[kr](t.multiple ? a ? new Set(s) : s : s[0]),
            t._assigning = !0,
            Ot( () => {
                t._assigning = !1
            }
            )
        }
        ),
        t[kr] = gs(r)
    },
    mounted(t, {value: e, modifiers: {number: n}}) {
        pg(t, e)
    },
    beforeUpdate(t, e, n) {
        t[kr] = gs(n)
    },
    updated(t, {value: e, modifiers: {number: n}}) {
        t._assigning || pg(t, e)
    }
};
function pg(t, e, n) {
    const r = t.multiple
      , a = Ge(e);
    if (!(r && !a && !xi(e))) {
        for (let s = 0, l = t.options.length; s < l; s++) {
            const i = t.options[s]
              , o = ni(i);
            if (r)
                if (a) {
                    const u = typeof o;
                    u === "string" || u === "number" ? i.selected = e.some(d => String(d) === String(o)) : i.selected = Ph(e, o) > -1
                } else
                    i.selected = e.has(o);
            else if (al(ni(i), e)) {
                t.selectedIndex !== s && (t.selectedIndex = s);
                return
            }
        }
        !r && t.selectedIndex !== -1 && (t.selectedIndex = -1)
    }
}
function ni(t) {
    return "_value"in t ? t._value : t.value
}
function J1(t, e) {
    const n = e ? "_trueValue" : "_falseValue";
    return n in t ? t[n] : e
}
const _2 = ["ctrl", "shift", "alt", "meta"]
  , w2 = {
    stop: t => t.stopPropagation(),
    prevent: t => t.preventDefault(),
    self: t => t.target !== t.currentTarget,
    ctrl: t => !t.ctrlKey,
    shift: t => !t.shiftKey,
    alt: t => !t.altKey,
    meta: t => !t.metaKey,
    left: t => "button"in t && t.button !== 0,
    middle: t => "button"in t && t.button !== 1,
    right: t => "button"in t && t.button !== 2,
    exact: (t, e) => _2.some(n => t[`${n}Key`] && !e.includes(n))
}
  , _t = (t, e) => {
    const n = t._withMods || (t._withMods = {})
      , r = e.join(".");
    return n[r] || (n[r] = (a, ...s) => {
        for (let l = 0; l < e.length; l++) {
            const i = w2[e[l]];
            if (i && i(a, e))
                return
        }
        return t(a, ...s)
    }
    )
}
  , x2 = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , Xe = (t, e) => {
    const n = t._withKeys || (t._withKeys = {})
      , r = e.join(".");
    return n[r] || (n[r] = a => {
        if (!("key"in a))
            return;
        const s = fl(a.key);
        if (e.some(l => l === s || x2[l] === s))
            return t(a)
    }
    )
}
  , S2 = rn({
    patchProp: d2
}, qT);
let hg;
function X1() {
    return hg || (hg = TT(S2))
}
const mg = (...t) => {
    X1().render(...t)
}
  , Q1 = (...t) => {
    const e = X1().createApp(...t)
      , {mount: n} = e;
    return e.mount = r => {
        const a = T2(r);
        if (!a)
            return;
        const s = e._component;
        !et(s) && !s.render && !s.template && (s.template = a.innerHTML),
        a.innerHTML = "";
        const l = n(a, !1, $2(a));
        return a instanceof Element && (a.removeAttribute("v-cloak"),
        a.setAttribute("data-v-app", "")),
        l
    }
    ,
    e
}
;
function $2(t) {
    if (t instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && t instanceof MathMLElement)
        return "mathml"
}
function T2(t) {
    return Yt(t) ? document.querySelector(t) : t
}
const ro = {};
function vg(t) {
    return function(e, n) {
        var r;
        if (n) {
            if (n.kind !== "class")
                throw "deco stage 3 class";
            const a = (r = ro.fakePrototype) !== null && r !== void 0 ? r : ro.fakePrototype = {}
              , s = dn(a);
            return delete ro.fakePrototype,
            dn(e.prototype, s),
            t(e)
        } else
            return t(e)
    }
}
function cp(t) {
    return function(e, n) {
        var r;
        if (typeof n == "object") {
            const a = (r = ro.fakePrototype) !== null && r !== void 0 ? r : ro.fakePrototype = {};
            return a[n.name] = e,
            t(a, n.name)
        } else
            return t(e, n)
    }
}
const Z1 = Symbol("vue-facing-decorator-slot");
class C2 {
    constructor(e) {
        this.names = new Map,
        this.inComponent = !1,
        this.cachedVueComponent = null,
        this.master = e
    }
    obtainMap(e) {
        let n = this.getMap(e);
        return n || (n = new Map,
        this.names.set(e, n)),
        n
    }
    getMap(e) {
        return this.names.get(e)
    }
}
function E2(t, e) {
    if (Yd(t))
        throw "";
    e && (e.master = t);
    const n = e ?? new C2(t);
    return Object.defineProperty(t, Z1, {
        enumerable: !1,
        value: n
    }),
    n
}
function Yd(t) {
    var e;
    return (e = Object.getOwnPropertyDescriptor(t, Z1)) === null || e === void 0 ? void 0 : e.value
}
function dn(t, e) {
    const n = Yd(t);
    return n || E2(t, e)
}
function A2(t, e) {
    return t.reduce( (n, r) => (n[r] = e[r],
    n), {})
}
function Qh(t) {
    const e = [];
    let n = t;
    do
        e.unshift(n),
        n = Object.getPrototypeOf(n);
    while (n.constructor !== tm && !Yd(n));
    return e
}
function ek(t) {
    let e = Object.getPrototypeOf(t);
    for (; e.constructor !== tm; ) {
        const n = Yd(e);
        if (n)
            return n;
        e = Object.getPrototypeOf(e)
    }
    return null
}
function tk(t, e, n) {
    return t.filter(r => {
        let a = e;
        for (; a != null; ) {
            for (const s of a.names.keys()) {
                if (n && !n(s))
                    continue;
                if (s === "customDecorator") {
                    const i = a.obtainMap("customDecorator");
                    if (i.has(r)) {
                        if (i.get(r).every(o => !o.preserve))
                            return !1;
                        continue
                    }
                }
                if (a.names.get(s).has(r))
                    return !1
            }
            a = ek(a.master)
        }
        return !0
    }
    )
}
function Zh(t, e) {
    const n = Object.getOwnPropertyDescriptors(t);
    return Object.keys(n).filter(r => e(n[r], r))
}
function nk(t) {
    function e(n, r) {
        if (r)
            cp(function(a, s) {
                t(a, s)
            })(n, r);
        else
            return cp(function(a, s) {
                t(a, s, n)
            })
    }
    return e
}
function gg(t) {
    return typeof t == "function" ? t : function() {
        return t || {}
    }
}
const M2 = t => t instanceof Promise;
function O2(t, e) {
    const r = dn(t.prototype).getMap("setup");
    if (!r || r.size === 0)
        return;
    const a = function(s, l) {
        const i = {};
        let o = null;
        for (const u of r.keys()) {
            const d = r.get(u).setupFunction(s, l);
            M2(d) ? (o ?? (o = []),
            o.push(d.then(f => {
                i[u] = f
            }
            ))) : i[u] = d
        }
        return Array.isArray(o) ? Promise.all(o).then( () => i) : i
    };
    e.setup = a
}
function N2(t, e) {
    var n;
    (n = e.computed) !== null && n !== void 0 || (e.computed = {});
    const r = dn(t.prototype)
      , a = r.obtainMap("computed")
      , s = r.obtainMap("vanilla");
    Qh(t.prototype).forEach(i => {
        Zh(i, (o, u) => (typeof o.get == "function" || typeof o.set == "function") && !s.has(u)).forEach(o => {
            a.set(o, !0);
            const u = Object.getOwnPropertyDescriptor(i, o);
            e.computed[o] = {
                get: typeof u.get == "function" ? u.get : void 0,
                set: typeof u.set == "function" ? u.set : void 0
            }
        }
        )
    }
    )
}
function D2(t, e, n) {
    var r;
    (r = e.data) !== null && r !== void 0 || (e.data = {});
    const a = new t(e,n);
    let s = Zh(a, (i, o) => {
        var u, d;
        return !!i.enumerable && !(!((u = e.methods) === null || u === void 0) && u[o]) && !(!((d = e.props) === null || d === void 0) && d[o])
    }
    );
    const l = dn(t.prototype);
    s = tk(s, l, i => !["provide"].includes(i)),
    Object.assign(e.data, A2(s, a))
}
const P2 = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "activated", "deactivated", "beforeDestroy", "beforeUnmount", "destroyed", "unmounted", "renderTracked", "renderTriggered", "errorCaptured", "serverPrefetch", "render"];
function F2(t, e) {
    var n, r, a;
    const s = dn(t.prototype)
      , l = Qh(t.prototype)
      , i = s.obtainMap("hooks");
    (n = e.hooks) !== null && n !== void 0 || (e.hooks = {}),
    (r = e.methods) !== null && r !== void 0 || (e.methods = {});
    const o = {}
      , u = {};
    l.forEach(f => {
        let p = Zh(f, (h, v) => typeof h.value == "function" && v !== "constructor");
        p = tk(p, s, h => !["watch", "hooks", "emits", "provide"].includes(h)),
        p.forEach(h => {
            P2.includes(h) || i.has(h) ? o[h] = f[h] : u[h] = f[h]
        }
        )
    }
    ),
    Object.assign(e.methods, u);
    const d = [...(a = e.beforeCreateCallbacks) !== null && a !== void 0 ? a : []];
    if (d && d.length > 0) {
        const f = o.beforeCreate;
        o.beforeCreate = function() {
            d.forEach(p => p.apply(this, arguments)),
            f && f.apply(this, arguments)
        }
    }
    Object.assign(e.hooks, o)
}
function rk(t, e) {
    var n;
    (n = t.beforeCreateCallbacks) !== null && n !== void 0 || (t.beforeCreateCallbacks = []),
    t.beforeCreateCallbacks.push(function() {
        const r = this;
        e(r).forEach( (s, l) => {
            Object.defineProperty(r, l, s)
        }
        )
    })
}
const em = nk(function(t, e, n) {
    dn(t).obtainMap("ref").set(e, typeof n > "u" ? null : n)
});
function B2(t, e) {
    const r = dn(t.prototype).getMap("ref");
    !r || r.size === 0 || rk(e, a => {
        const s = new Map;
        return r.forEach( (l, i) => {
            const o = l === null ? i : l;
            s.set(i, {
                get: function() {
                    return a.$refs[o]
                },
                set: void 0
            })
        }
        ),
        s
    }
    )
}
function V2(t, e) {
    return cp(function(n, r) {
        const s = dn(n).obtainMap("watch")
          , l = Object.assign({}, e ?? {}, {
            key: t,
            handler: n[r]
        });
        if (s.has(r)) {
            const i = s.get(r);
            Array.isArray(i) ? i.push(l) : s.set(r, [i, l])
        } else
            s.set(r, l)
    })
}
function I2(t, e) {
    var n;
    (n = e.watch) !== null && n !== void 0 || (e.watch = {});
    const a = dn(t.prototype).getMap("watch");
    !a || a.size === 0 || a.forEach( (s, l) => {
        (Array.isArray(s) ? s : [s]).forEach(o => {
            if (!e.watch[o.key])
                e.watch[o.key] = o;
            else {
                const u = e.watch[o.key];
                Array.isArray(u) ? u.push(o) : e.watch[o.key] = [u, o]
            }
        }
        )
    }
    )
}
const Bn = nk(function(t, e, n) {
    const a = dn(t).obtainMap("props")
      , s = Object.assign({}, n ?? {});
    a.set(e, s)
});
function R2(t, e) {
    var n;
    (n = e.props) !== null && n !== void 0 || (e.props = {});
    const a = dn(t.prototype).getMap("props");
    !a || a.size === 0 || a.forEach( (s, l) => {
        e.props[l] = s
    }
    )
}
function L2(t, e) {
    var n;
    (n = e.inject) !== null && n !== void 0 || (e.inject = {});
    const a = dn(t.prototype).getMap("inject");
    !a || a.size === 0 || a.forEach( (s, l) => {
        e.inject[l] = s
    }
    )
}
function j2(t, e, n) {
    var r;
    (r = e.provide) !== null && r !== void 0 || (e.provide = {});
    const s = dn(t.prototype).obtainMap("provide");
    if (!s)
        return null;
    s.forEach( (l, i) => {
        const o = l === null ? i : l;
        e.provide[o] = K( () => n[i])
    }
    )
}
var U2 = globalThis && globalThis.__awaiter || function(t, e, n, r) {
    function a(s) {
        return s instanceof n ? s : new n(function(l) {
            l(s)
        }
        )
    }
    return new (n || (n = Promise))(function(s, l) {
        function i(d) {
            try {
                u(r.next(d))
            } catch (f) {
                l(f)
            }
        }
        function o(d) {
            try {
                u(r.throw(d))
            } catch (f) {
                l(f)
            }
        }
        function u(d) {
            d.done ? s(d.value) : a(d.value).then(i, o)
        }
        u((r = r.apply(t, e || [])).next())
    }
    )
}
;
function H2(t, e) {
    var n;
    (n = e.methods) !== null && n !== void 0 || (e.methods = {});
    const r = t.prototype
      , a = dn(r)
      , s = a.getMap("emit");
    if (!s || s.size === 0)
        return;
    const l = a.obtainMap("emits");
    s.forEach( (i, o) => {
        const u = i === null ? o : i;
        l.set(u, !0),
        e.methods[o] = function() {
            return U2(this, arguments, void 0, function*() {
                const d = r[o].apply(this, arguments);
                if (d instanceof Promise) {
                    const f = yield d;
                    this.$emit(u, f)
                } else
                    d === void 0 ? this.$emit(u) : this.$emit(u, d)
            })
        }
    }
    )
}
function K2(t, e) {
    var n;
    (n = e.computed) !== null && n !== void 0 || (e.computed = {});
    const r = dn(t.prototype)
      , a = r.getMap("v-model");
    if (!a || a.size === 0)
        return;
    const s = r.obtainMap("emits");
    a.forEach( (l, i) => {
        var o;
        const u = (o = l && l.name) !== null && o !== void 0 ? o : "modelValue"
          , d = `update:${u}`;
        e.computed[i] = {
            get: function() {
                return this[u]
            },
            set: function(f) {
                this.$emit(d, f)
            }
        },
        s.set(d, !0)
    }
    )
}
function z2(t, e) {
    const r = dn(t.prototype).getMap("vanilla");
    if (!r || r.size === 0)
        return;
    const a = Qh(t.prototype)
      , s = new Map;
    rk(e, l => (a.forEach(i => {
        const o = Object.getOwnPropertyDescriptors(i);
        for (const u in o) {
            const d = o[u];
            d && r.has(u) && (typeof d.get == "function" || typeof d.set == "function") && s.set(u, {
                set: typeof d.set == "function" ? d.set.bind(l) : void 0,
                get: typeof d.get == "function" ? d.get.bind(l) : void 0
            })
        }
    }
    ),
    s))
}
function q2(t, e) {
    const n = {};
    return O2(t, n),
    K2(t, n),
    N2(t, n),
    I2(t, n),
    R2(t, n),
    L2(t, n),
    H2(t, n),
    B2(t, n),
    z2(t, n),
    F2(t, n),
    Object.assign(Object.assign({
        name: t.name,
        setup: n.setup,
        data() {
            var a;
            return delete n.data,
            D2(t, n, this),
            (a = n.data) !== null && a !== void 0 ? a : {}
        },
        methods: n.methods,
        computed: n.computed,
        watch: n.watch,
        props: n.props,
        inject: n.inject,
        provide() {
            var a;
            return j2(t, n, this),
            (a = n.provide) !== null && a !== void 0 ? a : {}
        }
    }, n.hooks), {
        extends: e
    })
}
function W2(t, e, n) {
    var r, a;
    const s = q2(t, n)
      , l = dn(t.prototype);
    Object.keys(e).reduce( (f, p) => (["options", "modifier", "methods", "emits", "setup", "provide"].includes(p) || (f[p] = e[p]),
    f), s);
    let i = Array.from(l.obtainMap("emits").keys());
    if (Array.isArray(e.emits) && (i = Array.from(new Set([...i, ...e.emits]))),
    s.emits = i,
    typeof e.methods == "object" && !Array.isArray(e.methods) && e.methods !== null && ((r = s.methods) !== null && r !== void 0 || (s.methods = {}),
    Object.assign(s.methods, e.methods)),
    !s.setup)
        s.setup = e.setup;
    else {
        const f = s.setup
          , p = (a = e.setup) !== null && a !== void 0 ? a : function() {
            return {}
        }
          , h = function(v, y) {
            const k = p(v, y)
              , w = f(v, y);
            return w instanceof Promise || k instanceof Promise ? Promise.all([k, w]).then($ => Object.assign({}, $[0], $[1])) : Object.assign({}, k, w)
        };
        s.setup = h
    }
    const o = gg(s.provide)
      , u = gg(e.provide);
    s.provide = function() {
        return Object.assign({}, o.call(this), u.call(this))
    }
    ;
    const d = l.getMap("customDecorator");
    return d && d.size > 0 && d.forEach(f => {
        f.forEach(p => p.creator.apply({}, [s, p.key]))
    }
    ),
    e.options && Object.assign(s, e.options),
    e.modifier && e.modifier(s),
    Se(s)
}
function G2(t, e) {
    const n = dn(t.prototype);
    n.inComponent = !0;
    const r = ek(t.prototype);
    if (r) {
        if (!r.inComponent)
            throw "Class should be decorated by Component or ComponentBase: " + n.master;
        if (r.cachedVueComponent === null)
            throw "Component decorator 1"
    }
    const a = W2(t, e, r === null ? void 0 : r.cachedVueComponent);
    a.__vfdConstructor = t,
    n.cachedVueComponent = a,
    t.__vccOpts = a
}
function Y2(t, e, n) {
    return typeof e == "function" ? vg(function(r) {
        return t(r, {})
    })(e, n) : vg(function(r) {
        return t(r, e)
    })
}
function J2(t, e) {
    return Y2(function(n, r) {
        return G2(n, r),
        n
    }, t, e)
}
const Ct = J2;
function Et(t) {
    const e = dn(t.prototype);
    if (!e.inComponent)
        throw "to native 1";
    const n = e.cachedVueComponent;
    if (!n)
        throw "to native 2";
    return n
}
const tm = class {
    constructor(t, e) {
        const n = t.props;
        n && Object.keys(n).forEach(a => {
            this[a] = e[a]
        }
        );
        const r = t.methods;
        r && Object.keys(r).forEach(a => {
            this[a] = r[a].bind(e)
        }
        )
    }
}
  , Jt = tm;
function X2(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var nm = {
    exports: {}
}
  , ak = function(e, n) {
    return function() {
        for (var a = new Array(arguments.length), s = 0; s < a.length; s++)
            a[s] = arguments[s];
        return e.apply(n, a)
    }
}
  , Q2 = ak
  , hl = Object.prototype.toString;
function rm(t) {
    return hl.call(t) === "[object Array]"
}
function fp(t) {
    return typeof t > "u"
}
function Z2(t) {
    return t !== null && !fp(t) && t.constructor !== null && !fp(t.constructor) && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t)
}
function eC(t) {
    return hl.call(t) === "[object ArrayBuffer]"
}
function tC(t) {
    return typeof FormData < "u" && t instanceof FormData
}
function nC(t) {
    var e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && t.buffer instanceof ArrayBuffer,
    e
}
function rC(t) {
    return typeof t == "string"
}
function aC(t) {
    return typeof t == "number"
}
function sk(t) {
    return t !== null && typeof t == "object"
}
function Ou(t) {
    if (hl.call(t) !== "[object Object]")
        return !1;
    var e = Object.getPrototypeOf(t);
    return e === null || e === Object.prototype
}
function sC(t) {
    return hl.call(t) === "[object Date]"
}
function lC(t) {
    return hl.call(t) === "[object File]"
}
function iC(t) {
    return hl.call(t) === "[object Blob]"
}
function lk(t) {
    return hl.call(t) === "[object Function]"
}
function oC(t) {
    return sk(t) && lk(t.pipe)
}
function uC(t) {
    return typeof URLSearchParams < "u" && t instanceof URLSearchParams
}
function dC(t) {
    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
}
function cC() {
    return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u"
}
function am(t, e) {
    if (!(t === null || typeof t > "u"))
        if (typeof t != "object" && (t = [t]),
        rm(t))
            for (var n = 0, r = t.length; n < r; n++)
                e.call(null, t[n], n, t);
        else
            for (var a in t)
                Object.prototype.hasOwnProperty.call(t, a) && e.call(null, t[a], a, t)
}
function pp() {
    var t = {};
    function e(a, s) {
        Ou(t[s]) && Ou(a) ? t[s] = pp(t[s], a) : Ou(a) ? t[s] = pp({}, a) : rm(a) ? t[s] = a.slice() : t[s] = a
    }
    for (var n = 0, r = arguments.length; n < r; n++)
        am(arguments[n], e);
    return t
}
function fC(t, e, n) {
    return am(e, function(a, s) {
        n && typeof a == "function" ? t[s] = Q2(a, n) : t[s] = a
    }),
    t
}
function pC(t) {
    return t.charCodeAt(0) === 65279 && (t = t.slice(1)),
    t
}
var or = {
    isArray: rm,
    isArrayBuffer: eC,
    isBuffer: Z2,
    isFormData: tC,
    isArrayBufferView: nC,
    isString: rC,
    isNumber: aC,
    isObject: sk,
    isPlainObject: Ou,
    isUndefined: fp,
    isDate: sC,
    isFile: lC,
    isBlob: iC,
    isFunction: lk,
    isStream: oC,
    isURLSearchParams: uC,
    isStandardBrowserEnv: cC,
    forEach: am,
    merge: pp,
    extend: fC,
    trim: dC,
    stripBOM: pC
}
  , Cl = or;
function bg(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
var ik = function(e, n, r) {
    if (!n)
        return e;
    var a;
    if (r)
        a = r(n);
    else if (Cl.isURLSearchParams(n))
        a = n.toString();
    else {
        var s = [];
        Cl.forEach(n, function(o, u) {
            o === null || typeof o > "u" || (Cl.isArray(o) ? u = u + "[]" : o = [o],
            Cl.forEach(o, function(f) {
                Cl.isDate(f) ? f = f.toISOString() : Cl.isObject(f) && (f = JSON.stringify(f)),
                s.push(bg(u) + "=" + bg(f))
            }))
        }),
        a = s.join("&")
    }
    if (a) {
        var l = e.indexOf("#");
        l !== -1 && (e = e.slice(0, l)),
        e += (e.indexOf("?") === -1 ? "?" : "&") + a
    }
    return e
}
  , hC = or;
function Jd() {
    this.handlers = []
}
Jd.prototype.use = function(e, n, r) {
    return this.handlers.push({
        fulfilled: e,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null
    }),
    this.handlers.length - 1
}
;
Jd.prototype.eject = function(e) {
    this.handlers[e] && (this.handlers[e] = null)
}
;
Jd.prototype.forEach = function(e) {
    hC.forEach(this.handlers, function(r) {
        r !== null && e(r)
    })
}
;
var mC = Jd, vC = or, gC = function(e, n) {
    vC.forEach(e, function(a, s) {
        s !== n && s.toUpperCase() === n.toUpperCase() && (e[n] = a,
        delete e[s])
    })
}, ok = function(e, n, r, a, s) {
    return e.config = n,
    r && (e.code = r),
    e.request = a,
    e.response = s,
    e.isAxiosError = !0,
    e.toJSON = function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code
        }
    }
    ,
    e
}, zc, yg;
function uk() {
    if (yg)
        return zc;
    yg = 1;
    var t = ok;
    return zc = function(n, r, a, s, l) {
        var i = new Error(n);
        return t(i, r, a, s, l)
    }
    ,
    zc
}
var qc, kg;
function bC() {
    if (kg)
        return qc;
    kg = 1;
    var t = uk();
    return qc = function(n, r, a) {
        var s = a.config.validateStatus;
        !a.status || !s || s(a.status) ? n(a) : r(t("Request failed with status code " + a.status, a.config, null, a.request, a))
    }
    ,
    qc
}
var Wc, _g;
function yC() {
    if (_g)
        return Wc;
    _g = 1;
    var t = or;
    return Wc = t.isStandardBrowserEnv() ? function() {
        return {
            write: function(r, a, s, l, i, o) {
                var u = [];
                u.push(r + "=" + encodeURIComponent(a)),
                t.isNumber(s) && u.push("expires=" + new Date(s).toGMTString()),
                t.isString(l) && u.push("path=" + l),
                t.isString(i) && u.push("domain=" + i),
                o === !0 && u.push("secure"),
                document.cookie = u.join("; ")
            },
            read: function(r) {
                var a = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
                return a ? decodeURIComponent(a[3]) : null
            },
            remove: function(r) {
                this.write(r, "", Date.now() - 864e5)
            }
        }
    }() : function() {
        return {
            write: function() {},
            read: function() {
                return null
            },
            remove: function() {}
        }
    }(),
    Wc
}
var Gc, wg;
function kC() {
    return wg || (wg = 1,
    Gc = function(e) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)
    }
    ),
    Gc
}
var Yc, xg;
function _C() {
    return xg || (xg = 1,
    Yc = function(e, n) {
        return n ? e.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : e
    }
    ),
    Yc
}
var Jc, Sg;
function wC() {
    if (Sg)
        return Jc;
    Sg = 1;
    var t = kC()
      , e = _C();
    return Jc = function(r, a) {
        return r && !t(a) ? e(r, a) : a
    }
    ,
    Jc
}
var Xc, $g;
function xC() {
    if ($g)
        return Xc;
    $g = 1;
    var t = or
      , e = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    return Xc = function(r) {
        var a = {}, s, l, i;
        return r && t.forEach(r.split(`
`), function(u) {
            if (i = u.indexOf(":"),
            s = t.trim(u.substr(0, i)).toLowerCase(),
            l = t.trim(u.substr(i + 1)),
            s) {
                if (a[s] && e.indexOf(s) >= 0)
                    return;
                s === "set-cookie" ? a[s] = (a[s] ? a[s] : []).concat([l]) : a[s] = a[s] ? a[s] + ", " + l : l
            }
        }),
        a
    }
    ,
    Xc
}
var Qc, Tg;
function SC() {
    if (Tg)
        return Qc;
    Tg = 1;
    var t = or;
    return Qc = t.isStandardBrowserEnv() ? function() {
        var n = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"), a;
        function s(l) {
            var i = l;
            return n && (r.setAttribute("href", i),
            i = r.href),
            r.setAttribute("href", i),
            {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, "") : "",
                hash: r.hash ? r.hash.replace(/^#/, "") : "",
                hostname: r.hostname,
                port: r.port,
                pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
            }
        }
        return a = s(window.location.href),
        function(i) {
            var o = t.isString(i) ? s(i) : i;
            return o.protocol === a.protocol && o.host === a.host
        }
    }() : function() {
        return function() {
            return !0
        }
    }(),
    Qc
}
var Zc, Cg;
function Eg() {
    if (Cg)
        return Zc;
    Cg = 1;
    var t = or
      , e = bC()
      , n = yC()
      , r = ik
      , a = wC()
      , s = xC()
      , l = SC()
      , i = uk();
    return Zc = function(u) {
        return new Promise(function(f, p) {
            var h = u.data
              , v = u.headers
              , y = u.responseType;
            t.isFormData(h) && delete v["Content-Type"];
            var k = new XMLHttpRequest;
            if (u.auth) {
                var w = u.auth.username || ""
                  , $ = u.auth.password ? unescape(encodeURIComponent(u.auth.password)) : "";
                v.Authorization = "Basic " + btoa(w + ":" + $)
            }
            var M = a(u.baseURL, u.url);
            k.open(u.method.toUpperCase(), r(M, u.params, u.paramsSerializer), !0),
            k.timeout = u.timeout;
            function S() {
                if (k) {
                    var E = "getAllResponseHeaders"in k ? s(k.getAllResponseHeaders()) : null
                      , O = !y || y === "text" || y === "json" ? k.responseText : k.response
                      , U = {
                        data: O,
                        status: k.status,
                        statusText: k.statusText,
                        headers: E,
                        config: u,
                        request: k
                    };
                    e(f, p, U),
                    k = null
                }
            }
            if ("onloadend"in k ? k.onloadend = S : k.onreadystatechange = function() {
                !k || k.readyState !== 4 || k.status === 0 && !(k.responseURL && k.responseURL.indexOf("file:") === 0) || setTimeout(S)
            }
            ,
            k.onabort = function() {
                k && (p(i("Request aborted", u, "ECONNABORTED", k)),
                k = null)
            }
            ,
            k.onerror = function() {
                p(i("Network Error", u, null, k)),
                k = null
            }
            ,
            k.ontimeout = function() {
                var O = "timeout of " + u.timeout + "ms exceeded";
                u.timeoutErrorMessage && (O = u.timeoutErrorMessage),
                p(i(O, u, u.transitional && u.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", k)),
                k = null
            }
            ,
            t.isStandardBrowserEnv()) {
                var T = (u.withCredentials || l(M)) && u.xsrfCookieName ? n.read(u.xsrfCookieName) : void 0;
                T && (v[u.xsrfHeaderName] = T)
            }
            "setRequestHeader"in k && t.forEach(v, function(O, U) {
                typeof h > "u" && U.toLowerCase() === "content-type" ? delete v[U] : k.setRequestHeader(U, O)
            }),
            t.isUndefined(u.withCredentials) || (k.withCredentials = !!u.withCredentials),
            y && y !== "json" && (k.responseType = u.responseType),
            typeof u.onDownloadProgress == "function" && k.addEventListener("progress", u.onDownloadProgress),
            typeof u.onUploadProgress == "function" && k.upload && k.upload.addEventListener("progress", u.onUploadProgress),
            u.cancelToken && u.cancelToken.promise.then(function(O) {
                k && (k.abort(),
                p(O),
                k = null)
            }),
            h || (h = null),
            k.send(h)
        }
        )
    }
    ,
    Zc
}
var $n = or
  , Ag = gC
  , $C = ok
  , TC = {
    "Content-Type": "application/x-www-form-urlencoded"
};
function Mg(t, e) {
    !$n.isUndefined(t) && $n.isUndefined(t["Content-Type"]) && (t["Content-Type"] = e)
}
function CC() {
    var t;
    return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (t = Eg()),
    t
}
function EC(t, e, n) {
    if ($n.isString(t))
        try {
            return (e || JSON.parse)(t),
            $n.trim(t)
        } catch (r) {
            if (r.name !== "SyntaxError")
                throw r
        }
    return (n || JSON.stringify)(t)
}
var Xd = {
    transitional: {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    adapter: CC(),
    transformRequest: [function(e, n) {
        return Ag(n, "Accept"),
        Ag(n, "Content-Type"),
        $n.isFormData(e) || $n.isArrayBuffer(e) || $n.isBuffer(e) || $n.isStream(e) || $n.isFile(e) || $n.isBlob(e) ? e : $n.isArrayBufferView(e) ? e.buffer : $n.isURLSearchParams(e) ? (Mg(n, "application/x-www-form-urlencoded;charset=utf-8"),
        e.toString()) : $n.isObject(e) || n && n["Content-Type"] === "application/json" ? (Mg(n, "application/json"),
        EC(e)) : e
    }
    ],
    transformResponse: [function(e) {
        var n = this.transitional
          , r = n && n.silentJSONParsing
          , a = n && n.forcedJSONParsing
          , s = !r && this.responseType === "json";
        if (s || a && $n.isString(e) && e.length)
            try {
                return JSON.parse(e)
            } catch (l) {
                if (s)
                    throw l.name === "SyntaxError" ? $C(l, this, "E_JSON_PARSE") : l
            }
        return e
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function(e) {
        return e >= 200 && e < 300
    }
};
Xd.headers = {
    common: {
        Accept: "application/json, text/plain, */*"
    }
};
$n.forEach(["delete", "get", "head"], function(e) {
    Xd.headers[e] = {}
});
$n.forEach(["post", "put", "patch"], function(e) {
    Xd.headers[e] = $n.merge(TC)
});
var sm = Xd, AC = or, MC = sm, OC = function(e, n, r) {
    var a = this || MC;
    return AC.forEach(r, function(l) {
        e = l.call(a, e, n)
    }),
    e
}, ef, Og;
function dk() {
    return Og || (Og = 1,
    ef = function(e) {
        return !!(e && e.__CANCEL__)
    }
    ),
    ef
}
var Ng = or
  , tf = OC
  , NC = dk()
  , DC = sm;
function nf(t) {
    t.cancelToken && t.cancelToken.throwIfRequested()
}
var PC = function(e) {
    nf(e),
    e.headers = e.headers || {},
    e.data = tf.call(e, e.data, e.headers, e.transformRequest),
    e.headers = Ng.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers),
    Ng.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(a) {
        delete e.headers[a]
    });
    var n = e.adapter || DC.adapter;
    return n(e).then(function(a) {
        return nf(e),
        a.data = tf.call(e, a.data, a.headers, e.transformResponse),
        a
    }, function(a) {
        return NC(a) || (nf(e),
        a && a.response && (a.response.data = tf.call(e, a.response.data, a.response.headers, e.transformResponse))),
        Promise.reject(a)
    })
}
  , On = or
  , ck = function(e, n) {
    n = n || {};
    var r = {}
      , a = ["url", "method", "data"]
      , s = ["headers", "auth", "proxy", "params"]
      , l = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"]
      , i = ["validateStatus"];
    function o(p, h) {
        return On.isPlainObject(p) && On.isPlainObject(h) ? On.merge(p, h) : On.isPlainObject(h) ? On.merge({}, h) : On.isArray(h) ? h.slice() : h
    }
    function u(p) {
        On.isUndefined(n[p]) ? On.isUndefined(e[p]) || (r[p] = o(void 0, e[p])) : r[p] = o(e[p], n[p])
    }
    On.forEach(a, function(h) {
        On.isUndefined(n[h]) || (r[h] = o(void 0, n[h]))
    }),
    On.forEach(s, u),
    On.forEach(l, function(h) {
        On.isUndefined(n[h]) ? On.isUndefined(e[h]) || (r[h] = o(void 0, e[h])) : r[h] = o(void 0, n[h])
    }),
    On.forEach(i, function(h) {
        h in n ? r[h] = o(e[h], n[h]) : h in e && (r[h] = o(void 0, e[h]))
    });
    var d = a.concat(s).concat(l).concat(i)
      , f = Object.keys(e).concat(Object.keys(n)).filter(function(h) {
        return d.indexOf(h) === -1
    });
    return On.forEach(f, u),
    r
};
const FC = "axios"
  , BC = "0.21.4"
  , VC = "Promise based HTTP client for the browser and node.js"
  , IC = "index.js"
  , RC = {
    test: "grunt test",
    start: "node ./sandbox/server.js",
    build: "NODE_ENV=production grunt build",
    preversion: "npm test",
    version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    postversion: "git push && git push --tags",
    examples: "node ./examples/server.js",
    coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    fix: "eslint --fix lib/**/*.js"
}
  , LC = {
    type: "git",
    url: "https://github.com/axios/axios.git"
}
  , jC = ["xhr", "http", "ajax", "promise", "node"]
  , UC = "Matt Zabriskie"
  , HC = "MIT"
  , KC = {
    url: "https://github.com/axios/axios/issues"
}
  , zC = "https://axios-http.com"
  , qC = {
    coveralls: "^3.0.0",
    "es6-promise": "^4.2.4",
    grunt: "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    karma: "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    minimist: "^1.2.0",
    mocha: "^8.2.1",
    sinon: "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    typescript: "^4.0.5",
    "url-search-params": "^0.10.0",
    webpack: "^4.44.2",
    "webpack-dev-server": "^3.11.0"
}
  , WC = {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}
  , GC = "dist/axios.min.js"
  , YC = "dist/axios.min.js"
  , JC = "./index.d.ts"
  , XC = {
    "follow-redirects": "^1.14.0"
}
  , QC = [{
    path: "./dist/axios.min.js",
    threshold: "5kB"
}]
  , ZC = {
    name: FC,
    version: BC,
    description: VC,
    main: IC,
    scripts: RC,
    repository: LC,
    keywords: jC,
    author: UC,
    license: HC,
    bugs: KC,
    homepage: zC,
    devDependencies: qC,
    browser: WC,
    jsdelivr: GC,
    unpkg: YC,
    typings: JC,
    dependencies: XC,
    bundlesize: QC
};
var fk = ZC
  , lm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(t, e) {
    lm[t] = function(r) {
        return typeof r === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
var Dg = {}
  , eE = fk.version.split(".");
function pk(t, e) {
    for (var n = e ? e.split(".") : eE, r = t.split("."), a = 0; a < 3; a++) {
        if (n[a] > r[a])
            return !0;
        if (n[a] < r[a])
            return !1
    }
    return !1
}
lm.transitional = function(e, n, r) {
    var a = n && pk(n);
    function s(l, i) {
        return "[Axios v" + fk.version + "] Transitional option '" + l + "'" + i + (r ? ". " + r : "")
    }
    return function(l, i, o) {
        if (e === !1)
            throw new Error(s(i, " has been removed in " + n));
        return a && !Dg[i] && (Dg[i] = !0,
        console.warn(s(i, " has been deprecated since v" + n + " and will be removed in the near future"))),
        e ? e(l, i, o) : !0
    }
}
;
function tE(t, e, n) {
    if (typeof t != "object")
        throw new TypeError("options must be an object");
    for (var r = Object.keys(t), a = r.length; a-- > 0; ) {
        var s = r[a]
          , l = e[s];
        if (l) {
            var i = t[s]
              , o = i === void 0 || l(i, s, t);
            if (o !== !0)
                throw new TypeError("option " + s + " must be " + o);
            continue
        }
        if (n !== !0)
            throw Error("Unknown option " + s)
    }
}
var nE = {
    isOlderVersion: pk,
    assertOptions: tE,
    validators: lm
}
  , hk = or
  , rE = ik
  , Pg = mC
  , Fg = PC
  , Qd = ck
  , mk = nE
  , El = mk.validators;
function qo(t) {
    this.defaults = t,
    this.interceptors = {
        request: new Pg,
        response: new Pg
    }
}
qo.prototype.request = function(e) {
    typeof e == "string" ? (e = arguments[1] || {},
    e.url = arguments[0]) : e = e || {},
    e = Qd(this.defaults, e),
    e.method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get";
    var n = e.transitional;
    n !== void 0 && mk.assertOptions(n, {
        silentJSONParsing: El.transitional(El.boolean, "1.0.0"),
        forcedJSONParsing: El.transitional(El.boolean, "1.0.0"),
        clarifyTimeoutError: El.transitional(El.boolean, "1.0.0")
    }, !1);
    var r = []
      , a = !0;
    this.interceptors.request.forEach(function(p) {
        typeof p.runWhen == "function" && p.runWhen(e) === !1 || (a = a && p.synchronous,
        r.unshift(p.fulfilled, p.rejected))
    });
    var s = [];
    this.interceptors.response.forEach(function(p) {
        s.push(p.fulfilled, p.rejected)
    });
    var l;
    if (!a) {
        var i = [Fg, void 0];
        for (Array.prototype.unshift.apply(i, r),
        i = i.concat(s),
        l = Promise.resolve(e); i.length; )
            l = l.then(i.shift(), i.shift());
        return l
    }
    for (var o = e; r.length; ) {
        var u = r.shift()
          , d = r.shift();
        try {
            o = u(o)
        } catch (f) {
            d(f);
            break
        }
    }
    try {
        l = Fg(o)
    } catch (f) {
        return Promise.reject(f)
    }
    for (; s.length; )
        l = l.then(s.shift(), s.shift());
    return l
}
;
qo.prototype.getUri = function(e) {
    return e = Qd(this.defaults, e),
    rE(e.url, e.params, e.paramsSerializer).replace(/^\?/, "")
}
;
hk.forEach(["delete", "get", "head", "options"], function(e) {
    qo.prototype[e] = function(n, r) {
        return this.request(Qd(r || {}, {
            method: e,
            url: n,
            data: (r || {}).data
        }))
    }
});
hk.forEach(["post", "put", "patch"], function(e) {
    qo.prototype[e] = function(n, r, a) {
        return this.request(Qd(a || {}, {
            method: e,
            url: n,
            data: r
        }))
    }
});
var aE = qo, rf, Bg;
function vk() {
    if (Bg)
        return rf;
    Bg = 1;
    function t(e) {
        this.message = e
    }
    return t.prototype.toString = function() {
        return "Cancel" + (this.message ? ": " + this.message : "")
    }
    ,
    t.prototype.__CANCEL__ = !0,
    rf = t,
    rf
}
var af, Vg;
function sE() {
    if (Vg)
        return af;
    Vg = 1;
    var t = vk();
    function e(n) {
        if (typeof n != "function")
            throw new TypeError("executor must be a function.");
        var r;
        this.promise = new Promise(function(l) {
            r = l
        }
        );
        var a = this;
        n(function(l) {
            a.reason || (a.reason = new t(l),
            r(a.reason))
        })
    }
    return e.prototype.throwIfRequested = function() {
        if (this.reason)
            throw this.reason
    }
    ,
    e.source = function() {
        var r, a = new e(function(l) {
            r = l
        }
        );
        return {
            token: a,
            cancel: r
        }
    }
    ,
    af = e,
    af
}
var sf, Ig;
function lE() {
    return Ig || (Ig = 1,
    sf = function(e) {
        return function(r) {
            return e.apply(null, r)
        }
    }
    ),
    sf
}
var lf, Rg;
function iE() {
    return Rg || (Rg = 1,
    lf = function(e) {
        return typeof e == "object" && e.isAxiosError === !0
    }
    ),
    lf
}
var Lg = or
  , oE = ak
  , Nu = aE
  , uE = ck
  , dE = sm;
function gk(t) {
    var e = new Nu(t)
      , n = oE(Nu.prototype.request, e);
    return Lg.extend(n, Nu.prototype, e),
    Lg.extend(n, e),
    n
}
var Br = gk(dE);
Br.Axios = Nu;
Br.create = function(e) {
    return gk(uE(Br.defaults, e))
}
;
Br.Cancel = vk();
Br.CancelToken = sE();
Br.isCancel = dk();
Br.all = function(e) {
    return Promise.all(e)
}
;
Br.spread = lE();
Br.isAxiosError = iE();
nm.exports = Br;
nm.exports.default = Br;
var cE = nm.exports
  , fE = cE;
const Pt = X2(fE);
var pE = !1;
/*!
 * pinia v2.1.7
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let bk;
const Zd = t => bk = t
  , yk = Symbol();
function hp(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var ao;
(function(t) {
    t.direct = "direct",
    t.patchObject = "patch object",
    t.patchFunction = "patch function"
}
)(ao || (ao = {}));
function hE() {
    const t = Fd(!0)
      , e = t.run( () => me({}));
    let n = []
      , r = [];
    const a = Ld({
        install(s) {
            Zd(a),
            a._a = s,
            s.provide(yk, a),
            s.config.globalProperties.$pinia = a,
            r.forEach(l => n.push(l)),
            r = []
        },
        use(s) {
            return !this._a && !pE ? r.push(s) : n.push(s),
            this
        },
        _p: n,
        _a: null,
        _e: t,
        _s: new Map,
        state: e
    });
    return a
}
const kk = () => {}
;
function jg(t, e, n, r=kk) {
    t.push(e);
    const a = () => {
        const s = t.indexOf(e);
        s > -1 && (t.splice(s, 1),
        r())
    }
    ;
    return !n && Ho() && Bd(a),
    a
}
function Al(t, ...e) {
    t.slice().forEach(n => {
        n(...e)
    }
    )
}
const mE = t => t();
function mp(t, e) {
    t instanceof Map && e instanceof Map && e.forEach( (n, r) => t.set(r, n)),
    t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
        if (!e.hasOwnProperty(n))
            continue;
        const r = e[n]
          , a = t[n];
        hp(a) && hp(r) && t.hasOwnProperty(n) && !Kt(r) && !Gs(r) ? t[n] = mp(a, r) : t[n] = r
    }
    return t
}
const vE = Symbol();
function gE(t) {
    return !hp(t) || !t.hasOwnProperty(vE)
}
const {assign: Ha} = Object;
function bE(t) {
    return !!(Kt(t) && t.effect)
}
function yE(t, e, n, r) {
    const {state: a, actions: s, getters: l} = e
      , i = n.state.value[t];
    let o;
    function u() {
        i || (n.state.value[t] = a ? a() : {});
        const d = V$(n.state.value[t]);
        return Ha(d, s, Object.keys(l || {}).reduce( (f, p) => (f[p] = Ld(K( () => {
            Zd(n);
            const h = n._s.get(t);
            return l[p].call(h, h)
        }
        )),
        f), {}))
    }
    return o = _k(t, u, e, n, r, !0),
    o
}
function _k(t, e, n={}, r, a, s) {
    let l;
    const i = Ha({
        actions: {}
    }, n)
      , o = {
        deep: !0
    };
    let u, d, f = [], p = [], h;
    const v = r.state.value[t];
    !s && !v && (r.state.value[t] = {}),
    me({});
    let y;
    function k(U) {
        let L;
        u = d = !1,
        typeof U == "function" ? (U(r.state.value[t]),
        L = {
            type: ao.patchFunction,
            storeId: t,
            events: h
        }) : (mp(r.state.value[t], U),
        L = {
            type: ao.patchObject,
            payload: U,
            storeId: t,
            events: h
        });
        const C = y = Symbol();
        Ot().then( () => {
            y === C && (u = !0)
        }
        ),
        d = !0,
        Al(f, L, r.state.value[t])
    }
    const w = s ? function() {
        const {state: L} = n
          , C = L ? L() : {};
        this.$patch(W => {
            Ha(W, C)
        }
        )
    }
    : kk;
    function $() {
        l.stop(),
        f = [],
        p = [],
        r._s.delete(t)
    }
    function M(U, L) {
        return function() {
            Zd(r);
            const C = Array.from(arguments)
              , W = []
              , R = [];
            function G(ae) {
                W.push(ae)
            }
            function te(ae) {
                R.push(ae)
            }
            Al(p, {
                args: C,
                name: U,
                store: T,
                after: G,
                onError: te
            });
            let J;
            try {
                J = L.apply(this && this.$id === t ? this : T, C)
            } catch (ae) {
                throw Al(R, ae),
                ae
            }
            return J instanceof Promise ? J.then(ae => (Al(W, ae),
            ae)).catch(ae => (Al(R, ae),
            Promise.reject(ae))) : (Al(W, J),
            J)
        }
    }
    const S = {
        _p: r,
        $id: t,
        $onAction: jg.bind(null, p),
        $patch: k,
        $reset: w,
        $subscribe(U, L={}) {
            const C = jg(f, U, L.detached, () => W())
              , W = l.run( () => Ke( () => r.state.value[t], R => {
                (L.flush === "sync" ? d : u) && U({
                    storeId: t,
                    type: ao.direct,
                    events: h
                }, R)
            }
            , Ha({}, o, L)));
            return C
        },
        $dispose: $
    }
      , T = Fn(S);
    r._s.set(t, T);
    const O = (r._a && r._a.runWithContext || mE)( () => r._e.run( () => (l = Fd()).run(e)));
    for (const U in O) {
        const L = O[U];
        if (Kt(L) && !bE(L) || Gs(L))
            s || (v && gE(L) && (Kt(L) ? L.value = v[U] : mp(L, v[U])),
            r.state.value[t][U] = L);
        else if (typeof L == "function") {
            const C = M(U, L);
            O[U] = C,
            i.actions[U] = L
        }
    }
    return Ha(T, O),
    Ha(vt(T), O),
    Object.defineProperty(T, "$state", {
        get: () => r.state.value[t],
        set: U => {
            k(L => {
                Ha(L, U)
            }
            )
        }
    }),
    r._p.forEach(U => {
        Ha(T, l.run( () => U({
            store: T,
            app: r._a,
            pinia: r,
            options: i
        })))
    }
    ),
    v && s && n.hydrate && n.hydrate(T.$state, v),
    u = !0,
    d = !0,
    T
}
function Lr(t, e, n) {
    let r, a;
    const s = typeof e == "function";
    typeof t == "string" ? (r = t,
    a = s ? n : e) : (a = t,
    r = t.id);
    function l(i, o) {
        const u = kT();
        return i = i || (u ? Gt(yk, null) : null),
        i && Zd(i),
        i = bk,
        i._s.has(r) || (s ? _k(r, e, a, i) : yE(r, a, i)),
        i._s.get(r)
    }
    return l.$id = r,
    l
}
function of(t, e) {
    return Array.isArray(e) ? e.reduce( (n, r) => (n[r] = function() {
        return t(this.$pinia)[r]
    }
    ,
    n), {}) : Object.keys(e).reduce( (n, r) => (n[r] = function() {
        const a = t(this.$pinia)
          , s = e[r];
        return typeof s == "function" ? s.call(this, a) : a[s]
    }
    ,
    n), {})
}
function uf(t, e) {
    return Array.isArray(e) ? e.reduce( (n, r) => (n[r] = function(...a) {
        return t(this.$pinia)[r](...a)
    }
    ,
    n), {}) : Object.keys(e).reduce( (n, r) => (n[r] = function(...a) {
        return t(this.$pinia)[e[r]](...a)
    }
    ,
    n), {})
}
const dt = Lr("inloggning", {
    state: () => ({
        kundanvandare: null
    }),
    getters: {
        isLoggedin: t => {
            if (!t.kundanvandare) {
                const e = sessionStorage.getItem("PoIT");
                e && (t.kundanvandare = JSON.parse(e))
            }
            return !!t.kundanvandare
        }
        ,
        getKundanvandare: t => t.kundanvandare
    },
    actions: {
        async hamtaSalt(t) {
            try {
                const e = "/poit/rest/HamtaSalt";
                return (await Pt.post(e, t)).data
            } catch (e) {
                if (this.setKundanvandare(null),
                console.log("Felaktigt användarnamn eller lösenord:" + e.response.status),
                e.response.status == "400") {
                    const n = e.response.data;
                    throw console.log("felmeddelande:" + n),
                    n
                } else
                    throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        async loggaIn(t) {
            try {
                const e = "/poit/rest/LoggaIn"
                  , n = await Pt.post(e, t)
                  , r = n.data;
                if (r.namn == null)
                    this.setKundanvandare(null),
                    sessionStorage.clear();
                else {
                    console.log(r.namn + "(" + r.personnummer + ") loggar in"),
                    r.poitkunder.sort( (s, l) => s.namn < l.namn ? -1 : 1);
                    const a = new Date;
                    sessionStorage.setItem("PoIT", JSON.stringify(r)),
                    sessionStorage.setItem("PoIT_TS", a.getTime().toString()),
                    this.setKundanvandare(r)
                }
                return n.data
            } catch (e) {
                if (this.setKundanvandare(null),
                console.log("Felaktigt användarnamn eller lösenord:" + e.response.status),
                e.response.status == "400") {
                    const n = e.response.data;
                    throw console.log("felmeddelande:" + n),
                    n
                } else
                    throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        loggaUt() {
            this.setKundanvandare(null),
            localStorage.clear(),
            sessionStorage.clear()
        },
        async skaBekraftelseSkickas(t) {
            try {
                const e = "/poit/rest/SkaBekraftelseSkickas";
                await Pt.post(e, t)
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        async bytLosenord(t) {
            try {
                const e = "/poit/rest/BytLosenord";
                return (await Pt.post(e, t)).data
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        async glomtLosenord(t) {
            try {
                const e = "/poit/rest/GlomtLosenord";
                return (await Pt.post(e, t)).data
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        setKundanvandare(t) {
            this.kundanvandare = t
        }
    }
})
  , kE = Se({
    __name: "NyVersionFinnsModal",
    setup(t) {
        const e = me(!1);
        function n() {
            setTimeout( () => {
                e.value = !0
            }
            , 5 * 60 * 1e3)
        }
        function r() {
            location.reload()
        }
        const a = () => fetch("/poit-app", {
            method: "HEAD",
            cache: "no-cache"
        }).then(s => new Date(s.headers.get("Last-modified")).getTime());
        return a().then(s => {
            const l = s
              , i = setInterval( () => {
                a().then(o => {
                    o != l && (clearInterval(i),
                    e.value = !0)
                }
                )
            }
            , 3 * 60 * 60 * 1e3)
        }
        ),
        (s, l) => {
            const i = ue("BModal");
            return g(),
            de(i, {
                modelValue: e.value,
                "onUpdate:modelValue": l[0] || (l[0] = o => e.value = o),
                "hide-header-close": "",
                "no-close-on-esc": "",
                "no-close-on-backdrop": "",
                onOk: r,
                onCancel: n,
                centered: "true",
                title: "Uppdatera sidan",
                okTitle: "Uppdatera nu",
                cancelTitle: "Påminn mig senare"
            }, {
                default: N( () => [ve(" För att Post- och inrikes tidningar ska fungera på bästa sätt behöver du uppdatera sidan. ")]),
                _: 1
            }, 8, ["modelValue"])
        }
    }
});
var _E = Object.defineProperty
  , wE = Object.getOwnPropertyDescriptor
  , xE = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? wE(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && _E(e, n, a),
    a
}
;
let vp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "wrapActive", !1);
        V(this, "intervall", null);
        V(this, "timer", null);
        V(this, "disableApp", !1);
        V(this, "nyVersionFinnsKontroll", !0);
        V(this, "secondwrapActive", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get layout() {
        return "default-layout"
    }
    get() {
        return "default-layout"
    }
    timerCallback() {
        this.kundanvandare != null && (dt().loggaUt(),
        this.$router.push({
            name: "loggain"
        }),
        window.location.reload())
    }
    resetTimer() {
        this.timer != null && (clearTimeout(this.timer),
        this.timer = setTimeout(this.timerCallback, 18e5))
    }
    intervallCallback() {
        if (this.timer == null && this.kundanvandare != null && (this.timer = setTimeout(this.timerCallback, 18e5),
        document.addEventListener("click", this.resetTimer),
        document.addEventListener("scroll", this.resetTimer),
        document.addEventListener("keydown", this.resetTimer)),
        this.timer != null && this.kundanvandare == null && clearTimeout(this.timer),
        this.kundanvandare != null) {
            var n = sessionStorage.getItem("PoIT_TS");
            if (n) {
                var r = new Date;
                parseInt(n) + 8639e4 < r.getTime() && (dt().loggaUt(),
                this.$router.push({
                    name: "loggain"
                }),
                window.location.reload())
            }
        }
    }
    created() {
        window.performance && performance.navigation.type == 1 && this.$router.push({
            name: "home"
        }),
        "fetch"in window || (this.disableApp = !0);
        var n = sessionStorage.getItem("PoIT_TS");
        if (n) {
            var r = new Date;
            parseInt(n) + 8639e4 < r.getTime() && (dt().loggaUt(),
            window.location.reload())
        }
        dt().isLoggedin || localStorage.getItem("PoIT_Redirect") == "true" && (localStorage.removeItem("PoIT_Redirect"),
        this.autologin().then(s => {
            s && this.$router.push({
                name: "minauppgifter"
            })
        }
        ))
    }
    async autologin() {
        var n = {
            email: "shibboleth",
            losenordsHash: "v3.0"
        }
          , r = await dt().loggaIn(n);
        return r == "INVALID_REDIRECT_TOKEN" ? (console.log("INVALID_REDIRECT_TOKEN"),
        !1) : !0
    }
    mounted() {
        this.intervall = setInterval(this.intervallCallback, 6e4)
    }
    beforeUnmount() {
        clearInterval(this.intervall),
        this.timer != null && clearTimeout(this.timer)
    }
}
;
vp = xE([Ct({
    components: {
        NyVersionFinnsModal: kE
    }
})], vp);
const SE = Et(vp);
const rt = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r,a] of e)
        n[r] = a;
    return n
}
  , $E = {
    key: 1
}
  , TE = {
    key: 2
}
  , CE = c("div", {
    class: "not-supported"
}, [c("h1", {
    class: "text-l"
}, "Välkommen till Post- och Inrikes Tidningar"), c("p", null, " Denna webbsida är endast tillgänglig i moderna webbläsare som Google Chrome, Microsoft Edge, Mozilla Firefox eller Safari. "), c("p", {
    class: "text-micro"
}, " This website is only available in modern browsers like Chrome, Edge, Firefox or Safari. Please upgrade to continue. ")], -1)
  , EE = [CE];
function AE(t, e, n, r, a, s) {
    const l = ue("NyVersionFinnsModal")
      , i = ue("router-view");
    return g(),
    _(we, null, [t.nyVersionFinnsKontroll ? (g(),
    de(l, {
        key: 0
    })) : q("", !0), t.disableApp ? (g(),
    _("div", TE, EE)) : (g(),
    _("div", $E, [(g(),
    de(qe(t.layout), null, {
        default: N( () => [x(i)]),
        _: 1
    }))]))], 64)
}
const ME = rt(SE, [["render", AE]]);
/*!
  * vue-router v4.3.2
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const Fl = typeof document < "u";
function OE(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const Dt = Object.assign;
function df(t, e) {
    const n = {};
    for (const r in e) {
        const a = e[r];
        n[r] = Vr(a) ? a.map(t) : t(a)
    }
    return n
}
const so = () => {}
  , Vr = Array.isArray
  , wk = /#/g
  , NE = /&/g
  , DE = /\//g
  , PE = /=/g
  , FE = /\?/g
  , xk = /\+/g
  , BE = /%5B/g
  , VE = /%5D/g
  , Sk = /%5E/g
  , IE = /%60/g
  , $k = /%7B/g
  , RE = /%7C/g
  , Tk = /%7D/g
  , LE = /%20/g;
function im(t) {
    return encodeURI("" + t).replace(RE, "|").replace(BE, "[").replace(VE, "]")
}
function jE(t) {
    return im(t).replace($k, "{").replace(Tk, "}").replace(Sk, "^")
}
function gp(t) {
    return im(t).replace(xk, "%2B").replace(LE, "+").replace(wk, "%23").replace(NE, "%26").replace(IE, "`").replace($k, "{").replace(Tk, "}").replace(Sk, "^")
}
function UE(t) {
    return gp(t).replace(PE, "%3D")
}
function HE(t) {
    return im(t).replace(wk, "%23").replace(FE, "%3F")
}
function KE(t) {
    return t == null ? "" : HE(t).replace(DE, "%2F")
}
function So(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {}
    return "" + t
}
const zE = /\/$/
  , qE = t => t.replace(zE, "");
function cf(t, e, n="/") {
    let r, a = {}, s = "", l = "";
    const i = e.indexOf("#");
    let o = e.indexOf("?");
    return i < o && i >= 0 && (o = -1),
    o > -1 && (r = e.slice(0, o),
    s = e.slice(o + 1, i > -1 ? i : e.length),
    a = t(s)),
    i > -1 && (r = r || e.slice(0, i),
    l = e.slice(i, e.length)),
    r = JE(r ?? e, n),
    {
        fullPath: r + (s && "?") + s + l,
        path: r,
        query: a,
        hash: So(l)
    }
}
function WE(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}
function Ug(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}
function GE(t, e, n) {
    const r = e.matched.length - 1
      , a = n.matched.length - 1;
    return r > -1 && r === a && ri(e.matched[r], n.matched[a]) && Ck(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}
function ri(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}
function Ck(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const n in t)
        if (!YE(t[n], e[n]))
            return !1;
    return !0
}
function YE(t, e) {
    return Vr(t) ? Hg(t, e) : Vr(e) ? Hg(e, t) : t === e
}
function Hg(t, e) {
    return Vr(e) ? t.length === e.length && t.every( (n, r) => n === e[r]) : t.length === 1 && t[0] === e
}
function JE(t, e) {
    if (t.startsWith("/"))
        return t;
    if (!t)
        return e;
    const n = e.split("/")
      , r = t.split("/")
      , a = r[r.length - 1];
    (a === ".." || a === ".") && r.push("");
    let s = n.length - 1, l, i;
    for (l = 0; l < r.length; l++)
        if (i = r[l],
        i !== ".")
            if (i === "..")
                s > 1 && s--;
            else
                break;
    return n.slice(0, s).join("/") + "/" + r.slice(l).join("/")
}
var $o;
(function(t) {
    t.pop = "pop",
    t.push = "push"
}
)($o || ($o = {}));
var lo;
(function(t) {
    t.back = "back",
    t.forward = "forward",
    t.unknown = ""
}
)(lo || (lo = {}));
function XE(t) {
    if (!t)
        if (Fl) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/",
            t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t),
    qE(t)
}
const QE = /^[^#]+#/;
function ZE(t, e) {
    return t.replace(QE, "#") + e
}
function eA(t, e) {
    const n = document.documentElement.getBoundingClientRect()
      , r = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: r.left - n.left - (e.left || 0),
        top: r.top - n.top - (e.top || 0)
    }
}
const ec = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function tA(t) {
    let e;
    if ("el"in t) {
        const n = t.el
          , r = typeof n == "string" && n.startsWith("#")
          , a = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!a)
            return;
        e = eA(a, t)
    } else
        e = t;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}
function Kg(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const bp = new Map;
function nA(t, e) {
    bp.set(t, e)
}
function rA(t) {
    const e = bp.get(t);
    return bp.delete(t),
    e
}
let aA = () => location.protocol + "//" + location.host;
function Ek(t, e) {
    const {pathname: n, search: r, hash: a} = e
      , s = t.indexOf("#");
    if (s > -1) {
        let i = a.includes(t.slice(s)) ? t.slice(s).length : 1
          , o = a.slice(i);
        return o[0] !== "/" && (o = "/" + o),
        Ug(o, "")
    }
    return Ug(n, t) + r + a
}
function sA(t, e, n, r) {
    let a = []
      , s = []
      , l = null;
    const i = ({state: p}) => {
        const h = Ek(t, location)
          , v = n.value
          , y = e.value;
        let k = 0;
        if (p) {
            if (n.value = h,
            e.value = p,
            l && l === v) {
                l = null;
                return
            }
            k = y ? p.position - y.position : 0
        } else
            r(h);
        a.forEach(w => {
            w(n.value, v, {
                delta: k,
                type: $o.pop,
                direction: k ? k > 0 ? lo.forward : lo.back : lo.unknown
            })
        }
        )
    }
    ;
    function o() {
        l = n.value
    }
    function u(p) {
        a.push(p);
        const h = () => {
            const v = a.indexOf(p);
            v > -1 && a.splice(v, 1)
        }
        ;
        return s.push(h),
        h
    }
    function d() {
        const {history: p} = window;
        p.state && p.replaceState(Dt({}, p.state, {
            scroll: ec()
        }), "")
    }
    function f() {
        for (const p of s)
            p();
        s = [],
        window.removeEventListener("popstate", i),
        window.removeEventListener("beforeunload", d)
    }
    return window.addEventListener("popstate", i),
    window.addEventListener("beforeunload", d, {
        passive: !0
    }),
    {
        pauseListeners: o,
        listen: u,
        destroy: f
    }
}
function zg(t, e, n, r=!1, a=!1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: a ? ec() : null
    }
}
function lA(t) {
    const {history: e, location: n} = window
      , r = {
        value: Ek(t, n)
    }
      , a = {
        value: e.state
    };
    a.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(o, u, d) {
        const f = t.indexOf("#")
          , p = f > -1 ? (n.host && document.querySelector("base") ? t : t.slice(f)) + o : aA() + t + o;
        try {
            e[d ? "replaceState" : "pushState"](u, "", p),
            a.value = u
        } catch (h) {
            console.error(h),
            n[d ? "replace" : "assign"](p)
        }
    }
    function l(o, u) {
        const d = Dt({}, e.state, zg(a.value.back, o, a.value.forward, !0), u, {
            position: a.value.position
        });
        s(o, d, !0),
        r.value = o
    }
    function i(o, u) {
        const d = Dt({}, a.value, e.state, {
            forward: o,
            scroll: ec()
        });
        s(d.current, d, !0);
        const f = Dt({}, zg(r.value, o, null), {
            position: d.position + 1
        }, u);
        s(o, f, !1),
        r.value = o
    }
    return {
        location: r,
        state: a,
        push: i,
        replace: l
    }
}
function iA(t) {
    t = XE(t);
    const e = lA(t)
      , n = sA(t, e.state, e.location, e.replace);
    function r(s, l=!0) {
        l || n.pauseListeners(),
        history.go(s)
    }
    const a = Dt({
        location: "",
        base: t,
        go: r,
        createHref: ZE.bind(null, t)
    }, e, n);
    return Object.defineProperty(a, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
    Object.defineProperty(a, "state", {
        enumerable: !0,
        get: () => e.state.value
    }),
    a
}
function oA(t) {
    return typeof t == "string" || t && typeof t == "object"
}
function Ak(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const Ra = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
}
  , Mk = Symbol("");
var qg;
(function(t) {
    t[t.aborted = 4] = "aborted",
    t[t.cancelled = 8] = "cancelled",
    t[t.duplicated = 16] = "duplicated"
}
)(qg || (qg = {}));
function ai(t, e) {
    return Dt(new Error, {
        type: t,
        [Mk]: !0
    }, e)
}
function va(t, e) {
    return t instanceof Error && Mk in t && (e == null || !!(t.type & e))
}
const Wg = "[^/]+?"
  , uA = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , dA = /[.+*?^${}()[\]/\\]/g;
function cA(t, e) {
    const n = Dt({}, uA, e)
      , r = [];
    let a = n.start ? "^" : "";
    const s = [];
    for (const u of t) {
        const d = u.length ? [] : [90];
        n.strict && !u.length && (a += "/");
        for (let f = 0; f < u.length; f++) {
            const p = u[f];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (p.type === 0)
                f || (a += "/"),
                a += p.value.replace(dA, "\\$&"),
                h += 40;
            else if (p.type === 1) {
                const {value: v, repeatable: y, optional: k, regexp: w} = p;
                s.push({
                    name: v,
                    repeatable: y,
                    optional: k
                });
                const $ = w || Wg;
                if ($ !== Wg) {
                    h += 10;
                    try {
                        new RegExp(`(${$})`)
                    } catch (S) {
                        throw new Error(`Invalid custom RegExp for param "${v}" (${$}): ` + S.message)
                    }
                }
                let M = y ? `((?:${$})(?:/(?:${$}))*)` : `(${$})`;
                f || (M = k && u.length < 2 ? `(?:/${M})` : "/" + M),
                k && (M += "?"),
                a += M,
                h += 20,
                k && (h += -8),
                y && (h += -20),
                $ === ".*" && (h += -50)
            }
            d.push(h)
        }
        r.push(d)
    }
    if (n.strict && n.end) {
        const u = r.length - 1;
        r[u][r[u].length - 1] += .7000000000000001
    }
    n.strict || (a += "/?"),
    n.end ? a += "$" : n.strict && (a += "(?:/|$)");
    const l = new RegExp(a,n.sensitive ? "" : "i");
    function i(u) {
        const d = u.match(l)
          , f = {};
        if (!d)
            return null;
        for (let p = 1; p < d.length; p++) {
            const h = d[p] || ""
              , v = s[p - 1];
            f[v.name] = h && v.repeatable ? h.split("/") : h
        }
        return f
    }
    function o(u) {
        let d = ""
          , f = !1;
        for (const p of t) {
            (!f || !d.endsWith("/")) && (d += "/"),
            f = !1;
            for (const h of p)
                if (h.type === 0)
                    d += h.value;
                else if (h.type === 1) {
                    const {value: v, repeatable: y, optional: k} = h
                      , w = v in u ? u[v] : "";
                    if (Vr(w) && !y)
                        throw new Error(`Provided param "${v}" is an array but it is not repeatable (* or + modifiers)`);
                    const $ = Vr(w) ? w.join("/") : w;
                    if (!$)
                        if (k)
                            p.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : f = !0);
                        else
                            throw new Error(`Missing required param "${v}"`);
                    d += $
                }
        }
        return d || "/"
    }
    return {
        re: l,
        score: r,
        keys: s,
        parse: i,
        stringify: o
    }
}
function fA(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length; ) {
        const r = e[n] - t[n];
        if (r)
            return r;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}
function pA(t, e) {
    let n = 0;
    const r = t.score
      , a = e.score;
    for (; n < r.length && n < a.length; ) {
        const s = fA(r[n], a[n]);
        if (s)
            return s;
        n++
    }
    if (Math.abs(a.length - r.length) === 1) {
        if (Gg(r))
            return 1;
        if (Gg(a))
            return -1
    }
    return a.length - r.length
}
function Gg(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const hA = {
    type: 0,
    value: ""
}
  , mA = /[a-zA-Z0-9_]/;
function vA(t) {
    if (!t)
        return [[]];
    if (t === "/")
        return [[hA]];
    if (!t.startsWith("/"))
        throw new Error(`Invalid path "${t}"`);
    function e(h) {
        throw new Error(`ERR (${n})/"${u}": ${h}`)
    }
    let n = 0
      , r = n;
    const a = [];
    let s;
    function l() {
        s && a.push(s),
        s = []
    }
    let i = 0, o, u = "", d = "";
    function f() {
        u && (n === 0 ? s.push({
            type: 0,
            value: u
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (o === "*" || o === "+") && e(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),
        s.push({
            type: 1,
            value: u,
            regexp: d,
            repeatable: o === "*" || o === "+",
            optional: o === "*" || o === "?"
        })) : e("Invalid state to consume buffer"),
        u = "")
    }
    function p() {
        u += o
    }
    for (; i < t.length; ) {
        if (o = t[i++],
        o === "\\" && n !== 2) {
            r = n,
            n = 4;
            continue
        }
        switch (n) {
        case 0:
            o === "/" ? (u && f(),
            l()) : o === ":" ? (f(),
            n = 1) : p();
            break;
        case 4:
            p(),
            n = r;
            break;
        case 1:
            o === "(" ? n = 2 : mA.test(o) ? p() : (f(),
            n = 0,
            o !== "*" && o !== "?" && o !== "+" && i--);
            break;
        case 2:
            o === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + o : n = 3 : d += o;
            break;
        case 3:
            f(),
            n = 0,
            o !== "*" && o !== "?" && o !== "+" && i--,
            d = "";
            break;
        default:
            e("Unknown state");
            break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${u}"`),
    f(),
    l(),
    a
}
function gA(t, e, n) {
    const r = cA(vA(t.path), n)
      , a = Dt(r, {
        record: t,
        parent: e,
        children: [],
        alias: []
    });
    return e && !a.record.aliasOf == !e.record.aliasOf && e.children.push(a),
    a
}
function bA(t, e) {
    const n = []
      , r = new Map;
    e = Xg({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function a(d) {
        return r.get(d)
    }
    function s(d, f, p) {
        const h = !p
          , v = yA(d);
        v.aliasOf = p && p.record;
        const y = Xg(e, d)
          , k = [v];
        if ("alias"in d) {
            const M = typeof d.alias == "string" ? [d.alias] : d.alias;
            for (const S of M)
                k.push(Dt({}, v, {
                    components: p ? p.record.components : v.components,
                    path: S,
                    aliasOf: p ? p.record : v
                }))
        }
        let w, $;
        for (const M of k) {
            const {path: S} = M;
            if (f && S[0] !== "/") {
                const T = f.record.path
                  , E = T[T.length - 1] === "/" ? "" : "/";
                M.path = f.record.path + (S && E + S)
            }
            if (w = gA(M, f, y),
            p ? p.alias.push(w) : ($ = $ || w,
            $ !== w && $.alias.push(w),
            h && d.name && !Jg(w) && l(d.name)),
            v.children) {
                const T = v.children;
                for (let E = 0; E < T.length; E++)
                    s(T[E], w, p && p.children[E])
            }
            p = p || w,
            (w.record.components && Object.keys(w.record.components).length || w.record.name || w.record.redirect) && o(w)
        }
        return $ ? () => {
            l($)
        }
        : so
    }
    function l(d) {
        if (Ak(d)) {
            const f = r.get(d);
            f && (r.delete(d),
            n.splice(n.indexOf(f), 1),
            f.children.forEach(l),
            f.alias.forEach(l))
        } else {
            const f = n.indexOf(d);
            f > -1 && (n.splice(f, 1),
            d.record.name && r.delete(d.record.name),
            d.children.forEach(l),
            d.alias.forEach(l))
        }
    }
    function i() {
        return n
    }
    function o(d) {
        let f = 0;
        for (; f < n.length && pA(d, n[f]) >= 0 && (d.record.path !== n[f].record.path || !Ok(d, n[f])); )
            f++;
        n.splice(f, 0, d),
        d.record.name && !Jg(d) && r.set(d.record.name, d)
    }
    function u(d, f) {
        let p, h = {}, v, y;
        if ("name"in d && d.name) {
            if (p = r.get(d.name),
            !p)
                throw ai(1, {
                    location: d
                });
            y = p.record.name,
            h = Dt(Yg(f.params, p.keys.filter($ => !$.optional).concat(p.parent ? p.parent.keys.filter($ => $.optional) : []).map($ => $.name)), d.params && Yg(d.params, p.keys.map($ => $.name))),
            v = p.stringify(h)
        } else if (d.path != null)
            v = d.path,
            p = n.find($ => $.re.test(v)),
            p && (h = p.parse(v),
            y = p.record.name);
        else {
            if (p = f.name ? r.get(f.name) : n.find($ => $.re.test(f.path)),
            !p)
                throw ai(1, {
                    location: d,
                    currentLocation: f
                });
            y = p.record.name,
            h = Dt({}, f.params, d.params),
            v = p.stringify(h)
        }
        const k = [];
        let w = p;
        for (; w; )
            k.unshift(w.record),
            w = w.parent;
        return {
            name: y,
            path: v,
            params: h,
            matched: k,
            meta: _A(k)
        }
    }
    return t.forEach(d => s(d)),
    {
        addRoute: s,
        resolve: u,
        removeRoute: l,
        getRoutes: i,
        getRecordMatcher: a
    }
}
function Yg(t, e) {
    const n = {};
    for (const r of e)
        r in t && (n[r] = t[r]);
    return n
}
function yA(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: kA(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}
function kA(t) {
    const e = {}
      , n = t.props || !1;
    if ("component"in t)
        e.default = n;
    else
        for (const r in t.components)
            e[r] = typeof n == "object" ? n[r] : n;
    return e
}
function Jg(t) {
    for (; t; ) {
        if (t.record.aliasOf)
            return !0;
        t = t.parent
    }
    return !1
}
function _A(t) {
    return t.reduce( (e, n) => Dt(e, n.meta), {})
}
function Xg(t, e) {
    const n = {};
    for (const r in t)
        n[r] = r in e ? e[r] : t[r];
    return n
}
function Ok(t, e) {
    return e.children.some(n => n === t || Ok(t, n))
}
function wA(t) {
    const e = {};
    if (t === "" || t === "?")
        return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let a = 0; a < r.length; ++a) {
        const s = r[a].replace(xk, " ")
          , l = s.indexOf("=")
          , i = So(l < 0 ? s : s.slice(0, l))
          , o = l < 0 ? null : So(s.slice(l + 1));
        if (i in e) {
            let u = e[i];
            Vr(u) || (u = e[i] = [u]),
            u.push(o)
        } else
            e[i] = o
    }
    return e
}
function Qg(t) {
    let e = "";
    for (let n in t) {
        const r = t[n];
        if (n = UE(n),
        r == null) {
            r !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }
        (Vr(r) ? r.map(s => s && gp(s)) : [r && gp(r)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + n,
            s != null && (e += "=" + s))
        }
        )
    }
    return e
}
function xA(t) {
    const e = {};
    for (const n in t) {
        const r = t[n];
        r !== void 0 && (e[n] = Vr(r) ? r.map(a => a == null ? null : "" + a) : r == null ? r : "" + r)
    }
    return e
}
const SA = Symbol("")
  , Zg = Symbol("")
  , om = Symbol("")
  , Nk = Symbol("")
  , yp = Symbol("");
function Bi() {
    let t = [];
    function e(r) {
        return t.push(r),
        () => {
            const a = t.indexOf(r);
            a > -1 && t.splice(a, 1)
        }
    }
    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t.slice(),
        reset: n
    }
}
function Ya(t, e, n, r, a, s=l => l()) {
    const l = r && (r.enterCallbacks[a] = r.enterCallbacks[a] || []);
    return () => new Promise( (i, o) => {
        const u = p => {
            p === !1 ? o(ai(4, {
                from: n,
                to: e
            })) : p instanceof Error ? o(p) : oA(p) ? o(ai(2, {
                from: e,
                to: p
            })) : (l && r.enterCallbacks[a] === l && typeof p == "function" && l.push(p),
            i())
        }
          , d = s( () => t.call(r && r.instances[a], e, n, u));
        let f = Promise.resolve(d);
        t.length < 3 && (f = f.then(u)),
        f.catch(p => o(p))
    }
    )
}
function ff(t, e, n, r, a=s => s()) {
    const s = [];
    for (const l of t)
        for (const i in l.components) {
            let o = l.components[i];
            if (!(e !== "beforeRouteEnter" && !l.instances[i]))
                if ($A(o)) {
                    const d = (o.__vccOpts || o)[e];
                    d && s.push(Ya(d, n, r, l, i, a))
                } else {
                    let u = o();
                    s.push( () => u.then(d => {
                        if (!d)
                            return Promise.reject(new Error(`Couldn't resolve component "${i}" at "${l.path}"`));
                        const f = OE(d) ? d.default : d;
                        l.components[i] = f;
                        const h = (f.__vccOpts || f)[e];
                        return h && Ya(h, n, r, l, i, a)()
                    }
                    ))
                }
        }
    return s
}
function $A(t) {
    return typeof t == "object" || "displayName"in t || "props"in t || "__vccOpts"in t
}
function eb(t) {
    const e = Gt(om)
      , n = Gt(Nk)
      , r = K( () => {
        const o = A(t.to);
        return e.resolve(o)
    }
    )
      , a = K( () => {
        const {matched: o} = r.value
          , {length: u} = o
          , d = o[u - 1]
          , f = n.matched;
        if (!d || !f.length)
            return -1;
        const p = f.findIndex(ri.bind(null, d));
        if (p > -1)
            return p;
        const h = tb(o[u - 2]);
        return u > 1 && tb(d) === h && f[f.length - 1].path !== h ? f.findIndex(ri.bind(null, o[u - 2])) : p
    }
    )
      , s = K( () => a.value > -1 && AA(n.params, r.value.params))
      , l = K( () => a.value > -1 && a.value === n.matched.length - 1 && Ck(n.params, r.value.params));
    function i(o={}) {
        return EA(o) ? e[A(t.replace) ? "replace" : "push"](A(t.to)).catch(so) : Promise.resolve()
    }
    return {
        route: r,
        href: K( () => r.value.href),
        isActive: s,
        isExactActive: l,
        navigate: i
    }
}
const TA = Se({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: eb,
    setup(t, {slots: e}) {
        const n = Fn(eb(t))
          , {options: r} = Gt(om)
          , a = K( () => ({
            [nb(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
            [nb(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
        }));
        return () => {
            const s = e.default && e.default(n);
            return t.custom ? s : st("a", {
                "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: a.value
            }, s)
        }
    }
})
  , CA = TA;
function EA(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return t.preventDefault && t.preventDefault(),
        !0
    }
}
function AA(t, e) {
    for (const n in e) {
        const r = e[n]
          , a = t[n];
        if (typeof r == "string") {
            if (r !== a)
                return !1
        } else if (!Vr(a) || a.length !== r.length || r.some( (s, l) => s !== a[l]))
            return !1
    }
    return !0
}
function tb(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const nb = (t, e, n) => t ?? e ?? n
  , MA = Se({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(t, {attrs: e, slots: n}) {
        const r = Gt(yp)
          , a = K( () => t.route || r.value)
          , s = Gt(Zg, 0)
          , l = K( () => {
            let u = A(s);
            const {matched: d} = a.value;
            let f;
            for (; (f = d[u]) && !f.components; )
                u++;
            return u
        }
        )
          , i = K( () => a.value.matched[l.value]);
        zn(Zg, K( () => l.value + 1)),
        zn(SA, i),
        zn(yp, a);
        const o = me();
        return Ke( () => [o.value, i.value, t.name], ([u,d,f], [p,h,v]) => {
            d && (d.instances[f] = u,
            h && h !== d && u && u === p && (d.leaveGuards.size || (d.leaveGuards = h.leaveGuards),
            d.updateGuards.size || (d.updateGuards = h.updateGuards))),
            u && d && (!h || !ri(d, h) || !p) && (d.enterCallbacks[f] || []).forEach(y => y(u))
        }
        , {
            flush: "post"
        }),
        () => {
            const u = a.value
              , d = t.name
              , f = i.value
              , p = f && f.components[d];
            if (!p)
                return rb(n.default, {
                    Component: p,
                    route: u
                });
            const h = f.props[d]
              , v = h ? h === !0 ? u.params : typeof h == "function" ? h(u) : h : null
              , k = st(p, Dt({}, v, e, {
                onVnodeUnmounted: w => {
                    w.component.isUnmounted && (f.instances[d] = null)
                }
                ,
                ref: o
            }));
            return rb(n.default, {
                Component: k,
                route: u
            }) || k
        }
    }
});
function rb(t, e) {
    if (!t)
        return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const OA = MA;
function NA(t) {
    const e = bA(t.routes, t)
      , n = t.parseQuery || wA
      , r = t.stringifyQuery || Qg
      , a = t.history
      , s = Bi()
      , l = Bi()
      , i = Bi()
      , o = jh(Ra);
    let u = Ra;
    Fl && t.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const d = df.bind(null, ee => "" + ee)
      , f = df.bind(null, KE)
      , p = df.bind(null, So);
    function h(ee, B) {
        let se, pe;
        return Ak(ee) ? (se = e.getRecordMatcher(ee),
        pe = B) : pe = ee,
        e.addRoute(pe, se)
    }
    function v(ee) {
        const B = e.getRecordMatcher(ee);
        B && e.removeRoute(B)
    }
    function y() {
        return e.getRoutes().map(ee => ee.record)
    }
    function k(ee) {
        return !!e.getRecordMatcher(ee)
    }
    function w(ee, B) {
        if (B = Dt({}, B || o.value),
        typeof ee == "string") {
            const z = cf(n, ee, B.path)
              , ge = e.resolve({
                path: z.path
            }, B)
              , Te = a.createHref(z.fullPath);
            return Dt(z, ge, {
                params: p(ge.params),
                hash: So(z.hash),
                redirectedFrom: void 0,
                href: Te
            })
        }
        let se;
        if (ee.path != null)
            se = Dt({}, ee, {
                path: cf(n, ee.path, B.path).path
            });
        else {
            const z = Dt({}, ee.params);
            for (const ge in z)
                z[ge] == null && delete z[ge];
            se = Dt({}, ee, {
                params: f(z)
            }),
            B.params = f(B.params)
        }
        const pe = e.resolve(se, B)
          , ie = ee.hash || "";
        pe.params = d(p(pe.params));
        const fe = WE(r, Dt({}, ee, {
            hash: jE(ie),
            path: pe.path
        }))
          , F = a.createHref(fe);
        return Dt({
            fullPath: fe,
            hash: ie,
            query: r === Qg ? xA(ee.query) : ee.query || {}
        }, pe, {
            redirectedFrom: void 0,
            href: F
        })
    }
    function $(ee) {
        return typeof ee == "string" ? cf(n, ee, o.value.path) : Dt({}, ee)
    }
    function M(ee, B) {
        if (u !== ee)
            return ai(8, {
                from: B,
                to: ee
            })
    }
    function S(ee) {
        return O(ee)
    }
    function T(ee) {
        return S(Dt($(ee), {
            replace: !0
        }))
    }
    function E(ee) {
        const B = ee.matched[ee.matched.length - 1];
        if (B && B.redirect) {
            const {redirect: se} = B;
            let pe = typeof se == "function" ? se(ee) : se;
            return typeof pe == "string" && (pe = pe.includes("?") || pe.includes("#") ? pe = $(pe) : {
                path: pe
            },
            pe.params = {}),
            Dt({
                query: ee.query,
                hash: ee.hash,
                params: pe.path != null ? {} : ee.params
            }, pe)
        }
    }
    function O(ee, B) {
        const se = u = w(ee)
          , pe = o.value
          , ie = ee.state
          , fe = ee.force
          , F = ee.replace === !0
          , z = E(se);
        if (z)
            return O(Dt($(z), {
                state: typeof z == "object" ? Dt({}, ie, z.state) : ie,
                force: fe,
                replace: F
            }), B || se);
        const ge = se;
        ge.redirectedFrom = B;
        let Te;
        return !fe && GE(r, pe, se) && (Te = ai(16, {
            to: ge,
            from: pe
        }),
        re(pe, pe, !0, !1)),
        (Te ? Promise.resolve(Te) : C(ge, pe)).catch(ke => va(ke) ? va(ke, 2) ? ke : j(ke) : ne(ke, ge, pe)).then(ke => {
            if (ke) {
                if (va(ke, 2))
                    return O(Dt({
                        replace: F
                    }, $(ke.to), {
                        state: typeof ke.to == "object" ? Dt({}, ie, ke.to.state) : ie,
                        force: fe
                    }), B || ge)
            } else
                ke = R(ge, pe, !0, F, ie);
            return W(ge, pe, ke),
            ke
        }
        )
    }
    function U(ee, B) {
        const se = M(ee, B);
        return se ? Promise.reject(se) : Promise.resolve()
    }
    function L(ee) {
        const B = xe.values().next().value;
        return B && typeof B.runWithContext == "function" ? B.runWithContext(ee) : ee()
    }
    function C(ee, B) {
        let se;
        const [pe,ie,fe] = DA(ee, B);
        se = ff(pe.reverse(), "beforeRouteLeave", ee, B);
        for (const z of pe)
            z.leaveGuards.forEach(ge => {
                se.push(Ya(ge, ee, B))
            }
            );
        const F = U.bind(null, ee, B);
        return se.push(F),
        be(se).then( () => {
            se = [];
            for (const z of s.list())
                se.push(Ya(z, ee, B));
            return se.push(F),
            be(se)
        }
        ).then( () => {
            se = ff(ie, "beforeRouteUpdate", ee, B);
            for (const z of ie)
                z.updateGuards.forEach(ge => {
                    se.push(Ya(ge, ee, B))
                }
                );
            return se.push(F),
            be(se)
        }
        ).then( () => {
            se = [];
            for (const z of fe)
                if (z.beforeEnter)
                    if (Vr(z.beforeEnter))
                        for (const ge of z.beforeEnter)
                            se.push(Ya(ge, ee, B));
                    else
                        se.push(Ya(z.beforeEnter, ee, B));
            return se.push(F),
            be(se)
        }
        ).then( () => (ee.matched.forEach(z => z.enterCallbacks = {}),
        se = ff(fe, "beforeRouteEnter", ee, B, L),
        se.push(F),
        be(se))).then( () => {
            se = [];
            for (const z of l.list())
                se.push(Ya(z, ee, B));
            return se.push(F),
            be(se)
        }
        ).catch(z => va(z, 8) ? z : Promise.reject(z))
    }
    function W(ee, B, se) {
        i.list().forEach(pe => L( () => pe(ee, B, se)))
    }
    function R(ee, B, se, pe, ie) {
        const fe = M(ee, B);
        if (fe)
            return fe;
        const F = B === Ra
          , z = Fl ? history.state : {};
        se && (pe || F ? a.replace(ee.fullPath, Dt({
            scroll: F && z && z.scroll
        }, ie)) : a.push(ee.fullPath, ie)),
        o.value = ee,
        re(ee, B, se, F),
        j()
    }
    let G;
    function te() {
        G || (G = a.listen( (ee, B, se) => {
            if (!X.listening)
                return;
            const pe = w(ee)
              , ie = E(pe);
            if (ie) {
                O(Dt(ie, {
                    replace: !0
                }), pe).catch(so);
                return
            }
            u = pe;
            const fe = o.value;
            Fl && nA(Kg(fe.fullPath, se.delta), ec()),
            C(pe, fe).catch(F => va(F, 12) ? F : va(F, 2) ? (O(F.to, pe).then(z => {
                va(z, 20) && !se.delta && se.type === $o.pop && a.go(-1, !1)
            }
            ).catch(so),
            Promise.reject()) : (se.delta && a.go(-se.delta, !1),
            ne(F, pe, fe))).then(F => {
                F = F || R(pe, fe, !1),
                F && (se.delta && !va(F, 8) ? a.go(-se.delta, !1) : se.type === $o.pop && va(F, 20) && a.go(-1, !1)),
                W(pe, fe, F)
            }
            ).catch(so)
        }
        ))
    }
    let J = Bi(), ae = Bi(), oe;
    function ne(ee, B, se) {
        j(ee);
        const pe = ae.list();
        return pe.length ? pe.forEach(ie => ie(ee, B, se)) : console.error(ee),
        Promise.reject(ee)
    }
    function I() {
        return oe && o.value !== Ra ? Promise.resolve() : new Promise( (ee, B) => {
            J.add([ee, B])
        }
        )
    }
    function j(ee) {
        return oe || (oe = !ee,
        te(),
        J.list().forEach( ([B,se]) => ee ? se(ee) : B()),
        J.reset()),
        ee
    }
    function re(ee, B, se, pe) {
        const {scrollBehavior: ie} = t;
        if (!Fl || !ie)
            return Promise.resolve();
        const fe = !se && rA(Kg(ee.fullPath, 0)) || (pe || !se) && history.state && history.state.scroll || null;
        return Ot().then( () => ie(ee, B, fe)).then(F => F && tA(F)).catch(F => ne(F, ee, B))
    }
    const le = ee => a.go(ee);
    let ce;
    const xe = new Set
      , X = {
        currentRoute: o,
        listening: !0,
        addRoute: h,
        removeRoute: v,
        hasRoute: k,
        getRoutes: y,
        resolve: w,
        options: t,
        push: S,
        replace: T,
        go: le,
        back: () => le(-1),
        forward: () => le(1),
        beforeEach: s.add,
        beforeResolve: l.add,
        afterEach: i.add,
        onError: ae.add,
        isReady: I,
        install(ee) {
            const B = this;
            ee.component("RouterLink", CA),
            ee.component("RouterView", OA),
            ee.config.globalProperties.$router = B,
            Object.defineProperty(ee.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => A(o)
            }),
            Fl && !ce && o.value === Ra && (ce = !0,
            S(a.location).catch(ie => {}
            ));
            const se = {};
            for (const ie in Ra)
                Object.defineProperty(se, ie, {
                    get: () => o.value[ie],
                    enumerable: !0
                });
            ee.provide(om, B),
            ee.provide(Nk, t1(se)),
            ee.provide(yp, o);
            const pe = ee.unmount;
            xe.add(ee),
            ee.unmount = function() {
                xe.delete(ee),
                xe.size < 1 && (u = Ra,
                G && G(),
                G = null,
                o.value = Ra,
                ce = !1,
                oe = !1),
                pe()
            }
        }
    };
    function be(ee) {
        return ee.reduce( (B, se) => B.then( () => L(se)), Promise.resolve())
    }
    return X
}
function DA(t, e) {
    const n = []
      , r = []
      , a = []
      , s = Math.max(e.matched.length, t.matched.length);
    for (let l = 0; l < s; l++) {
        const i = e.matched[l];
        i && (t.matched.find(u => ri(u, i)) ? r.push(i) : n.push(i));
        const o = t.matched[l];
        o && (e.matched.find(u => ri(u, o)) || a.push(o))
    }
    return [n, r, a]
}
const PA = Se({
    name: "Selectlist",
    props: {
        id: {
            type: String,
            default: ""
        },
        selected: {
            type: String,
            default: "Samtliga"
        },
        selectedValue: {
            type: String,
            default: ""
        },
        lista: {
            type: Array
        }
    },
    data() {
        return {
            valtVarde: ""
        }
    },
    watch: {
        valtVarde: function(t) {
            this.$emit("onChange", t)
        }
    }
});
const FA = ["id"]
  , BA = ["value"]
  , VA = ["value"];
function IA(t, e, n, r, a, s) {
    return g(),
    _("div", null, [Z(t.$slots, "default", {}, void 0, !0), ft(c("select", {
        id: t.id,
        class: "form-select",
        "onUpdate:modelValue": e[0] || (e[0] = l => t.valtVarde = l)
    }, [c("option", {
        value: t.selectedValue,
        selected: ""
    }, Q(t.selected), 9, BA), (g(!0),
    _(we, null, Ne(t.lista, l => (g(),
    _("option", {
        key: l.id,
        value: l
    }, Q(l.namn), 9, VA))), 128))], 8, FA), [[Xn, t.valtVarde]])])
}
const Vn = rt(PA, [["render", IA], ["__scopeId", "data-v-11ad4515"]])
  , RA = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , LA = c("path", {
    fill: "currentColor",
    "fill-rule": "evenodd",
    d: "M1 8a7 7 0 1 0 14 0A7 7 0 0 0 1 8m15 0A8 8 0 1 1 0 8a8 8 0 0 1 16 0M4.5 7.5a.5.5 0 0 0 0 1h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5z"
}, null, -1)
  , jA = [LA];
function UA(t, e) {
    return g(),
    _("svg", RA, [...jA])
}
const Dk = {
    name: "bi-arrow-right-circle",
    render: UA
}
  , HA = Se({
    name: "Sokresultat",
    props: {
        sokresultat: {
            type: Object,
            required: !0
        },
        inloggad: {
            type: Boolean,
            default: !1
        }
    },
    components: {
        IBiArrowRightCircle: Dk
    },
    data: function() {
        return {
            sorteringsalternativ: [{
                namn: "Uppgiftslämnare",
                id: "uppgiftslamnare",
                sorteringsordning: "asc"
            }, {
                namn: "Typ av kungörelse",
                id: "kungorelsetyp",
                sorteringsordning: "asc"
            }, {
                namn: "Namn",
                id: "namn",
                sorteringsordning: "asc"
            }, {
                namn: "Publicerad",
                id: "publiceringsdatum",
                sorteringsordning: "desc"
            }]
        }
    },
    methods: {
        fixLink: function(t) {
            return t.replaceAll("/", "-")
        },
        sortera: function(t) {
            this.sokresultat.sort( (e, n) => {
                const r = t.id;
                return t.sorteringsordning == "asc" ? e[r].toLocaleLowerCase() > n[r].toLocaleLowerCase() ? 1 : -1 : n[r].toLocaleLowerCase() > e[r].toLocaleLowerCase() ? 1 : -1
            }
            )
        }
    }
});
const ml = t => ($t("data-v-577824d8"),
t = t(),
Tt(),
t)
  , KA = {
    key: 0
}
  , zA = {
    class: "row mt-3 mb-0"
}
  , qA = {
    class: "col-12 col-md-3 align-self-center mx-auto mx-md-0"
}
  , WA = {
    class: "col-12 col-md-9 d-flex flex-wrap justify-content-md-end align-self-center mx-auto mx-md-0 table__actions"
}
  , GA = ml( () => c("span", {
    class: "btn btn-link-disabled"
}, "Sortera på:", -1))
  , YA = ["title", "onClick"]
  , JA = {
    class: "row mt-1"
}
  , XA = {
    class: "col"
}
  , QA = {
    class: "table-responsive"
}
  , ZA = {
    class: "table table-hover table-striped table-bv",
    id: "sokresultat"
}
  , eM = ml( () => c("caption", {
    class: "visually-hidden"
}, " Sökresultat, kungörelser ", -1))
  , tM = {
    class: "blv-thead"
}
  , nM = ml( () => c("th", null, "Kungörelse-id", -1))
  , rM = ml( () => c("th", null, "Uppgiftslämnare", -1))
  , aM = ml( () => c("th", null, "Typ av kungörelse", -1))
  , sM = ml( () => c("th", null, "Namn/fastighetsbeteckning", -1))
  , lM = ml( () => c("th", null, "Publicerad", -1))
  , iM = {
    key: 0,
    class: "text-center"
}
  , oM = {
    key: 1,
    class: "text-center"
}
  , uM = {
    class: "align-middle"
}
  , dM = {
    class: "align-middle"
}
  , cM = {
    class: "align-middle"
}
  , fM = {
    class: "align-middle"
}
  , pM = {
    class: "align-middle text-nowrap"
}
  , hM = {
    class: "align-middle text-center"
};
function mM(t, e, n, r, a, s) {
    const l = ue("router-link")
      , i = ue("i-bi-arrow-right-circle");
    return t.sokresultat && t.sokresultat.length > 0 ? (g(),
    _("div", KA, [Z(t.$slots, "default", {}, void 0, !0), c("div", zA, [c("div", qA, [c("span", null, [ve("Antal träffar: "), c("strong", null, Q(t.sokresultat.length), 1)])]), c("div", WA, [GA, (g(!0),
    _(we, null, Ne(t.sorteringsalternativ, o => (g(),
    _("button", {
        key: o.id,
        type: "button",
        title: "Sortera på " + o.namn,
        class: "btn btn-link",
        onClick: u => t.sortera(o)
    }, Q(o.namn), 9, YA))), 128))])]), c("div", JA, [c("div", XA, [c("div", QA, [c("table", ZA, [eM, c("thead", tM, [c("tr", null, [nM, rM, aM, sM, lM, t.inloggad ? (g(),
    _("th", iM, "Visa/rätta")) : (g(),
    _("th", oM, "Visa"))])]), c("tbody", null, [(g(!0),
    _(we, null, Ne(t.sokresultat, (o, u) => (g(),
    _("tr", {
        key: o.kungorelseid + u
    }, [c("td", uM, [x(l, {
        title: "Visa kungörelse",
        class: "kungorelse__link",
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: t.fixLink(o.kungorelseid)
            }
        }
    }, {
        default: N( () => [ve(Q(o.kungorelseid), 1)]),
        _: 2
    }, 1032, ["to"])]), c("td", dM, Q(o.uppgiftslamnare), 1), c("td", cM, Q(o.kungorelsetyp), 1), c("td", fM, Q(o.namn != "" ? o.namn : "–"), 1), c("td", pM, Q(o.publiceringsdatum), 1), c("td", hM, [x(l, {
        class: "btn btn-link rounded-circle square-40",
        title: "Visa kungörelse",
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: t.fixLink(o.kungorelseid)
            }
        }
    }, {
        default: N( () => [x(i, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "arrow right circle",
            focusable: "false"
        })]),
        _: 2
    }, 1032, ["to"])])]))), 128))])])])])])])) : q("", !0)
}
const tc = rt(HA, [["render", mM], ["__scopeId", "data-v-577824d8"]])
  , vM = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , gM = c("path", {
    fill: "currentColor",
    d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M8 4a.905.905 0 0 0-.9.995l.35 3.507a.552.552 0 0 0 1.1 0l.35-3.507A.905.905 0 0 0 8 4m.002 6a1 1 0 1 0 0 2a1 1 0 0 0 0-2"
}, null, -1)
  , bM = [gM];
function yM(t, e) {
    return g(),
    _("svg", vM, [...bM])
}
const Pk = {
    name: "bi-exclamation-circle-fill",
    render: yM
}
  , kM = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , _M = c("path", {
    fill: "currentColor",
    d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417L5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"
}, null, -1)
  , wM = [_M];
function xM(t, e) {
    return g(),
    _("svg", kM, [...wM])
}
const SM = {
    name: "bi-check-circle-fill",
    render: xM
}
  , $M = Se({
    name: "Meddelande",
    components: {
        IBiExclamationCircleFill: Pk,
        IBiCheckCircleFill: SM
    },
    props: {
        meddelande: {
            default: ""
        },
        meddelandeTyp: {
            default: "info"
        }
    }
})
  , TM = ["innerHTML"];
function CM(t, e, n, r, a, s) {
    const l = ue("i-bi-exclamation-circle-fill")
      , i = ue("i-bi-check-circle-fill");
    return g(),
    _("div", {
        class: ye(["blv-alert-" + t.meddelandeTyp, "alert mt-2 mb-3 d-flex"]),
        tabindex: "0",
        ref: "mymessage",
        role: "alert",
        "aria-live": "polite",
        "aria-describedby": "#message"
    }, [t.meddelandeTyp == "danger" ? (g(),
    de(l, {
        key: 0,
        class: "blv-color-danger x2 me-2 align-self-center b-icon bi",
        role: "img",
        "aria-label": "exclamation circle fill",
        focusable: "false"
    })) : q("", !0), t.meddelandeTyp == "info" ? (g(),
    de(l, {
        key: 1,
        class: "blv-color-info x2 me-2 align-self-center b-icon bi",
        role: "img",
        "aria-label": "exclamation circle fill",
        focusable: "false"
    })) : q("", !0), t.meddelandeTyp == "success" ? (g(),
    de(i, {
        key: 2,
        class: "blv-color-success x2 me-2 align-self-center b-icon bi",
        role: "img",
        "aria-label": "check circle fill",
        focusable: "false"
    })) : q("", !0), c("div", {
        id: "message",
        class: "align-self-center mx-2 mx-md-0",
        innerHTML: t.meddelande
    }, null, 8, TM)], 2)
}
const Ft = rt($M, [["render", CM]]);
var EM = Object.defineProperty
  , AM = (t, e, n) => e in t ? EM(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n
  , pr = (t, e, n) => (AM(t, typeof e != "symbol" ? e + "" : e, n),
n);
const Fk = t => typeof t == "boolean" || t === "" || t === "true" || t === "false"
  , nc = t => typeof t == "boolean" ? t : t === "" || t === "true";
let si = class Bk {
    constructor(e, n={}) {
        if (pr(this, "cancelable", !0),
        pr(this, "componentId", null),
        pr(this, "_defaultPrevented", !1),
        pr(this, "eventType", ""),
        pr(this, "nativeEvent", null),
        pr(this, "_preventDefault"),
        pr(this, "relatedTarget", null),
        pr(this, "target", null),
        !e)
            throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);
        Object.assign(this, Bk.Defaults, n, {
            eventType: e
        }),
        this._preventDefault = function() {
            this.cancelable && (this.defaultPrevented = !0)
        }
    }
    get defaultPrevented() {
        return this._defaultPrevented
    }
    set defaultPrevented(e) {
        this._defaultPrevented = e
    }
    get preventDefault() {
        return this._preventDefault
    }
    set preventDefault(e) {
        this._preventDefault = e
    }
    static get Defaults() {
        return {
            cancelable: !0,
            componentId: null,
            eventType: "",
            nativeEvent: null,
            relatedTarget: null,
            target: null
        }
    }
}
  , Wo = class extends si {
    constructor(e, n={}) {
        super(e, n),
        pr(this, "trigger", null),
        Object.assign(this, si.Defaults, n, {
            eventType: e
        })
    }
    static get Defaults() {
        return {
            ...super.Defaults,
            trigger: null
        }
    }
}
  , MM = class extends si {
    constructor(e, n) {
        super(e, n),
        pr(this, "from"),
        pr(this, "to"),
        pr(this, "direction"),
        Object.assign(this, si.Defaults, n, {
            eventType: e
        });
        const {from: r, direction: a, to: s} = n;
        this.from = r,
        this.to = s,
        this.direction = a
    }
    static get Defaults() {
        return {
            ...super.Defaults
        }
    }
}
;
const kp = t => t !== null && typeof t == "object"
  , OM = t => /^[0-9]*\.?[0-9]+$/.test(String(t))
  , NM = t => Object.prototype.toString.call(t) === "[object Object]"
  , Vk = /_/g
  , Ik = /([a-z])([A-Z])/g
  , DM = /(\s|^)(\w)/g
  , PM = /(\s|^)(\w)/
  , Du = /\s+/
  , FM = /^#/
  , BM = /^#[A-Za-z]+[\w\-:.]*$/
  , VM = /-u-.+/
  , IM = /[-/\\^$*+?.()|[\]{}]/g
  , RM = /[\s\uFEFF\xA0]+/g
  , Yu = (t, e=2) => typeof t == "string" ? t : t == null ? "" : Array.isArray(t) || NM(t) && t.toString === Object.prototype.toString ? JSON.stringify(t, null, e) : String(t)
  , ab = t => t.replace(Vk, " ").replace(Ik, (e, n, r) => `${n} ${r}`).replace(PM, (e, n, r) => n + r.toUpperCase())
  , sb = t => t.replace(Vk, " ").replace(Ik, (e, n, r) => `${n} ${r}`).replace(DM, (e, n, r) => n + r.toUpperCase())
  , LM = t => {
    const e = t.trim();
    return e.charAt(0).toUpperCase() + e.slice(1)
}
  , jM = t => t.replace(IM, "\\$&")
  , UM = t => jM(t).replace(RM, "\\s")
  , pf = t => `\\${t}`
  , HM = t => {
    const e = Yu(t)
      , {length: n} = e
      , r = e.charCodeAt(0);
    return e.split("").reduce( (a, s, l) => {
        const i = e.charCodeAt(l);
        return i === 0 ? `${a}�` : i === 127 || i >= 1 && i <= 31 || l === 0 && i >= 48 && i <= 57 || l === 1 && i >= 48 && i <= 57 && r === 45 ? a + pf(`${i.toString(16)} `) : l === 0 && i === 45 && n === 1 ? a + pf(s) : i >= 128 || i === 45 || i === 95 || i >= 48 && i <= 57 || i >= 65 && i <= 90 || i >= 97 && i <= 122 ? a + s : a + pf(s)
    }
    , "")
}
  , Rk = typeof window < "u"
  , Lk = typeof document < "u"
  , KM = typeof Element < "u"
  , zM = typeof navigator < "u"
  , qM = Rk && Lk && zM
  , lb = Rk ? window : {}
  , um = Lk ? document : {};
( () => {
    let t = !1;
    if (qM)
        try {
            const e = {
                get passive() {
                    return t = !0,
                    t
                }
            };
            lb.addEventListener("test", e, e),
            lb.removeEventListener("test", e, e)
        } catch {
            t = !1
        }
    return t
}
)();
const jk = typeof window < "u"
  , WM = typeof document < "u"
  , GM = typeof navigator < "u"
  , dm = jk && WM && GM
  , ib = jk ? window : {}
  , YM = ( () => {
    let t = !1;
    if (dm)
        try {
            const e = {
                get passive() {
                    t = !0
                }
            };
            ib.addEventListener("test", e, e),
            ib.removeEventListener("test", e, e)
        } catch {
            t = !1
        }
    return t
}
)()
  , Ja = KM ? Element.prototype : void 0
  , JM = (Ja == null ? void 0 : Ja.matches) || (Ja == null ? void 0 : Ja.msMatchesSelector) || (Ja == null ? void 0 : Ja.webkitMatchesSelector)
  , pa = t => !!(t && t.nodeType === Node.ELEMENT_NODE)
  , XM = t => pa(t) ? t.getBoundingClientRect() : null
  , QM = (t=[]) => {
    const {activeElement: e} = document;
    return e && !t.some(n => n === e) ? e : null
}
  , ZM = t => pa(t) && t === QM()
  , eO = (t, e={}) => {
    try {
        t.focus(e)
    } catch (n) {
        console.error(n)
    }
    return ZM(t)
}
  , tO = (t, e) => e && pa(t) && t.getAttribute(e) || null
  , nO = t => {
    if (tO(t, "display") === "none")
        return !1;
    const e = XM(t);
    return !!(e && e.height > 0 && e.width > 0)
}
  , Mn = t => ((t == null ? void 0 : t()) ?? []).length === 0
  , Uk = (t, e) => (pa(e) ? e : um).querySelector(t) || null
  , rO = (t, e) => Array.from([(pa(e) ? e : um).querySelectorAll(t)])
  , cm = (t, e) => e && pa(t) ? t.getAttribute(e) : null
  , aO = t => um.getElementById(/^#/.test(t) ? t.slice(1) : t) || null
  , sO = (t, e, n) => {
    e && pa(t) && t.setAttribute(e, n)
}
  , lO = (t, e) => {
    e && pa(t) && t.removeAttribute(e)
}
  , iO = (t, e) => Yu(t).toLowerCase() === Yu(e).toLowerCase()
  , Hk = (t, e) => pa(t) ? JM.call(t, e) : !1
  , oO = (Ja == null ? void 0 : Ja.closest) || function(t) {
    let e = this;
    if (!e)
        return null;
    do {
        if (Hk(e, t))
            return e;
        e = e.parentElement || e.parentNode
    } while (e !== null && e.nodeType === Node.ELEMENT_NODE);
    return null
}
  , ob = (t, e, n=!1) => {
    if (!pa(e))
        return null;
    const r = oO.call(e, t);
    return n ? r : r === e ? null : r
}
  , _p = t => {
    const e = window.getComputedStyle(t)
      , n = e.transitionDelay.split(",")[0] || ""
      , r = e.transitionDuration.split(",")[0] || ""
      , a = Number(n.slice(0, -1)) * 1e3
      , s = Number(r.slice(0, -1)) * 1e3;
    return a + s
}
  , rc = (t, e, n) => e.concat(["sm", "md", "lg", "xl", "xxl"]).reduce( (r, a) => (r[t ? `${t}${a.charAt(0).toUpperCase() + a.slice(1)}` : a] = n,
r), Object.create(null))
  , Kk = (t, e, n, r=n) => Object.keys(e).reduce( (a, s) => (t[s] && a.push([r, s.replace(n, ""), t[s]].filter(l => l && typeof l != "boolean").join("-").toLowerCase()),
a), [])
  , js = (t="") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${t}__`
  , uO = t => !!(t.href || t.to)
  , wa = (t, e={}, n={}) => {
    const r = [t];
    let a;
    for (let s = 0; s < r.length && !a; s++) {
        const l = r[s];
        a = n[l]
    }
    return a && typeof a == "function" ? a(e) : a
}
  , Us = (t, e=NaN) => Number.isInteger(t) ? t : e
  , dO = (t, e=NaN) => {
    const n = Number.parseInt(t, 10);
    return Number.isNaN(n) ? e : n
}
  , Pu = (t, e=NaN) => {
    const n = Number.parseFloat(t.toString());
    return Number.isNaN(n) ? e : n
}
  , zk = (t, e) => Object.keys(t).filter(n => !e.map(r => r.toString()).includes(n)).reduce( (n, r) => ({
    ...n,
    [r]: t[r]
}), {})
  , fm = (t, e) => [...e].reduce( (n, r) => (n[r] = t[r],
n), {})
  , ub = (t, e, n) => {
    const r = e.split(/[.[\]]/g);
    let a = t;
    for (const s of r) {
        if (a == null)
            return n;
        s.trim() !== "" && (a = a[s])
    }
    return a === void 0 ? n : a
}
  , db = (t, e) => e + (t ? LM(t) : "")
  , ac = (t, e) => t === !0 || t === "true" || t === "" ? "true" : t === "grammar" || t === "spelling" ? t : e === !1 ? "true" : t === !1 || t === "false" ? "false" : void 0
  , qk = Symbol("carousel")
  , Wk = Symbol("tabs")
  , Gk = Symbol("progress")
  , Yk = Symbol("listGroup")
  , Jk = Symbol("avatarGroup")
  , Xk = Symbol("accordion")
  , Qk = Symbol("checkboxGroup")
  , Zk = Symbol("radioGroup")
  , pm = Symbol("collapse")
  , e_ = Symbol("collapse")
  , hm = Symbol("navbar")
  , wp = (t, e) => ((t == null ? void 0 : t()) ?? []).reduce( (n, r) => (typeof r.type == "symbol" ? n = n.concat(r.children) : n.push(r),
n), []).filter(n => {
    var r;
    return ((r = n.type) == null ? void 0 : r.__name) === e
}
)
  , t_ = ["top", "right", "bottom", "left"]
  , cb = ["start", "end"]
  , fb = t_.reduce( (t, e) => t.concat(e, e + "-" + cb[0], e + "-" + cb[1]), [])
  , Ea = Math.min
  , na = Math.max
  , Ju = Math.round
  , hu = Math.floor
  , bs = t => ({
    x: t,
    y: t
})
  , cO = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , fO = {
    start: "end",
    end: "start"
};
function xp(t, e, n) {
    return na(t, Ea(e, n))
}
function Ss(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Ir(t) {
    return t.split("-")[0]
}
function ra(t) {
    return t.split("-")[1]
}
function n_(t) {
    return t === "x" ? "y" : "x"
}
function mm(t) {
    return t === "y" ? "height" : "width"
}
function Go(t) {
    return ["top", "bottom"].includes(Ir(t)) ? "y" : "x"
}
function vm(t) {
    return n_(Go(t))
}
function r_(t, e, n) {
    n === void 0 && (n = !1);
    const r = ra(t)
      , a = vm(t)
      , s = mm(a);
    let l = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return e.reference[s] > e.floating[s] && (l = Qu(l)),
    [l, Qu(l)]
}
function pO(t) {
    const e = Qu(t);
    return [Xu(t), e, Xu(e)]
}
function Xu(t) {
    return t.replace(/start|end/g, e => fO[e])
}
function hO(t, e, n) {
    const r = ["left", "right"]
      , a = ["right", "left"]
      , s = ["top", "bottom"]
      , l = ["bottom", "top"];
    switch (t) {
    case "top":
    case "bottom":
        return n ? e ? a : r : e ? r : a;
    case "left":
    case "right":
        return e ? s : l;
    default:
        return []
    }
}
function mO(t, e, n, r) {
    const a = ra(t);
    let s = hO(Ir(t), n === "start", r);
    return a && (s = s.map(l => l + "-" + a),
    e && (s = s.concat(s.map(Xu)))),
    s
}
function Qu(t) {
    return t.replace(/left|right|bottom|top/g, e => cO[e])
}
function vO(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function gm(t) {
    return typeof t != "number" ? vO(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function li(t) {
    return {
        ...t,
        top: t.y,
        left: t.x,
        right: t.x + t.width,
        bottom: t.y + t.height
    }
}
function pb(t, e, n) {
    let {reference: r, floating: a} = t;
    const s = Go(e)
      , l = vm(e)
      , i = mm(l)
      , o = Ir(e)
      , u = s === "y"
      , d = r.x + r.width / 2 - a.width / 2
      , f = r.y + r.height / 2 - a.height / 2
      , p = r[i] / 2 - a[i] / 2;
    let h;
    switch (o) {
    case "top":
        h = {
            x: d,
            y: r.y - a.height
        };
        break;
    case "bottom":
        h = {
            x: d,
            y: r.y + r.height
        };
        break;
    case "right":
        h = {
            x: r.x + r.width,
            y: f
        };
        break;
    case "left":
        h = {
            x: r.x - a.width,
            y: f
        };
        break;
    default:
        h = {
            x: r.x,
            y: r.y
        }
    }
    switch (ra(e)) {
    case "start":
        h[l] -= p * (n && u ? -1 : 1);
        break;
    case "end":
        h[l] += p * (n && u ? -1 : 1);
        break
    }
    return h
}
const gO = async (t, e, n) => {
    const {placement: r="bottom", strategy: a="absolute", middleware: s=[], platform: l} = n
      , i = s.filter(Boolean)
      , o = await (l.isRTL == null ? void 0 : l.isRTL(e));
    let u = await l.getElementRects({
        reference: t,
        floating: e,
        strategy: a
    })
      , {x: d, y: f} = pb(u, r, o)
      , p = r
      , h = {}
      , v = 0;
    for (let y = 0; y < i.length; y++) {
        const {name: k, fn: w} = i[y]
          , {x: $, y: M, data: S, reset: T} = await w({
            x: d,
            y: f,
            initialPlacement: r,
            placement: p,
            strategy: a,
            middlewareData: h,
            rects: u,
            platform: l,
            elements: {
                reference: t,
                floating: e
            }
        });
        if (d = $ ?? d,
        f = M ?? f,
        h = {
            ...h,
            [k]: {
                ...h[k],
                ...S
            }
        },
        T && v <= 50) {
            v++,
            typeof T == "object" && (T.placement && (p = T.placement),
            T.rects && (u = T.rects === !0 ? await l.getElementRects({
                reference: t,
                floating: e,
                strategy: a
            }) : T.rects),
            {x: d, y: f} = pb(u, p, o)),
            y = -1;
            continue
        }
    }
    return {
        x: d,
        y: f,
        placement: p,
        strategy: a,
        middlewareData: h
    }
}
;
async function To(t, e) {
    var n;
    e === void 0 && (e = {});
    const {x: r, y: a, platform: s, rects: l, elements: i, strategy: o} = t
      , {boundary: u="clippingAncestors", rootBoundary: d="viewport", elementContext: f="floating", altBoundary: p=!1, padding: h=0} = Ss(e, t)
      , v = gm(h)
      , y = i[p ? f === "floating" ? "reference" : "floating" : f]
      , k = li(await s.getClippingRect({
        element: (n = await (s.isElement == null ? void 0 : s.isElement(y))) == null || n ? y : y.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(i.floating)),
        boundary: u,
        rootBoundary: d,
        strategy: o
    }))
      , w = f === "floating" ? {
        ...l.floating,
        x: r,
        y: a
    } : l.reference
      , $ = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i.floating))
      , M = await (s.isElement == null ? void 0 : s.isElement($)) ? await (s.getScale == null ? void 0 : s.getScale($)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , S = li(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: w,
        offsetParent: $,
        strategy: o
    }) : w);
    return {
        top: (k.top - S.top + v.top) / M.y,
        bottom: (S.bottom - k.bottom + v.bottom) / M.y,
        left: (k.left - S.left + v.left) / M.x,
        right: (S.right - k.right + v.right) / M.x
    }
}
const bO = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const {x: n, y: r, placement: a, rects: s, platform: l, elements: i} = e
          , {element: o, padding: u=0} = Ss(t, e) || {};
        if (o == null)
            return {};
        const d = gm(u)
          , f = {
            x: n,
            y: r
        }
          , p = vm(a)
          , h = mm(p)
          , v = await l.getDimensions(o)
          , y = p === "y"
          , k = y ? "top" : "left"
          , w = y ? "bottom" : "right"
          , $ = y ? "clientHeight" : "clientWidth"
          , M = s.reference[h] + s.reference[p] - f[p] - s.floating[h]
          , S = f[p] - s.reference[p]
          , T = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(o));
        let E = T ? T[$] : 0;
        (!E || !await (l.isElement == null ? void 0 : l.isElement(T))) && (E = i.floating[$] || s.floating[h]);
        const O = M / 2 - S / 2
          , U = E / 2 - v[h] / 2 - 1
          , L = Ea(d[k], U)
          , C = Ea(d[w], U)
          , W = L
          , R = E - v[h] - C
          , G = E / 2 - v[h] / 2 + O
          , te = xp(W, G, R)
          , J = ra(a) != null && G != te && s.reference[h] / 2 - (G < W ? L : C) - v[h] / 2 < 0 ? G < W ? W - G : R - G : 0;
        return {
            [p]: f[p] - J,
            data: {
                [p]: te,
                centerOffset: G - te + J
            }
        }
    }
});
function yO(t, e, n) {
    return (t ? [...n.filter(r => ra(r) === t), ...n.filter(r => ra(r) !== t)] : n.filter(r => Ir(r) === r)).filter(r => t ? ra(r) === t || (e ? Xu(r) !== r : !1) : !0)
}
const kO = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "autoPlacement",
        options: t,
        async fn(e) {
            var n, r, a;
            const {rects: s, middlewareData: l, placement: i, platform: o, elements: u} = e
              , {crossAxis: d=!1, alignment: f, allowedPlacements: p=fb, autoAlignment: h=!0, ...v} = Ss(t, e)
              , y = f !== void 0 || p === fb ? yO(f || null, h, p) : p
              , k = await To(e, v)
              , w = ((n = l.autoPlacement) == null ? void 0 : n.index) || 0
              , $ = y[w];
            if ($ == null)
                return {};
            const M = r_($, s, await (o.isRTL == null ? void 0 : o.isRTL(u.floating)));
            if (i !== $)
                return {
                    reset: {
                        placement: y[0]
                    }
                };
            const S = [k[Ir($)], k[M[0]], k[M[1]]]
              , T = [...((r = l.autoPlacement) == null ? void 0 : r.overflows) || [], {
                placement: $,
                overflows: S
            }]
              , E = y[w + 1];
            if (E)
                return {
                    data: {
                        index: w + 1,
                        overflows: T
                    },
                    reset: {
                        placement: E
                    }
                };
            const O = T.map(L => {
                const C = ra(L.placement);
                return [L.placement, C && d ? L.overflows.slice(0, 2).reduce( (W, R) => W + R, 0) : L.overflows[0], L.overflows]
            }
            ).sort( (L, C) => L[1] - C[1])
              , U = ((a = O.filter(L => L[2].slice(0, ra(L[0]) ? 2 : 3).every(C => C <= 0))[0]) == null ? void 0 : a[0]) || O[0][0];
            return U !== i ? {
                data: {
                    index: w + 1,
                    overflows: T
                },
                reset: {
                    placement: U
                }
            } : {}
        }
    }
}
  , a_ = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "flip",
        options: t,
        async fn(e) {
            var n;
            const {placement: r, middlewareData: a, rects: s, initialPlacement: l, platform: i, elements: o} = e
              , {mainAxis: u=!0, crossAxis: d=!0, fallbackPlacements: f, fallbackStrategy: p="bestFit", fallbackAxisSideDirection: h="none", flipAlignment: v=!0, ...y} = Ss(t, e)
              , k = Ir(r)
              , w = Ir(l) === l
              , $ = await (i.isRTL == null ? void 0 : i.isRTL(o.floating))
              , M = f || (w || !v ? [Qu(l)] : pO(l));
            !f && h !== "none" && M.push(...mO(l, v, h, $));
            const S = [l, ...M]
              , T = await To(e, y)
              , E = [];
            let O = ((n = a.flip) == null ? void 0 : n.overflows) || [];
            if (u && E.push(T[k]),
            d) {
                const W = r_(r, s, $);
                E.push(T[W[0]], T[W[1]])
            }
            if (O = [...O, {
                placement: r,
                overflows: E
            }],
            !E.every(W => W <= 0)) {
                var U, L;
                const W = (((U = a.flip) == null ? void 0 : U.index) || 0) + 1
                  , R = S[W];
                if (R)
                    return {
                        data: {
                            index: W,
                            overflows: O
                        },
                        reset: {
                            placement: R
                        }
                    };
                let G = (L = O.filter(te => te.overflows[0] <= 0).sort( (te, J) => te.overflows[1] - J.overflows[1])[0]) == null ? void 0 : L.placement;
                if (!G)
                    switch (p) {
                    case "bestFit":
                        {
                            var C;
                            const te = (C = O.map(J => [J.placement, J.overflows.filter(ae => ae > 0).reduce( (ae, oe) => ae + oe, 0)]).sort( (J, ae) => J[1] - ae[1])[0]) == null ? void 0 : C[0];
                            te && (G = te);
                            break
                        }
                    case "initialPlacement":
                        G = l;
                        break
                    }
                if (r !== G)
                    return {
                        reset: {
                            placement: G
                        }
                    }
            }
            return {}
        }
    }
};
function hb(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function mb(t) {
    return t_.some(e => t[e] >= 0)
}
const _O = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const {rects: n} = e
              , {strategy: r="referenceHidden", ...a} = Ss(t, e);
            switch (r) {
            case "referenceHidden":
                {
                    const s = await To(e, {
                        ...a,
                        elementContext: "reference"
                    })
                      , l = hb(s, n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: l,
                            referenceHidden: mb(l)
                        }
                    }
                }
            case "escaped":
                {
                    const s = await To(e, {
                        ...a,
                        altBoundary: !0
                    })
                      , l = hb(s, n.floating);
                    return {
                        data: {
                            escapedOffsets: l,
                            escaped: mb(l)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
};
function s_(t) {
    const e = Ea(...t.map(s => s.left))
      , n = Ea(...t.map(s => s.top))
      , r = na(...t.map(s => s.right))
      , a = na(...t.map(s => s.bottom));
    return {
        x: e,
        y: n,
        width: r - e,
        height: a - n
    }
}
function wO(t) {
    const e = t.slice().sort( (a, s) => a.y - s.y)
      , n = [];
    let r = null;
    for (let a = 0; a < e.length; a++) {
        const s = e[a];
        !r || s.y - r.y > r.height / 2 ? n.push([s]) : n[n.length - 1].push(s),
        r = s
    }
    return n.map(a => li(s_(a)))
}
const xO = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "inline",
        options: t,
        async fn(e) {
            const {placement: n, elements: r, rects: a, platform: s, strategy: l} = e
              , {padding: i=2, x: o, y: u} = Ss(t, e)
              , d = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(r.reference)) || [])
              , f = wO(d)
              , p = li(s_(d))
              , h = gm(i);
            function v() {
                if (f.length === 2 && f[0].left > f[1].right && o != null && u != null)
                    return f.find(k => o > k.left - h.left && o < k.right + h.right && u > k.top - h.top && u < k.bottom + h.bottom) || p;
                if (f.length >= 2) {
                    if (Go(n) === "y") {
                        const C = f[0]
                          , W = f[f.length - 1]
                          , R = Ir(n) === "top"
                          , G = C.top
                          , te = W.bottom
                          , J = R ? C.left : W.left
                          , ae = R ? C.right : W.right
                          , oe = ae - J
                          , ne = te - G;
                        return {
                            top: G,
                            bottom: te,
                            left: J,
                            right: ae,
                            width: oe,
                            height: ne,
                            x: J,
                            y: G
                        }
                    }
                    const k = Ir(n) === "left"
                      , w = na(...f.map(C => C.right))
                      , $ = Ea(...f.map(C => C.left))
                      , M = f.filter(C => k ? C.left === $ : C.right === w)
                      , S = M[0].top
                      , T = M[M.length - 1].bottom
                      , E = $
                      , O = w
                      , U = O - E
                      , L = T - S;
                    return {
                        top: S,
                        bottom: T,
                        left: E,
                        right: O,
                        width: U,
                        height: L,
                        x: E,
                        y: S
                    }
                }
                return p
            }
            const y = await s.getElementRects({
                reference: {
                    getBoundingClientRect: v
                },
                floating: r.floating,
                strategy: l
            });
            return a.reference.x !== y.reference.x || a.reference.y !== y.reference.y || a.reference.width !== y.reference.width || a.reference.height !== y.reference.height ? {
                reset: {
                    rects: y
                }
            } : {}
        }
    }
};
async function SO(t, e) {
    const {placement: n, platform: r, elements: a} = t
      , s = await (r.isRTL == null ? void 0 : r.isRTL(a.floating))
      , l = Ir(n)
      , i = ra(n)
      , o = Go(n) === "y"
      , u = ["left", "top"].includes(l) ? -1 : 1
      , d = s && o ? -1 : 1
      , f = Ss(e, t);
    let {mainAxis: p, crossAxis: h, alignmentAxis: v} = typeof f == "number" ? {
        mainAxis: f,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...f
    };
    return i && typeof v == "number" && (h = i === "end" ? v * -1 : v),
    o ? {
        x: h * d,
        y: p * u
    } : {
        x: p * u,
        y: h * d
    }
}
const l_ = function(t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            const {x: n, y: r} = e
              , a = await SO(e, t);
            return {
                x: n + a.x,
                y: r + a.y,
                data: a
            }
        }
    }
}
  , i_ = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "shift",
        options: t,
        async fn(e) {
            const {x: n, y: r, placement: a} = e
              , {mainAxis: s=!0, crossAxis: l=!1, limiter: i={
                fn: k => {
                    let {x: w, y: $} = k;
                    return {
                        x: w,
                        y: $
                    }
                }
            }, ...o} = Ss(t, e)
              , u = {
                x: n,
                y: r
            }
              , d = await To(e, o)
              , f = Go(Ir(a))
              , p = n_(f);
            let h = u[p]
              , v = u[f];
            if (s) {
                const k = p === "y" ? "top" : "left"
                  , w = p === "y" ? "bottom" : "right"
                  , $ = h + d[k]
                  , M = h - d[w];
                h = xp($, h, M)
            }
            if (l) {
                const k = f === "y" ? "top" : "left"
                  , w = f === "y" ? "bottom" : "right"
                  , $ = v + d[k]
                  , M = v - d[w];
                v = xp($, v, M)
            }
            const y = i.fn({
                ...e,
                [p]: h,
                [f]: v
            });
            return {
                ...y,
                data: {
                    x: y.x - n,
                    y: y.y - r
                }
            }
        }
    }
};
function ys(t) {
    return o_(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function lr(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function Oa(t) {
    var e;
    return (e = (o_(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function o_(t) {
    return t instanceof Node || t instanceof lr(t).Node
}
function Aa(t) {
    return t instanceof Element || t instanceof lr(t).Element
}
function ia(t) {
    return t instanceof HTMLElement || t instanceof lr(t).HTMLElement
}
function vb(t) {
    return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof lr(t).ShadowRoot
}
function Yo(t) {
    const {overflow: e, overflowX: n, overflowY: r, display: a} = wr(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(a)
}
function $O(t) {
    return ["table", "td", "th"].includes(ys(t))
}
function bm(t) {
    const e = ym()
      , n = wr(t);
    return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}
function TO(t) {
    let e = ii(t);
    for (; ia(e) && !sc(e); ) {
        if (bm(e))
            return e;
        e = ii(e)
    }
    return null
}
function ym() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function sc(t) {
    return ["html", "body", "#document"].includes(ys(t))
}
function wr(t) {
    return lr(t).getComputedStyle(t)
}
function lc(t) {
    return Aa(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.pageXOffset,
        scrollTop: t.pageYOffset
    }
}
function ii(t) {
    if (ys(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || vb(t) && t.host || Oa(t);
    return vb(e) ? e.host : e
}
function u_(t) {
    const e = ii(t);
    return sc(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : ia(e) && Yo(e) ? e : u_(e)
}
function Zu(t, e) {
    var n;
    e === void 0 && (e = []);
    const r = u_(t)
      , a = r === ((n = t.ownerDocument) == null ? void 0 : n.body)
      , s = lr(r);
    return a ? e.concat(s, s.visualViewport || [], Yo(r) ? r : []) : e.concat(r, Zu(r))
}
function d_(t) {
    const e = wr(t);
    let n = parseFloat(e.width) || 0
      , r = parseFloat(e.height) || 0;
    const a = ia(t)
      , s = a ? t.offsetWidth : n
      , l = a ? t.offsetHeight : r
      , i = Ju(n) !== s || Ju(r) !== l;
    return i && (n = s,
    r = l),
    {
        width: n,
        height: r,
        $: i
    }
}
function km(t) {
    return Aa(t) ? t : t.contextElement
}
function Yl(t) {
    const e = km(t);
    if (!ia(e))
        return bs(1);
    const n = e.getBoundingClientRect()
      , {width: r, height: a, $: s} = d_(e);
    let l = (s ? Ju(n.width) : n.width) / r
      , i = (s ? Ju(n.height) : n.height) / a;
    return (!l || !Number.isFinite(l)) && (l = 1),
    (!i || !Number.isFinite(i)) && (i = 1),
    {
        x: l,
        y: i
    }
}
const CO = bs(0);
function c_(t) {
    const e = lr(t);
    return !ym() || !e.visualViewport ? CO : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function EO(t, e, n) {
    return e === void 0 && (e = !1),
    !n || e && n !== lr(t) ? !1 : e
}
function sl(t, e, n, r) {
    e === void 0 && (e = !1),
    n === void 0 && (n = !1);
    const a = t.getBoundingClientRect()
      , s = km(t);
    let l = bs(1);
    e && (r ? Aa(r) && (l = Yl(r)) : l = Yl(t));
    const i = EO(s, n, r) ? c_(s) : bs(0);
    let o = (a.left + i.x) / l.x
      , u = (a.top + i.y) / l.y
      , d = a.width / l.x
      , f = a.height / l.y;
    if (s) {
        const p = lr(s)
          , h = r && Aa(r) ? lr(r) : r;
        let v = p.frameElement;
        for (; v && r && h !== p; ) {
            const y = Yl(v)
              , k = v.getBoundingClientRect()
              , w = wr(v)
              , $ = k.left + (v.clientLeft + parseFloat(w.paddingLeft)) * y.x
              , M = k.top + (v.clientTop + parseFloat(w.paddingTop)) * y.y;
            o *= y.x,
            u *= y.y,
            d *= y.x,
            f *= y.y,
            o += $,
            u += M,
            v = lr(v).frameElement
        }
    }
    return li({
        width: d,
        height: f,
        x: o,
        y: u
    })
}
function AO(t) {
    let {rect: e, offsetParent: n, strategy: r} = t;
    const a = ia(n)
      , s = Oa(n);
    if (n === s)
        return e;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , i = bs(1);
    const o = bs(0);
    if ((a || !a && r !== "fixed") && ((ys(n) !== "body" || Yo(s)) && (l = lc(n)),
    ia(n))) {
        const u = sl(n);
        i = Yl(n),
        o.x = u.x + n.clientLeft,
        o.y = u.y + n.clientTop
    }
    return {
        width: e.width * i.x,
        height: e.height * i.y,
        x: e.x * i.x - l.scrollLeft * i.x + o.x,
        y: e.y * i.y - l.scrollTop * i.y + o.y
    }
}
function MO(t) {
    return Array.from(t.getClientRects())
}
function f_(t) {
    return sl(Oa(t)).left + lc(t).scrollLeft
}
function OO(t) {
    const e = Oa(t)
      , n = lc(t)
      , r = t.ownerDocument.body
      , a = na(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth)
      , s = na(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
    let l = -n.scrollLeft + f_(t);
    const i = -n.scrollTop;
    return wr(r).direction === "rtl" && (l += na(e.clientWidth, r.clientWidth) - a),
    {
        width: a,
        height: s,
        x: l,
        y: i
    }
}
function NO(t, e) {
    const n = lr(t)
      , r = Oa(t)
      , a = n.visualViewport;
    let s = r.clientWidth
      , l = r.clientHeight
      , i = 0
      , o = 0;
    if (a) {
        s = a.width,
        l = a.height;
        const u = ym();
        (!u || u && e === "fixed") && (i = a.offsetLeft,
        o = a.offsetTop)
    }
    return {
        width: s,
        height: l,
        x: i,
        y: o
    }
}
function DO(t, e) {
    const n = sl(t, !0, e === "fixed")
      , r = n.top + t.clientTop
      , a = n.left + t.clientLeft
      , s = ia(t) ? Yl(t) : bs(1)
      , l = t.clientWidth * s.x
      , i = t.clientHeight * s.y
      , o = a * s.x
      , u = r * s.y;
    return {
        width: l,
        height: i,
        x: o,
        y: u
    }
}
function gb(t, e, n) {
    let r;
    if (e === "viewport")
        r = NO(t, n);
    else if (e === "document")
        r = OO(Oa(t));
    else if (Aa(e))
        r = DO(e, n);
    else {
        const a = c_(t);
        r = {
            ...e,
            x: e.x - a.x,
            y: e.y - a.y
        }
    }
    return li(r)
}
function p_(t, e) {
    const n = ii(t);
    return n === e || !Aa(n) || sc(n) ? !1 : wr(n).position === "fixed" || p_(n, e)
}
function PO(t, e) {
    const n = e.get(t);
    if (n)
        return n;
    let r = Zu(t).filter(i => Aa(i) && ys(i) !== "body")
      , a = null;
    const s = wr(t).position === "fixed";
    let l = s ? ii(t) : t;
    for (; Aa(l) && !sc(l); ) {
        const i = wr(l)
          , o = bm(l);
        !o && i.position === "fixed" && (a = null),
        (s ? !o && !a : !o && i.position === "static" && a && ["absolute", "fixed"].includes(a.position) || Yo(l) && !o && p_(t, l)) ? r = r.filter(u => u !== l) : a = i,
        l = ii(l)
    }
    return e.set(t, r),
    r
}
function FO(t) {
    let {element: e, boundary: n, rootBoundary: r, strategy: a} = t;
    const s = [...n === "clippingAncestors" ? PO(e, this._c) : [].concat(n), r]
      , l = s[0]
      , i = s.reduce( (o, u) => {
        const d = gb(e, u, a);
        return o.top = na(d.top, o.top),
        o.right = Ea(d.right, o.right),
        o.bottom = Ea(d.bottom, o.bottom),
        o.left = na(d.left, o.left),
        o
    }
    , gb(e, l, a));
    return {
        width: i.right - i.left,
        height: i.bottom - i.top,
        x: i.left,
        y: i.top
    }
}
function BO(t) {
    return d_(t)
}
function VO(t, e, n) {
    const r = ia(e)
      , a = Oa(e)
      , s = n === "fixed"
      , l = sl(t, !0, s, e);
    let i = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const o = bs(0);
    if (r || !r && !s)
        if ((ys(e) !== "body" || Yo(a)) && (i = lc(e)),
        r) {
            const u = sl(e, !0, s, e);
            o.x = u.x + e.clientLeft,
            o.y = u.y + e.clientTop
        } else
            a && (o.x = f_(a));
    return {
        x: l.left + i.scrollLeft - o.x,
        y: l.top + i.scrollTop - o.y,
        width: l.width,
        height: l.height
    }
}
function bb(t, e) {
    return !ia(t) || wr(t).position === "fixed" ? null : e ? e(t) : t.offsetParent
}
function h_(t, e) {
    const n = lr(t);
    if (!ia(t))
        return n;
    let r = bb(t, e);
    for (; r && $O(r) && wr(r).position === "static"; )
        r = bb(r, e);
    return r && (ys(r) === "html" || ys(r) === "body" && wr(r).position === "static" && !bm(r)) ? n : r || TO(t) || n
}
const IO = async function(t) {
    let {reference: e, floating: n, strategy: r} = t;
    const a = this.getOffsetParent || h_
      , s = this.getDimensions;
    return {
        reference: VO(e, await a(n), r),
        floating: {
            x: 0,
            y: 0,
            ...await s(n)
        }
    }
};
function RO(t) {
    return wr(t).direction === "rtl"
}
const LO = {
    convertOffsetParentRelativeRectToViewportRelativeRect: AO,
    getDocumentElement: Oa,
    getClippingRect: FO,
    getOffsetParent: h_,
    getElementRects: IO,
    getClientRects: MO,
    getDimensions: BO,
    getScale: Yl,
    isElement: Aa,
    isRTL: RO
};
function jO(t, e) {
    let n = null, r;
    const a = Oa(t);
    function s() {
        clearTimeout(r),
        n && n.disconnect(),
        n = null
    }
    function l(i, o) {
        i === void 0 && (i = !1),
        o === void 0 && (o = 1),
        s();
        const {left: u, top: d, width: f, height: p} = t.getBoundingClientRect();
        if (i || e(),
        !f || !p)
            return;
        const h = hu(d)
          , v = hu(a.clientWidth - (u + f))
          , y = hu(a.clientHeight - (d + p))
          , k = hu(u)
          , w = {
            rootMargin: -h + "px " + -v + "px " + -y + "px " + -k + "px",
            threshold: na(0, Ea(1, o)) || 1
        };
        let $ = !0;
        function M(S) {
            const T = S[0].intersectionRatio;
            if (T !== o) {
                if (!$)
                    return l();
                T ? l(!1, T) : r = setTimeout( () => {
                    l(!1, 1e-7)
                }
                , 100)
            }
            $ = !1
        }
        try {
            n = new IntersectionObserver(M,{
                ...w,
                root: a.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(M,w)
        }
        n.observe(t)
    }
    return l(!0),
    s
}
function m_(t, e, n, r) {
    r === void 0 && (r = {});
    const {ancestorScroll: a=!0, ancestorResize: s=!0, elementResize: l=typeof ResizeObserver == "function", layoutShift: i=typeof IntersectionObserver == "function", animationFrame: o=!1} = r
      , u = km(t)
      , d = a || s ? [...u ? Zu(u) : [], ...Zu(e)] : [];
    d.forEach(w => {
        a && w.addEventListener("scroll", n, {
            passive: !0
        }),
        s && w.addEventListener("resize", n)
    }
    );
    const f = u && i ? jO(u, n) : null;
    let p = -1
      , h = null;
    l && (h = new ResizeObserver(w => {
        let[$] = w;
        $ && $.target === u && h && (h.unobserve(e),
        cancelAnimationFrame(p),
        p = requestAnimationFrame( () => {
            h && h.observe(e)
        }
        )),
        n()
    }
    ),
    u && !o && h.observe(u),
    h.observe(e));
    let v, y = o ? sl(t) : null;
    o && k();
    function k() {
        const w = sl(t);
        y && (w.x !== y.x || w.y !== y.y || w.width !== y.width || w.height !== y.height) && n(),
        y = w,
        v = requestAnimationFrame(k)
    }
    return n(),
    () => {
        d.forEach(w => {
            a && w.removeEventListener("scroll", n),
            s && w.removeEventListener("resize", n)
        }
        ),
        f && f(),
        h && h.disconnect(),
        h = null,
        o && cancelAnimationFrame(v)
    }
}
const UO = (t, e, n) => {
    const r = new Map
      , a = {
        platform: LO,
        ...n
    }
      , s = {
        ...a.platform,
        _c: r
    };
    return gO(t, e, {
        ...a,
        platform: s
    })
}
;
function Sp(t) {
    var e;
    return (e = t == null ? void 0 : t.$el) != null ? e : t
}
function HO(t) {
    return {
        name: "arrow",
        options: t,
        fn(e) {
            const n = Sp(A(t.element));
            return n == null ? {} : bO({
                element: n,
                padding: t.padding
            }).fn(e)
        }
    }
}
function v_(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function yb(t, e) {
    const n = v_(t);
    return Math.round(e * n) / n
}
function g_(t, e, n) {
    n === void 0 && (n = {});
    const r = n.whileElementsMounted
      , a = K( () => {
        var O;
        return (O = A(n.open)) != null ? O : !0
    }
    )
      , s = K( () => A(n.middleware))
      , l = K( () => {
        var O;
        return (O = A(n.placement)) != null ? O : "bottom"
    }
    )
      , i = K( () => {
        var O;
        return (O = A(n.strategy)) != null ? O : "absolute"
    }
    )
      , o = K( () => {
        var O;
        return (O = A(n.transform)) != null ? O : !0
    }
    )
      , u = K( () => Sp(t.value))
      , d = K( () => Sp(e.value))
      , f = me(0)
      , p = me(0)
      , h = me(i.value)
      , v = me(l.value)
      , y = jh({})
      , k = me(!1)
      , w = K( () => {
        const O = {
            position: h.value,
            left: "0",
            top: "0"
        };
        if (!d.value)
            return O;
        const U = yb(d.value, f.value)
          , L = yb(d.value, p.value);
        return o.value ? {
            ...O,
            transform: "translate(" + U + "px, " + L + "px)",
            ...v_(d.value) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: h.value,
            left: U + "px",
            top: L + "px"
        }
    }
    );
    let $;
    function M() {
        u.value == null || d.value == null || UO(u.value, d.value, {
            middleware: s.value,
            placement: l.value,
            strategy: i.value
        }).then(O => {
            f.value = O.x,
            p.value = O.y,
            h.value = O.strategy,
            v.value = O.placement,
            y.value = O.middlewareData,
            k.value = !0
        }
        )
    }
    function S() {
        typeof $ == "function" && ($(),
        $ = void 0)
    }
    function T() {
        if (S(),
        r === void 0) {
            M();
            return
        }
        if (u.value != null && d.value != null) {
            $ = r(u.value, d.value, M);
            return
        }
    }
    function E() {
        a.value || (k.value = !1)
    }
    return Ke([s, l, i], M, {
        flush: "sync"
    }),
    Ke([u, d], T, {
        flush: "sync"
    }),
    Ke(a, E, {
        flush: "sync"
    }),
    Ho() && Bd(S),
    {
        x: Tl(f),
        y: Tl(p),
        strategy: Tl(h),
        placement: Tl(v),
        middlewareData: Tl(y),
        isPositioned: Tl(k),
        floatingStyles: w,
        update: M
    }
}
const KO = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
  , zO = /^aria-[\w-]*$/i
  , qO = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i
  , WO = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i
  , GO = (t, e) => {
    const n = t.nodeName.toLowerCase();
    return e.includes(n) ? KO.has(n) ? !!(qO.test(t.nodeValue || "") || WO.test(t.nodeValue || "")) : !0 : e.filter(r => r instanceof RegExp).some(r => r.test(n))
}
  , Ll = {
    "*": ["class", "dir", "id", "lang", "role", zO],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
}
  , jl = (t, e, n) => {
    if (!t.length)
        return t;
    if (n && typeof n == "function")
        return n(t);
    const r = new window.DOMParser().parseFromString(t, "text/html")
      , a = r.body.querySelectorAll("*");
    for (const s of a) {
        const l = s.nodeName.toLowerCase();
        if (!Object.keys(e).includes(l)) {
            s.remove();
            continue
        }
        const i = s.attributes
          , o = [...e["*"] || [], ...e[l] || []];
        for (const u of i)
            GO(u, o) || s.removeAttribute(u.nodeName)
    }
    return r.body.innerHTML
}
;
function b_(t, e) {
    var n;
    const r = jh();
    return Si( () => {
        r.value = t()
    }
    , {
        ...e,
        flush: (n = e == null ? void 0 : e.flush) != null ? n : "sync"
    }),
    Hn(r)
}
function oi(t) {
    return Ho() ? (Bd(t),
    !0) : !1
}
function y_(t) {
    let e = !1, n;
    const r = Fd(!0);
    return (...a) => (e || (n = r.run( () => t(...a)),
    e = !0),
    n)
}
function YO(t) {
    let e = 0, n, r;
    const a = () => {
        e -= 1,
        r && e <= 0 && (r.stop(),
        n = void 0,
        r = void 0)
    }
    ;
    return (...s) => (e += 1,
    n || (r = Fd(!0),
    n = r.run( () => t(...s))),
    oi(a),
    n)
}
function aa(t) {
    return typeof t == "function" ? t() : A(t)
}
const ed = typeof window < "u" && typeof document < "u"
  , JO = t => typeof t < "u"
  , XO = Object.prototype.toString
  , QO = t => XO.call(t) === "[object Object]"
  , ks = () => {}
  , $p = ZO();
function ZO() {
    var t;
    return ed && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent)
}
function eN(t, e) {
    function n(...r) {
        return new Promise( (a, s) => {
            Promise.resolve(t( () => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(a).catch(s)
        }
        )
    }
    return n
}
function tN(t, e={}) {
    let n, r, a = ks;
    const s = l => {
        clearTimeout(l),
        a(),
        a = ks
    }
    ;
    return l => {
        const i = aa(t)
          , o = aa(e.maxWait);
        return n && s(n),
        i <= 0 || o !== void 0 && o <= 0 ? (r && (s(r),
        r = null),
        Promise.resolve(l())) : new Promise( (u, d) => {
            a = e.rejectOnCancel ? d : u,
            o && !r && (r = setTimeout( () => {
                n && s(n),
                r = null,
                u(l())
            }
            , o)),
            n = setTimeout( () => {
                r && s(r),
                r = null,
                u(l())
            }
            , i)
        }
        )
    }
}
function nN(...t) {
    if (t.length !== 1)
        return _e(...t);
    const e = t[0];
    return typeof e == "function" ? Hn(l1( () => ({
        get: e,
        set: ks
    }))) : me(e)
}
function rN(t, e=200, n={}) {
    return eN(tN(e, n), t)
}
function k_(t, e=1e3, n={}) {
    const {immediate: r=!0, immediateCallback: a=!1} = n;
    let s = null;
    const l = me(!1);
    function i() {
        s && (clearInterval(s),
        s = null)
    }
    function o() {
        l.value = !1,
        i()
    }
    function u() {
        const d = aa(e);
        d <= 0 || (l.value = !0,
        a && t(),
        i(),
        s = setInterval(t, d))
    }
    if (r && ed && u(),
    Kt(e) || typeof e == "function") {
        const d = Ke(e, () => {
            l.value && ed && u()
        }
        );
        oi(d)
    }
    return oi(o),
    {
        isActive: l,
        pause: o,
        resume: u
    }
}
function zt(t, e={}) {
    const {method: n="parseFloat", radix: r, nanToZero: a} = e;
    return K( () => {
        let s = aa(t);
        return typeof s == "string" && (s = Number[n](s, r)),
        a && Number.isNaN(s) && (s = 0),
        s
    }
    )
}
function es(t) {
    var e;
    const n = aa(t);
    return (e = n == null ? void 0 : n.$el) != null ? e : n
}
const vl = ed ? window : void 0;
function on(...t) {
    let e, n, r, a;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n,r,a] = t,
    e = vl) : [e,n,r,a] = t,
    !e)
        return ks;
    Array.isArray(n) || (n = [n]),
    Array.isArray(r) || (r = [r]);
    const s = []
      , l = () => {
        s.forEach(d => d()),
        s.length = 0
    }
      , i = (d, f, p, h) => (d.addEventListener(f, p, h),
    () => d.removeEventListener(f, p, h))
      , o = Ke( () => [es(e), aa(a)], ([d,f]) => {
        if (l(),
        !d)
            return;
        const p = QO(f) ? {
            ...f
        } : f;
        s.push(...n.flatMap(h => r.map(v => i(d, h, v, p))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        o(),
        l()
    }
    ;
    return oi(u),
    u
}
let kb = !1;
function __(t, e, n={}) {
    const {window: r=vl, ignore: a=[], capture: s=!0, detectIframe: l=!1} = n;
    if (!r)
        return;
    $p && !kb && (kb = !0,
    Array.from(r.document.body.children).forEach(d => d.addEventListener("click", ks)),
    r.document.documentElement.addEventListener("click", ks));
    let i = !0;
    const o = d => a.some(f => {
        if (typeof f == "string")
            return Array.from(r.document.querySelectorAll(f)).some(p => p === d.target || d.composedPath().includes(p));
        {
            const p = es(f);
            return p && (d.target === p || d.composedPath().includes(p))
        }
    }
    )
      , u = [on(r, "click", d => {
        const f = es(t);
        if (!(!f || f === d.target || d.composedPath().includes(f))) {
            if (d.detail === 0 && (i = !o(d)),
            !i) {
                i = !0;
                return
            }
            e(d)
        }
    }
    , {
        passive: !0,
        capture: s
    }), on(r, "pointerdown", d => {
        const f = es(t);
        f && (i = !d.composedPath().includes(f) && !o(d))
    }
    , {
        passive: !0
    }), l && on(r, "blur", d => {
        setTimeout( () => {
            var f;
            const p = es(t);
            ((f = r.document.activeElement) == null ? void 0 : f.tagName) === "IFRAME" && !(p != null && p.contains(r.document.activeElement)) && e(d)
        }
        , 0)
    }
    )].filter(Boolean);
    return () => u.forEach(d => d())
}
function aN(t) {
    return typeof t == "function" ? t : typeof t == "string" ? e => e.key === t : Array.isArray(t) ? e => t.includes(e.key) : () => !0
}
function Cr(...t) {
    let e, n, r = {};
    t.length === 3 ? (e = t[0],
    n = t[1],
    r = t[2]) : t.length === 2 ? typeof t[1] == "object" ? (e = !0,
    n = t[0],
    r = t[1]) : (e = t[0],
    n = t[1]) : (e = !0,
    n = t[0]);
    const {target: a=vl, eventName: s="keydown", passive: l=!1, dedupe: i=!1} = r
      , o = aN(e);
    return on(a, s, u => {
        u.repeat && aa(i) || o(u) && n(u)
    }
    , l)
}
function sN(t) {
    return JSON.parse(JSON.stringify(t))
}
const mu = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , vu = "__vueuse_ssr_handlers__"
  , lN = iN();
function iN() {
    return vu in mu || (mu[vu] = mu[vu] || {}),
    mu[vu]
}
function oN(t, e) {
    return lN[t] || e
}
function _m(t, e={}) {
    const {delayEnter: n=0, delayLeave: r=0, window: a=vl} = e
      , s = me(!1);
    let l;
    const i = o => {
        const u = o ? n : r;
        l && (clearTimeout(l),
        l = void 0),
        u ? l = setTimeout( () => s.value = o, u) : s.value = o
    }
    ;
    return a && (on(t, "mouseenter", () => i(!0), {
        passive: !0
    }),
    on(t, "mouseleave", () => i(!1), {
        passive: !0
    })),
    s
}
function ar(t, e={}) {
    const {initialValue: n=!1, focusVisible: r=!1} = e
      , a = me(!1)
      , s = K( () => es(t));
    on(s, "focus", i => {
        var o, u;
        (!r || (u = (o = i.target).matches) != null && u.call(o, ":focus-visible")) && (a.value = !0)
    }
    ),
    on(s, "blur", () => a.value = !1);
    const l = K({
        get: () => a.value,
        set(i) {
            var o, u;
            !i && a.value ? (o = s.value) == null || o.blur() : i && !a.value && ((u = s.value) == null || u.focus())
        }
    });
    return Ke(s, () => {
        l.value = n
    }
    , {
        immediate: !0,
        flush: "post"
    }),
    {
        focused: l
    }
}
function hf(t) {
    return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t
}
const uN = {
    page: t => [t.pageX, t.pageY],
    client: t => [t.clientX, t.clientY],
    screen: t => [t.screenX, t.screenY],
    movement: t => t instanceof Touch ? null : [t.movementX, t.movementY]
};
function dN(t={}) {
    const {type: e="page", touch: n=!0, resetOnTouchEnds: r=!1, initialValue: a={
        x: 0,
        y: 0
    }, window: s=vl, target: l=s, scroll: i=!0, eventFilter: o} = t;
    let u = null;
    const d = me(a.x)
      , f = me(a.y)
      , p = me(null)
      , h = typeof e == "function" ? e : uN[e]
      , v = T => {
        const E = h(T);
        u = T,
        E && ([d.value,f.value] = E,
        p.value = "mouse")
    }
      , y = T => {
        if (T.touches.length > 0) {
            const E = h(T.touches[0]);
            E && ([d.value,f.value] = E,
            p.value = "touch")
        }
    }
      , k = () => {
        if (!u || !s)
            return;
        const T = h(u);
        u instanceof MouseEvent && T && (d.value = T[0] + s.scrollX,
        f.value = T[1] + s.scrollY)
    }
      , w = () => {
        d.value = a.x,
        f.value = a.y
    }
      , $ = o ? T => o( () => v(T), {}) : T => v(T)
      , M = o ? T => o( () => y(T), {}) : T => y(T)
      , S = o ? () => o( () => k(), {}) : () => k();
    if (l) {
        const T = {
            passive: !0
        };
        on(l, ["mousemove", "dragover"], $, T),
        n && e !== "movement" && (on(l, ["touchstart", "touchmove"], M, T),
        r && on(l, "touchend", w, T)),
        i && e === "page" && on(s, "scroll", S, {
            passive: !0
        })
    }
    return {
        x: d,
        y: f,
        sourceType: p
    }
}
function _b(t, e={}) {
    const {handleOutside: n=!0, window: r=vl} = e
      , {x: a, y: s, sourceType: l} = dN(e)
      , i = me(t ?? (r == null ? void 0 : r.document.body))
      , o = me(0)
      , u = me(0)
      , d = me(0)
      , f = me(0)
      , p = me(0)
      , h = me(0)
      , v = me(!0);
    let y = () => {}
    ;
    return r && (y = Ke([i, a, s], () => {
        const k = es(i);
        if (!k)
            return;
        const {left: w, top: $, width: M, height: S} = k.getBoundingClientRect();
        d.value = w + r.pageXOffset,
        f.value = $ + r.pageYOffset,
        p.value = S,
        h.value = M;
        const T = a.value - d.value
          , E = s.value - f.value;
        v.value = M === 0 || S === 0 || T < 0 || E < 0 || T > M || E > S,
        (n || !v.value) && (o.value = T,
        u.value = E)
    }
    , {
        immediate: !0
    }),
    on(document, "mouseleave", () => {
        v.value = !0
    }
    )),
    {
        x: a,
        y: s,
        sourceType: l,
        elementX: o,
        elementY: u,
        elementPositionX: d,
        elementPositionY: f,
        elementHeight: p,
        elementWidth: h,
        isOutside: v,
        stop: y
    }
}
function w_(t) {
    const e = window.getComputedStyle(t);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight)
        return !0;
    {
        const n = t.parentNode;
        return !n || n.tagName === "BODY" ? !1 : w_(n)
    }
}
function cN(t) {
    const e = t || window.event
      , n = e.target;
    return w_(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(),
    !1)
}
function fN(t, e=!1) {
    const n = me(e);
    let r = null, a;
    Ke(nN(t), i => {
        const o = hf(aa(i));
        if (o) {
            const u = o;
            a = u.style.overflow,
            n.value && (u.style.overflow = "hidden")
        }
    }
    , {
        immediate: !0
    });
    const s = () => {
        const i = hf(aa(t));
        !i || n.value || ($p && (r = on(i, "touchmove", o => {
            cN(o)
        }
        , {
            passive: !1
        })),
        i.style.overflow = "hidden",
        n.value = !0)
    }
      , l = () => {
        const i = hf(aa(t));
        !i || !n.value || ($p && (r == null || r()),
        i.style.overflow = a,
        n.value = !1)
    }
    ;
    return oi(l),
    K({
        get() {
            return n.value
        },
        set(i) {
            i ? s() : l()
        }
    })
}
function pN(t, e={}) {
    const {threshold: n=50, onSwipe: r, onSwipeEnd: a, onSwipeStart: s, passive: l=!0, window: i=vl} = e
      , o = Fn({
        x: 0,
        y: 0
    })
      , u = Fn({
        x: 0,
        y: 0
    })
      , d = K( () => o.x - u.x)
      , f = K( () => o.y - u.y)
      , {max: p, abs: h} = Math
      , v = K( () => p(h(d.value), h(f.value)) >= n)
      , y = me(!1)
      , k = K( () => v.value ? h(d.value) > h(f.value) ? d.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none")
      , w = U => [U.touches[0].clientX, U.touches[0].clientY]
      , $ = (U, L) => {
        o.x = U,
        o.y = L
    }
      , M = (U, L) => {
        u.x = U,
        u.y = L
    }
    ;
    let S;
    const T = hN(i == null ? void 0 : i.document);
    l ? S = T ? {
        passive: !0
    } : {
        capture: !1
    } : S = T ? {
        passive: !1,
        capture: !0
    } : {
        capture: !0
    };
    const E = U => {
        y.value && (a == null || a(U, k.value)),
        y.value = !1
    }
      , O = [on(t, "touchstart", U => {
        if (U.touches.length !== 1)
            return;
        S.capture && !S.passive && U.preventDefault();
        const [L,C] = w(U);
        $(L, C),
        M(L, C),
        s == null || s(U)
    }
    , S), on(t, "touchmove", U => {
        if (U.touches.length !== 1)
            return;
        const [L,C] = w(U);
        M(L, C),
        !y.value && v.value && (y.value = !0),
        y.value && (r == null || r(U))
    }
    , S), on(t, ["touchend", "touchcancel"], E, S)];
    return {
        isPassiveEventSupported: T,
        isSwiping: y,
        direction: k,
        coordsStart: o,
        coordsEnd: u,
        lengthX: d,
        lengthY: f,
        stop: () => O.forEach(U => U())
    }
}
function hN(t) {
    if (!t)
        return !1;
    let e = !1;
    const n = {
        get passive() {
            return e = !0,
            !1
        }
    };
    return t.addEventListener("x", ks, n),
    t.removeEventListener("x", ks),
    e
}
function qt(t, e, n, r={}) {
    var a, s, l;
    const {clone: i=!1, passive: o=!1, eventName: u, deep: d=!1, defaultValue: f, shouldEmit: p} = r
      , h = pl()
      , v = n || (h == null ? void 0 : h.emit) || ((a = h == null ? void 0 : h.$emit) == null ? void 0 : a.bind(h)) || ((l = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : l.bind(h == null ? void 0 : h.proxy));
    let y = u;
    e || (e = "modelValue"),
    y = y || `update:${e.toString()}`;
    const k = M => i ? typeof i == "function" ? i(M) : sN(M) : M
      , w = () => JO(t[e]) ? k(t[e]) : f
      , $ = M => {
        p ? p(M) && v(y, M) : v(y, M)
    }
    ;
    if (o) {
        const M = w()
          , S = me(M);
        let T = !1;
        return Ke( () => t[e], E => {
            T || (T = !0,
            S.value = k(E),
            Ot( () => T = !1))
        }
        ),
        Ke(S, E => {
            !T && (E !== t[e] || d) && $(E)
        }
        , {
            deep: d
        }),
        S
    } else
        return K({
            get() {
                return w()
            },
            set(M) {
                $(M)
            }
        })
}
const ic = Se({
    name: "ComponentOrEmpty",
    slots: Object,
    props: {
        tag: {
            type: String,
            default: "div"
        },
        to: {
            type: [String, Object],
            default: null
        },
        skip: {
            type: Boolean,
            default: !1
        }
    },
    setup(t, {slots: e, attrs: n}) {
        return () => {
            var r, a, s;
            return t.skip ? (r = e.default) == null ? void 0 : r.call(e) : t.tag === "Teleport" ? st(Ti, {
                to: t.to
            }, [(a = e.default) == null ? void 0 : a.call(e)]) : st(t.tag, {
                ...n
            }, [(s = e.default) == null ? void 0 : s.call(e)])
        }
    }
})
  , Jo = t => b_( () => {
    const e = ca(t);
    return e ? `justify-content-${e}` : ""
}
)
  , gl = (t, e) => {
    const n = _e(e)
      , r = _e(t)
      , a = K( () => uO(r.value))
      , s = K( () => a.value ? fm(r.value, n.value ?? ["active", "activeClass", "append", "href", "rel", "replace", "routerComponentName", "target", "to", "variant", "opacity", "opacityHover", "underlineVariant", "underlineOffset", "underlineOffsetHover", "underlineOpacity", "underlineOpacityHover"]) : {});
    return {
        computedLink: a,
        computedLinkProps: s
    }
}
  , Nr = t => K( () => {
    const e = ca(t);
    return {
        [`text-bg-${e.variant}`]: e.variant !== null,
        [`text-${e.textVariant}`]: e.textVariant !== null && e.variant === null,
        [`bg-${e.bgVariant}`]: e.bgVariant !== null && e.variant === null
    }
}
);
function H(t) {
    return b_( () => {
        const e = ca(t);
        return e == null ? e : nc(e)
    }
    )
}
const mN = y_( () => {
    const t = Fn([]);
    return {
        items: t,
        reset: () => {
            t.splice(0, t.length)
        }
    }
}
)
  , x_ = (t, e=me(1e3), n={}) => {
    const r = Hn(_e(t))
      , a = Hn(_e(e))
      , s = me(!1)
      , l = me(0)
      , i = _e( () => Math.ceil(r.value / a.value))
      , o = _e( () => f.value || s.value ? Math.round(r.value - l.value * a.value) : 0)
      , {pause: u, resume: d, isActive: f} = k_( () => {
        l.value = l.value + 1
    }
    , e, n)
      , p = () => {
        s.value = !1,
        l.value = 0,
        d()
    }
      , h = () => {
        s.value = !1,
        l.value = i.value
    }
    ;
    Si( () => {
        l.value > i.value && (l.value = i.value),
        l.value === i.value && u()
    }
    ),
    Ke([a, r], () => {
        h(),
        p()
    }
    );
    const v = () => {
        f.value !== !1 && (s.value = !0,
        u())
    }
      , y = () => {
        l.value !== i.value && (s.value = !1,
        d())
    }
    ;
    return {
        isActive: Hn(f),
        isPaused: Hn(s),
        restart: p,
        stop: h,
        pause: v,
        resume: y,
        value: o
    }
}
  , bl = t => K( () => {
    const e = ca(t);
    return e === !0 ? "is-valid" : e === !1 ? "is-invalid" : null
}
)
  , S_ = t => K( () => {
    const e = ca(t);
    return {
        "form-check": e.plain === !1 && e.button === !1,
        "form-check-inline": e.inline === !0,
        "form-switch": e.switch === !0,
        [`form-control-${e.size}`]: e.size !== void 0 && e.size !== "md" && e.button === !1
    }
}
)
  , $_ = t => {
    const e = _e(t)
      , n = bl(_e( () => e.value.state ?? null));
    return K( () => [n.value, {
        "form-check-input": e.value.plain === !1 && e.value.button === !1,
        "btn-check": e.value.button === !0
    }])
}
  , T_ = t => K( () => {
    const e = ca(t);
    return {
        "form-check-label": e.plain === !1 && e.button === !1,
        btn: e.button === !0,
        [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0 && e.buttonVariant !== null,
        [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
    }
}
)
  , C_ = t => K( () => {
    const e = ca(t);
    return {
        "aria-invalid": ac(e.ariaInvalid, e.state),
        "aria-required": e.required === !0 ? !0 : void 0
    }
}
)
  , E_ = t => K( () => {
    const e = ca(t);
    return {
        "was-validated": e.validated === !0,
        "btn-group": e.buttons === !0 && e.stacked === !1,
        "btn-group-vertical": e.stacked === !0 && e.buttons === !0,
        [`btn-group-${e.size}`]: e.size !== void 0
    }
}
)
  , A_ = (t, e) => {
    const n = me(null);
    let r = null
      , a = !0;
    const s = qt(t, "modelValue", e)
      , l = an( () => t.id, "input")
      , i = H( () => t.autofocus)
      , o = H( () => t.disabled)
      , u = H( () => t.lazy)
      , d = H( () => t.lazyFormatter)
      , f = H( () => t.number)
      , p = H( () => t.state)
      , h = H( () => t.trim)
      , v = zt(_e( () => t.debounce ?? 0))
      , y = zt(_e( () => t.debounceMaxWait ?? NaN))
      , k = _e( () => u.value === !0 ? 0 : v.value)
      , w = _e( () => u.value === !0 ? NaN : y.value)
      , $ = rN(G => {
        s.value = G
    }
    , k, {
        maxWait: w
    })
      , M = (G, te=!1) => {
        u.value === !0 && te === !1 || $(G)
    }
      , {focused: S} = ar(n, {
        initialValue: i.value
    })
      , T = (G, te, J=!1) => (G = String(G),
    typeof t.formatter == "function" && (!d.value || J) ? (a = !1,
    t.formatter(G, te)) : G)
      , E = G => h.value ? G.trim() : f.value ? Number.parseFloat(G) : G;
    Zt( () => {
        n.value && (n.value.value = s.value)
    }
    ),
    b1( () => {
        Ot( () => {
            i.value && (S.value = !0)
        }
        )
    }
    );
    const O = K( () => ac(t.ariaInvalid, p.value))
      , U = G => {
        const {value: te} = G.target
          , J = T(te, G);
        if (J === !1 || G.defaultPrevented) {
            G.preventDefault();
            return
        }
        const ae = E(J);
        r = te,
        M(ae),
        e("input", J)
    }
      , L = G => {
        const {value: te} = G.target
          , J = T(te, G);
        if (J === !1 || G.defaultPrevented) {
            G.preventDefault();
            return
        }
        const ae = E(J);
        s.value !== ae && (r = te,
        M(J, !0)),
        e("change", J)
    }
      , C = G => {
        if (e("blur", G),
        !u.value && !d.value)
            return;
        const {value: te} = G.target
          , J = T(te, G, !0)
          , ae = E(J);
        s.value !== ae && (r = te,
        M(J, !0))
    }
      , W = () => {
        o.value || (S.value = !0)
    }
      , R = () => {
        o.value || (S.value = !1)
    }
    ;
    return Ke(s, G => {
        n.value && (n.value.value = r && a ? r : G,
        r = null,
        a = !0)
    }
    ),
    {
        input: n,
        computedId: l,
        computedAriaInvalid: O,
        onInput: U,
        onChange: L,
        onBlur: C,
        focus: W,
        blur: R
    }
}
  , Bl = (t, e) => {
    if (!t)
        return t;
    if (e in t)
        return t[e];
    const n = e.split(".");
    return Bl(t[n[0]], n.splice(1).join("."))
}
  , mf = (t, e=null, n, r) => {
    if (Object.prototype.toString.call(t) === "[object Object]") {
        const a = Bl(t, r.valueField)
          , s = Bl(t, r.textField)
          , l = Bl(t, r.htmlField)
          , i = Bl(t, r.disabledField)
          , o = t[r.optionsField] || null;
        return o !== null ? {
            label: String(Bl(t, r.labelField) || s),
            options: wm(o, n, r)
        } : {
            value: typeof a > "u" ? e || s : a,
            text: String(typeof s > "u" ? e : s),
            html: l,
            disabled: !!i
        }
    }
    return {
        value: e || t,
        text: String(t),
        disabled: !1
    }
}
  , wm = (t, e, n) => Array.isArray(t) ? t.map(r => mf(r, null, e, n)) : Object.prototype.toString.call(t) === "[object Object]" ? (console.warn(`[BootstrapVue warn]: ${e} - Setting prop "options" to an object is deprecated. Use the array format instead.`),
Object.keys(t).map(r => {
    const a = t[r];
    switch (typeof a) {
    case "object":
        return mf(a.text, String(a.value), e, n);
    default:
        return mf(a, String(r), e, n)
    }
}
)) : []
  , an = (t, e) => K( () => ca(t) || js(e))
  , vf = "modal-open"
  , vN = YO( () => {
    const t = me([])
      , e = me([])
      , n = _e( () => e.value.length)
      , r = _e( () => e.value[e.value.length - 1])
      , a = u => e.value.push(u)
      , s = () => e.value.pop()
      , l = u => {
        e.value = e.value.filter(d => d.uid !== u.uid)
    }
      , i = u => t.value.find(d => {
        var f;
        return ((f = d.exposed) == null ? void 0 : f.id) === u
    }
    ) || null
      , o = oN("updateHTMLAttrs", (u, d, f) => {
        const p = typeof u == "string" ? window == null ? void 0 : window.document.querySelector(u) : es(u);
        p && (d === "class" ? p.classList.toggle(vf, f === vf) : p.setAttribute(d, f))
    }
    );
    return oi( () => {
        o("body", "class", "")
    }
    ),
    Ke(n, u => {
        o("body", "class", u > 0 ? vf : "")
    }
    ),
    {
        registry: t,
        stack: e,
        last: r,
        count: n,
        push: a,
        pop: s,
        remove: l,
        find: i
    }
}
)
  , gN = (t, e) => {
    const {registry: n, push: r, remove: a, stack: s} = vN()
      , l = pl();
    if (!l || l.type.__name !== "BModal")
        throw new Error("useModalManager must only use in BModal component");
    return n.value.push(l),
    Ke(t, (i, o) => {
        i ? r(l) : o && !i && a(l)
    }
    , {
        immediate: !0
    }),
    {
        activePosition: K( () => s.value.findIndex(i => {
            var o;
            return ((o = i.exposed) == null ? void 0 : o.id) === ca(e)
        }
        )),
        activeModalCount: _e( () => s.value.length)
    }
}
  , M_ = (t, e) => {
    const n = Hn(_e(t))
      , r = Hn(_e(e))
      , a = _e( () => !r.value);
    Zt( () => {
        const s = fN(document.body, n.value && a.value);
        Ke([n, a], ([l,i]) => {
            s.value = l && i
        }
        )
    }
    )
}
  , bN = (t, e, n, r, a) => {
    if (t === void 0 || e === void 0 || n === void 0 || r === void 0)
        return e ?? [];
    const s = n;
    return e.sort( (l, i) => {
        if (a !== void 0)
            return a(l, i, n, r);
        const o = u => typeof u == "object" ? JSON.stringify(u) : u;
        return o(l[s]) > o(i[s]) ? r ? -1 : 1 : o(i[s]) > o(l[s]) ? r ? 1 : -1 : 0
    }
    )
}
  , yN = (t, e, n) => t.filter(r => Object.entries(r).filter(a => {
    const [s,l] = a;
    return !l || s[0] === "_" || n && n.length > 0 && !n.includes(s) ? !1 : (typeof l == "object" ? JSON.stringify(Object.values(l)) : l.toString()).toLowerCase().includes(e.toLowerCase())
}
).length > 0)
  , kN = (t, e, n, r, a) => {
    let s = t.value;
    const l = "isFilterableTable"in n && n.isFilterableTable.value === !0 && e.filter;
    (l && !r.value || l && r.value && n.noProviderFilteringBoolean.value) && (s = yN(s, e.filter, e.filterable));
    const i = "isSortable"in n && n.isSortable.value === !0;
    return (i && !r.value || i && r.value && n.noProviderSortingBoolean.value) && (s = bN(e.fields, s, a == null ? void 0 : a.value, n.sortDescBoolean.value, e.sortCompare)),
    s
}
  , _N = (t, e, n, r) => {
    const a = me()
      , s = me(t.items ?? [])
      , l = me([0, s.value.length])
      , i = K( () => {
        const u = e.requireItemsMapping.value ? kN(s, t, e, n, r) : n.value ? s.value : t.items ?? [];
        if (t.perPage !== void 0) {
            const d = ((t.currentPage ?? 0) - 1) * t.perPage
              , f = d + t.perPage > u.length ? u.length : d + t.perPage;
            l.value = [d, f]
        }
        return u
    }
    )
      , o = K( () => t.perPage === void 0 || n.value && !e.noProviderPagingBoolean.value ? i.value : i.value.slice(l.value[0], l.value[1]));
    return {
        internalItems: s,
        computedItems: i,
        updateInternalItems: async u => {
            try {
                return s.value = u,
                s.value
            } catch {
                return
            }
        }
        ,
        filteredHandler: a,
        notifyFilteredItems: () => {
            a.value && a.value(i.value)
        }
        ,
        computedDisplayItems: o
    }
}
  , wN = "top-right"
  , xN = y_( () => {
    const t = me([]);
    return {
        toasts: t,
        show: (...[e,n]) => {
            const r = {
                pos: wN
            };
            typeof e == "string" ? Object.assign(r, n, {
                body: e,
                value: (n == null ? void 0 : n.value) || 5e3
            }) : Object.assign(r, e, {
                value: e.value || 5e3
            });
            const a = Symbol();
            return t.value.push({
                ...r,
                self: a
            }),
            a
        }
        ,
        hide: e => {
            const n = t.value.findIndex(r => r.self === e);
            n !== -1 && t.value.splice(n, 1)
        }
    }
}
)
  , SN = ["id"]
  , $N = ["innerHTML"]
  , TN = ["innerHTML"]
  , xm = Se({
    inheritAttrs: !1,
    __name: "BPopover",
    props: {
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        container: {
            default: void 0
        },
        target: {
            default: null
        },
        reference: {
            default: null
        },
        content: {
            default: void 0
        },
        id: {
            default: void 0
        },
        title: {
            default: void 0
        },
        delay: {
            default: () => ({
                show: 100,
                hide: 300
            })
        },
        click: {
            type: [String, Boolean],
            default: !1
        },
        manual: {
            type: [String, Boolean],
            default: !1
        },
        variant: {
            default: null
        },
        offset: {
            default: null
        },
        customClass: {
            default: ""
        },
        placement: {
            default: "top"
        },
        strategy: {
            default: "absolute"
        },
        floatingMiddleware: {
            default: void 0
        },
        noFlip: {
            type: [String, Boolean],
            default: !1
        },
        noShift: {
            type: [String, Boolean],
            default: !1
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        noAutoClose: {
            type: [String, Boolean],
            default: !1
        },
        hide: {
            type: [String, Boolean]
        },
        realtime: {
            type: [String, Boolean],
            default: !1
        },
        inline: {
            type: [String, Boolean],
            default: !1
        },
        tooltip: {
            type: [String, Boolean],
            default: !1
        },
        html: {
            type: [String, Boolean],
            default: !1
        },
        noninteractive: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = H( () => r.modelValue)
          , s = me(a.value)
          , l = me(a.value);
        Si( () => {
            n("update:modelValue", s.value)
        }
        ),
        Ke(a, () => {
            a.value !== s.value && (a.value ? ee() : B(new Event("update:modelValue")))
        }
        );
        const i = an( () => r.id, "popover")
          , o = H( () => r.click)
          , u = H( () => r.manual)
          , d = H( () => r.noShift)
          , f = H( () => r.noFlip)
          , p = H( () => r.noFade)
          , h = H( () => r.noAutoClose)
          , v = H( () => r.noHide)
          , y = H( () => r.realtime)
          , k = H( () => r.inline)
          , w = H( () => r.tooltip)
          , $ = H( () => r.noninteractive)
          , M = H( () => r.html)
          , S = me(!1)
          , T = me(null)
          , E = me(null)
          , O = me(null)
          , U = me(null)
          , L = me(null)
          , C = K( () => r.title ? jl(r.title, Ll) : "")
          , W = K( () => r.content ? jl(r.content, Ll) : "")
          , R = _e( () => r.placement.startsWith("auto"))
          , G = zt(_e( () => r.offset ?? NaN))
          , te = K( () => {
            if (r.floatingMiddleware !== void 0)
                return r.floatingMiddleware;
            const fe = r.offset !== null ? G.value : w.value ? 0 : 10
              , F = [l_(fe)];
            return f.value === !1 && !R.value && F.push(a_()),
            R.value && F.push(kO({
                alignment: r.placement.split("-")[1] || void 0
            })),
            d.value === !1 && F.push(i_()),
            v.value === !1 && F.push(_O({
                padding: 10
            })),
            k.value === !0 && F.push(xO()),
            F.push(HO({
                element: O,
                padding: 10
            })),
            F
        }
        )
          , J = _e( () => R.value ? void 0 : r.placement)
          , {floatingStyles: ae, middlewareData: oe, placement: ne, update: I} = g_(E, T, {
            placement: J,
            middleware: te,
            strategy: Hn(_e(r, "strategy")),
            whileElementsMounted: (...fe) => m_(...fe, {
                animationFrame: y.value
            })
        })
          , j = me({
            position: "absolute"
        });
        Ke(oe, () => {
            var fe;
            if (v.value === !1 && ((fe = oe.value.hide) != null && fe.referenceHidden ? S.value = !0 : S.value = !1),
            oe.value.arrow) {
                const {x: F, y: z} = oe.value.arrow;
                j.value = {
                    position: "absolute",
                    top: z ? `${z}px` : "",
                    left: F ? `${F}px` : ""
                }
            }
        }
        );
        const re = K( () => {
            const fe = w.value ? "tooltip" : "popover";
            return [fe, `b-${fe}`, {
                [`b-${fe}-${r.variant}`]: r.variant !== null,
                show: s.value && !S.value,
                "pe-none": !s.value,
                fade: !p.value,
                "d-none": !s.value && p.value,
                [`${r.customClass}`]: r.customClass !== void 0,
                [`bs-${fe}-${EN(ne.value)}`]: ne.value !== void 0
            }]
        }
        )
          , {isOutside: le} = _b(T)
          , {isOutside: ce} = _b(U)
          , xe = fe => {
            const F = fe ?? new Event("click");
            s.value ? B(F) : ee()
        }
          , X = (fe, F={}) => new Wo(fe,{
            cancelable: !1,
            target: T.value || null,
            relatedTarget: null,
            trigger: null,
            ...F,
            componentId: i.value
        });
        let be;
        const ee = () => {
            const fe = X("show", {
                cancelable: !0
            });
            if (n("show", fe),
            fe.defaultPrevented) {
                n("show-prevented");
                return
            }
            l.value = !0,
            Ot( () => {
                var F;
                I(),
                be = setTimeout( () => {
                    I(),
                    s.value = !0,
                    Ot( () => {
                        n("shown", X("shown"))
                    }
                    )
                }
                , typeof r.delay == "number" ? r.delay : ((F = r.delay) == null ? void 0 : F.show) || 0)
            }
            )
        }
          , B = fe => {
            var F;
            const z = X("hide", {
                cancelable: !0
            });
            if (n("hide", z),
            z.defaultPrevented) {
                n("hide-prevented");
                return
            }
            be && (clearTimeout(be),
            be = void 0);
            const ge = typeof r.delay == "number" ? r.delay : ((F = r.delay) == null ? void 0 : F.hide) || 0;
            setTimeout( () => {
                var Te, ke;
                (fe == null ? void 0 : fe.type) === "click" || (fe == null ? void 0 : fe.type) === "forceHide" || (fe == null ? void 0 : fe.type) === "update:modelValue" && u.value || !$.value && le.value && ce.value && !((Te = T.value) != null && Te.contains(document == null ? void 0 : document.activeElement)) && !((ke = U.value) != null && ke.contains(document == null ? void 0 : document.activeElement)) || $.value && ce.value ? (s.value = !1,
                Ot( () => {
                    setTimeout( () => {
                        l.value = !1
                    }
                    , T.value ? _p(T.value) : 150),
                    n("hidden", X("hidden"))
                }
                )) : setTimeout( () => {
                    B(fe)
                }
                , ge < 50 ? 50 : ge)
            }
            , ge)
        }
        ;
        e({
            hide: B,
            show: ee,
            toggle: xe
        });
        const se = fe => {
            const F = A(fe);
            if (F)
                return typeof F == "string" ? document.getElementById(F) || void 0 : F.$el ? F.$el : F
        }
          , pe = () => {
            var fe;
            if (r.target) {
                const F = se(r.target);
                F ? U.value = F : console.warn("Target element not found", r.target)
            } else
                U.value = (fe = L.value) == null ? void 0 : fe.nextElementSibling;
            if (r.reference) {
                const F = se(r.reference);
                F ? E.value = F : console.warn("Reference element not found", r.reference)
            } else
                E.value = U.value;
            !U.value || u.value || dm && (U.value.addEventListener("forceHide", B),
            o.value && U.value.addEventListener("click", xe),
            !o.value && U.value.addEventListener("pointerenter", ee),
            !o.value && U.value.addEventListener("pointerleave", B),
            !o.value && U.value.addEventListener("focus", ee),
            !o.value && U.value.addEventListener("blur", B))
        }
          , ie = () => {
            U.value && (U.value.removeEventListener("forceHide", B),
            U.value.removeEventListener("click", xe),
            U.value.removeEventListener("pointerenter", ee),
            U.value.removeEventListener("pointerleave", B),
            U.value.removeEventListener("focus", ee),
            U.value.removeEventListener("blur", B))
        }
        ;
        return __(T, () => {
            s.value && o.value && !h.value && !u.value && B(new Event("clickOutside"))
        }
        , {
            ignore: [U]
        }),
        Ke([ () => r.click, () => r.target, () => r.reference], () => {
            ie(),
            pe()
        }
        ),
        Zt(pe),
        $i(ie),
        (fe, F) => (g(),
        _(we, null, [c("span", {
            ref_key: "placeholder",
            ref: L
        }, null, 512), Z(fe.$slots, "target", {
            show: ee,
            hide: B,
            toggle: xe,
            showState: s.value
        }), x(ic, {
            tag: "Teleport",
            to: fe.container,
            skip: !fe.container
        }, {
            default: N( () => [l.value ? (g(),
            _("div", Ve({
                key: 0,
                id: fe.id
            }, fe.$attrs, {
                ref_key: "element",
                ref: T,
                class: re.value,
                role: "tooltip",
                tabindex: "-1",
                style: A(ae)
            }), [c("div", {
                ref_key: "arrow",
                ref: O,
                class: ye(`${A(w) ? "tooltip" : "popover"}-arrow`),
                style: Rt(j.value),
                "data-popper-arrow": ""
            }, null, 6), fe.title || fe.$slots.title ? (g(),
            _(we, {
                key: 0
            }, [A(M) ? (g(),
            _("div", {
                key: 1,
                class: ye(A(w) ? "tooltip-inner" : "popover-header"),
                innerHTML: C.value
            }, null, 10, $N)) : (g(),
            _("div", {
                key: 0,
                class: ye(A(w) ? "tooltip-inner" : "popover-header")
            }, [Z(fe.$slots, "title", {}, () => [ve(Q(fe.title), 1)])], 2))], 64)) : q("", !0), A(w) && !fe.$slots.title && !fe.title || !A(w) ? (g(),
            _(we, {
                key: 1
            }, [A(M) ? (g(),
            _("div", {
                key: 1,
                class: ye(A(w) ? "tooltip-inner" : "popover-body"),
                innerHTML: W.value
            }, null, 10, TN)) : (g(),
            _("div", {
                key: 0,
                class: ye(A(w) ? "tooltip-inner" : "popover-body")
            }, [Z(fe.$slots, "default", {}, () => [ve(Q(fe.content), 1)])], 2))], 64)) : q("", !0)], 16, SN)) : q("", !0)]),
            _: 3
        }, 8, ["to", "skip"])], 64))
    }
})
  , CN = ({top: t, end: e, start: n, alignCenter: r, alignEnd: a}) => {
    const s = t ? "top" : n ? "left" : e ? "right" : "bottom"
      , l = a ? "end" : r ? null : "start";
    return `${s}${l ? `-${l}` : ""}`
}
  , EN = t => {
    const [e] = t.split("-");
    switch (e) {
    case "left":
        return "start";
    case "right":
        return "end";
    default:
        return e
    }
}
  , Co = t => typeof t != "object" || t.active !== !1
  , td = (t, e) => {
    if (!Co(t))
        return {};
    const n = typeof t > "u" || typeof t == "object" && !t.title && !t.content
      , r = e.getAttribute("title") || e.getAttribute("data-original-title");
    return n ? r ? (e.removeAttribute("title"),
    e.setAttribute("data-original-title", r),
    {
        content: jl(r, Ll)
    }) : {} : typeof t == "string" ? {
        content: jl(t, Ll)
    } : {
        title: t != null && t.title ? jl(t == null ? void 0 : t.title, Ll) : void 0,
        content: t != null && t.content ? jl(t == null ? void 0 : t.content, Ll) : void 0
    }
}
  , Jl = (t, e) => ({
    target: e,
    modelValue: t.modifiers.show,
    inline: t.modifiers.inline,
    click: t.modifiers.click,
    realtime: t.modifiers.realtime,
    placement: t.modifiers.left ? "left" : t.modifiers.right ? "right" : t.modifiers.bottom ? "bottom" : t.modifiers.top ? "top" : void 0,
    html: !0,
    ...typeof t.value == "object" ? t.value : {},
    title: null,
    content: null
})
  , nd = (t, e) => {
    var n;
    const r = document.createElement("span");
    e.modifiers.body ? document.body.appendChild(r) : e.modifiers.child ? t.appendChild(r) : (n = t.parentNode) == null || n.insertBefore(r, t.nextSibling),
    t.$__app = Q1({
        render: () => {
            var a;
            return st(xm, {
                ...(a = t.$__state) == null ? void 0 : a.value
            })
        }
    }),
    t.$__app.mount(r),
    t.$__element = r
}
  , O_ = t => {
    var e;
    const n = t.$__element;
    (e = t.$__app) == null || e.unmount(),
    delete t.$__app,
    delete t.$__state,
    setTimeout( () => {
        n == null || n.remove()
    }
    , 0),
    delete t.$__element
}
  , wb = (t, e) => {
    const {all: n, ...r} = t
      , a = {};
    n && e.forEach(l => {
        a[l] = n
    }
    );
    const s = {
        ...a,
        ...r
    };
    return Object.entries(s).filter( ([l,i]) => !!i && e.includes(l)).map( ([l]) => l)
}
  , AN = ["id"]
  , MN = Se({
    __name: "BAccordion",
    props: {
        flush: {
            type: [String, Boolean],
            default: !1
        },
        free: {
            type: [String, Boolean],
            default: !1
        },
        id: {
            default: void 0
        },
        modelValue: {
            default: void 0
        }
    },
    emits: ["update:modelValue"],
    setup(t, {emit: e}) {
        const n = t
          , r = qt(n, "modelValue", e, {
            passive: !0
        })
          , a = an( () => n.id, "accordion")
          , s = H( () => n.flush)
          , l = H( () => n.free)
          , i = K( () => ({
            "accordion-flush": s.value
        }));
        return zn(Xk, {
            openItem: Hn(r),
            free: l,
            setOpenItem: o => {
                r.value = o
            }
        }),
        (o, u) => (g(),
        _("div", {
            id: A(a),
            class: ye(["accordion", i.value])
        }, [Z(o.$slots, "default")], 10, AN))
    }
})
  , N_ = Se({
    inheritAttrs: !1,
    __name: "BCollapse",
    props: {
        id: {
            default: void 0
        },
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        },
        toggle: {
            type: [String, Boolean],
            default: !1
        },
        horizontal: {
            type: [String, Boolean],
            default: !1
        },
        visible: {
            type: [String, Boolean],
            default: !1
        },
        isNav: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = (T, E={}) => new Wo(T,{
            cancelable: !1,
            target: p.value || null,
            relatedTarget: null,
            trigger: null,
            ...E,
            componentId: f.value
        })
          , s = qt(r, "modelValue", n, {
            passive: !0
        })
          , l = H(s)
          , i = H( () => r.toggle)
          , o = H( () => r.horizontal)
          , u = H( () => r.isNav)
          , d = H( () => r.visible)
          , f = an( () => r.id, "collapse")
          , p = me(null)
          , h = me(!1)
          , v = me(l.value)
          , y = K( () => ({
            show: v.value,
            "navbar-collapse": u.value,
            collapsing: h.value,
            closing: v.value && !l.value,
            "collapse-horizontal": o.value
        }))
          , k = () => {
            s.value = !1
        }
          , w = () => {
            s.value = !0
        }
          , $ = () => {
            s.value = !l.value
        }
          , M = () => {
            v.value = !0,
            h.value = !0;
            const T = a("show", {
                cancelable: !0
            });
            if (n("show", T),
            T.defaultPrevented) {
                n("show-prevented");
                return
            }
            Ot( () => {
                p.value !== null && (o.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`,
                setTimeout( () => {
                    h.value = !1,
                    n("shown"),
                    p.value !== null && (p.value.style.height = "",
                    p.value.style.width = "")
                }
                , _p(p.value)))
            }
            )
        }
          , S = () => {
            const T = a("hide", {
                cancelable: !0
            });
            if (n("hide", T),
            T.defaultPrevented) {
                n("hide-prevented");
                return
            }
            p.value !== null && (o.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`,
            p.value.offsetHeight,
            h.value = !0,
            Ot( () => {
                p.value !== null && (p.value.style.height = "",
                p.value.style.width = "",
                setTimeout( () => {
                    v.value = !1,
                    h.value = !1,
                    n("hidden")
                }
                , _p(p.value)))
            }
            ))
        }
        ;
        return Ke([s, v], () => {
            if (l.value === !0) {
                if (v.value)
                    return;
                M();
                return
            }
            S()
        }
        ),
        Zt( () => {
            p.value !== null && !l.value && i.value && Ot( () => {
                s.value = !0
            }
            )
        }
        ),
        d.value && (s.value = !0,
        v.value = !0),
        Ke(d, T => {
            T ? w() : k()
        }
        ),
        on(p, "bv-toggle", () => {
            s.value = !l.value
        }
        ),
        e({
            close: k,
            open: w,
            toggle: $,
            visible: Hn(v),
            isNav: u
        }),
        zn(pm, {
            id: f,
            close: k,
            open: w,
            toggle: $,
            visible: Hn(v),
            isNav: u
        }),
        (T, E) => (g(),
        _(we, null, [Z(T.$slots, "header", {
            id: A(f),
            visible: A(l),
            toggle: $,
            open: w,
            close: k
        }), (g(),
        de(qe(T.tag), Ve({
            id: A(f),
            ref_key: "element",
            ref: p,
            class: ["collapse", y.value],
            "is-nav": A(u)
        }, T.$attrs), {
            default: N( () => [Z(T.$slots, "default", {
                visible: A(l),
                toggle: T.toggle,
                open: w,
                close: k
            })]),
            _: 3
        }, 16, ["id", "class", "is-nav"])), Z(T.$slots, "footer", {
            id: A(f),
            visible: A(l),
            toggle: $,
            open: w,
            close: k
        })], 64))
    }
})
  , ON = {
    class: "accordion-item"
}
  , NN = ["aria-expanded", "aria-controls", "onClick"]
  , DN = {
    class: "accordion-body"
}
  , PN = Se({
    inheritAttrs: !1,
    __name: "BAccordionItem",
    props: {
        id: {
            default: void 0
        },
        title: {
            default: void 0
        },
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        headerTag: {
            default: "h2"
        },
        tag: {
            default: void 0
        },
        toggle: {
            type: [String, Boolean],
            default: void 0
        },
        horizontal: {
            type: [String, Boolean],
            default: void 0
        },
        visible: {
            type: [String, Boolean],
            default: !1
        },
        isNav: {
            type: [String, Boolean],
            default: void 0
        }
    },
    emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
    setup(t, {emit: e}) {
        const n = t
          , r = qt(n, "modelValue", e, {
            passive: !0
        })
          , a = Gt(Xk, null)
          , s = an( () => n.id, "accordion_item");
        return Zt( () => {
            r.value && !(a != null && a.free.value) && (a == null || a.setOpenItem(s.value)),
            !r.value && (a == null ? void 0 : a.openItem.value) === s.value && (r.value = !0)
        }
        ),
        Ke( () => a == null ? void 0 : a.openItem.value, () => r.value = (a == null ? void 0 : a.openItem.value) === s.value && !(a != null && a.free.value)),
        Ke(r, () => {
            r.value && !(a != null && a.free.value) && (a == null || a.setOpenItem(s.value))
        }
        ),
        (l, i) => (g(),
        _("div", ON, [x(N_, Ve({
            id: A(s),
            modelValue: A(r),
            "onUpdate:modelValue": i[0] || (i[0] = o => Kt(r) ? r.value = o : null),
            class: "accordion-collapse"
        }, l.$attrs, {
            "aria-labelledby": `${A(s)}-heading`,
            tag: l.tag,
            toggle: l.toggle,
            horizontal: l.horizontal,
            visible: l.visible,
            "is-nav": l.isNav,
            onShow: i[1] || (i[1] = o => e("show", o)),
            onShown: i[2] || (i[2] = o => e("shown")),
            onHide: i[3] || (i[3] = o => e("hide", o)),
            onHidden: i[4] || (i[4] = o => e("hidden")),
            onHidePrevented: i[5] || (i[5] = o => e("hide-prevented")),
            onShowPrevented: i[6] || (i[6] = o => e("show-prevented"))
        }), {
            header: N( ({visible: o, toggle: u}) => [(g(),
            de(qe(l.headerTag), {
                id: `${A(s)}-heading`,
                class: "accordion-header"
            }, {
                default: N( () => [c("button", {
                    class: ye(["accordion-button", {
                        collapsed: !o
                    }]),
                    type: "button",
                    "aria-expanded": o ? "true" : "false",
                    "aria-controls": A(s),
                    onClick: u
                }, [Z(l.$slots, "title", {}, () => [ve(Q(l.title), 1)])], 10, NN)]),
                _: 2
            }, 1032, ["id"]))]),
            default: N( () => [c("div", DN, [Z(l.$slots, "default")])]),
            _: 3
        }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])]))
    }
})
  , Ei = Se({
    __name: "BTransition",
    props: {
        appear: {
            type: [String, Boolean],
            default: !1
        },
        mode: {
            default: void 0
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        transProps: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.appear)
          , r = H( () => e.noFade)
          , a = K( () => {
            const i = {
                name: "",
                enterActiveClass: "",
                enterToClass: "",
                leaveActiveClass: "",
                leaveToClass: "showing",
                enterFromClass: "showing",
                leaveFromClass: ""
            }
              , o = {
                ...i,
                enterActiveClass: "fade showing",
                leaveActiveClass: "fade showing"
            };
            return r.value ? i : o
        }
        )
          , s = K( () => ({
            mode: e.mode,
            css: !0,
            ...a.value
        }))
          , l = K( () => e.transProps !== void 0 ? {
            ...s.value,
            ...e.transProps
        } : n.value ? {
            ...s.value,
            appear: !0,
            appearActiveClass: a.value.enterActiveClass,
            appearToClass: a.value.enterToClass
        } : s.value);
        return (i, o) => (g(),
        de(fa, ut(Vt(l.value)), {
            default: N( () => [Z(i.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , FN = ["type", "disabled", "aria-label"]
  , Ai = Se({
    __name: "BCloseButton",
    props: {
        ariaLabel: {
            default: "Close"
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        type: {
            default: "button"
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.disabled);
        return (a, s) => (g(),
        _("button", {
            type: a.type,
            class: "btn-close",
            disabled: A(r),
            "aria-label": a.ariaLabel,
            onClick: s[0] || (s[0] = l => e("click", l))
        }, null, 8, FN))
    }
})
  , BN = {
    key: 0,
    class: "visually-hidden"
}
  , er = Se({
    __name: "BSpinner",
    props: {
        label: {
            default: void 0
        },
        role: {
            default: "status"
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "span"
        },
        type: {
            default: "border"
        },
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = en()
          , r = H( () => e.small)
          , a = K( () => [`spinner-${e.type}`, {
            [`spinner-${e.type}-sm`]: r.value,
            [`text-${e.variant}`]: e.variant !== null
        }])
          , s = _e( () => !Mn(n.label));
        return (l, i) => (g(),
        de(qe(l.tag), {
            class: ye(a.value),
            role: l.label || s.value ? l.role : null,
            "aria-hidden": l.label || s.value ? null : !0
        }, {
            default: N( () => [l.label || s.value ? (g(),
            _("span", BN, [Z(l.$slots, "label", {}, () => [ve(Q(l.label), 1)])])) : q("", !0)]),
            _: 3
        }, 8, ["class", "role", "aria-hidden"]))
    }
})
  , xb = "active"
  , ha = Se({
    __name: "BLink",
    props: {
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: "router-link-active"
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        event: {
            default: "click"
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        routerTag: {
            default: "a"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: null
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = x1()
          , a = H( () => n.active)
          , s = H( () => n.icon);
        H( () => n.append);
        const l = H( () => n.disabled);
        H( () => n.replace);
        const i = Gt(pm, null)
          , o = Gt(hm, null)
          , u = pl()
          , d = K( () => {
            const k = n.routerComponentName.split("-").map(w => w.charAt(0).toUpperCase() + w.slice(1)).join("");
            return (u == null ? void 0 : u.appContext.app.component(k)) === void 0 || l.value || !n.to ? "a" : n.routerComponentName
        }
        )
          , f = K( () => {
            const k = "#";
            if (n.href)
                return n.href;
            if (typeof n.to == "string")
                return n.to || k;
            const w = n.to;
            if (Object.prototype.toString.call(w) === "[object Object]" && (w.path || w.query || w.hash)) {
                const $ = w.path || ""
                  , M = w.query ? `?${Object.keys(w.query).map(T => `${T}=${w.query[T]}`).join("=")}` : ""
                  , S = !w.hash || w.hash.charAt(0) === "#" ? w.hash || "" : `#${w.hash}`;
                return `${$}${M}${S}` || k
            }
            return k
        }
        )
          , p = K( () => ({
            [`link-${n.variant}`]: n.variant !== null,
            [`link-opacity-${n.opacity}`]: n.opacity !== void 0,
            [`link-opacity-${n.opacityHover}-hover`]: n.opacityHover !== void 0,
            [`link-underline-${n.underlineVariant}`]: n.underlineVariant !== null,
            [`link-offset-${n.underlineOffset}`]: n.underlineOffset !== void 0,
            [`link-offset-${n.underlineOffsetHover}-hover`]: n.underlineOffsetHover !== void 0,
            [`link-underline-opacity-${n.underlineOpacity}`]: n.underlineOpacity !== void 0,
            [`link-underline-opacity-${n.underlineOpacityHover}-hover`]: n.underlineOpacityHover !== void 0,
            "icon-link": s.value === !0
        }))
          , h = K( () => ({
            class: p.value,
            to: n.to,
            href: f.value,
            target: n.target,
            rel: n.target === "_blank" && n.rel === void 0 ? "noopener" : n.rel || void 0,
            tabindex: l.value ? "-1" : typeof r.tabindex > "u" ? null : r.tabindex,
            "aria-disabled": l.value ? !0 : null
        }))
          , v = K( () => ({
            [xb]: a.value,
            disabled: l.value
        }))
          , y = k => {
            var w, $, M;
            if (l.value) {
                k.preventDefault(),
                k.stopImmediatePropagation();
                return
            }
            (((w = i == null ? void 0 : i.isNav) == null ? void 0 : w.value) === !0 && o === null || o !== null && (($ = o.autoClose) == null ? void 0 : $.value) === !0) && ((M = i == null ? void 0 : i.close) == null || M.call(i)),
            e("click", k)
        }
        ;
        return (k, w) => d.value === "router-link" ? (g(),
        de(qe(d.value), Ve({
            key: 0
        }, h.value, {
            custom: ""
        }), {
            default: N( ({href: $, navigate: M, isActive: S}) => [(g(),
            de(qe(k.routerTag), Ve({
                href: $,
                class: [(A(a) ?? S) && `${k.activeClass} ${xb}`]
            }, k.$attrs, {
                onClick: T => {
                    M(T),
                    y(T)
                }
            }), {
                default: N( () => [Z(k.$slots, "default")]),
                _: 2
            }, 1040, ["href", "class", "onClick"]))]),
            _: 3
        }, 16)) : (g(),
        de(qe(d.value), Ve({
            key: 1,
            class: v.value
        }, h.value, {
            onClick: y
        }), {
            default: N( () => [Z(k.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , is = Se({
    __name: "BButton",
    props: {
        pill: {
            type: [String, Boolean],
            default: !1
        },
        pressed: {
            type: [String, Boolean],
            default: void 0
        },
        size: {
            default: "md"
        },
        squared: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "button"
        },
        type: {
            default: "button"
        },
        variant: {
            default: "secondary"
        },
        loading: {
            type: [String, Boolean],
            default: !1
        },
        loadingFill: {
            type: [String, Boolean],
            default: !1
        },
        block: {
            type: [String, Boolean],
            default: !1
        },
        loadingText: {
            default: "Loading..."
        },
        active: {
            type: [String, Boolean],
            default: !1
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        event: {
            default: "click"
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        routerTag: {
            default: "a"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["click", "update:pressed"],
    setup(t, {emit: e}) {
        const n = t
          , r = qt(n, "pressed", e)
          , a = H( () => n.active)
          , s = H( () => n.block)
          , l = H( () => n.disabled)
          , i = H( () => n.pill)
          , o = H( () => n.pressed)
          , u = H( () => n.squared)
          , d = H( () => n.loading)
          , f = H( () => n.loadingFill)
          , {computedLink: p} = gl(n)
          , h = _e( () => typeof o.value == "boolean")
          , v = _e( () => n.tag === "button" && n.href === void 0 && n.to === void 0)
          , y = _e( () => n.to !== void 0)
          , k = _e( () => n.href !== void 0 ? !1 : !v.value)
          , w = K( () => [[`btn-${n.size}`], {
            [`btn-${n.variant}`]: n.variant !== null,
            "btn-block": s.value,
            active: a.value || o.value,
            "rounded-pill": i.value,
            "rounded-0": u.value,
            disabled: l.value
        }])
          , $ = _e( () => y.value ? ha : n.href ? "a" : n.tag)
          , M = S => {
            if (l.value) {
                S.preventDefault(),
                S.stopPropagation();
                return
            }
            e("click", S),
            h.value && (r.value = !o.value)
        }
        ;
        return (S, T) => (g(),
        de(qe($.value), {
            class: ye(["btn", w.value]),
            "aria-disabled": k.value ? A(l) : null,
            "aria-pressed": h.value ? A(o) : null,
            autocomplete: h.value ? "off" : null,
            disabled: v.value ? A(l) : null,
            href: S.href,
            rel: A(p) ? S.rel : null,
            role: k.value || A(p) ? "button" : null,
            target: A(p) ? S.target : null,
            type: v.value ? S.type : null,
            to: v.value ? null : S.to,
            append: A(p) ? S.append : null,
            "active-class": y.value ? S.activeClass : null,
            event: y.value ? S.event : null,
            replace: y.value ? S.replace : null,
            "router-component-name": y.value ? S.routerComponentName : null,
            "router-tag": y.value ? S.routerTag : null,
            onClick: M
        }, {
            default: N( () => [A(d) ? Z(S.$slots, "loading", {
                key: 0
            }, () => [A(f) ? q("", !0) : (g(),
            _(we, {
                key: 0
            }, [ve(Q(S.loadingText), 1)], 64)), Z(S.$slots, "loading-spinner", {}, () => [x(er, {
                small: S.size !== "lg",
                label: A(f) ? S.loadingText : void 0
            }, null, 8, ["small", "label"])])]) : Z(S.$slots, "default", {
                key: 1
            })]),
            _: 3
        }, 8, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to", "append", "active-class", "event", "replace", "router-component-name", "router-tag"]))
    }
})
  , VN = Se({
    __name: "BAlert",
    props: {
        closeVariant: {
            default: "secondary"
        },
        closeClass: {
            default: void 0
        },
        closeLabel: {
            default: "Close"
        },
        closeContent: {
            default: void 0
        },
        noHoverPause: {
            type: [String, Boolean],
            default: !1
        },
        dismissible: {
            type: [String, Boolean],
            default: !1
        },
        fade: {
            type: [String, Boolean],
            default: !1
        },
        modelValue: {
            type: [Boolean, Number],
            default: !1
        },
        variant: {
            default: "info"
        },
        immediate: {
            type: [String, Boolean],
            default: !0
        },
        interval: {
            default: 1e3
        },
        showOnPause: {
            type: [String, Boolean],
            default: !0
        }
    },
    emits: ["close", "closed", "close-countdown", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = me(null)
          , l = qt(r, "modelValue", n)
          , i = _m(s)
          , o = H( () => r.dismissible)
          , u = H( () => r.fade)
          , d = H( () => r.immediate)
          , f = H( () => r.showOnPause)
          , p = H( () => r.noHoverPause)
          , h = zt( () => r.interval)
          , v = _e( () => !Mn(a.close))
          , y = _e( () => typeof l.value == "boolean" ? 0 : l.value)
          , k = K( () => ({
            [`alert-${r.variant}`]: r.variant !== null,
            "alert-dismissible": o.value
        }))
          , w = K( () => [r.closeClass, {
            "btn-close-custom": v.value
        }])
          , {isActive: $, pause: M, restart: S, resume: T, stop: E, isPaused: O, value: U} = x_(y, h, {
            immediate: typeof l.value == "number" && d.value
        })
          , L = _e( () => typeof l.value == "boolean" ? l.value : $.value || f.value && O.value)
          , C = K( () => ({
            variant: v.value ? r.closeVariant : void 0,
            class: w.value
        }));
        Si( () => {
            n("close-countdown", U.value)
        }
        );
        const W = () => {
            n("close"),
            typeof l.value == "boolean" ? l.value = !1 : (l.value = 0,
            E()),
            n("closed")
        }
          , R = () => {
            p.value || M()
        }
        ;
        return Ke(i, G => {
            if (G) {
                R();
                return
            }
            T()
        }
        ),
        $i(E),
        e({
            pause: M,
            resume: T,
            restart: S,
            stop: E
        }),
        (G, te) => (g(),
        de(Ei, {
            "no-fade": !A(u),
            "trans-props": {
                enterToClass: "show"
            }
        }, {
            default: N( () => [L.value ? (g(),
            _("div", {
                key: 0,
                ref_key: "element",
                ref: s,
                class: ye(["alert", k.value]),
                role: "alert",
                "aria-live": "polite",
                "aria-atomic": "true"
            }, [Z(G.$slots, "default", {}, void 0, !0), A(o) ? (g(),
            _(we, {
                key: 0
            }, [v.value || G.closeContent ? (g(),
            de(is, Ve({
                key: 0
            }, C.value, {
                onClick: W
            }), {
                default: N( () => [Z(G.$slots, "close", {}, () => [ve(Q(G.closeContent), 1)], !0)]),
                _: 3
            }, 16)) : (g(),
            de(Ai, Ve({
                key: 1,
                "aria-label": G.closeLabel
            }, C.value, {
                onClick: W
            }), null, 16, ["aria-label"]))], 64)) : q("", !0)], 2)) : q("", !0)]),
            _: 3
        }, 8, ["no-fade"]))
    }
})
  , oc = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r,a] of e)
        n[r] = a;
    return n
}
  , IN = oc(VN, [["__scopeId", "data-v-dd6c5e17"]])
  , RN = {
    key: 0,
    class: "b-avatar-custom"
}
  , LN = {
    key: 1,
    class: "b-avatar-img"
}
  , jN = ["src", "alt"]
  , UN = {
    key: 1
}
  , Tp = t => {
    const e = typeof t == "string" && OM(t) ? Pu(t, 0) : t;
    return typeof e == "number" ? `${e}px` : e || null
}
  , HN = Se({
    __name: "BAvatar",
    props: {
        alt: {
            default: "avatar"
        },
        badge: {
            type: [Boolean, String],
            default: !1
        },
        badgeLeft: {
            type: [String, Boolean],
            default: !1
        },
        badgeOffset: {
            default: void 0
        },
        badgeTop: {
            type: [String, Boolean],
            default: !1
        },
        badgeVariant: {
            default: "primary"
        },
        badgeTextVariant: {
            default: null
        },
        badgeBgVariant: {
            default: null
        },
        button: {
            type: [String, Boolean],
            default: !1
        },
        buttonType: {
            default: "button"
        },
        icon: {
            type: [String, Boolean],
            default: void 0
        },
        rounded: {
            type: [Boolean, String],
            default: "circle"
        },
        size: {
            default: void 0
        },
        square: {
            type: [String, Boolean],
            default: !1
        },
        src: {
            default: void 0
        },
        text: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: "secondary"
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    emits: ["click", "img-error"],
    setup(t, {emit: e}) {
        const n = t
          , r = en()
          , {computedLink: a, computedLinkProps: s} = gl(n)
          , l = Gt(Jk, null)
          , i = ["sm", null, "lg"]
          , o = .4
          , u = o * .7
          , d = H( () => n.badgeLeft)
          , f = H( () => n.badgeTop)
          , p = H( () => n.button)
          , h = H( () => n.disabled)
          , v = H( () => n.square)
          , y = _e( () => !Mn(r.default))
          , k = _e( () => !Mn(r.badge))
          , w = _e( () => !!n.badge || n.badge === "" || k.value)
          , $ = _e( () => (l == null ? void 0 : l.size.value) ?? Tp(n.size))
          , M = _e( () => (l == null ? void 0 : l.variant.value) ?? n.variant)
          , S = _e( () => (l == null ? void 0 : l.rounded.value) ?? n.rounded)
          , T = Nr( () => ({
            variant: n.badgeVariant,
            bgVariant: n.badgeBgVariant,
            textVariant: n.badgeTextVariant
        }))
          , E = _e( () => n.badge === !0 ? "" : n.badge)
          , O = _e( () => (l == null ? void 0 : l.textVariant.value) ?? n.textVariant)
          , U = _e( () => (l == null ? void 0 : l.bgVariant.value) ?? n.bgVariant)
          , L = Nr( () => ({
            bgVariant: U.value,
            textVariant: O.value,
            variant: M.value
        }))
          , C = K( () => [L.value, {
            [`b-avatar-${n.size}`]: !!n.size && i.indexOf(Tp(n.size)) !== -1,
            badge: !p.value && M.value !== null && y.value,
            rounded: S.value === "" || S.value === !0,
            "rounded-circle": !v.value && S.value === "circle",
            "rounded-0": v.value || S.value === "0",
            "rounded-1": !v.value && S.value === "sm",
            "rounded-3": !v.value && S.value === "lg",
            "rounded-top": !v.value && S.value === "top",
            "rounded-bottom": !v.value && S.value === "bottom",
            "rounded-start": !v.value && S.value === "left",
            "rounded-end": !v.value && S.value === "right",
            btn: p.value,
            [`btn-${M.value}`]: p.value ? M.value !== null : !1
        }])
          , W = K( () => {
            const ne = n.badgeOffset || "0px";
            return {
                fontSize: (i.indexOf($.value || null) === -1 ? `calc(${$.value} * ${u})` : "") || "",
                top: f.value ? ne : "",
                bottom: f.value ? "" : ne,
                left: d.value ? ne : "",
                right: d.value ? "" : ne
            }
        }
        )
          , R = K( () => {
            const ne = i.indexOf($.value || null) === -1 ? `calc(${$.value} * ${o})` : null;
            return ne ? {
                fontSize: ne
            } : {}
        }
        )
          , G = K( () => {
            var ne;
            const I = ((ne = l == null ? void 0 : l.overlapScale) == null ? void 0 : ne.value) || 0
              , j = $.value && I ? `calc(${$.value} * -${I})` : null;
            return j ? {
                marginLeft: j,
                marginRight: j
            } : {}
        }
        )
          , te = _e( () => a.value ? ha : p.value ? "button" : "span")
          , J = K( () => ({
            ...G.value,
            width: $.value ?? void 0,
            height: $.value ?? void 0
        }))
          , ae = ne => {
            !h.value && (a.value || p.value) && e("click", ne)
        }
          , oe = ne => {
            e("img-error", ne)
        }
        ;
        return (ne, I) => (g(),
        de(qe(te.value), Ve({
            class: ["b-avatar", C.value],
            style: J.value
        }, A(s), {
            type: A(p) && !A(a) ? n.buttonType : void 0,
            disabled: A(h) || null,
            onClick: ae
        }), {
            default: N( () => [y.value ? (g(),
            _("span", RN, [Z(ne.$slots, "default")])) : ne.src ? (g(),
            _("span", LN, [c("img", {
                src: ne.src,
                alt: ne.alt,
                onError: oe
            }, null, 40, jN)])) : ne.text ? (g(),
            _("span", {
                key: 2,
                class: "b-avatar-text",
                style: Rt(R.value)
            }, Q(ne.text), 5)) : q("", !0), w.value ? (g(),
            _("span", {
                key: 3,
                class: ye(["b-avatar-badge", A(T)]),
                style: Rt(W.value)
            }, [k.value ? Z(ne.$slots, "badge", {
                key: 0
            }) : (g(),
            _("span", UN, Q(E.value), 1))], 6)) : q("", !0)]),
            _: 3
        }, 16, ["class", "style", "type", "disabled"]))
    }
})
  , KN = Se({
    __name: "BAvatarGroup",
    props: {
        overlap: {
            default: .3
        },
        rounded: {
            type: [Boolean, String],
            default: !1
        },
        size: {
            default: void 0
        },
        square: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.square)
          , r = zt( () => e.overlap)
          , a = K( () => Tp(e.size))
          , s = K( () => Math.min(Math.max(r.value, 0), 1) / 2)
          , l = K( () => {
            const i = a.value ? `calc(${a.value} * ${s.value})` : null;
            return i ? {
                paddingLeft: i,
                paddingRight: i
            } : {}
        }
        );
        return zn(Jk, {
            overlapScale: s,
            size: _e( () => e.size),
            square: n,
            rounded: _e( () => e.rounded),
            variant: _e( () => e.variant),
            bgVariant: _e( () => e.bgVariant),
            textVariant: _e( () => e.textVariant)
        }),
        (i, o) => (g(),
        de(qe(i.tag), {
            class: "b-avatar-group",
            role: "group"
        }, {
            default: N( () => [c("div", {
                class: "b-avatar-group-inner",
                style: Rt(l.value)
            }, [Z(i.$slots, "default")], 4)]),
            _: 3
        }))
    }
})
  , zN = Se({
    __name: "BBadge",
    props: {
        pill: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "span"
        },
        textIndicator: {
            type: [String, Boolean],
            default: !1
        },
        dotIndicator: {
            type: [String, Boolean],
            default: !1
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: "secondary"
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.pill)
          , r = H( () => e.textIndicator)
          , a = H( () => e.dotIndicator)
          , s = H( () => e.active)
          , l = H( () => e.disabled)
          , i = Nr(e)
          , {computedLink: o, computedLinkProps: u} = gl(e, ["active", "activeClass", "append", "disabled", "href", "rel", "replace", "routerComponentName", "target", "to", "opacity", "opacityHover", "underlineVariant", "underlineOffset", "underlineOffsetHover", "underlineOpacity", "underlineOpacityHover", "icon"])
          , d = _e( () => o.value ? ha : e.tag)
          , f = K( () => [i.value, {
            active: s.value,
            disabled: l.value,
            "rounded-pill": n.value,
            "position-absolute top-0 start-100 translate-middle": r.value || a.value,
            "p-2 border border-light rounded-circle": a.value,
            "text-decoration-none": o.value
        }]);
        return (p, h) => (g(),
        de(qe(d.value), Ve({
            class: ["badge", f.value]
        }, A(u)), {
            default: N( () => [Z(p.$slots, "default")]),
            _: 3
        }, 16, ["class"]))
    }
})
  , D_ = Se({
    __name: "BBreadcrumbItem",
    props: {
        ariaCurrent: {
            default: "location"
        },
        text: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: !1
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: void 0
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.active)
          , a = H( () => n.disabled)
          , s = K( () => ({
            active: r.value
        }))
          , l = _e( () => r.value ? "span" : ha)
          , i = _e( () => r.value ? n.ariaCurrent : void 0)
          , o = K( () => l.value !== "span" ? fm(n, ["active", "activeClass", "append", "disabled", "href", "rel", "replace", "routerComponentName", "target", "to", "variant", "opacity", "opacityHover", "underlineVariant", "underlineOffset", "underlineOffsetHover", "underlineOpacity", "underlineOpacityHover", "icon"]) : {})
          , u = d => {
            if (a.value || r.value) {
                d.preventDefault(),
                d.stopImmediatePropagation();
                return
            }
            a.value || e("click", d)
        }
        ;
        return (d, f) => (g(),
        _("li", {
            class: ye(["breadcrumb-item", s.value])
        }, [(g(),
        de(qe(l.value), Ve({
            "aria-current": i.value
        }, o.value, {
            onClick: u
        }), {
            default: N( () => [Z(d.$slots, "default", {}, () => [ve(Q(d.text), 1)])]),
            _: 3
        }, 16, ["aria-current"]))], 2))
    }
})
  , qN = {
    "aria-label": "breadcrumb"
}
  , WN = {
    class: "breadcrumb"
}
  , GN = Se({
    __name: "BBreadcrumb",
    props: {
        items: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = mN()
          , r = K( () => {
            const a = e.items || (n == null ? void 0 : n.items) || [];
            let s = !1;
            return a.map( (l, i) => (typeof l == "string" && (l = {
                text: l
            },
            i < a.length - 1 && (l.href = "#")),
            l.active && (s = !0),
            !l.active && !s && (l.active = i + 1 === a.length),
            l))
        }
        );
        return (a, s) => (g(),
        _("nav", qN, [c("ol", WN, [Z(a.$slots, "prepend"), (g(!0),
        _(we, null, Ne(r.value, (l, i) => (g(),
        de(D_, Ve({
            key: i
        }, l), {
            default: N( () => [ve(Q(l.text), 1)]),
            _: 2
        }, 1040))), 128)), Z(a.$slots, "default"), Z(a.$slots, "append")])]))
    }
})
  , YN = Se({
    __name: "BButtonGroup",
    props: {
        ariaLabel: {
            default: "Group"
        },
        size: {
            default: "md"
        },
        tag: {
            default: "div"
        },
        vertical: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.vertical)
          , r = K( () => ({
            "btn-group": !n.value,
            [`btn-group-${e.size}`]: e.size !== "md",
            "btn-group-vertical": n.value
        }));
        return (a, s) => (g(),
        de(qe(a.tag), {
            class: ye(r.value),
            role: "group",
            "aria-label": a.ariaLabel
        }, {
            default: N( () => [Z(a.$slots, "default")]),
            _: 3
        }, 8, ["class", "aria-label"]))
    }
})
  , JN = ["role", "aria-label"]
  , XN = Se({
    __name: "BButtonToolbar",
    props: {
        ariaLabel: {
            default: "Group"
        },
        justify: {
            type: [String, Boolean],
            default: !1
        },
        role: {
            default: "toolbar"
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.justify)
          , r = K( () => ({
            "justify-content-between": n.value
        }));
        return (a, s) => (g(),
        _("div", {
            class: ye([r.value, "btn-toolbar"]),
            role: a.role,
            "aria-label": a.ariaLabel
        }, [Z(a.$slots, "default")], 10, JN))
    }
})
  , QN = ["src", "width", "height", "srcset", "sizes", "loading"]
  , ZN = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>'
  , Sm = Se({
    __name: "BImg",
    props: {
        blank: {
            type: [String, Boolean],
            default: !1
        },
        blankColor: {
            default: "transparent"
        },
        block: {
            type: [String, Boolean],
            default: !1
        },
        center: {
            type: [String, Boolean],
            default: !1
        },
        fluid: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        fluidGrow: {
            type: [String, Boolean],
            default: !1
        },
        height: {
            default: void 0
        },
        start: {
            type: [String, Boolean],
            default: !1
        },
        end: {
            type: [String, Boolean],
            default: !1
        },
        rounded: {
            type: [Boolean, String],
            default: !1
        },
        sizes: {
            default: void 0
        },
        src: {
            default: void 0
        },
        srcset: {
            default: void 0
        },
        thumbnail: {
            type: [String, Boolean],
            default: !1
        },
        width: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.lazy)
          , r = H( () => e.blank)
          , a = H( () => e.block)
          , s = H( () => e.center)
          , l = H( () => e.fluid)
          , i = H( () => e.fluidGrow)
          , o = H( () => e.start)
          , u = H( () => e.end)
          , d = H( () => e.thumbnail)
          , f = zt(_e( () => e.height ?? NaN))
          , p = zt(_e( () => e.width ?? NaN))
          , h = K( () => typeof e.srcset == "string" ? e.srcset.split(",").filter(S => S).join(",") : Array.isArray(e.srcset) ? e.srcset.filter(S => S).join(",") : void 0)
          , v = K( () => typeof e.sizes == "string" ? e.sizes.split(",").filter(S => S).join(",") : Array.isArray(e.sizes) ? e.sizes.filter(S => S).join(",") : void 0)
          , y = K( () => {
            const S = Number.isNaN(p.value) ? void 0 : p.value
              , T = Number.isNaN(f.value) ? void 0 : f.value;
            if (r.value) {
                if (S !== void 0 && T === void 0)
                    return {
                        height: S,
                        width: S
                    };
                if (S === void 0 && T !== void 0)
                    return {
                        height: T,
                        width: T
                    };
                if (S === void 0 && T === void 0)
                    return {
                        height: 1,
                        width: 1
                    }
            }
            return {
                width: S,
                height: T
            }
        }
        )
          , k = K( () => M(y.value.width, y.value.height, e.blankColor))
          , w = K( () => o.value ? "float-start" : u.value ? "float-end" : s.value ? "mx-auto" : void 0)
          , $ = K( () => ({
            "img-thumbnail": d.value,
            "img-fluid": l.value || i.value,
            "w-100": i.value,
            rounded: e.rounded === "" || e.rounded === !0,
            [`rounded-${e.rounded}`]: typeof e.rounded == "string" && e.rounded !== "",
            [`${w.value}`]: w.value !== void 0,
            "d-block": a.value || s.value
        }))
          , M = (S, T, E) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(ZN.replace("%{w}", String(S)).replace("%{h}", String(T)).replace("%{f}", E))}`;
        return (S, T) => (g(),
        _("img", {
            class: ye($.value),
            src: A(r) ? k.value : e.src,
            width: y.value.width || void 0,
            height: y.value.height || void 0,
            srcset: A(r) ? void 0 : h.value,
            sizes: A(r) ? void 0 : v.value,
            loading: A(n) ? "lazy" : "eager"
        }, null, 10, QN))
    }
})
  , rd = Se({
    __name: "BCardImg",
    props: {
        bottom: {
            type: [String, Boolean],
            default: !1
        },
        top: {
            type: [String, Boolean],
            default: !1
        },
        blank: {
            type: [String, Boolean]
        },
        blankColor: {},
        block: {
            type: [String, Boolean]
        },
        center: {
            type: [String, Boolean]
        },
        fluid: {
            type: [String, Boolean]
        },
        lazy: {
            type: [String, Boolean]
        },
        fluidGrow: {
            type: [String, Boolean]
        },
        height: {},
        start: {
            type: [String, Boolean]
        },
        end: {
            type: [String, Boolean]
        },
        rounded: {
            type: [Boolean, String]
        },
        sizes: {},
        src: {},
        srcset: {},
        thumbnail: {
            type: [String, Boolean]
        },
        width: {}
    },
    setup(t) {
        const e = t
          , n = H( () => e.bottom)
          , r = H( () => e.end)
          , a = H( () => e.start)
          , s = H( () => e.top)
          , l = K( () => s.value ? "card-img-top" : r.value ? "card-img-right" : n.value ? "card-img-bottom" : a.value ? "card-img-left" : "card-img")
          , i = K( () => zk(e, ["bottom", "top", "end", "start"]));
        return (o, u) => (g(),
        de(Sm, Ve(i.value, {
            class: l.value
        }), null, 16, ["class"]))
    }
})
  , eD = ["innerHTML"]
  , P_ = Se({
    __name: "BCardHeadFoot",
    props: {
        text: {
            default: void 0
        },
        borderVariant: {
            default: null
        },
        html: {
            default: void 0
        },
        tag: {
            default: "div"
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = Nr(e)
          , r = K( () => [n.value, {
            [`border-${e.borderVariant}`]: e.borderVariant !== null
        }]);
        return (a, s) => (g(),
        de(qe(a.tag), {
            class: ye(r.value)
        }, {
            default: N( () => [a.html ? (g(),
            _("div", {
                key: 0,
                innerHTML: a.html
            }, null, 8, eD)) : Z(a.$slots, "default", {
                key: 1
            }, () => [ve(Q(a.text), 1)])]),
            _: 3
        }, 8, ["class"]))
    }
})
  , F_ = Se({
    __name: "BCardHeader",
    props: {
        text: {
            default: void 0
        },
        borderVariant: {
            default: void 0
        },
        html: {
            default: void 0
        },
        tag: {
            default: "div"
        },
        variant: {
            default: void 0
        },
        bgVariant: {
            default: void 0
        },
        textVariant: {
            default: void 0
        }
    },
    setup(t) {
        const e = t;
        return (n, r) => (g(),
        de(P_, Ve({
            class: "card-header"
        }, e), {
            default: N( () => [Z(n.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , B_ = Se({
    __name: "BCardTitle",
    props: {
        text: {
            default: void 0
        },
        tag: {
            default: "h4"
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(qe(e.tag), {
            class: "card-title"
        }, {
            default: N( () => [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)])]),
            _: 3
        }))
    }
})
  , V_ = Se({
    __name: "BCardSubtitle",
    props: {
        text: {
            default: void 0
        },
        tag: {
            default: "h6"
        },
        textVariant: {
            default: "body-secondary"
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`text-${e.textVariant}`]: e.textVariant !== null
        }));
        return (r, a) => (g(),
        de(qe(r.tag), {
            class: ye(["card-subtitle mb-2", n.value])
        }, {
            default: N( () => [Z(r.$slots, "default", {}, () => [ve(Q(r.text), 1)])]),
            _: 3
        }, 8, ["class"]))
    }
})
  , I_ = Se({
    __name: "BCardBody",
    props: {
        tag: {
            default: "div"
        },
        overlay: {
            type: [String, Boolean],
            default: !1
        },
        subtitle: {
            default: void 0
        },
        subtitleTag: {
            default: "h4"
        },
        subtitleTextVariant: {
            default: void 0
        },
        title: {
            default: void 0
        },
        titleTag: {
            default: "h4"
        },
        text: {
            default: void 0
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = en()
          , r = H( () => e.overlay)
          , a = Nr(e)
          , s = _e( () => !Mn(n.title))
          , l = _e( () => !Mn(n.subtitle))
          , i = K( () => [a.value, {
            "card-img-overlay": r.value
        }]);
        return (o, u) => (g(),
        de(qe(o.tag), {
            class: ye(["card-body", i.value])
        }, {
            default: N( () => [o.title || s.value ? (g(),
            de(B_, {
                key: 0,
                tag: o.titleTag
            }, {
                default: N( () => [Z(o.$slots, "title", {}, () => [ve(Q(o.title), 1)])]),
                _: 3
            }, 8, ["tag"])) : q("", !0), o.subtitle || l.value ? (g(),
            de(V_, {
                key: 1,
                tag: o.subtitleTag,
                "text-variant": o.subtitleTextVariant
            }, {
                default: N( () => [Z(o.$slots, "subtitle", {}, () => [ve(Q(o.subtitle), 1)])]),
                _: 3
            }, 8, ["tag", "text-variant"])) : q("", !0), Z(o.$slots, "default", {}, () => [ve(Q(o.text), 1)])]),
            _: 3
        }, 8, ["class"]))
    }
})
  , R_ = Se({
    __name: "BCardFooter",
    props: {
        text: {
            default: void 0
        },
        borderVariant: {
            default: void 0
        },
        html: {
            default: void 0
        },
        tag: {
            default: "div"
        },
        variant: {
            default: void 0
        },
        bgVariant: {
            default: void 0
        },
        textVariant: {
            default: void 0
        }
    },
    setup(t) {
        const e = t;
        return (n, r) => (g(),
        de(P_, Ve({
            class: "card-footer"
        }, e), {
            default: N( () => [Z(n.$slots, "default", {}, () => [ve(Q(n.text), 1)])]),
            _: 3
        }, 16))
    }
})
  , $m = Se({
    __name: "BCard",
    props: {
        align: {
            default: void 0
        },
        bodyBgVariant: {
            default: void 0
        },
        bodyTextVariant: {
            default: void 0
        },
        bodyClass: {
            default: void 0
        },
        bodyTag: {
            default: "div"
        },
        borderVariant: {
            default: null
        },
        footer: {
            default: void 0
        },
        footerVariant: {
            default: null
        },
        footerBgVariant: {
            default: void 0
        },
        footerBorderVariant: {
            default: void 0
        },
        footerClass: {
            default: void 0
        },
        footerHtml: {
            default: ""
        },
        footerTag: {
            default: "div"
        },
        footerTextVariant: {
            default: void 0
        },
        header: {
            default: void 0
        },
        headerBgVariant: {
            default: void 0
        },
        headerBorderVariant: {
            default: void 0
        },
        headerClass: {
            default: void 0
        },
        headerHtml: {
            default: ""
        },
        headerTag: {
            default: "div"
        },
        headerVariant: {
            default: null
        },
        headerTextVariant: {
            default: void 0
        },
        imgAlt: {
            default: void 0
        },
        imgBottom: {
            type: [String, Boolean],
            default: !1
        },
        imgEnd: {
            type: [String, Boolean],
            default: !1
        },
        imgHeight: {
            default: void 0
        },
        imgSrc: {
            default: void 0
        },
        imgStart: {
            type: [String, Boolean],
            default: !1
        },
        imgTop: {
            type: [String, Boolean],
            default: !1
        },
        imgWidth: {
            default: void 0
        },
        noBody: {
            type: [String, Boolean],
            default: !1
        },
        overlay: {
            type: [String, Boolean],
            default: !1
        },
        subtitle: {
            default: void 0
        },
        subtitleTag: {
            default: "h6"
        },
        subtitleTextVariant: {
            default: "body-secondary"
        },
        tag: {
            default: "div"
        },
        title: {
            default: void 0
        },
        titleTag: {
            default: "h4"
        },
        bodyText: {
            default: ""
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = en()
          , r = H( () => e.imgBottom)
          , a = H( () => e.imgEnd)
          , s = H( () => e.imgStart)
          , l = H( () => e.noBody)
          , i = _e( () => !Mn(n.header))
          , o = _e( () => !Mn(n.footer))
          , u = Nr(e)
          , d = K( () => [u.value, {
            [`text-${e.align}`]: e.align !== void 0,
            [`border-${e.borderVariant}`]: e.borderVariant !== null,
            "flex-row": s.value,
            "flex-row-reverse": a.value
        }])
          , f = K( () => ({
            src: e.imgSrc,
            alt: e.imgAlt,
            height: e.imgHeight,
            width: e.imgWidth,
            bottom: e.imgBottom,
            end: e.imgEnd,
            start: e.imgStart,
            top: e.imgTop
        }));
        return (p, h) => (g(),
        de(qe(p.tag), {
            class: ye(["card", d.value])
        }, {
            default: N( () => [A(r) ? q("", !0) : Z(p.$slots, "img", {
                key: 0
            }, () => [p.imgSrc ? (g(),
            de(rd, ut(Ve({
                key: 0
            }, f.value)), null, 16)) : q("", !0)]), p.header || i.value || p.headerHtml ? (g(),
            de(F_, {
                key: 1,
                "bg-variant": p.headerBgVariant,
                variant: p.headerVariant,
                "border-variant": p.headerBorderVariant,
                html: p.headerHtml,
                tag: p.headerTag,
                "text-variant": p.headerTextVariant,
                class: ye(p.headerClass)
            }, {
                default: N( () => [Z(p.$slots, "header", {}, () => [ve(Q(p.header), 1)])]),
                _: 3
            }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : q("", !0), A(l) ? Z(p.$slots, "default", {
                key: 3
            }, () => [ve(Q(p.bodyText), 1)]) : (g(),
            de(I_, {
                key: 2,
                overlay: p.overlay,
                "bg-variant": p.bodyBgVariant,
                tag: p.bodyTag,
                "text-variant": p.bodyTextVariant,
                subtitle: p.subtitle,
                "subtitle-tag": p.subtitleTag,
                "subtitle-text-variant": p.subtitleTextVariant,
                title: p.title,
                "title-tag": p.titleTag,
                class: ye(p.bodyClass)
            }, {
                default: N( () => [Z(p.$slots, "default", {}, () => [ve(Q(p.bodyText), 1)])]),
                _: 3
            }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])), p.footer || o.value || p.footerHtml ? (g(),
            de(R_, {
                key: 4,
                "bg-variant": p.footerBgVariant,
                "border-variant": p.footerBorderVariant,
                variant: p.footerVariant,
                html: p.footerHtml,
                tag: p.footerTag,
                "text-variant": p.footerTextVariant,
                class: ye(p.footerClass)
            }, {
                default: N( () => [Z(p.$slots, "footer", {}, () => [ve(Q(p.footer), 1)])]),
                _: 3
            }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : q("", !0), A(r) ? Z(p.$slots, "img", {
                key: 5
            }, () => [p.imgSrc ? (g(),
            de(rd, ut(Ve({
                key: 0
            }, f.value)), null, 16)) : q("", !0)]) : q("", !0)]),
            _: 3
        }, 8, ["class"]))
    }
})
  , tD = Se({
    __name: "BCardGroup",
    props: {
        columns: {
            type: [String, Boolean],
            default: !1
        },
        deck: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.columns)
          , r = H( () => e.deck)
          , a = K( () => r.value ? "card-deck" : n.value ? "card-columns" : "card-group");
        return (s, l) => (g(),
        de(qe(s.tag), {
            class: ye(a.value)
        }, {
            default: N( () => [Z(s.$slots, "default")]),
            _: 3
        }, 8, ["class"]))
    }
})
  , nD = Se({
    __name: "BCardText",
    props: {
        text: {
            default: void 0
        },
        tag: {
            default: "p"
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(qe(e.tag), {
            class: "card-text"
        }, {
            default: N( () => [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)])]),
            _: 3
        }))
    }
})
  , rD = ["id"]
  , aD = {
    key: 0,
    class: "carousel-indicators"
}
  , sD = ["aria-current", "aria-label", "onClick"]
  , lD = c("span", {
    class: "carousel-control-prev-icon",
    "aria-hidden": "true"
}, null, -1)
  , iD = {
    class: "visually-hidden"
}
  , oD = c("span", {
    class: "carousel-control-next-icon",
    "aria-hidden": "true"
}, null, -1)
  , uD = {
    class: "visually-hidden"
}
  , dD = Se({
    __name: "BCarousel",
    props: {
        ride: {
            type: [Boolean, String],
            default: !1
        },
        noHoverPause: {
            type: [String, Boolean],
            default: !1
        },
        rideReverse: {
            type: [String, Boolean],
            default: !1
        },
        fade: {
            type: [String, Boolean],
            default: !1
        },
        id: {
            default: void 0
        },
        imgHeight: {
            default: void 0
        },
        imgWidth: {
            default: void 0
        },
        background: {
            default: void 0
        },
        modelValue: {
            default: 0
        },
        controls: {
            type: [String, Boolean],
            default: !1
        },
        indicators: {
            type: [String, Boolean],
            default: !1
        },
        interval: {
            default: 5e3
        },
        noTouch: {
            type: [String, Boolean],
            default: !1
        },
        noWrap: {
            type: [String, Boolean],
            default: !1
        },
        controlsPrevText: {
            default: "Previous"
        },
        controlsNextText: {
            default: "Next"
        },
        indicatorsButtonLabel: {
            default: "Slide"
        },
        keyboard: {
            type: [String, Boolean],
            default: !0
        },
        touchThreshold: {
            default: 50
        }
    },
    emits: ["slid", "slide", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = an( () => r.id, "carousel")
          , l = qt(r, "modelValue", n, {
            passive: !0
        })
          , i = H( () => r.keyboard)
          , o = H( () => r.rideReverse)
          , u = H( () => r.noHoverPause)
          , d = H( () => r.fade)
          , f = H( () => r.controls)
          , p = H( () => r.indicators)
          , h = H( () => r.noTouch)
          , v = H( () => r.noWrap)
          , y = zt( () => r.touchThreshold)
          , k = zt( () => r.interval)
          , w = me(!1)
          , $ = me(!1)
          , M = me(!0)
          , S = me(null)
          , T = me(null)
          , E = me(l.value)
          , O = _m(T)
          , U = K( () => Fk(r.ride) ? nc(r.ride) : r.ride)
          , L = K( () => `carousel-item carousel-item-${M.value ? "prev" : "next"} carousel-item-${M.value ? "end" : "start"}`)
          , C = K( () => `carousel-item active carousel-item-${M.value ? "start" : "end"}`)
          , {pause: W, resume: R} = k_( () => {
            o.value ? ne() : I()
        }
        , k, {
            immediate: U.value === "carousel"
        })
          , G = K( () => U.value === !0 && $.value === !0 || U.value === "carousel")
          , te = K( () => wp(a.default, "BCarouselSlide"))
          , J = K( () => ({
            "carousel-fade": d.value
        }))
          , ae = ee => {
            var B;
            return new MM(ee,{
                componentId: s.value,
                cancelable: !1,
                target: T.value,
                direction: M.value ? "right" : "left",
                from: E.value,
                to: l.value,
                relatedTarget: ((B = S.value) == null ? void 0 : B.children[l.value]) ?? null
            })
        }
          , oe = ee => {
            if (w.value !== !0) {
                if (U.value === !0 && ($.value = !0),
                G.value === !0 && R(),
                M.value = !(ee < l.value),
                ee >= te.value.length) {
                    if (v.value)
                        return;
                    l.value = 0;
                    return
                }
                if (ee < 0) {
                    if (v.value)
                        return;
                    l.value = te.value.length - 1;
                    return
                }
                E.value = l.value,
                l.value = ee
            }
        }
          , ne = () => {
            oe(l.value - 1)
        }
          , I = () => {
            oe(l.value + 1)
        }
          , j = ee => {
            i.value !== !1 && ee()
        }
          , re = () => {
            u.value || W()
        }
          , le = () => {
            G.value && R()
        }
          , {lengthX: ce} = pN(T, {
            passive: !0,
            onSwipeStart() {
                h.value !== !0 && W()
            },
            onSwipeEnd() {
                if (h.value === !0)
                    return;
                const ee = () => {
                    G.value !== !1 && R()
                }
                ;
                if (ce.value >= y.value) {
                    I(),
                    ee();
                    return
                }
                ce.value <= -y.value && (ne(),
                ee())
            }
        })
          , xe = () => {
            n("slide", ae("slide")),
            w.value = !0
        }
          , X = () => {
            n("slid", ae("slid")),
            w.value = !1
        }
          , be = ee => {
            l.value !== 0 && ee.classList.add("carousel-item")
        }
        ;
        return Cr("ArrowLeft", () => {
            j(ne)
        }
        , {
            target: T
        }),
        Cr("ArrowRight", () => {
            j(I)
        }
        , {
            target: T
        }),
        Ke( () => r.ride, () => {
            $.value = !1
        }
        ),
        Ke(O, ee => {
            if (ee) {
                re();
                return
            }
            le()
        }
        ),
        e({
            pause: W,
            resume: R,
            prev: ne,
            next: I
        }),
        zn(qk, {
            background: _e( () => r.background),
            width: _e( () => r.imgWidth),
            height: _e( () => r.imgHeight)
        }),
        (ee, B) => (g(),
        _("div", {
            id: A(s),
            ref_key: "element",
            ref: T,
            class: ye(["carousel slide pointer-event", J.value])
        }, [A(p) ? (g(),
        _("div", aD, [(g(!0),
        _(we, null, Ne(te.value.length, (se, pe) => (g(),
        _("button", {
            key: pe,
            type: "button",
            "data-bs-target": "",
            class: ye(pe === A(l) ? "active" : ""),
            "aria-current": pe === A(l) ? !0 : void 0,
            "aria-label": `${ee.indicatorsButtonLabel} ${pe}`,
            onClick: ie => oe(pe)
        }, null, 10, sD))), 128))])) : q("", !0), c("div", {
            ref_key: "relatedTarget",
            ref: S,
            class: "carousel-inner"
        }, [x(p2, {
            "enter-from-class": L.value,
            "enter-active-class": L.value,
            "enter-to-class": L.value,
            "leave-from-class": C.value,
            "leave-active-class": C.value,
            "leave-to-class": C.value,
            onBeforeLeave: xe,
            onAfterLeave: X,
            onAfterEnter: be
        }, {
            default: N( () => [(g(!0),
            _(we, null, Ne(te.value, (se, pe) => ft((g(),
            de(qe(se), {
                key: pe,
                class: ye({
                    active: pe === A(l) && w.value === !1
                })
            }, null, 8, ["class"])), [[jn, pe === A(l)]])), 128))]),
            _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])], 512), A(f) ? (g(),
        _(we, {
            key: 1
        }, [c("button", {
            class: "carousel-control-prev",
            type: "button",
            onClick: ne
        }, [lD, c("span", iD, Q(ee.controlsPrevText), 1)]), c("button", {
            class: "carousel-control-next",
            type: "button",
            onClick: I
        }, [oD, c("span", uD, Q(ee.controlsNextText), 1)])], 64)) : q("", !0)], 10, rD))
    }
})
  , cD = ["innerHTML"]
  , fD = {
    key: 1
}
  , pD = ["innerHTML"]
  , hD = {
    key: 1
}
  , mD = Se({
    __name: "BCarouselSlide",
    props: {
        imgSrc: {
            default: void 0
        },
        imgHeight: {
            default: void 0
        },
        imgWidth: {
            default: void 0
        },
        interval: {
            default: void 0
        },
        background: {
            default: void 0
        },
        caption: {
            default: void 0
        },
        captionHtml: {
            default: void 0
        },
        captionTag: {
            default: "h3"
        },
        contentTag: {
            default: "div"
        },
        contentVisibleUp: {
            default: void 0
        },
        id: {
            default: void 0
        },
        imgSrcset: {
            default: void 0
        },
        imgAlt: {
            default: void 0
        },
        imgBlank: {
            type: [String, Boolean],
            default: !1
        },
        imgBlankColor: {
            default: "transparent"
        },
        text: {
            default: void 0
        },
        textHtml: {
            default: void 0
        },
        textTag: {
            default: "p"
        }
    },
    setup(t) {
        const e = t
          , n = en()
          , r = Gt(qk, null)
          , a = _e( () => e.text || e.textHtml || !Mn(n.text))
          , s = _e( () => e.caption || e.captionHtml || !Mn(n.caption))
          , l = _e( () => a.value || s.value || !Mn(n.default))
          , i = K( () => ({
            background: `${e.background || (r == null ? void 0 : r.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
        }))
          , o = K( () => ({
            "d-none": e.contentVisibleUp !== void 0,
            [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0
        }));
        return (u, d) => (g(),
        _("div", {
            class: "carousel-item",
            style: Rt(i.value)
        }, [Z(u.$slots, "img", {}, () => {
            var f, p;
            return [x(Sm, {
                class: "d-block w-100",
                alt: u.imgAlt,
                srcset: u.imgSrcset,
                src: u.imgSrc,
                width: u.imgWidth || ((f = A(r)) == null ? void 0 : f.width.value),
                height: u.imgHeight || ((p = A(r)) == null ? void 0 : p.height.value),
                blank: u.imgBlank,
                "blank-color": u.imgBlankColor
            }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])]
        }
        ), l.value ? (g(),
        de(qe(u.contentTag), {
            key: 0,
            class: ye(["carousel-caption", o.value])
        }, {
            default: N( () => [s.value ? (g(),
            de(qe(u.captionTag), {
                key: 0
            }, {
                default: N( () => [Z(u.$slots, "caption", {}, () => [u.captionHtml ? (g(),
                _("span", {
                    key: 0,
                    innerHTML: u.captionHtml
                }, null, 8, cD)) : (g(),
                _("span", fD, Q(u.caption), 1))])]),
                _: 3
            })) : q("", !0), a.value ? (g(),
            de(qe(u.textTag), {
                key: 1
            }, {
                default: N( () => [Z(u.$slots, "text", {}, () => [u.textHtml ? (g(),
                _("span", {
                    key: 0,
                    innerHTML: u.textHtml
                }, null, 8, pD)) : (g(),
                _("span", hD, Q(u.text), 1))])]),
                _: 3
            })) : q("", !0), Z(u.$slots, "default")]),
            _: 3
        }, 8, ["class"])) : q("", !0)], 4))
    }
})
  , Sb = rc("", [], {
    type: [Boolean, String, Number],
    default: !1
})
  , $b = rc("offset", [""], {
    type: [String, Number],
    default: null
})
  , Tb = rc("order", [""], {
    type: [String, Number],
    default: null
})
  , vD = Se({
    name: "BCol",
    slots: Object,
    props: {
        col: {
            type: [Boolean, String],
            default: !1
        },
        cols: {
            type: [String, Number],
            default: null
        },
        ...Sb,
        offset: {
            type: [String, Number],
            default: null
        },
        ...$b,
        order: {
            type: [String, Number],
            default: null
        },
        ...Tb,
        alignSelf: {
            type: String,
            default: null
        },
        tag: {
            type: String,
            default: "div"
        }
    },
    setup(t) {
        const e = [{
            content: Sb,
            propPrefix: "cols",
            classPrefix: "col"
        }, {
            content: $b,
            propPrefix: "offset"
        }, {
            content: Tb,
            propPrefix: "order"
        }]
          , n = H( () => t.col)
          , r = K( () => e.flatMap(a => Kk(t, a.content, a.propPrefix, a.classPrefix)));
        return {
            computedClasses: K( () => [r.value, {
                col: n.value || !r.value.some(a => /^col-/.test(a)) && !t.cols,
                [`col-${t.cols}`]: !!t.cols,
                [`offset-${t.offset}`]: !!t.offset,
                [`order-${t.order}`]: !!t.order,
                [`align-self-${t.alignSelf}`]: !!t.alignSelf
            }])
        }
    }
});
function gD(t, e, n, r, a, s) {
    return g(),
    de(qe(t.tag), {
        class: ye(t.computedClasses)
    }, {
        default: N( () => [Z(t.$slots, "default")]),
        _: 3
    }, 8, ["class"])
}
const zi = oc(vD, [["render", gD]])
  , bD = Se({
    __name: "BContainer",
    props: {
        gutterX: {
            default: void 0
        },
        gutterY: {
            default: void 0
        },
        fluid: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        }
    },
    setup(t) {
        const e = t
          , n = zt(_e( () => e.gutterX ?? NaN), {
            method: "parseInt"
        })
          , r = zt(_e( () => e.gutterY ?? NaN), {
            method: "parseInt"
        })
          , a = K( () => Fk(e.fluid) ? nc(e.fluid) : e.fluid)
          , s = K( () => ({
            container: a.value === !1,
            "container-fluid": a.value === !0,
            [`container-${a.value}`]: typeof a.value == "string",
            [`gx-${n.value}`]: !Number.isNaN(n.value),
            [`gy-${r.value}`]: !Number.isNaN(r.value)
        }));
        return (l, i) => (g(),
        de(qe(l.tag), {
            class: ye(s.value)
        }, {
            default: N( () => [Z(l.$slots, "default")]),
            _: 3
        }, 8, ["class"]))
    }
})
  , yD = {
    class: "visually-hidden"
}
  , kD = ["aria-labelledby", "role"]
  , L_ = Se({
    __name: "BDropdown",
    props: {
        ariaLabel: {
            default: void 0
        },
        id: {
            default: void 0
        },
        menuClass: {
            default: void 0
        },
        size: {
            default: "md"
        },
        splitClass: {
            default: void 0
        },
        splitVariant: {
            default: void 0
        },
        text: {
            default: void 0
        },
        toggleClass: {
            default: void 0
        },
        autoClose: {
            type: [Boolean, String],
            default: !0
        },
        block: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        isNav: {
            type: [String, Boolean],
            default: !1
        },
        dropup: {
            type: [String, Boolean],
            default: !1
        },
        dropend: {
            type: [String, Boolean],
            default: !1
        },
        dropstart: {
            type: [String, Boolean],
            default: !1
        },
        center: {
            type: [String, Boolean],
            default: !1
        },
        end: {
            type: [String, Boolean],
            default: !1
        },
        noFlip: {
            type: [String, Boolean],
            default: !1
        },
        noShift: {
            type: [String, Boolean],
            default: !1
        },
        offset: {
            default: 0
        },
        role: {
            default: "menu"
        },
        split: {
            type: [String, Boolean],
            default: !1
        },
        splitButtonType: {
            default: "button"
        },
        splitHref: {
            default: void 0
        },
        splitDisabled: {
            type: [String, Boolean],
            default: void 0
        },
        noCaret: {
            type: [String, Boolean],
            default: !1
        },
        toggleText: {
            default: "Toggle dropdown"
        },
        variant: {
            default: "secondary"
        },
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        strategy: {
            default: "absolute"
        },
        floatingMiddleware: {
            default: void 0
        },
        splitTo: {
            default: void 0
        },
        boundary: {
            default: "clippingAncestors"
        },
        container: {
            default: void 0
        }
    },
    emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = an( () => r.id, "dropdown")
          , s = qt(r, "modelValue", n, {
            passive: !0
        })
          , l = H(s)
          , i = H( () => r.block)
          , o = H( () => r.dropup)
          , u = H( () => r.dropend)
          , d = H( () => r.isNav)
          , f = H( () => r.dropstart)
          , p = H( () => r.center)
          , h = H( () => r.end)
          , v = H( () => r.split)
          , y = H( () => r.noCaret)
          , k = H( () => r.noFlip)
          , w = H( () => r.noShift)
          , $ = H( () => r.lazy)
          , M = H( () => r.splitDisabled)
          , S = _e( () => typeof r.offset == "string" || typeof r.offset == "number" ? r.offset : NaN)
          , T = zt(S)
          , E = me(null)
          , O = me(null)
          , U = me(null)
          , L = me(null)
          , C = K( () => r.boundary === "document" || r.boundary === "viewport" ? void 0 : r.boundary)
          , W = K( () => r.boundary === "document" || r.boundary === "viewport" ? r.boundary : void 0)
          , R = _e( () => v.value ? O.value : U.value);
        Cr("Escape", () => {
            s.value = !l
        }
        , {
            target: R
        }),
        Cr("Escape", () => {
            s.value = !l
        }
        , {
            target: E
        });
        const G = (be, ee) => {
            var B, se, pe, ie;
            if (be.preventDefault(),
            !l.value) {
                xe(),
                Ot( () => G(be, ee));
                return
            }
            const fe = (B = E.value) == null ? void 0 : B.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
            if (fe)
                if ((se = E.value) != null && se.contains(document.activeElement)) {
                    const F = E.value.querySelector(".dropdown-item:focus")
                      , z = Array.prototype.indexOf.call(fe, F) + ee;
                    z >= 0 && z < (fe == null ? void 0 : fe.length) && ((pe = fe[z]) == null || pe.focus())
                } else
                    (ie = fe[ee === -1 ? fe.length - 1 : 0]) == null || ie.focus()
        }
        ;
        Cr("ArrowUp", be => G(be, -1), {
            target: R
        }),
        Cr("ArrowDown", be => G(be, 1), {
            target: R
        }),
        Cr("ArrowUp", be => G(be, -1), {
            target: E
        }),
        Cr("ArrowDown", be => G(be, 1), {
            target: E
        });
        const te = K( () => CN({
            top: o.value,
            start: f.value,
            end: u.value,
            alignCenter: p.value,
            alignEnd: h.value
        }))
          , J = K( () => {
            if (r.floatingMiddleware !== void 0)
                return r.floatingMiddleware;
            const be = typeof r.offset == "string" || typeof r.offset == "number" ? T.value : r.offset
              , ee = [l_(be)];
            return k.value === !1 && ee.push(a_({
                boundary: C.value,
                rootBoundary: W.value
            })),
            w.value === !1 && ee.push(i_({
                boundary: C.value,
                rootBoundary: W.value
            })),
            ee
        }
        )
          , {update: ae, floatingStyles: oe} = g_(R, E, {
            placement: te,
            middleware: J,
            strategy: Hn(_e(r, "strategy")),
            whileElementsMounted: m_
        })
          , ne = K( () => ({
            "d-grid": i.value,
            dropup: o.value,
            dropend: u.value,
            dropstart: f.value,
            "d-flex": i.value && v.value,
            "position-static": r.boundary !== "clippingAncestors" && !d.value
        }))
          , I = K( () => [v.value ? r.splitClass : r.toggleClass, {
            "nav-link": d.value,
            "dropdown-toggle": !v.value,
            "dropdown-toggle-no-caret": y.value && !v.value,
            "w-100": v.value && i.value,
            show: v.value ? void 0 : l.value
        }])
          , j = () => {
            X()
        }
          , re = be => {
            v.value ? n("click", be) : j()
        }
        ;
        __(E, () => {
            l.value && (r.autoClose === !0 || r.autoClose === "outside") && X()
        }
        , {
            ignore: [O, U]
        });
        const le = () => {
            l.value && (r.autoClose === !0 || r.autoClose === "inside") && X()
        }
          , ce = () => {
            s.value && X()
        }
          , xe = () => {
            s.value || X()
        }
          , X = () => {
            var be;
            n("toggle");
            const ee = l.value
              , B = new Wo(ee ? "hide" : "show");
            if (n(ee ? "hide" : "show", B),
            B.defaultPrevented) {
                n(ee ? "hide-prevented" : "show-prevented");
                return
            }
            s.value = !ee,
            n(ee ? "hidden" : "shown"),
            (be = L.value) == null || be.dispatchEvent(new Event("forceHide"))
        }
        ;
        return Ke(l, ae),
        e({
            close: ce,
            open: xe,
            toggle: X
        }),
        zn(e_, {
            id: a,
            open: xe,
            close: ce,
            toggle: X,
            visible: l,
            isNav: d
        }),
        (be, ee) => (g(),
        _("div", {
            ref_key: "wrapper",
            ref: L,
            class: ye([ne.value, "btn-group"])
        }, [x(is, {
            id: A(a),
            ref_key: "splitButton",
            ref: U,
            variant: be.splitVariant || be.variant,
            size: be.size,
            class: ye(I.value),
            disabled: A(M) || be.disabled,
            type: be.splitButtonType,
            "aria-label": be.ariaLabel,
            "aria-expanded": A(v) ? void 0 : A(l),
            "aria-haspopup": A(v) ? void 0 : "menu",
            href: A(v) ? be.splitHref : void 0,
            to: A(v) && be.splitTo ? be.splitTo : void 0,
            onClick: re
        }, {
            default: N( () => [Z(be.$slots, "button-content", {}, () => [ve(Q(be.text), 1)])]),
            _: 3
        }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]), A(v) ? (g(),
        de(is, {
            key: 0,
            ref_key: "button",
            ref: O,
            variant: be.variant,
            size: be.size,
            disabled: be.disabled,
            class: ye([[be.toggleClass, A(l) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
            "aria-expanded": A(l),
            "aria-haspopup": "menu",
            onClick: j
        }, {
            default: N( () => [c("span", yD, [Z(be.$slots, "toggle-text", {}, () => [ve(Q(be.toggleText), 1)])])]),
            _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : q("", !0), x(ic, {
            tag: "Teleport",
            to: be.container,
            skip: !be.container
        }, {
            default: N( () => [!A($) || A(l) ? ft((g(),
            _("ul", {
                key: 0,
                ref_key: "floating",
                ref: E,
                style: Rt(A(oe)),
                class: ye(["dropdown-menu show", be.menuClass]),
                "aria-labelledby": A(a),
                role: be.role,
                onClick: le
            }, [Z(be.$slots, "default", {
                hide: ce,
                show: xe
            })], 14, kD)), [[jn, A($) || A(l)]]) : q("", !0)]),
            _: 3
        }, 8, ["to", "skip"])], 2))
    }
})
  , _D = {
    role: "presentation"
}
  , wD = Se({
    __name: "BDropdownDivider",
    props: {
        tag: {
            default: "hr"
        }
    },
    setup(t) {
        return (e, n) => (g(),
        _("li", _D, [(g(),
        de(qe(e.tag), {
            class: "dropdown-divider",
            role: "separator",
            "aria-orientation": "horizontal"
        }))]))
    }
})
  , xD = {
    role: "presentation"
}
  , SD = {
    class: "px-4 py-3"
}
  , $D = Se({
    __name: "BDropdownForm",
    setup(t) {
        return (e, n) => (g(),
        _("li", xD, [c("form", SD, [Z(e.$slots, "default")])]))
    }
})
  , TD = {
    role: "presentation"
}
  , CD = ["id", "aria-describedby"]
  , ED = Se({
    inheritAttrs: !1,
    __name: "BDropdownGroup",
    props: {
        id: {
            default: void 0
        },
        ariaDescribedby: {
            default: void 0
        },
        header: {
            default: void 0
        },
        headerClass: {
            default: void 0
        },
        headerTag: {
            default: "header"
        },
        headerVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = _e( () => e.id ? `${e.id}_group_dd_header` : void 0)
          , r = _e( () => e.headerTag === "header" ? void 0 : "heading")
          , a = K( () => [e.headerClass, {
            [`text-${e.headerVariant}`]: e.headerVariant !== null
        }]);
        return (s, l) => (g(),
        _("li", TD, [(g(),
        de(qe(s.headerTag), {
            id: n.value,
            class: ye(["dropdown-header", a.value]),
            role: r.value
        }, {
            default: N( () => [Z(s.$slots, "header", {}, () => [ve(Q(s.header), 1)])]),
            _: 3
        }, 8, ["id", "class", "role"])), c("ul", Ve({
            id: s.id,
            role: "group",
            class: "list-unstyled"
        }, s.$attrs, {
            "aria-describedby": s.ariaDescribedby || n.value
        }), [Z(s.$slots, "default")], 16, CD)]))
    }
})
  , AD = {
    class: "dropdown-header"
}
  , MD = Se({
    __name: "BDropdownHeader",
    setup(t) {
        return (e, n) => (g(),
        _("li", null, [c("h6", AD, [Z(e.$slots, "default")])]))
    }
})
  , OD = {
    role: "presentation"
}
  , ND = Se({
    inheritAttrs: !1,
    __name: "BDropdownItem",
    props: {
        linkClass: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean]
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {},
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean]
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.active)
          , a = H( () => n.disabled)
          , {computedLink: s, computedLinkProps: l} = gl(n)
          , i = K( () => [n.linkClass, {
            active: r.value,
            disabled: a.value,
            [`text-${n.variant}`]: n.variant !== null
        }])
          , o = _e( () => s.value ? ha : n.href ? "a" : "button")
          , u = Gt(pm, null)
          , d = Gt(e_, null)
          , f = Gt(hm, null)
          , p = h => {
            var v, y, k;
            e("click", h),
            f !== null && ((v = f == null ? void 0 : f.autoClose) == null ? void 0 : v.value) === !0 && ((y = u == null ? void 0 : u.close) == null || y.call(u)),
            (k = d == null ? void 0 : d.close) == null || k.call(d)
        }
        ;
        return (h, v) => (g(),
        _("li", OD, [(g(),
        de(qe(o.value), Ve({
            class: ["dropdown-item", i.value],
            disabled: A(a),
            "aria-disabled": A(a) ? !0 : null,
            "aria-current": A(r) ? !0 : null,
            href: o.value === "a" ? h.href : null,
            rel: h.rel,
            role: "menuitem",
            type: o.value === "button" ? "button" : null,
            target: h.target
        }, A(l), {
            onClick: p
        }), {
            default: N( () => [Z(h.$slots, "default")]),
            _: 3
        }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))]))
    }
})
  , DD = {
    role: "presentation"
}
  , PD = ["disabled"]
  , FD = Se({
    inheritAttrs: !1,
    __name: "BDropdownItemButton",
    props: {
        buttonClass: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: !1
        },
        activeClass: {
            default: "active"
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        variant: {
            default: null
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.active)
          , a = H( () => n.disabled)
          , s = K( () => [n.buttonClass, {
            [n.activeClass]: r.value,
            disabled: a.value,
            [`text-${n.variant}`]: n.variant !== null
        }])
          , l = i => {
            e("click", i)
        }
        ;
        return (i, o) => (g(),
        _("li", DD, [c("button", {
            role: "menu",
            type: "button",
            class: ye(["dropdown-item", s.value]),
            disabled: A(a),
            onClick: l
        }, [Z(i.$slots, "default")], 10, PD)]))
    }
})
  , BD = {
    role: "presentation"
}
  , VD = {
    class: "px-4 py-1 mb-0 text-body-secondary"
}
  , ID = Se({
    __name: "BDropdownText",
    props: {
        text: {
            default: ""
        }
    },
    setup(t) {
        return (e, n) => (g(),
        _("li", BD, [c("p", VD, [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)])])]))
    }
})
  , RD = ["id", "novalidate", "onSubmit"]
  , j_ = Se({
    __name: "BForm",
    props: {
        id: {
            default: void 0
        },
        floating: {
            type: [String, Boolean],
            default: !1
        },
        novalidate: {
            type: [String, Boolean],
            default: !1
        },
        validated: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["submit"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = me(null)
          , s = H( () => r.floating)
          , l = H( () => r.novalidate)
          , i = H( () => r.validated)
          , o = K( () => ({
            "form-floating": s.value,
            "was-validated": i.value
        }))
          , u = d => {
            n("submit", d)
        }
        ;
        return e({
            element: a
        }),
        (d, f) => (g(),
        _("form", {
            id: d.id,
            ref_key: "element",
            ref: a,
            novalidate: A(l),
            class: ye(o.value),
            onSubmit: _t(u, ["prevent"])
        }, [Z(d.$slots, "default")], 42, RD))
    }
})
  , LD = {
    class: "form-floating"
}
  , jD = ["for"]
  , UD = Se({
    __name: "BFormFloatingLabel",
    props: {
        labelFor: {
            default: void 0
        },
        label: {
            default: void 0
        },
        text: {
            default: void 0
        }
    },
    setup(t) {
        return (e, n) => (g(),
        _("div", LD, [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)]), c("label", {
            for: e.labelFor
        }, [Z(e.$slots, "label", {}, () => [ve(Q(e.label), 1)])], 8, jD)]))
    }
})
  , Cp = Se({
    __name: "BFormInvalidFeedback",
    props: {
        ariaLive: {
            default: void 0
        },
        forceShow: {
            type: [String, Boolean],
            default: !1
        },
        text: {
            default: void 0
        },
        id: {
            default: void 0
        },
        role: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        tag: {
            default: "div"
        },
        tooltip: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.forceShow)
          , r = H( () => e.state)
          , a = H( () => e.tooltip)
          , s = _e( () => n.value === !0 || r.value === !1)
          , l = K( () => ({
            "d-block": s.value,
            "invalid-feedback": !a.value,
            "invalid-tooltip": a.value
        }));
        return (i, o) => (g(),
        de(qe(i.tag), {
            id: i.id,
            role: i.role,
            "aria-live": i.ariaLive,
            "aria-atomic": i.ariaLive ? !0 : void 0,
            class: ye(l.value)
        }, {
            default: N( () => [Z(i.$slots, "default", {}, () => [ve(Q(i.text), 1)])]),
            _: 3
        }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]))
    }
})
  , Fu = Se({
    __name: "BFormRow",
    props: {
        tag: {
            default: "div"
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(qe(e.tag), {
            class: "row d-flex flex-wrap"
        }, {
            default: N( () => [Z(e.$slots, "default")]),
            _: 3
        }))
    }
})
  , Ep = Se({
    __name: "BFormText",
    props: {
        id: {
            default: void 0
        },
        inline: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "small"
        },
        text: {
            default: void 0
        },
        textVariant: {
            default: "body-secondary"
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.inline)
          , r = K( () => ({
            [`text-${e.textVariant}`]: e.textVariant !== null,
            "form-text": !n.value
        }));
        return (a, s) => (g(),
        de(qe(a.tag), {
            id: a.id,
            class: ye(r.value)
        }, {
            default: N( () => [Z(a.$slots, "default", {}, () => [ve(Q(a.text), 1)])]),
            _: 3
        }, 8, ["id", "class"]))
    }
})
  , Ap = Se({
    __name: "BFormValidFeedback",
    props: {
        ariaLive: {
            default: void 0
        },
        forceShow: {
            type: [String, Boolean],
            default: !1
        },
        text: {
            default: void 0
        },
        id: {
            default: void 0
        },
        role: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        tag: {
            default: "div"
        },
        tooltip: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.forceShow)
          , r = H( () => e.state)
          , a = H( () => e.tooltip)
          , s = _e( () => n.value === !0 || r.value === !0)
          , l = K( () => ({
            "d-block": s.value,
            "valid-feedback": !a.value,
            "valid-tooltip": a.value
        }));
        return (i, o) => (g(),
        de(qe(i.tag), {
            id: i.id,
            role: i.role,
            "aria-live": i.ariaLive,
            "aria-atomic": i.ariaLive ? !0 : void 0,
            class: ye(l.value)
        }, {
            default: N( () => [Z(i.$slots, "default", {}, () => [ve(Q(i.text), 1)])]),
            _: 3
        }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]))
    }
})
  , HD = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"]
  , KD = ["for"]
  , $s = Se({
    inheritAttrs: !1,
    __name: "BFormCheckbox",
    props: {
        ariaLabel: {
            default: void 0
        },
        ariaLabelledBy: {
            default: void 0
        },
        form: {
            default: void 0
        },
        indeterminate: {
            type: [String, Boolean],
            default: void 0
        },
        name: {
            default: void 0
        },
        id: {
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        plain: {
            type: [String, Boolean],
            default: !1
        },
        button: {
            type: [String, Boolean],
            default: !1
        },
        buttonGroup: {
            type: [String, Boolean],
            default: !1
        },
        switch: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        buttonVariant: {
            default: null
        },
        inline: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: void 0
        },
        size: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        uncheckedValue: {
            type: [Array, Set, Boolean, String, Object, Number, null],
            default: void 0
        },
        value: {
            type: [Array, Set, Boolean, String, Object, Number, null],
            default: !0
        },
        modelValue: {
            type: [Array, Set, Boolean, String, Object, Number, null],
            default: void 0
        }
    },
    emits: ["update:modelValue", "input", "change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = qt(r, "modelValue", n, {
            passive: !0
        })
          , l = an( () => r.id, "form-check")
          , i = H( () => r.indeterminate)
          , o = H( () => r.autofocus)
          , u = H( () => r.plain)
          , d = H( () => r.button)
          , f = H( () => r.buttonGroup)
          , p = H( () => r.switch)
          , h = H( () => r.disabled)
          , v = H( () => r.inline)
          , y = H( () => r.required)
          , k = H( () => r.state)
          , w = Gt(Qk, null)
          , $ = me(null)
          , {focused: M} = ar($, {
            initialValue: o.value
        })
          , S = _e( () => !Mn(a.default));
        let T = !1;
        const E = K({
            get: () => {
                var G;
                return w !== null ? w.modelValue.value.map(te => JSON.stringify(te)).includes(JSON.stringify(r.value)) : Array.isArray(s.value) ? (G = s.value) == null ? void 0 : G.map(te => JSON.stringify(te)).includes(JSON.stringify(r.value)) : JSON.stringify(s.value) === JSON.stringify(r.value)
            }
            ,
            set: G => {
                const te = G ? r.value : r.uncheckedValue === void 0 && r.value !== !1 ? !1 : r.uncheckedValue;
                n("input", te),
                w === null && Array.isArray(s.value) ? G ? (s.value.push(r.value),
                r.uncheckedValue !== void 0 && (s.value = s.value.filter(J => JSON.stringify(J) !== JSON.stringify(r.uncheckedValue)))) : (r.uncheckedValue !== void 0 && s.value.push(r.uncheckedValue),
                s.value = s.value.filter(J => JSON.stringify(J) !== JSON.stringify(r.value))) : w !== null ? (T = !0,
                s.value = te,
                G === !1 ? w.remove(r.value) : w.set(r.value)) : s.value = te,
                Ot( () => {
                    n("change", te),
                    T = !1
                }
                )
            }
        });
        Ke(s, G => {
            if (T) {
                T = !1;
                return
            }
            w !== null && ((G === r.value || G === !0) && E.value !== !0 ? E.value = !0 : (G === r.uncheckedValue || G === !1) && E.value !== !1 && (E.value = !1))
        }
        );
        const O = K( () => !!(r.name ?? (w == null ? void 0 : w.name.value)) && (y.value || (w == null ? void 0 : w.required.value)))
          , U = _e( () => f.value || ((w == null ? void 0 : w.buttons.value) ?? !1))
          , L = K( () => ({
            plain: u.value || ((w == null ? void 0 : w.plain.value) ?? !1),
            button: d.value || ((w == null ? void 0 : w.buttons.value) ?? !1),
            inline: v.value || ((w == null ? void 0 : w.inline.value) ?? !1),
            switch: p.value || ((w == null ? void 0 : w.switch.value) ?? !1),
            state: k.value || (w == null ? void 0 : w.state.value),
            size: r.size !== void 0 ? r.size : (w == null ? void 0 : w.size.value) ?? "md",
            buttonVariant: r.buttonVariant !== null ? r.buttonVariant : (w == null ? void 0 : w.buttonVariant.value) ?? "secondary"
        }))
          , C = S_(L)
          , W = $_(L)
          , R = T_(L);
        return e({
            element: $,
            focus: () => {
                M.value = !0
            }
            ,
            blur: () => {
                M.value = !1
            }
        }),
        (G, te) => (g(),
        de(ic, {
            skip: U.value,
            class: ye(A(C))
        }, {
            default: N( () => {
                var J, ae, oe;
                return [ft(c("input", Ve({
                    id: A(l)
                }, G.$attrs, {
                    ref_key: "input",
                    ref: $,
                    "onUpdate:modelValue": te[0] || (te[0] = ne => E.value = ne),
                    class: A(W),
                    type: "checkbox",
                    disabled: A(h) || ((J = A(w)) == null ? void 0 : J.disabled.value),
                    required: O.value || void 0,
                    name: G.name || ((ae = A(w)) == null ? void 0 : ae.name.value),
                    form: G.form || ((oe = A(w)) == null ? void 0 : oe.form.value),
                    "aria-label": G.ariaLabel,
                    "aria-labelledby": G.ariaLabelledBy,
                    "aria-required": O.value || void 0,
                    value: G.value,
                    indeterminate: A(i)
                }), null, 16, HD), [[y2, E.value]]), S.value || A(u) === !1 ? (g(),
                _("label", {
                    key: 0,
                    for: A(l),
                    class: ye(A(R))
                }, [Z(G.$slots, "default")], 10, KD)) : q("", !0)]
            }
            ),
            _: 3
        }, 8, ["skip", "class"]))
    }
})
  , zD = ["id"]
  , qD = ["innerHTML"]
  , WD = ["textContent"]
  , uc = Se({
    __name: "BFormCheckboxGroup",
    props: {
        id: {
            default: void 0
        },
        form: {
            default: void 0
        },
        modelValue: {
            default: () => []
        },
        ariaInvalid: {
            type: [String, Boolean],
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        buttonVariant: {
            default: "secondary"
        },
        buttons: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        disabledField: {
            default: "disabled"
        },
        htmlField: {
            default: "html"
        },
        name: {
            default: void 0
        },
        options: {
            default: () => []
        },
        plain: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        size: {
            default: "md"
        },
        stacked: {
            type: [String, Boolean],
            default: !1
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        switches: {
            type: [String, Boolean],
            default: !1
        },
        textField: {
            default: "text"
        },
        validated: {
            type: [String, Boolean],
            default: !1
        },
        valueField: {
            default: "value"
        }
    },
    emits: ["input", "update:modelValue", "change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = qt(r, "modelValue", n)
          , s = an( () => r.id, "checkbox")
          , l = an( () => r.name, "checkbox")
          , i = H( () => r.autofocus)
          , o = H( () => r.buttons)
          , u = H( () => r.disabled)
          , d = H( () => r.plain)
          , f = H( () => r.required)
          , p = H( () => r.stacked)
          , h = H( () => r.state)
          , v = H( () => r.switches)
          , y = H( () => r.validated)
          , k = me(null)
          , {focused: w} = ar(k, {
            initialValue: i.value
        });
        zn(Qk, {
            set: E => {
                let O = [...a.value];
                O = O.filter(U => JSON.stringify(U) !== JSON.stringify(E)),
                O.push(E),
                n("input", O),
                a.value = O,
                Ot( () => {
                    n("change", O)
                }
                )
            }
            ,
            remove: E => {
                let O = [...a.value];
                O = O.filter(U => JSON.stringify(U) !== JSON.stringify(E)),
                n("input", O),
                a.value = O,
                Ot( () => {
                    n("change", O)
                }
                )
            }
            ,
            modelValue: _e( () => a.value),
            switch: v,
            buttonVariant: _e( () => r.buttonVariant),
            form: _e( () => r.form),
            name: l,
            state: h,
            plain: d,
            size: _e( () => r.size),
            inline: _e( () => !p.value),
            required: f,
            buttons: o,
            disabled: u
        });
        const $ = K( () => r.options.map( (E, O) => typeof E == "string" || typeof E == "number" ? {
            props: {
                value: E,
                disabled: u.value
            },
            text: E.toString(),
            html: void 0,
            self: Symbol(`checkboxGroupOptionItem${O}`)
        } : {
            props: {
                value: E[r.valueField],
                disabled: E[r.disabledField],
                ...E.props ? E.props : {}
            },
            text: E[r.textField],
            html: E[r.htmlField],
            self: Symbol(`checkboxGroupOptionItem${O}`)
        }))
          , M = K( () => ({
            required: f.value,
            ariaInvalid: r.ariaInvalid,
            state: h.value,
            validated: y.value,
            buttons: o.value,
            stacked: p.value,
            size: r.size
        }))
          , S = C_(M)
          , T = E_(M);
        return e({
            focus: () => {
                w.value = !0
            }
            ,
            blur: () => {
                w.value = !1
            }
        }),
        (E, O) => (g(),
        _("div", Ve(A(S), {
            id: A(s),
            ref_key: "element",
            ref: k,
            role: "group",
            class: [A(T), "bv-no-focus-ring"],
            tabindex: "-1"
        }), [Z(E.$slots, "first"), (g(!0),
        _(we, null, Ne($.value, U => (g(),
        de($s, Ve({
            key: U.self
        }, U.props), {
            default: N( () => [U.html ? (g(),
            _("span", {
                key: 0,
                innerHTML: U.html
            }, null, 8, qD)) : (g(),
            _("span", {
                key: 1,
                textContent: Q(U.text)
            }, null, 8, WD))]),
            _: 2
        }, 1040))), 128)), Z(E.$slots, "default")], 16, zD))
    }
})
  , GD = ["for"]
  , YD = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-required", "directory", "webkitdirectory"]
  , JD = Se({
    inheritAttrs: !1,
    __name: "BFormFile",
    props: {
        accept: {
            default: ""
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        capture: {
            type: [Boolean, String],
            default: !1
        },
        directory: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        form: {
            default: void 0
        },
        id: {
            default: void 0
        },
        multiple: {
            type: [String, Boolean],
            default: !1
        },
        name: {
            default: void 0
        },
        noDrop: {
            type: [String, Boolean],
            default: !1
        },
        noTraverse: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        size: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        modelValue: {
            default: null
        },
        label: {
            default: ""
        },
        labelClass: {
            default: void 0
        }
    },
    emits: ["update:modelValue", "change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = qt(r, "modelValue", n)
          , l = an( () => r.id)
          , i = H( () => r.autofocus)
          , o = H( () => r.directory)
          , u = H( () => r.disabled)
          , d = H( () => r.multiple)
          , f = H( () => r.noDrop);
        H( () => r.noTraverse);
        const p = H( () => r.required)
          , h = H( () => r.state)
          , v = bl(h)
          , y = me(null)
          , {focused: k} = ar(y, {
            initialValue: i.value
        })
          , w = _e( () => !Mn(a.label))
          , $ = _e( () => typeof r.accept == "string" ? r.accept : r.accept.join(","))
          , M = K( () => r.capture === "user" || r.capture === "environment" ? r.capture : nc(r.capture))
          , S = K( () => [v.value, {
            [`form-control-${r.size}`]: r.size !== void 0
        }])
          , T = U => {
            var L, C;
            const W = ((L = y.value) == null ? void 0 : L.files) === null || ((C = y.value) == null ? void 0 : C.files) === void 0 ? null : [...y.value.files];
            s.value = W === null ? null : d.value === !0 ? W : W[0],
            n("change", U)
        }
          , E = U => {
            f.value === !0 && U.preventDefault()
        }
          , O = () => {
            s.value = null
        }
        ;
        return Ke(s, U => {
            U === null && y.value !== null && (y.value.value = "")
        }
        ),
        e({
            element: y,
            focus: () => {
                k.value = !0
            }
            ,
            blur: () => {
                k.value = !1
            }
            ,
            reset: O
        }),
        (U, L) => (g(),
        _(we, null, [w.value || U.label ? (g(),
        _("label", {
            key: 0,
            for: A(l),
            class: ye(["form-label", U.labelClass])
        }, [Z(U.$slots, "label", {}, () => [ve(Q(U.label), 1)])], 10, GD)) : q("", !0), c("input", Ve({
            id: A(l)
        }, U.$attrs, {
            ref_key: "input",
            ref: y,
            type: "file",
            class: ["form-control", S.value],
            form: U.form,
            name: U.name,
            multiple: A(d),
            disabled: A(u),
            capture: M.value,
            accept: $.value || void 0,
            required: A(p) || void 0,
            "aria-required": A(p) || void 0,
            directory: A(o),
            webkitdirectory: A(o),
            onChange: T,
            onDrop: E
        }), null, 16, YD)], 64))
    }
})
  , U_ = ["input", "select", "textarea"]
  , XD = U_.map(t => `${t}:not([disabled])`).join()
  , QD = [...U_, "a", "button", "label"]
  , ZD = "label"
  , eP = "invalid-feedback"
  , tP = "valid-feedback"
  , nP = "description"
  , rP = "default"
  , aP = Se({
    components: {
        BCol: zi,
        BFormInvalidFeedback: Cp,
        BFormRow: Fu,
        BFormText: Ep,
        BFormValidFeedback: Ap
    },
    props: {
        contentCols: {
            type: [Boolean, String, Number],
            default: void 0
        },
        contentColsLg: {
            type: [Boolean, String, Number],
            default: void 0
        },
        contentColsMd: {
            type: [Boolean, String, Number],
            default: void 0
        },
        contentColsSm: {
            type: [Boolean, String, Number],
            default: void 0
        },
        contentColsXl: {
            type: [Boolean, String, Number],
            default: void 0
        },
        description: {
            type: [String],
            default: void 0
        },
        disabled: {
            type: [Boolean, String],
            default: !1
        },
        feedbackAriaLive: {
            type: String,
            default: "assertive"
        },
        id: {
            type: String,
            default: void 0
        },
        invalidFeedback: {
            type: String,
            default: void 0
        },
        label: {
            type: String,
            default: void 0
        },
        labelAlign: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelAlignLg: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelAlignMd: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelAlignSm: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelAlignXl: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelClass: {
            type: [Array, Object, String],
            default: void 0
        },
        labelCols: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelColsLg: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelColsMd: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelColsSm: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelColsXl: {
            type: [Boolean, String, Number],
            default: void 0
        },
        labelFor: {
            type: String,
            default: void 0
        },
        labelSize: {
            type: String,
            default: void 0
        },
        labelSrOnly: {
            type: [Boolean, String],
            default: !1
        },
        state: {
            type: [Boolean, String],
            default: null
        },
        tooltip: {
            type: [Boolean, String],
            default: !1
        },
        validFeedback: {
            type: String,
            default: void 0
        },
        validated: {
            type: [Boolean, String],
            default: !1
        },
        floating: {
            type: [Boolean, String],
            default: !1
        }
    },
    setup(t, {attrs: e}) {
        const n = H( () => t.disabled)
          , r = H( () => t.labelSrOnly)
          , a = H( () => t.state)
          , s = H( () => t.tooltip)
          , l = H( () => t.validated)
          , i = H( () => t.floating)
          , o = null
          , u = ["xs", "sm", "md", "lg", "xl"]
          , d = (S, T) => u.reduce( (E, O) => {
            const U = db(O === "xs" ? "" : O, `${T}Align`)
              , L = S[U] || null;
            return L && (O === "xs" ? E.push(`text-${L}`) : E.push(`text-${O}-${L}`)),
            E
        }
        , [])
          , f = (S, T) => u.reduce( (E, O) => {
            const U = db(O === "xs" ? "" : O, `${T}Cols`);
            let L = S[U];
            return L = L === "" ? !0 : L || !1,
            typeof L != "boolean" && L !== "auto" && (L = dO(L, 0),
            L = L > 0 ? L : !1),
            L && (O === "xs" ? E[typeof L == "boolean" ? "col" : "cols"] = L : E[O || (typeof L == "boolean" ? "col" : "cols")] = L),
            E
        }
        , {})
          , p = me()
          , h = (S, T=null) => {
            if (dm && t.labelFor) {
                const E = Uk(`#${HM(t.labelFor)}`, p);
                if (E) {
                    const O = "aria-describedby"
                      , U = (S || "").split(Du)
                      , L = (T || "").split(Du)
                      , C = (cm(E, O) || "").split(Du).filter(W => !L.includes(W)).concat(U).filter( (W, R, G) => G.indexOf(W) === R).filter(W => W).join(" ").trim();
                    C ? sO(E, O, C) : lO(E, O)
                }
            }
        }
          , v = K( () => f(t, "content"))
          , y = K( () => d(t, "label"))
          , k = K( () => f(t, "label"))
          , w = K( () => Object.keys(v.value).length > 0 || Object.keys(k.value).length > 0)
          , $ = bl(a)
          , M = K( () => ac(e.ariaInvalid, a.value));
        return Ke( () => o, (S, T) => {
            S !== T && h(S, T)
        }
        ),
        Zt( () => {
            Ot( () => {
                h(o)
            }
            )
        }
        ),
        {
            disabledBoolean: n,
            labelSrOnlyBoolean: r,
            stateBoolean: a,
            tooltipBoolean: s,
            validatedBoolean: l,
            floatingBoolean: i,
            ariaDescribedby: o,
            computedAriaInvalid: M,
            contentColProps: v,
            isHorizontal: w,
            labelAlignClasses: y,
            labelColProps: k,
            onLegendClick: S => {
                if (t.labelFor)
                    return;
                const {target: T} = S
                  , E = T ? T.tagName : "";
                if (QD.indexOf(E) !== -1)
                    return;
                const O = rO(XD, p).filter(nO);
                O.length === 1 && eO(O[0])
            }
            ,
            stateClass: $
        }
    },
    render() {
        const t = this.$props
          , e = this.$slots
          , n = an()
          , r = !t.labelFor;
        let a = null;
        const s = wa(ZD, {}, e) || t.label
          , l = s ? js("_BV_label_") : null;
        if (s || this.isHorizontal) {
            const S = r ? "legend" : "label";
            if (this.labelSrOnlyBoolean)
                s && (a = st(S, {
                    class: "visually-hidden",
                    id: l,
                    for: t.labelFor || null
                }, s)),
                this.isHorizontal ? a = st(zi, this.labelColProps, {
                    default: () => a
                }) : a = st("div", {}, [a]);
            else {
                const T = {
                    onClick: r ? this.onLegendClick : null,
                    ...this.isHorizontal ? this.labelColProps : {},
                    tag: this.isHorizontal ? S : null,
                    id: l,
                    for: t.labelFor || null,
                    tabIndex: r ? "-1" : null,
                    class: [this.isHorizontal ? "col-form-label" : "form-label", {
                        "bv-no-focus-ring": r,
                        "col-form-label": this.isHorizontal || r,
                        "pt-0": !this.isHorizontal && r,
                        "d-block": !this.isHorizontal && !r,
                        [`col-form-label-${t.labelSize}`]: !!t.labelSize
                    }, this.labelAlignClasses, t.labelClass]
                };
                this.isHorizontal ? a = st(zi, T, {
                    default: () => s
                }) : a = st(S, T, s)
            }
        }
        let i = null;
        const o = wa(eP, {}, e) || this.invalidFeedback
          , u = o ? js("_BV_feedback_invalid_") : void 0;
        o && (i = st(Cp, {
            ariaLive: t.feedbackAriaLive,
            id: u,
            state: this.stateBoolean,
            tooltip: this.tooltipBoolean
        }, {
            default: () => o
        }));
        let d = null;
        const f = wa(tP, {}, e) || this.validFeedback
          , p = f ? js("_BV_feedback_valid_") : void 0;
        f && (d = st(Ap, {
            ariaLive: t.feedbackAriaLive,
            id: p,
            state: this.stateBoolean,
            tooltip: this.tooltipBoolean
        }, {
            default: () => f
        }));
        let h = null;
        const v = wa(nP, {}, e) || this.description
          , y = v ? js("_BV_description_") : void 0;
        v && (h = st(Ep, {
            id: y
        }, {
            default: () => v
        }));
        const k = this.ariaDescribedby = [y, this.stateBoolean === !1 ? u : null, this.stateBoolean === !0 ? p : null].filter(S => S).join(" ") || null
          , w = [wa(rP, {
            ariaDescribedby: k,
            descriptionId: y,
            id: n,
            labelId: l
        }, e) || "", i, d, h];
        !this.isHorizontal && this.floatingBoolean && w.push(a);
        let $ = st("div", {
            ref: "content",
            class: [{
                "form-floating": !this.isHorizontal && this.floatingBoolean
            }]
        }, w);
        this.isHorizontal && ($ = st(zi, {
            ref: "content",
            ...this.contentColProps
        }, {
            default: () => w
        }));
        const M = {
            class: [this.stateClass, {
                "was-validated": this.validatedBoolean
            }],
            id: an( () => t.id).value,
            disabled: r ? this.disabledBoolean : null,
            role: r ? null : "group",
            "aria-invalid": this.computedAriaInvalid,
            "aria-labelledby": r && this.isHorizontal ? l : null
        };
        return this.isHorizontal && !r ? st(Fu, M, {
            default: () => [a, $]
        }) : st(r ? "fieldset" : "div", M, this.isHorizontal && r ? [st(Fu, null, {
            default: () => [a, $]
        })] : this.isHorizontal || !this.floatingBoolean ? [a, $] : [$])
    }
})
  , sP = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"]
  , H_ = Se({
    __name: "BFormInput",
    props: {
        max: {
            default: void 0
        },
        min: {
            default: void 0
        },
        step: {
            default: void 0
        },
        type: {
            default: "text"
        },
        ariaInvalid: {
            type: [String, Boolean],
            default: void 0
        },
        autocomplete: {
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        form: {
            default: void 0
        },
        debounce: {
            default: 0
        },
        debounceMaxWait: {
            default: void 0
        },
        formatter: {
            type: Function,
            default: void 0
        },
        id: {
            default: void 0
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        lazyFormatter: {
            type: [String, Boolean],
            default: !1
        },
        list: {
            default: void 0
        },
        modelValue: {
            default: ""
        },
        name: {
            default: void 0
        },
        number: {
            type: [String, Boolean],
            default: !1
        },
        placeholder: {
            default: void 0
        },
        plaintext: {
            type: [String, Boolean],
            default: !1
        },
        readonly: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        size: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        trim: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["update:modelValue", "change", "blur", "input"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {input: a, computedId: s, computedAriaInvalid: l, onInput: i, onChange: o, onBlur: u, focus: d, blur: f} = A_(r, n)
          , p = H( () => r.disabled)
          , h = H( () => r.required)
          , v = H( () => r.readonly)
          , y = H( () => r.plaintext)
          , k = H( () => r.state)
          , w = bl(k)
          , $ = me(!1)
          , M = K( () => {
            const S = r.type === "range"
              , T = r.type === "color";
            return [w.value, {
                "form-control-highlighted": $.value,
                "form-range": S,
                "form-control": T || !r.plaintext && !S,
                "form-control-color": T,
                "form-control-plaintext": r.plaintext && !S && !T,
                [`form-control-${r.size}`]: !!r.size
            }]
        }
        );
        return e({
            element: a,
            focus: d,
            blur: f
        }),
        (S, T) => (g(),
        _("input", {
            id: A(s),
            ref_key: "input",
            ref: a,
            class: ye(M.value),
            name: S.name || void 0,
            form: S.form || void 0,
            type: S.type,
            disabled: A(p),
            placeholder: S.placeholder,
            required: A(h) || void 0,
            autocomplete: S.autocomplete || void 0,
            readonly: A(v) || A(y),
            min: S.min,
            max: S.max,
            step: S.step,
            list: S.type !== "password" ? S.list : void 0,
            "aria-required": A(h) || void 0,
            "aria-invalid": A(l),
            onInput: T[0] || (T[0] = E => A(i)(E)),
            onChange: T[1] || (T[1] = E => A(o)(E)),
            onBlur: T[2] || (T[2] = E => A(u)(E))
        }, null, 42, sP))
    }
})
  , lP = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"]
  , iP = ["for"]
  , Tm = Se({
    inheritAttrs: !1,
    __name: "BFormRadio",
    props: {
        ariaLabel: {
            default: void 0
        },
        ariaLabelledby: {
            default: void 0
        },
        form: {
            default: void 0
        },
        id: {
            default: void 0
        },
        name: {
            default: void 0
        },
        size: {
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        modelValue: {
            type: [Boolean, String, Array, Object, Number, null],
            default: void 0
        },
        plain: {
            type: [String, Boolean],
            default: !1
        },
        button: {
            type: [String, Boolean],
            default: !1
        },
        buttonGroup: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        buttonVariant: {
            default: null
        },
        inline: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        value: {
            type: [Boolean, String, Array, Object, Number, null],
            default: !0
        }
    },
    emits: ["input", "change", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = qt(r, "modelValue", n, {
            passive: !0
        })
          , l = an( () => r.id, "form-check")
          , i = H( () => r.autofocus)
          , o = H( () => r.plain)
          , u = H( () => r.button)
          , d = H( () => r.buttonGroup)
          , f = H( () => r.disabled)
          , p = H( () => r.inline)
          , h = H( () => r.required)
          , v = H( () => r.state)
          , y = Gt(Zk, null)
          , k = me(null)
          , {focused: w} = ar(k, {
            initialValue: i.value
        })
          , $ = _e( () => !Mn(a.default))
          , M = K({
            get: () => y !== null ? JSON.stringify(y.modelValue.value) === JSON.stringify(r.value) : JSON.stringify(s.value) === JSON.stringify(r.value),
            set: C => {
                const W = C || C === "" || C === 0 || JSON.stringify(C) === JSON.stringify(r.value) ? r.value : !1;
                n("input", W),
                s.value = W,
                Ot( () => {
                    n("change", W)
                }
                ),
                y !== null && y.set(r.value)
            }
        });
        Ke(s, C => {
            y === null || C === !1 || y.set(r.value)
        }
        );
        const S = K( () => !!(r.name ?? (y == null ? void 0 : y.name.value)) && (h.value || (y == null ? void 0 : y.required.value)))
          , T = _e( () => d.value || ((y == null ? void 0 : y.buttons.value) ?? !1))
          , E = K( () => ({
            plain: o.value || ((y == null ? void 0 : y.plain.value) ?? !1),
            button: u.value || ((y == null ? void 0 : y.buttons.value) ?? !1),
            inline: p.value || ((y == null ? void 0 : y.inline.value) ?? !1),
            state: v.value || (y == null ? void 0 : y.state.value),
            size: r.size !== void 0 ? r.size : (y == null ? void 0 : y.size.value) ?? "md",
            buttonVariant: r.buttonVariant !== null ? r.buttonVariant : (y == null ? void 0 : y.buttonVariant.value) ?? "secondary"
        }))
          , O = S_(E)
          , U = $_(E)
          , L = T_(E);
        return e({
            element: k,
            focus: () => {
                w.value = !0
            }
            ,
            blur: () => {
                w.value = !1
            }
        }),
        (C, W) => (g(),
        de(ic, {
            skip: T.value,
            class: ye(A(O))
        }, {
            default: N( () => {
                var R, G, te;
                return [ft(c("input", Ve({
                    id: A(l)
                }, C.$attrs, {
                    ref_key: "input",
                    ref: k,
                    "onUpdate:modelValue": W[0] || (W[0] = J => M.value = J),
                    checked: M.value,
                    class: A(U),
                    type: "radio",
                    disabled: A(f) || ((R = A(y)) == null ? void 0 : R.disabled.value),
                    required: S.value || void 0,
                    name: C.name || ((G = A(y)) == null ? void 0 : G.name.value),
                    form: C.form || ((te = A(y)) == null ? void 0 : te.form.value),
                    "aria-label": C.ariaLabel,
                    "aria-labelledby": C.ariaLabelledby,
                    value: C.value,
                    "aria-required": S.value || void 0
                }), null, 16, lP), [[k2, M.value]]), $.value || A(o) === !1 ? (g(),
                _("label", {
                    key: 0,
                    for: A(l),
                    class: ye(A(L))
                }, [Z(C.$slots, "default")], 10, iP)) : q("", !0)]
            }
            ),
            _: 3
        }, 8, ["skip", "class"]))
    }
})
  , oP = ["id"]
  , uP = ["innerHTML"]
  , dP = ["textContent"]
  , cP = Se({
    __name: "BFormRadioGroup",
    props: {
        size: {
            default: "md"
        },
        form: {
            default: void 0
        },
        id: {
            default: void 0
        },
        name: {
            default: void 0
        },
        modelValue: {
            type: [String, Boolean, Array, Object, Number, null],
            default: null
        },
        ariaInvalid: {
            type: [String, Boolean],
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        buttonVariant: {
            default: "secondary"
        },
        buttons: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        disabledField: {
            default: "disabled"
        },
        htmlField: {
            default: "html"
        },
        options: {
            default: () => []
        },
        plain: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        stacked: {
            type: [String, Boolean],
            default: !1
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        textField: {
            default: "text"
        },
        validated: {
            type: [String, Boolean],
            default: !1
        },
        valueField: {
            default: "value"
        }
    },
    emits: ["input", "update:modelValue", "change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = qt(r, "modelValue", n)
          , s = an( () => r.id, "radio")
          , l = an( () => r.name, "checkbox")
          , i = H( () => r.autofocus)
          , o = H( () => r.buttons)
          , u = H( () => r.disabled)
          , d = H( () => r.plain)
          , f = H( () => r.required)
          , p = H( () => r.stacked)
          , h = H( () => r.state)
          , v = H( () => r.validated)
          , y = me(null)
          , {focused: k} = ar(y, {
            initialValue: i.value
        });
        zn(Zk, {
            set: T => {
                n("input", T),
                a.value = T,
                Ot( () => {
                    n("change", T)
                }
                )
            }
            ,
            modelValue: _e( () => a.value),
            buttonVariant: _e( () => r.buttonVariant),
            form: _e( () => r.form),
            name: l,
            buttons: o,
            state: h,
            plain: d,
            size: _e( () => r.size),
            inline: _e( () => !p.value),
            required: f,
            disabled: u
        });
        const w = K( () => r.options.map( (T, E) => typeof T == "string" || typeof T == "number" ? {
            props: {
                value: T,
                disabled: u.value
            },
            text: T.toString(),
            html: void 0,
            self: Symbol(`radioGroupOptionItem${E}`)
        } : {
            props: {
                value: T[r.valueField],
                disabled: T[r.disabledField],
                ...T.props ? T.props : {}
            },
            text: T[r.textField],
            html: T[r.htmlField],
            self: Symbol(`radioGroupOptionItem${E}`)
        }))
          , $ = K( () => ({
            required: f.value,
            ariaInvalid: r.ariaInvalid,
            state: h.value,
            validated: v.value,
            buttons: o.value,
            stacked: p.value,
            size: r.size
        }))
          , M = C_($)
          , S = E_($);
        return e({
            focus: () => {
                k.value = !0
            }
            ,
            blur: () => {
                k.value = !1
            }
        }),
        (T, E) => (g(),
        _("div", Ve(A(M), {
            id: A(s),
            ref_key: "element",
            ref: y,
            role: "radiogroup",
            class: [A(S), "bv-no-focus-ring"],
            tabindex: "-1"
        }), [Z(T.$slots, "first"), (g(!0),
        _(we, null, Ne(w.value, O => (g(),
        de(Tm, Ve({
            key: O.self
        }, O.props), {
            default: N( () => [O.html ? (g(),
            _("span", {
                key: 0,
                innerHTML: O.html
            }, null, 8, uP)) : (g(),
            _("span", {
                key: 1,
                textContent: Q(O.text)
            }, null, 8, dP))]),
            _: 2
        }, 1040))), 128)), Z(T.$slots, "default")], 16, oP))
    }
})
  , fP = ["value", "disabled"]
  , Cm = Se({
    __name: "BFormSelectOption",
    props: {
        value: {
            default: void 0
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.disabled);
        return (r, a) => (g(),
        _("option", {
            value: r.value,
            disabled: A(n)
        }, [Z(r.$slots, "default")], 8, fP))
    }
})
  , pP = ["label"]
  , K_ = Se({
    __name: "BFormSelectOptionGroup",
    props: {
        label: {
            default: void 0
        },
        disabledField: {
            default: "disabled"
        },
        htmlField: {
            default: "html"
        },
        options: {
            default: () => []
        },
        textField: {
            default: "text"
        },
        valueField: {
            default: "value"
        }
    },
    setup(t) {
        const e = t
          , n = K( () => wm(e.options, "BFormSelectOptionGroup", e));
        return (r, a) => (g(),
        _("optgroup", {
            label: r.label
        }, [Z(r.$slots, "first"), (g(!0),
        _(we, null, Ne(n.value, (s, l) => (g(),
        de(Cm, Ve({
            key: l,
            value: s.value,
            disabled: s.disabled
        }, r.$attrs, {
            innerHTML: s.html || s.text
        }), null, 16, ["value", "disabled", "innerHTML"]))), 128)), Z(r.$slots, "default")], 8, pP))
    }
})
  , hP = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"]
  , yl = Se({
    __name: "BFormSelect",
    props: {
        ariaInvalid: {
            type: [String, Boolean],
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        disabledField: {
            default: "disabled"
        },
        form: {
            default: void 0
        },
        htmlField: {
            default: "html"
        },
        id: {
            default: void 0
        },
        labelField: {
            default: "label"
        },
        multiple: {
            type: [String, Boolean],
            default: !1
        },
        name: {
            default: void 0
        },
        options: {
            default: () => []
        },
        optionsField: {
            default: "options"
        },
        plain: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        selectSize: {
            default: 0
        },
        size: {
            default: "md"
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        textField: {
            default: "text"
        },
        valueField: {
            default: "value"
        },
        modelValue: {
            default: ""
        }
    },
    emits: ["input", "update:modelValue", "change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = qt(r, "modelValue", n)
          , s = an( () => r.id, "input")
          , l = H( () => r.autofocus)
          , i = H( () => r.disabled)
          , o = H( () => r.multiple)
          , u = H( () => r.plain)
          , d = H( () => r.required)
          , f = H( () => r.state)
          , p = zt( () => r.selectSize)
          , h = bl(f)
          , v = me()
          , {focused: y} = ar(v, {
            initialValue: l.value
        })
          , k = K( () => [h.value, {
            "form-control": u.value,
            [`form-control-${r.size}`]: r.size !== "md" && u.value,
            "form-select": !u.value,
            [`form-select-${r.size}`]: r.size !== "md" && !u.value
        }])
          , w = _e( () => p.value || u.value ? p.value : void 0)
          , $ = K( () => ac(r.ariaInvalid, f.value))
          , M = K( () => wm(r.options, "BFormSelect", r))
          , S = K({
            get: () => a.value,
            set: T => {
                n("input", T),
                a.value = T,
                Ot( () => {
                    n("change", T)
                }
                )
            }
        });
        return e({
            element: v,
            focus: () => {
                y.value = !0
            }
            ,
            blur: () => {
                y.value = !1
            }
        }),
        (T, E) => ft((g(),
        _("select", {
            id: A(s),
            ref_key: "input",
            ref: v,
            "onUpdate:modelValue": E[0] || (E[0] = O => S.value = O),
            class: ye(k.value),
            name: T.name,
            form: T.form || void 0,
            multiple: A(o) || void 0,
            size: w.value,
            disabled: A(i),
            required: A(d) || void 0,
            "aria-required": A(d) || void 0,
            "aria-invalid": $.value
        }, [Z(T.$slots, "first"), (g(!0),
        _(we, null, Ne(M.value, (O, U) => (g(),
        _(we, {
            key: U
        }, [Array.isArray(O.options) ? (g(),
        de(K_, {
            key: 0,
            label: O.label,
            options: O.options
        }, null, 8, ["label", "options"])) : (g(),
        de(Cm, {
            key: 1,
            value: O.value,
            disabled: O.disabled,
            innerHTML: O.html || O.text
        }, null, 8, ["value", "disabled", "innerHTML"]))], 64))), 128)), Z(T.$slots, "default")], 10, hP)), [[Xn, S.value]])
    }
})
  , Cb = ["ar", "az", "ckb", "fa", "he", "ks", "lrc", "mzn", "ps", "sd", "te", "ug", "ur", "yi"].map(t => t.toLowerCase())
  , mP = t => {
    const e = Yu(t).toLowerCase().replace(VM, "").split("-")
      , n = e.slice(0, 2).join("-")
      , [r] = e;
    return Cb.includes(n) || Cb.includes(r)
}
  , vP = t => YM ? kp(t) ? t : {
    capture: !!t || !1
} : !!(kp(t) ? t.capture : t)
  , gP = (t, e, n, r) => {
    t && t.addEventListener && t.addEventListener(e, n, vP(r))
}
  , bP = (t, e, n, r) => {
    t && t.removeEventListener && t.removeEventListener(e, n, r)
}
  , Eb = (t, e) => {
    (t ? gP : bP)(...e)
}
  , gu = (t, {preventDefault: e=!0, propagation: n=!0, immediatePropagation: r=!1}={}) => {
    e && t.preventDefault(),
    n && t.stopPropagation(),
    r && t.stopImmediatePropagation()
}
  , Mp = "ArrowDown"
  , z_ = "End"
  , q_ = "Home"
  , W_ = "PageDown"
  , G_ = "PageUp"
  , Op = "ArrowUp"
  , Ab = 1
  , Mb = 100
  , Ob = 1
  , Nb = 500
  , Db = 100
  , Pb = 10
  , Fb = 4
  , Bb = [Op, Mp, q_, z_, G_, W_]
  , yP = Se({
    props: {
        ariaControls: {
            type: String,
            default: void 0
        },
        ariaLabel: {
            type: String,
            default: void 0
        },
        labelIncrement: {
            type: String,
            default: "Increment"
        },
        labelDecrement: {
            type: String,
            default: "Decrement"
        },
        modelValue: {
            type: Number,
            default: null
        },
        name: {
            type: String,
            default: "BFormSpinbutton"
        },
        disabled: {
            type: [Boolean, String],
            default: !1
        },
        placeholder: {
            type: String,
            default: void 0
        },
        locale: {
            type: String,
            default: "locale"
        },
        form: {
            type: String,
            default: void 0
        },
        inline: {
            type: Boolean,
            default: !1
        },
        size: {
            type: String,
            default: void 0
        },
        formatterFn: {
            type: Function,
            default: void 0
        },
        readonly: {
            type: Boolean,
            default: !1
        },
        vertical: {
            type: Boolean,
            default: !1
        },
        repeatDelay: {
            type: [String, Number],
            default: Nb
        },
        repeatInterval: {
            type: [String, Number],
            default: Db
        },
        repeatStepMultiplier: {
            type: [String, Number],
            default: Fb
        },
        repeatThreshold: {
            type: [String, Number],
            default: Pb
        },
        required: {
            type: [Boolean, String],
            default: !1
        },
        step: {
            type: [String, Number],
            default: Ob
        },
        min: {
            type: [String, Number],
            default: Ab
        },
        max: {
            type: [String, Number],
            default: Mb
        },
        wrap: {
            type: Boolean,
            default: !1
        },
        state: {
            type: [Boolean, String],
            default: null
        }
    },
    emits: ["update:modelValue", "change"],
    setup(t, {emit: e}) {
        const n = qt(t, "modelValue", e)
          , r = me(!1)
          , a = K( () => 1)
          , s = () => {
            e("change", i.value)
        }
          , l = me(null)
          , i = K({
            get: () => n.value === null ? l.value : n.value,
            set: ce => {
                n.value === null ? l.value = ce : n.value = ce
            }
        });
        let o, u, d = !1;
        const f = K( () => Pu(t.step, Ob))
          , p = K( () => Pu(t.min, Ab))
          , h = K( () => {
            const ce = Pu(t.max, Mb)
              , xe = f.value
              , X = p.value;
            return Math.floor((ce - X) / xe) * xe + X
        }
        )
          , v = K( () => {
            const ce = Us(t.repeatDelay, 0);
            return ce > 0 ? ce : Nb
        }
        )
          , y = K( () => {
            const ce = Us(t.repeatInterval, 0);
            return ce > 0 ? ce : Db
        }
        )
          , k = K( () => Math.max(Us(t.repeatThreshold, Pb), 1))
          , w = K( () => Math.max(Us(t.repeatStepMultiplier, Fb), 1))
          , $ = K( () => {
            const ce = f.value;
            return Math.floor(ce) === ce ? 0 : (ce.toString().split(".")[1] || "").length
        }
        )
          , M = K( () => Math.pow(10, $.value || 0))
          , S = K( () => {
            const {value: ce} = i;
            return ce === null ? "" : ce.toFixed($.value)
        }
        )
          , T = K( () => {
            const ce = [t.locale];
            return new Intl.NumberFormat(ce).resolvedOptions().locale
        }
        )
          , E = K( () => mP(T.value))
          , O = () => {
            const ce = $.value;
            return new Intl.NumberFormat(T.value,{
                style: "decimal",
                useGrouping: !1,
                minimumIntegerDigits: 1,
                minimumFractionDigits: ce,
                maximumFractionDigits: ce,
                notation: "standard"
            }).format
        }
          , U = K( () => t.formatterFn ?? O())
          , L = K( () => ({
            role: "group",
            lang: T.value,
            tabindex: t.disabled ? null : "-1",
            title: t.ariaLabel
        }))
          , C = K( () => n.value !== null || l.value !== null)
          , W = K( () => ({
            dir: E.value,
            spinId: a.value,
            tabindex: t.disabled ? null : "0",
            role: "spinbutton",
            "aria-live": "off",
            "aria-label": t.ariaLabel || null,
            "aria-controls": t.ariaControls || null,
            "aria-invalid": t.state === !1 || !C.value && t.required ? !0 : null,
            "aria-required": t.required ? !0 : null,
            "aria-valuemin": p.value,
            "aria-valuemax": h.value,
            "aria-valuenow": i.value !== null ? i.value : null,
            "aria-valuetext": i.value !== null ? U.value(i.value) : null
        }))
          , R = ce => {
            let {value: xe} = i;
            if (!t.disabled && xe !== null) {
                const X = f.value * ce
                  , be = p.value
                  , ee = h.value
                  , B = M.value
                  , {wrap: se} = t;
                xe = Math.round((xe - be) / X) * X + be + X,
                xe = Math.round(xe * B) / B,
                i.value = xe > ee ? se ? be : ee : xe < be ? se ? ee : be : xe
            }
        }
          , G = (ce=1) => {
            i.value === null ? i.value = p.value : R(1 * ce)
        }
          , te = (ce=1) => {
            i.value === null ? i.value = t.wrap ? h.value : p.value : R(-1 * ce)
        }
          , J = ce => {
            const {code: xe, altKey: X, ctrlKey: be, metaKey: ee} = ce;
            if (!(t.disabled || t.readonly || X || be || ee) && Bb.includes(xe)) {
                if (gu(ce, {
                    propagation: !1
                }),
                d)
                    return;
                re(),
                [Op, Mp].includes(xe) ? (d = !0,
                xe === Op ? oe(ce, G) : xe === Mp && oe(ce, te)) : xe === G_ ? G(w.value) : xe === W_ ? te(w.value) : xe === q_ ? i.value = p.value : xe === z_ && (i.value = h.value)
            }
        }
          , ae = ce => {
            const {code: xe, altKey: X, ctrlKey: be, metaKey: ee} = ce;
            t.disabled || t.readonly || X || be || ee || Bb.includes(xe) && (gu(ce, {
                propagation: !1
            }),
            re(),
            d = !1,
            s())
        }
          , oe = (ce, xe) => {
            const {type: X} = ce || {};
            if (!t.disabled && !t.readonly) {
                if (ne(ce) && X === "mousedown" && ce.button)
                    return;
                re(),
                xe(1);
                const be = k.value
                  , ee = w.value
                  , B = v.value
                  , se = y.value;
                o = setTimeout( () => {
                    let pe = 0;
                    u = setInterval( () => {
                        xe(pe < be ? 1 : ee),
                        pe++
                    }
                    , se)
                }
                , B)
            }
        }
          , ne = ce => ce.type === "mouseup" || ce.type === "mousedown"
          , I = ce => {
            ne(ce) && ce.type === "mouseup" && ce.button || (gu(ce, {
                propagation: !1
            }),
            re(),
            j(!1),
            s())
        }
          , j = ce => {
            try {
                Eb(ce, [document.body, "mouseup", I, !1]),
                Eb(ce, [document.body, "touchend", I, !1])
            } catch {
                return 0
            }
        }
          , re = () => {
            clearTimeout(o),
            clearInterval(u),
            o = void 0,
            u = void 0
        }
          , le = (ce, xe, X, be, ee, B, se) => {
            const pe = st(X, {
                props: {
                    scale: r.value ? 1.5 : 1.25
                },
                attrs: {
                    "aria-hidden": !0
                }
            })
              , ie = {
                hasFocus: r.value
            }
              , fe = F => {
                !t.disabled && !t.readonly && (gu(F, {
                    propagation: !1
                }),
                j(!0),
                oe(F, ce))
            }
            ;
            return st("button", {
                class: [{
                    "py-0": !t.vertical
                }, "btn", "btn-sm", "border-0", "rounded-0"],
                tabindex: "-1",
                type: "button",
                disabled: t.disabled || t.readonly || B,
                "aria-disabled": t.disabled || t.readonly || B ? !0 : null,
                "aria-controls": a.value,
                "aria-label": xe || null,
                "aria-keyshortcuts": ee || null,
                onmousedown: fe,
                ontouchstart: fe
            }, [wa(se, ie) || pe])
        }
        ;
        return () => {
            const ce = le(G, t.labelIncrement, st("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                fill: "currentColor",
                class: "bi bi-plus",
                viewBox: "0 0 16 16"
            }, st("path", {
                d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
            })), "inc", "ArrowUp", !1, "increment")
              , xe = le(te, t.labelDecrement, st("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                fill: "currentColor",
                class: "bi bi-dash",
                viewBox: "0 0 16 16"
            }, st("path", {
                d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"
            })), "dec", "ArrowDown", !1, "decrement")
              , X = [];
            t.name && !t.disabled && X.push(st("input", {
                type: "hidden",
                name: t.name,
                form: t.form || null,
                value: S.value,
                key: "hidden"
            }));
            const be = st("output", {
                class: [{
                    "d-flex": t.vertical
                }, {
                    "align-self-center": !t.vertical
                }, {
                    "align-items-center": t.vertical
                }, {
                    "border-top": t.vertical
                }, {
                    "border-bottom": t.vertical
                }, {
                    "border-start": !t.vertical
                }, {
                    "border-end": !t.vertical
                }, "flex-grow-1"],
                ...W.value,
                key: "output"
            }, [st("bdi", C.value ? U.value(i.value) : t.placeholder || "")]);
            return st("div", {
                class: ["b-form-spinbutton form-control", {
                    disabled: t.disabled
                }, {
                    readonly: t.readonly
                }, {
                    focus: r
                }, {
                    "d-inline-flex": t.inline || t.vertical
                }, {
                    "d-flex": !t.inline && !t.vertical
                }, {
                    "align-items-stretch": !t.vertical
                }, {
                    "flex-column": t.vertical
                }, t.size ? `form-control-${t.size}` : null],
                ...L.value,
                onkeydown: J,
                onkeyup: ae
            }, t.vertical ? [ce, X, be, xe] : [xe, X, be, ce])
        }
    }
})
  , kP = ["id"]
  , Y_ = Se({
    __name: "BFormTag",
    props: {
        id: {
            default: void 0
        },
        title: {
            default: void 0
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        noRemove: {
            type: [String, Boolean],
            default: !1
        },
        pill: {
            type: [String, Boolean],
            default: !1
        },
        removeLabel: {
            default: "Remove tag"
        },
        tag: {
            default: "span"
        },
        variant: {
            default: "secondary"
        }
    },
    emits: ["remove"],
    setup(t, {emit: e}) {
        const n = t
          , r = en()
          , a = an( () => n.id)
          , s = H( () => n.disabled)
          , l = H( () => n.noRemove)
          , i = H( () => n.pill)
          , o = K( () => {
            var f;
            return ((((f = r.default) == null ? void 0 : f.call(r)[0].children) ?? "").toString() || n.title) ?? ""
        }
        )
          , u = _e( () => `${a.value}taglabel__`)
          , d = K( () => ({
            [`text-bg-${n.variant}`]: n.variant !== null,
            "rounded-pill": i.value,
            disabled: s.value
        }));
        return (f, p) => (g(),
        de(qe(f.tag), {
            id: A(a),
            title: o.value,
            class: ye(["badge b-form-tag d-inline-flex align-items-center mw-100", d.value]),
            "aria-labelledby": u.value
        }, {
            default: N( () => [c("span", {
                id: u.value,
                class: "b-form-tag-content flex-grow-1 text-truncate"
            }, [Z(f.$slots, "default", {}, () => [ve(Q(o.value), 1)])], 8, kP), !A(s) && !A(l) ? (g(),
            de(Ai, {
                key: 0,
                "aria-keyshortcuts": "Delete",
                "aria-label": f.removeLabel,
                class: "b-form-tag-remove",
                "aria-describedby": u.value,
                "aria-controls": f.id,
                onClick: p[0] || (p[0] = h => e("remove", o.value))
            }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : q("", !0)]),
            _: 3
        }, 8, ["id", "title", "class", "aria-labelledby"]))
    }
})
  , _P = ["id"]
  , wP = ["id", "for", "aria-live"]
  , xP = ["id", "aria-live"]
  , SP = ["id"]
  , $P = ["aria-controls"]
  , TP = {
    role: "group",
    class: "d-flex"
}
  , CP = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"]
  , EP = ["disabled"]
  , AP = {
    "aria-live": "polite",
    "aria-atomic": "true"
}
  , MP = {
    key: 0,
    class: "d-block invalid-feedback"
}
  , OP = {
    key: 1,
    class: "form-text text-body-secondary"
}
  , NP = {
    key: 2,
    class: "form-text text-body-secondary"
}
  , DP = ["name", "value"]
  , PP = Se({
    __name: "BFormTags",
    props: {
        addButtonText: {
            default: "Add"
        },
        addButtonVariant: {
            default: "outline-secondary"
        },
        addOnChange: {
            type: [String, Boolean],
            default: !1
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        duplicateTagText: {
            default: "Duplicate tag(s)"
        },
        inputAttrs: {
            default: void 0
        },
        inputClass: {
            default: void 0
        },
        inputId: {
            default: void 0
        },
        inputType: {
            default: "text"
        },
        invalidTagText: {
            default: "Invalid tag(s)"
        },
        form: {
            default: void 0
        },
        limit: {
            default: void 0
        },
        limitTagsText: {
            default: "Tag limit reached"
        },
        modelValue: {
            default: () => []
        },
        name: {
            default: void 0
        },
        noAddOnEnter: {
            type: [String, Boolean],
            default: !1
        },
        noOuterFocus: {
            type: [String, Boolean],
            default: !1
        },
        noTagRemove: {
            type: [String, Boolean],
            default: !1
        },
        placeholder: {
            default: "Add tag..."
        },
        removeOnDelete: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        separator: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        size: {
            default: "md"
        },
        tagClass: {
            default: void 0
        },
        tagPills: {
            type: [String, Boolean],
            default: !1
        },
        tagRemoveLabel: {
            default: void 0
        },
        tagRemovedLabel: {
            default: "Tag removed"
        },
        tagValidator: {
            type: Function,
            default: () => !0
        },
        tagVariant: {
            default: "secondary"
        }
    },
    emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = qt(r, "modelValue", n)
          , s = an()
          , l = H( () => r.addOnChange)
          , i = H( () => r.autofocus)
          , o = H( () => r.disabled)
          , u = H( () => r.noAddOnEnter)
          , d = H( () => r.noOuterFocus)
          , f = H( () => r.noTagRemove)
          , p = H( () => r.removeOnDelete)
          , h = H( () => r.required)
          , v = H( () => r.state)
          , y = H( () => r.tagPills)
          , k = zt(_e( () => r.limit ?? NaN))
          , w = bl(v)
          , $ = me(null)
          , {focused: M} = ar($, {
            initialValue: i.value
        })
          , S = _e( () => r.inputId || `${s.value}input__`)
          , T = me(a.value)
          , E = me("")
          , O = me(a.value.length > 0)
          , U = me("")
          , L = me([])
          , C = me([])
          , W = me([])
          , R = K( () => [w.value, {
            [`form-control-${r.size}`]: r.size !== "md",
            disabled: o.value,
            focus: M.value
        }])
          , G = K( () => T.value.includes(E.value))
          , te = K( () => E.value === "" ? !1 : !r.tagValidator(E.value))
          , J = _e( () => T.value.length === k.value)
          , ae = _e( () => !te.value && !G.value)
          , oe = K( () => ({
            addButtonText: r.addButtonText,
            addButtonVariant: r.addButtonVariant,
            addTag: be,
            disableAddButton: ae.value,
            disabled: o.value,
            duplicateTagText: r.duplicateTagText,
            duplicateTags: W.value,
            form: r.form,
            inputAttrs: {
                ...r.inputAttrs,
                disabled: o.value,
                form: r.form,
                id: S,
                value: E
            },
            inputHandlers: {
                input: re,
                keydown: ce,
                change: le
            },
            inputId: S,
            inputType: r.inputType,
            invalidTagText: r.invalidTagText,
            invalidTags: C.value,
            isDuplicate: G.value,
            isInvalid: te.value,
            isLimitReached: J.value,
            limitTagsText: r.limitTagsText,
            limit: k.value,
            noTagRemove: f.value,
            placeholder: r.placeholder,
            removeTag: ee,
            required: h.value,
            separator: r.separator,
            size: r.size,
            state: v.value,
            tagClass: r.tagClass,
            tagPills: y.value,
            tagRemoveLabel: r.tagRemoveLabel,
            tagVariant: r.tagVariant,
            tags: T.value
        }));
        Ke(a, B => {
            T.value = B
        }
        );
        const ne = B => {
            if (o.value) {
                B.target.blur();
                return
            }
            n("focusin", B)
        }
          , I = B => {
            o.value || d.value || (M.value = !0,
            n("focus", B))
        }
          , j = B => {
            M.value = !1,
            n("blur", B)
        }
          , re = B => {
            var se, pe;
            const ie = typeof B == "string" ? B : B.target.value;
            if (O.value = !1,
            (se = r.separator) != null && se.includes(ie.charAt(0)) && ie.length > 0) {
                $.value && ($.value.value = "");
                return
            }
            if (E.value = ie,
            (pe = r.separator) != null && pe.includes(ie.charAt(ie.length - 1))) {
                be(ie.slice(0, ie.length - 1));
                return
            }
            L.value = r.tagValidator(ie) && !G.value ? [ie] : [],
            C.value = r.tagValidator(ie) ? [] : [ie],
            W.value = G.value ? [ie] : [],
            n("tag-state", L.value, C.value, W.value)
        }
          , le = B => {
            l.value && (re(B),
            G.value || be(E.value))
        }
          , ce = B => {
            if (B.key === "Enter" && !u.value) {
                be(E.value);
                return
            }
            (B.key === "Backspace" || B.key === "Delete") && p.value && E.value === "" && O.value && T.value.length > 0 ? ee(T.value[T.value.length - 1]) : O.value = !0
        }
        ;
        Cr(ce, {
            target: $
        });
        const xe = K( () => {
            if (r.separator)
                return typeof r.separator == "string" ? r.separator : r.separator.join("")
        }
        )
          , X = K( () => {
            if (xe.value)
                return new RegExp(`[${UM(xe.value)}]+`)
        }
        )
          , be = B => {
            B = (B ?? E.value).trim();
            const se = X.value ? B.split(X.value).map(fe => fe.trim()) : [B]
              , pe = [];
            for (const fe of se)
                if (!(fe === "" || G.value || !r.tagValidator(fe))) {
                    if (k.value && J.value)
                        break;
                    pe.push(fe)
                }
            const ie = [...a.value, ...pe];
            E.value = "",
            O.value = !0,
            a.value = ie,
            n("input", ie),
            M.value = !0
        }
          , ee = B => {
            const se = T.value.indexOf((B == null ? void 0 : B.toString()) ?? "");
            U.value = T.value.splice(se, 1).toString(),
            a.value = T.value
        }
        ;
        return e({
            element: $,
            focus: () => {
                M.value = !0
            }
            ,
            blur: () => {
                M.value = !1
            }
        }),
        (B, se) => (g(),
        _("div", {
            id: A(s),
            class: ye(["b-form-tags form-control h-auto", R.value]),
            role: "group",
            tabindex: "-1",
            onFocusin: ne,
            onFocusout: se[1] || (se[1] = pe => n("focusout", pe))
        }, [c("output", {
            id: `${A(s)}selected_tags__`,
            class: "visually-hidden",
            for: S.value,
            "aria-live": A(M) ? "polite" : "off",
            "aria-atomic": "true",
            "aria-relevant": "additions text"
        }, Q(T.value.join(", ")), 9, wP), c("div", {
            id: `${A(s)}removed_tags__`,
            role: "status",
            "aria-live": A(M) ? "assertive" : "off",
            "aria-atomic": "true",
            class: "visually-hidden"
        }, " (" + Q(B.tagRemovedLabel) + ") " + Q(U.value), 9, xP), Z(B.$slots, "default", ut(Vt(oe.value)), () => [c("ul", {
            id: `${A(s)}tag_list__`,
            class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [(g(!0),
        _(we, null, Ne(T.value, (pe, ie) => Z(B.$slots, "tag", {
            key: ie,
            tag: pe,
            tagClass: B.tagClass,
            tagVariant: B.tagVariant,
            tagPills: A(y),
            removeTag: ee
        }, () => [(g(),
        de(Y_, {
            key: pe,
            class: ye(B.tagClass),
            tag: "li",
            variant: B.tagVariant,
            pill: B.tagPills,
            onRemove: ee
        }, {
            default: N( () => [ve(Q(pe), 1)]),
            _: 2
        }, 1032, ["class", "variant", "pill"]))])), 128)), c("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${A(s)}tag_list__`
        }, [c("div", TP, [c("input", Ve({
            id: S.value,
            ref_key: "input",
            ref: $,
            disabled: A(o),
            value: E.value,
            type: B.inputType,
            placeholder: B.placeholder,
            class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
            style: {
                outline: "currentcolor none 0px",
                "min-width": "5rem"
            }
        }, B.inputAttrs, {
            form: B.form,
            required: A(h) || void 0,
            "aria-required": A(h) || void 0,
            onInput: re,
            onChange: le,
            onFocus: I,
            onBlur: j
        }), null, 16, CP), ae.value ? (g(),
        _("button", {
            key: 0,
            type: "button",
            class: ye(["btn b-form-tags-button py-0", [B.inputClass, {
                [`btn-${B.addButtonVariant}`]: B.addButtonVariant !== null,
                "disabled invisible": E.value.length === 0
            }]]),
            style: {
                "font-size": "90%"
            },
            disabled: A(o) || E.value.length === 0 || J.value,
            onClick: se[0] || (se[0] = pe => be(E.value))
        }, [Z(B.$slots, "add-button-text", {}, () => [ve(Q(B.addButtonText), 1)])], 10, EP)) : q("", !0)])], 8, $P)], 8, SP), c("div", AP, [te.value ? (g(),
        _("div", MP, Q(B.invalidTagText) + ": " + Q(E.value), 1)) : q("", !0), G.value ? (g(),
        _("small", OP, Q(B.duplicateTagText) + ": " + Q(E.value), 1)) : q("", !0), T.value.length === B.limit ? (g(),
        _("small", NP, "Tag limit reached")) : q("", !0)])]), B.name ? (g(!0),
        _(we, {
            key: 0
        }, Ne(T.value, (pe, ie) => (g(),
        _("input", {
            key: ie,
            type: "hidden",
            name: B.name,
            value: pe
        }, null, 8, DP))), 128)) : q("", !0)], 42, _P))
    }
})
  , FP = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"]
  , Em = Se({
    __name: "BFormTextarea",
    props: {
        noResize: {
            type: [String, Boolean],
            default: !1
        },
        rows: {
            default: 2
        },
        wrap: {
            default: "soft"
        },
        ariaInvalid: {
            type: [String, Boolean],
            default: void 0
        },
        autocomplete: {
            default: void 0
        },
        autofocus: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        form: {
            default: void 0
        },
        debounce: {
            default: 0
        },
        debounceMaxWait: {
            default: void 0
        },
        formatter: {
            type: Function,
            default: void 0
        },
        id: {
            default: void 0
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        lazyFormatter: {
            type: [String, Boolean],
            default: !1
        },
        list: {
            default: void 0
        },
        modelValue: {
            default: ""
        },
        name: {
            default: void 0
        },
        number: {
            type: [String, Boolean],
            default: !1
        },
        placeholder: {
            default: void 0
        },
        plaintext: {
            type: [String, Boolean],
            default: !1
        },
        readonly: {
            type: [String, Boolean],
            default: !1
        },
        required: {
            type: [String, Boolean],
            default: !1
        },
        size: {
            default: void 0
        },
        state: {
            type: [String, Boolean, null],
            default: null
        },
        trim: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["update:modelValue", "change", "blur", "input"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {input: a, computedId: s, computedAriaInvalid: l, onInput: i, onChange: o, onBlur: u, focus: d, blur: f} = A_(r, n)
          , p = H( () => r.disabled)
          , h = H( () => r.required)
          , v = H( () => r.readonly)
          , y = H( () => r.plaintext)
          , k = H( () => r.noResize)
          , w = H( () => r.state)
          , $ = bl(w)
          , M = K( () => [$.value, {
            "form-control": !r.plaintext,
            "form-control-plaintext": r.plaintext,
            [`form-control-${r.size}`]: !!r.size
        }])
          , S = K( () => ({
            resize: k.value ? "none" : void 0
        }));
        return e({
            element: a,
            focus: d,
            blur: f
        }),
        (T, E) => (g(),
        _("textarea", {
            id: A(s),
            ref_key: "input",
            ref: a,
            class: ye(M.value),
            name: T.name || void 0,
            form: T.form || void 0,
            disabled: A(p),
            placeholder: T.placeholder,
            required: A(h) || void 0,
            autocomplete: T.autocomplete || void 0,
            readonly: A(v) || A(y),
            "aria-required": T.required || void 0,
            "aria-invalid": A(l),
            rows: T.rows,
            style: Rt(S.value),
            wrap: T.wrap || void 0,
            onInput: E[0] || (E[0] = O => A(i)(O)),
            onChange: E[1] || (E[1] = O => A(o)(O)),
            onBlur: E[2] || (E[2] = O => A(u)(O))
        }, null, 46, FP))
    }
})
  , BP = {
    key: 0,
    class: "input-group-text"
}
  , VP = ["innerHTML"]
  , IP = {
    key: 1
}
  , RP = {
    key: 0,
    class: "input-group-text"
}
  , LP = ["innerHTML"]
  , jP = {
    key: 1
}
  , UP = Se({
    __name: "BInputGroup",
    props: {
        append: {
            default: void 0
        },
        appendHtml: {
            default: void 0
        },
        id: {
            default: void 0
        },
        prepend: {
            default: void 0
        },
        prependHtml: {
            default: void 0
        },
        size: {
            default: "md"
        },
        tag: {
            default: "div"
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`input-group-${e.size}`]: e.size !== "md"
        }))
          , r = _e( () => !!e.append || !!e.appendHtml)
          , a = _e( () => !!e.prepend || !!e.prependHtml);
        return (s, l) => (g(),
        de(qe(s.tag), {
            id: s.id,
            class: ye(["input-group", n.value]),
            role: "group"
        }, {
            default: N( () => [Z(s.$slots, "prepend", {}, () => [a.value ? (g(),
            _("span", BP, [s.prependHtml ? (g(),
            _("span", {
                key: 0,
                innerHTML: s.prependHtml
            }, null, 8, VP)) : (g(),
            _("span", IP, Q(s.prepend), 1))])) : q("", !0)]), Z(s.$slots, "default"), Z(s.$slots, "append", {}, () => [r.value ? (g(),
            _("span", RP, [s.appendHtml ? (g(),
            _("span", {
                key: 0,
                innerHTML: s.appendHtml
            }, null, 8, LP)) : (g(),
            _("span", jP, Q(s.append), 1))])) : q("", !0)])]),
            _: 3
        }, 8, ["id", "class"]))
    }
})
  , J_ = Se({
    __name: "BInputGroupText",
    props: {
        tag: {
            default: "div"
        },
        text: {
            default: void 0
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(qe(e.tag), {
            class: "input-group-text"
        }, {
            default: N( () => [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)])]),
            _: 3
        }))
    }
})
  , Am = Se({
    __name: "BInputGroupAddon",
    props: {
        isText: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.isText);
        return (r, a) => A(n) ? (g(),
        de(J_, {
            key: 0
        }, {
            default: N( () => [Z(r.$slots, "default")]),
            _: 3
        })) : Z(r.$slots, "default", {
            key: 1
        })
    }
})
  , X_ = Se({
    __name: "BInputGroupAppend",
    props: {
        isText: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(Am, ut(Vt(e.$props)), {
            default: N( () => [Z(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , HP = Se({
    __name: "BInputGroupPrepend",
    props: {
        isText: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        return (e, n) => (g(),
        de(Am, ut(Vt(e.$props)), {
            default: N( () => [Z(e.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , KP = Se({
    __name: "BListGroup",
    props: {
        flush: {
            type: [String, Boolean],
            default: !1
        },
        horizontal: {
            type: [Boolean, String],
            default: !1
        },
        numbered: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.flush)
          , r = H( () => e.numbered)
          , a = K( () => {
            const l = n.value ? !1 : e.horizontal;
            return {
                "list-group-flush": n.value,
                "list-group-horizontal": l === !0,
                [`list-group-horizontal-${l}`]: typeof l == "string",
                "list-group-numbered": r.value
            }
        }
        )
          , s = _e( () => r.value === !0 ? "ol" : e.tag);
        return zn(Yk, {
            numbered: r
        }),
        (l, i) => (g(),
        de(qe(s.value), {
            class: ye(["list-group", a.value])
        }, {
            default: N( () => [Z(l.$slots, "default")]),
            _: 3
        }, 8, ["class"]))
    }
})
  , zP = Se({
    __name: "BListGroupItem",
    props: {
        action: {
            type: [String, Boolean],
            default: !1
        },
        button: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        },
        active: {
            type: [String, Boolean],
            default: !1
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: null
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean]
        }
    },
    setup(t) {
        const e = t
          , n = x1()
          , r = Gt(Yk, null)
          , a = H( () => e.action)
          , s = H( () => e.active)
          , l = H( () => e.button)
          , i = H( () => e.disabled)
          , {computedLink: o} = gl(e)
          , u = _e( () => !l.value && o.value)
          , d = K( () => r != null && r.numbered.value ? "li" : l.value ? "button" : u.value ? ha : e.tag)
          , f = K( () => a.value || u.value || l.value || ["a", "router-link", "button", "b-link"].includes(e.tag))
          , p = K( () => ({
            [`list-group-item-${e.variant}`]: e.variant !== null,
            "list-group-item-action": f.value,
            active: s.value,
            disabled: i.value
        }))
          , h = K( () => {
            const v = {};
            return l.value && ((!n || !n.type) && (v.type = "button"),
            i.value && (v.disabled = !0)),
            v
        }
        );
        return (v, y) => (g(),
        de(qe(d.value), Ve({
            class: ["list-group-item", p.value],
            "aria-current": A(s) ? !0 : void 0,
            "aria-disabled": A(i) ? !0 : void 0,
            target: u.value ? v.target : void 0,
            href: A(l) ? void 0 : v.href,
            to: A(l) ? void 0 : v.to
        }, h.value), {
            default: N( () => [Z(v.$slots, "default")]),
            _: 3
        }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]))
    }
})
  , Mm = Se({
    __name: "BOverlay",
    props: {
        bgColor: {
            default: void 0
        },
        blur: {
            default: "2px"
        },
        fixed: {
            type: [String, Boolean],
            default: !1
        },
        noCenter: {
            type: [String, Boolean],
            default: !1
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        noWrap: {
            type: [String, Boolean],
            default: !1
        },
        opacity: {
            default: .85
        },
        overlayTag: {
            default: "div"
        },
        rounded: {
            type: [Boolean, String],
            default: !1
        },
        show: {
            type: [String, Boolean],
            default: !1
        },
        spinnerSmall: {
            type: [String, Boolean],
            default: !1
        },
        spinnerType: {
            default: "border"
        },
        spinnerVariant: {
            default: void 0
        },
        noSpinner: {
            type: [String, Boolean],
            default: !1
        },
        variant: {
            default: "light"
        },
        wrapTag: {
            default: "div"
        },
        zIndex: {
            default: 10
        }
    },
    emits: ["click", "hidden", "shown"],
    setup(t, {emit: e}) {
        const n = t
          , r = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
        }
          , a = H( () => n.fixed)
          , s = H( () => n.noSpinner)
          , l = H( () => n.noCenter)
          , i = H( () => n.noWrap)
          , o = H( () => n.show)
          , u = H( () => n.spinnerSmall)
          , d = _e( () => n.rounded === !0 || n.rounded === "" ? "rounded" : n.rounded === !1 ? "" : `rounded-${n.rounded}`)
          , f = _e( () => n.variant !== null && !n.bgColor ? `bg-${n.variant}` : "")
          , p = _e( () => o.value ? !0 : null)
          , h = K( () => ({
            type: n.spinnerType,
            variant: n.spinnerVariant,
            small: u.value
        }))
          , v = K( () => ({
            ...r,
            zIndex: n.zIndex || 10
        }))
          , y = K( () => ({
            "position-absolute": !i.value || !a.value,
            "position-fixed": i.value && a.value
        }))
          , k = K( () => [f.value, d.value])
          , w = K( () => ({
            ...r,
            opacity: n.opacity,
            backgroundColor: n.bgColor || void 0,
            backdropFilter: n.blur ? `blur(${n.blur})` : void 0
        }))
          , $ = K( () => l.value ? r : {
            top: "50%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%)"
        });
        return (M, S) => (g(),
        de(qe(M.wrapTag), {
            class: "b-overlay-wrap position-relative",
            "aria-busy": p.value
        }, {
            default: N( () => [Z(M.$slots, "default"), x(Ei, {
                "no-fade": M.noFade,
                "trans-props": {
                    enterToClass: "show"
                },
                name: "fade",
                onOnAfterEnter: S[1] || (S[1] = T => e("shown")),
                onOnAfterLeave: S[2] || (S[2] = T => e("hidden"))
            }, {
                default: N( () => [A(o) ? (g(),
                de(qe(M.overlayTag), {
                    key: 0,
                    class: ye(["b-overlay", y.value]),
                    style: Rt(v.value),
                    onClick: S[0] || (S[0] = T => e("click", T))
                }, {
                    default: N( () => [c("div", {
                        class: ye(["position-absolute", k.value]),
                        style: Rt(w.value)
                    }, null, 6), c("div", {
                        class: "position-absolute",
                        style: Rt($.value)
                    }, [Z(M.$slots, "overlay", ut(Vt(h.value)), () => [A(s) ? q("", !0) : (g(),
                    de(er, ut(Ve({
                        key: 0
                    }, h.value)), null, 16))])], 4)]),
                    _: 3
                }, 8, ["class", "style"])) : q("", !0)]),
                _: 3
            }, 8, ["no-fade"])]),
            _: 3
        }, 8, ["aria-busy"]))
    }
})
  , qP = ["id", "aria-labelledby", "aria-describedby"]
  , WP = ["id"]
  , Vb = 1056
  , GP = Se({
    inheritAttrs: !1,
    __name: "BModal",
    props: {
        bodyVariant: {
            default: null
        },
        bodyBgVariant: {
            default: null
        },
        bodyClass: {
            default: void 0
        },
        bodyTextVariant: {
            default: null
        },
        busy: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        buttonSize: {
            default: "md"
        },
        cancelDisabled: {
            type: [String, Boolean],
            default: !1
        },
        cancelTitle: {
            default: "Cancel"
        },
        cancelVariant: {
            default: "secondary"
        },
        centered: {
            type: [String, Boolean],
            default: !1
        },
        contentClass: {
            default: void 0
        },
        dialogClass: {
            default: void 0
        },
        footerVariant: {
            default: null
        },
        footerBgVariant: {
            default: null
        },
        footerBorderVariant: {
            default: null
        },
        footerClass: {
            default: void 0
        },
        footerTextVariant: {
            default: null
        },
        fullscreen: {
            type: [Boolean, String],
            default: !1
        },
        headerBgVariant: {
            default: null
        },
        headerBorderVariant: {
            default: null
        },
        headerClass: {
            default: void 0
        },
        headerCloseClass: {
            default: void 0
        },
        headerCloseLabel: {
            default: "Close"
        },
        headerCloseVariant: {
            default: "secondary"
        },
        headerVariant: {
            default: null
        },
        headerTextVariant: {
            default: null
        },
        hideBackdrop: {
            type: [String, Boolean],
            default: !1
        },
        hideFooter: {
            type: [String, Boolean],
            default: !1
        },
        hideHeader: {
            type: [String, Boolean],
            default: !1
        },
        hideHeaderClose: {
            type: [String, Boolean],
            default: !1
        },
        id: {
            default: void 0
        },
        modalClass: {
            default: void 0
        },
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        noCloseOnBackdrop: {
            type: [String, Boolean],
            default: !1
        },
        noCloseOnEsc: {
            type: [String, Boolean],
            default: !1
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        autoFocus: {
            type: [String, Boolean],
            default: !0
        },
        okDisabled: {
            type: [String, Boolean],
            default: !1
        },
        okOnly: {
            type: [String, Boolean],
            default: !1
        },
        okTitle: {
            default: "Ok"
        },
        okVariant: {
            default: "primary"
        },
        scrollable: {
            type: [String, Boolean],
            default: !1
        },
        size: {
            default: "md"
        },
        title: {
            default: void 0
        },
        titleClass: {
            default: void 0
        },
        titleSrOnly: {
            type: [String, Boolean],
            default: !1
        },
        titleTag: {
            default: "h5"
        },
        autoFocusButton: {
            default: void 0
        },
        teleportDisabled: {
            type: [String, Boolean],
            default: !1
        },
        teleportTo: {
            default: "body"
        },
        bodyScrolling: {
            type: [String, Boolean],
            default: !1
        },
        backdropVariant: {
            default: void 0
        }
    },
    emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = an( () => r.id, "modal")
          , l = qt(r, "modelValue", n, {
            passive: !0
        })
          , i = H( () => r.busy)
          , o = H( () => r.lazy)
          , u = H( () => r.cancelDisabled)
          , d = H( () => r.centered)
          , f = H( () => r.hideBackdrop)
          , p = H( () => r.hideFooter)
          , h = H( () => r.hideHeader)
          , v = H( () => r.hideHeaderClose)
          , y = H(l)
          , k = H( () => r.noCloseOnBackdrop)
          , w = H( () => r.noCloseOnEsc)
          , $ = H( () => r.noFade)
          , M = H( () => r.autoFocus)
          , S = H( () => r.okDisabled)
          , T = H( () => r.okOnly)
          , E = H( () => r.scrollable)
          , O = H( () => r.titleSrOnly)
          , U = H( () => r.teleportDisabled)
          , L = H( () => r.bodyScrolling)
          , C = me(null)
          , W = me(null)
          , R = me(null)
          , G = me(null)
          , te = me(y.value)
          , J = me(!1);
        Cr("Escape", () => {
            ke("esc")
        }
        , {
            target: C
        }),
        M_(y, L);
        const {focused: ae} = ar(C, {
            initialValue: y.value && r.autoFocusButton === void 0
        })
          , {focused: oe} = ar(W, {
            initialValue: y.value && r.autoFocusButton === "ok"
        })
          , {focused: ne} = ar(R, {
            initialValue: y.value && r.autoFocusButton === "cancel"
        })
          , {focused: I} = ar(G, {
            initialValue: y.value && r.autoFocusButton === "close"
        })
          , j = K( () => [r.modalClass, {
            fade: !$.value,
            show: te.value
        }])
          , re = _e( () => o.value === !1 || o.value === !0 && J.value === !0 || o.value === !0 && y.value === !0)
          , le = _e( () => r.backdropVariant !== void 0 ? r.backdropVariant : f.value ? "transparent" : "dark")
          , ce = _e( () => !Mn(a["header-close"]))
          , xe = K( () => [r.dialogClass, {
            "modal-fullscreen": r.fullscreen === !0,
            [`modal-fullscreen-${r.fullscreen}-down`]: typeof r.fullscreen == "string",
            [`modal-${r.size}`]: r.size !== "md",
            "modal-dialog-centered": d.value,
            "modal-dialog-scrollable": E.value
        }])
          , X = Nr( () => ({
            bgVariant: r.bodyBgVariant,
            textVariant: r.bodyTextVariant,
            variant: r.bodyVariant
        }))
          , be = K( () => [r.bodyClass, X.value])
          , ee = Nr( () => ({
            bgVariant: r.headerBgVariant,
            textVariant: r.headerTextVariant,
            variant: r.headerVariant
        }))
          , B = K( () => [r.headerClass, ee.value, {
            [`border-${r.headerBorderVariant}`]: r.headerBorderVariant !== null
        }])
          , se = K( () => [r.headerCloseClass])
          , pe = K( () => ({
            variant: ce.value ? r.headerCloseVariant : void 0,
            class: se.value
        }))
          , ie = Nr( () => ({
            bgVariant: r.footerBgVariant,
            textVariant: r.footerTextVariant,
            variant: r.footerVariant
        }))
          , fe = K( () => [r.footerClass, ie.value, {
            [`border-${r.footerBorderVariant}`]: r.footerBorderVariant !== null
        }])
          , F = K( () => [r.titleClass, {
            "visually-hidden": O.value
        }])
          , z = _e( () => u.value || i.value)
          , ge = _e( () => S.value || i.value)
          , Te = (m, b={}) => new Wo(m,{
            cancelable: !1,
            target: C.value || null,
            relatedTarget: null,
            trigger: null,
            ...b,
            componentId: s.value
        })
          , ke = (m="") => {
            const b = Te("hide", {
                cancelable: m !== "",
                trigger: m
            });
            if (m === "ok" && n(m, b),
            m === "cancel" && n(m, b),
            m === "close" && n(m, b),
            n("hide", b),
            b.defaultPrevented || m === "backdrop" && k.value || m === "esc" && w.value) {
                n("hide-prevented");
                return
            }
            l.value = !1
        }
          , Ee = () => {
            const m = Te("show", {
                cancelable: !0
            });
            if (n("show", m),
            m.defaultPrevented) {
                l.value = !1,
                n("show-prevented");
                return
            }
            l.value = !0
        }
          , Fe = () => {
            M.value !== !1 && (r.autoFocusButton === "ok" ? oe.value = !0 : r.autoFocusButton === "close" ? I.value = !0 : r.autoFocusButton === "cancel" ? ne.value = !0 : ae.value = !0)
        }
          , Oe = () => Ee()
          , De = () => {
            te.value = !0,
            Fe(),
            n("shown", Te("shown")),
            o.value === !0 && (J.value = !0)
        }
          , Ce = () => {
            te.value = !1
        }
          , Be = () => {
            n("hidden", Te("hidden")),
            o.value === !0 && (J.value = !1)
        }
          , {activePosition: ze, activeModalCount: Le} = gN(te, s)
          , Ye = K( () => ({
            "z-index": te.value ? Vb - (Le.value - ze.value) : Vb
        }));
        on(C, "bv-toggle", () => {
            y.value ? ke() : Ee()
        }
        );
        const D = Fn({
            cancel: () => ke("cancel"),
            close: () => ke("close"),
            hide: ke,
            ok: () => ke("ok"),
            visible: y
        });
        return e({
            hide: ke,
            show: Ee,
            id: s.value
        }),
        (m, b) => (g(),
        de(Ti, {
            to: m.teleportTo,
            disabled: A(U)
        }, [x(Ei, {
            "no-fade": !0,
            "trans-props": {
                enterToClass: "show"
            },
            onBeforeEnter: Oe,
            onAfterEnter: De,
            onLeave: Ce,
            onAfterLeave: Be
        }, {
            default: N( () => [ft(c("div", Ve({
                id: A(s),
                ref_key: "element",
                ref: C,
                class: ["modal", j.value],
                role: "dialog",
                "aria-labelledby": A(h) ? void 0 : `${A(s)}-label`,
                "aria-describedby": `${A(s)}-body`,
                tabindex: "-1"
            }, m.$attrs, {
                style: Ye.value
            }), [c("div", {
                class: ye(["modal-dialog", xe.value])
            }, [re.value ? (g(),
            _("div", {
                key: 0,
                class: ye(["modal-content", m.contentClass])
            }, [A(h) ? q("", !0) : (g(),
            _("div", {
                key: 0,
                class: ye(["modal-header", B.value])
            }, [Z(m.$slots, "header", ut(Vt(D)), () => [(g(),
            de(qe(m.titleTag), {
                id: `${A(s)}-label`,
                class: ye(["modal-title", F.value])
            }, {
                default: N( () => [Z(m.$slots, "title", ut(Vt(D)), () => [ve(Q(m.title), 1)], !0)]),
                _: 3
            }, 8, ["id", "class"])), A(v) ? q("", !0) : (g(),
            _(we, {
                key: 0
            }, [ce.value ? (g(),
            de(is, Ve({
                key: 0
            }, pe.value, {
                onClick: b[0] || (b[0] = P => ke("close"))
            }), {
                default: N( () => [Z(m.$slots, "header-close", {}, void 0, !0)]),
                _: 3
            }, 16)) : (g(),
            de(Ai, Ve({
                key: 1,
                "aria-label": m.headerCloseLabel
            }, pe.value, {
                onClick: b[1] || (b[1] = P => ke("close"))
            }), null, 16, ["aria-label"]))], 64))], !0)], 2)), c("div", {
                id: `${A(s)}-body`,
                class: ye(["modal-body", be.value])
            }, [Z(m.$slots, "default", ut(Vt(D)), void 0, !0)], 10, WP), A(p) ? q("", !0) : (g(),
            _("div", {
                key: 1,
                class: ye(["modal-footer", fe.value])
            }, [Z(m.$slots, "footer", ut(Vt(D)), () => [Z(m.$slots, "cancel", ut(Vt(D)), () => [A(T) ? q("", !0) : (g(),
            de(is, {
                key: 0,
                ref_key: "cancelButton",
                ref: R,
                disabled: z.value,
                size: m.buttonSize,
                variant: m.cancelVariant,
                onClick: b[2] || (b[2] = P => ke("cancel"))
            }, {
                default: N( () => [ve(Q(m.cancelTitle), 1)]),
                _: 1
            }, 8, ["disabled", "size", "variant"]))], !0), Z(m.$slots, "ok", ut(Vt(D)), () => [x(is, {
                ref_key: "okButton",
                ref: W,
                disabled: ge.value,
                size: m.buttonSize,
                variant: m.okVariant,
                onClick: b[3] || (b[3] = P => ke("ok"))
            }, {
                default: N( () => [ve(Q(m.okTitle), 1)]),
                _: 1
            }, 8, ["disabled", "size", "variant"])], !0)], !0)], 2))], 2)) : q("", !0)], 2), Z(m.$slots, "backdrop", {}, () => [x(Mm, {
                variant: le.value,
                show: A(y),
                "no-spinner": "",
                fixed: "",
                "no-wrap": "",
                blur: null,
                onClick: b[4] || (b[4] = P => ke("backdrop"))
            }, null, 8, ["variant", "show"])], !0)], 16, qP), [[jn, A(y)]])]),
            _: 3
        })], 8, ["to", "disabled"]))
    }
})
  , YP = oc(GP, [["__scopeId", "data-v-49f7b865"]])
  , JP = Se({
    __name: "BNav",
    props: {
        align: {
            default: void 0
        },
        cardHeader: {
            type: [String, Boolean],
            default: !1
        },
        fill: {
            type: [String, Boolean],
            default: !1
        },
        justified: {
            type: [String, Boolean],
            default: !1
        },
        pills: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tabs: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "ul"
        },
        vertical: {
            type: [String, Boolean],
            default: !1
        },
        underline: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.cardHeader)
          , r = H( () => e.fill)
          , a = H( () => e.justified)
          , s = H( () => e.pills)
          , l = H( () => e.small)
          , i = H( () => e.tabs)
          , o = H( () => e.vertical)
          , u = Jo( () => e.align)
          , d = H( () => e.underline)
          , f = K( () => ({
            "nav-tabs": i.value,
            "nav-pills": s.value && !i.value,
            "card-header-tabs": !o.value && n.value && i.value,
            "card-header-pills": !o.value && n.value && s.value && !i.value,
            "flex-column": o.value,
            "nav-fill": !o.value && r.value,
            "nav-justified": !o.value && a.value,
            [u.value]: !o.value && e.align !== void 0,
            small: l.value,
            "nav-underline": d.value
        }));
        return (p, h) => (g(),
        de(qe(p.tag), {
            class: ye(["nav", f.value])
        }, {
            default: N( () => [Z(p.$slots, "default")]),
            _: 3
        }, 8, ["class"]))
    }
})
  , XP = {
    class: "d-flex flex-row align-items-center flex-wrap"
}
  , QP = Se({
    inheritAttrs: !1,
    __name: "BNavForm",
    props: {
        role: {
            default: void 0
        },
        id: {
            default: void 0
        },
        floating: {
            type: [String, Boolean],
            default: !1
        },
        novalidate: {
            type: [String, Boolean],
            default: !1
        },
        validated: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["submit"],
    setup(t, {emit: e}) {
        const n = r => {
            e("submit", r)
        }
        ;
        return (r, a) => (g(),
        _("li", XP, [x(j_, Ve(r.$attrs, {
            id: r.id,
            floating: r.floating,
            role: r.role,
            novalidate: r.novalidate,
            validated: r.validated,
            class: "d-flex",
            onSubmit: _t(n, ["prevent"])
        }), {
            default: N( () => [Z(r.$slots, "default")]),
            _: 3
        }, 16, ["id", "floating", "role", "novalidate", "validated", "onSubmit"])]))
    }
})
  , ZP = {
    class: "nav-item"
}
  , e5 = Se({
    __name: "BNavItem",
    props: {
        linkClass: {
            default: void 0
        },
        linkAttrs: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: void 0
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.disabled)
          , a = K( () => fm(n, ["active", "activeClass", "append", "disabled", "href", "icon", "opacity", "opacityHover", "rel", "replace", "routerComponentName", "target", "to", "underlineOffset", "underlineOffsetHover", "underlineOpacity", "underlineOpacityHover", "underlineVariant", "variant"]));
        return (s, l) => (g(),
        _("li", ZP, [x(ha, Ve({
            class: ["nav-link", s.linkClass]
        }, {
            ...a.value,
            ...s.linkAttrs
        }, {
            "active-class": s.activeClass,
            tabindex: A(r) ? -1 : void 0,
            "aria-disabled": A(r) ? !0 : void 0,
            onClick: l[0] || (l[0] = i => e("click", i))
        }), {
            default: N( () => [Z(s.$slots, "default")]),
            _: 3
        }, 16, ["class", "active-class", "tabindex", "aria-disabled"])]))
    }
})
  , t5 = {
    class: "nav-item dropdown"
}
  , n5 = Se({
    __name: "BNavItemDropdown",
    props: {
        ariaLabel: {
            default: void 0
        },
        id: {
            default: void 0
        },
        menuClass: {
            default: void 0
        },
        size: {
            default: "md"
        },
        splitClass: {
            default: void 0
        },
        splitVariant: {
            default: void 0
        },
        text: {
            default: void 0
        },
        toggleClass: {
            default: void 0
        },
        autoClose: {
            type: [Boolean, String],
            default: !0
        },
        block: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        isNav: {
            type: [String, Boolean],
            default: !0
        },
        dropup: {
            type: [String, Boolean],
            default: !1
        },
        dropend: {
            type: [String, Boolean],
            default: !1
        },
        dropstart: {
            type: [String, Boolean],
            default: !1
        },
        center: {
            type: [String, Boolean],
            default: !1
        },
        end: {
            type: [String, Boolean],
            default: !1
        },
        noFlip: {
            type: [String, Boolean],
            default: !1
        },
        noShift: {
            type: [String, Boolean],
            default: !1
        },
        offset: {
            default: 0
        },
        role: {
            default: "menu"
        },
        split: {
            type: [String, Boolean],
            default: !1
        },
        splitButtonType: {
            default: "button"
        },
        splitHref: {
            default: void 0
        },
        splitDisabled: {
            type: [String, Boolean],
            default: void 0
        },
        noCaret: {
            type: [String, Boolean],
            default: !1
        },
        toggleText: {
            default: "Toggle dropdown"
        },
        variant: {
            default: "link"
        },
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        strategy: {
            default: "absolute"
        },
        floatingMiddleware: {
            default: void 0
        },
        splitTo: {
            default: void 0
        },
        boundary: {
            default: "clippingAncestors"
        },
        container: {}
    },
    emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = me(null)
          , s = () => {
            var i;
            (i = a.value) == null || i.close()
        }
          , l = () => {
            var i;
            (i = a.value) == null || i.open()
        }
        ;
        return e({
            close: s,
            open: l,
            toggle: () => {
                var i;
                (i = a.value) == null || i.toggle()
            }
        }),
        (i, o) => (g(),
        _("li", t5, [x(L_, Ve({
            ref_key: "dropdown",
            ref: a
        }, r, {
            "is-nav": "",
            onShow: o[0] || (o[0] = u => n("show", u)),
            onShown: o[1] || (o[1] = u => n("shown")),
            onHide: o[2] || (o[2] = u => n("hide", u)),
            onHidden: o[3] || (o[3] = u => n("hidden")),
            onHidePrevented: o[4] || (o[4] = u => n("hide-prevented")),
            onShowPrevented: o[5] || (o[5] = u => n("show-prevented")),
            onClick: o[6] || (o[6] = u => n("click", u)),
            onToggle: o[7] || (o[7] = u => n("toggle")),
            "onUpdate:modelValue": o[8] || (o[8] = u => n("update:modelValue", u))
        }), {
            "button-content": N( () => [Z(i.$slots, "button-content")]),
            "toggle-text": N( () => [Z(i.$slots, "toggle-text")]),
            default: N( () => [Z(i.$slots, "default", {
                hide: s,
                show: l
            })]),
            _: 3
        }, 16)]))
    }
})
  , r5 = {
    class: "navbar-text"
}
  , a5 = Se({
    __name: "BNavText",
    props: {
        text: {
            default: void 0
        }
    },
    setup(t) {
        return (e, n) => (g(),
        _("li", r5, [Z(e.$slots, "default", {}, () => [ve(Q(e.text), 1)])]))
    }
})
  , s5 = Se({
    __name: "BNavbar",
    props: {
        fixed: {
            default: void 0
        },
        print: {
            type: [String, Boolean],
            default: !1
        },
        sticky: {
            default: void 0
        },
        tag: {
            default: "nav"
        },
        toggleable: {
            type: [Boolean, String],
            default: !1
        },
        variant: {
            default: null
        },
        container: {
            type: [String, Boolean],
            default: "fluid"
        },
        autoClose: {
            type: Boolean,
            default: !0
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.print)
          , r = _e( () => e.tag === "nav" ? void 0 : "navigation")
          , a = K( () => typeof e.toggleable == "string" ? `navbar-expand-${e.toggleable}` : e.toggleable === !1 ? "navbar-expand" : void 0)
          , s = _e( () => e.container === !0 ? "container" : "container-fluid")
          , l = K( () => ({
            "d-print": n.value,
            [`sticky-${e.sticky}`]: e.sticky !== void 0,
            [`bg-${e.variant}`]: e.variant !== null,
            [`fixed-${e.fixed}`]: e.fixed !== void 0,
            [`${a.value}`]: a.value !== void 0
        }));
        return zn(hm, {
            tag: _e( () => e.tag),
            autoClose: _e( () => e.autoClose)
        }),
        (i, o) => (g(),
        de(qe(i.tag), {
            class: ye(["navbar", l.value]),
            role: r.value
        }, {
            default: N( () => [i.container !== !1 ? (g(),
            _("div", {
                key: 0,
                class: ye(s.value)
            }, [Z(i.$slots, "default")], 2)) : Z(i.$slots, "default", {
                key: 1
            })]),
            _: 3
        }, 8, ["class", "role"]))
    }
})
  , l5 = Se({
    __name: "BNavbarBrand",
    props: {
        tag: {
            default: "div"
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        variant: {
            default: void 0
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , {computedLink: n, computedLinkProps: r} = gl(e, ["active", "activeClass", "append", "disabled", "href", "rel", "replace", "routerComponentName", "target", "to", "variant", "opacity", "opacityHover", "underlineVariant", "underlineOffset", "underlineOffsetHover", "underlineOpacity", "underlineOpacityHover", "icon"])
          , a = _e( () => n.value ? ha : e.tag);
        return (s, l) => (g(),
        de(qe(a.value), Ve({
            class: "navbar-brand"
        }, A(r)), {
            default: N( () => [Z(s.$slots, "default")]),
            _: 3
        }, 16))
    }
})
  , i5 = Se({
    __name: "BNavbarNav",
    props: {
        align: {
            default: void 0
        },
        fill: {
            type: [String, Boolean],
            default: !1
        },
        justified: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "ul"
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.fill)
          , r = H( () => e.justified)
          , a = H( () => e.small)
          , s = Jo( () => e.align)
          , l = K( () => ({
            "nav-fill": n.value,
            "nav-justified": r.value,
            [s.value]: e.align !== void 0,
            small: a.value
        }));
        return (i, o) => (g(),
        _("ul", {
            class: ye(["navbar-nav", l.value])
        }, [Z(i.$slots, "default")], 2))
    }
})
  , Ib = (t, e) => t.setAttribute("data-bs-theme", e)
  , o5 = {
    mounted(t, e) {
        Ib(t, e.value)
    },
    updated(t, e) {
        Ib(t, e.value)
    }
}
  , u5 = (t, e) => {
    const {modifiers: n, arg: r, value: a} = t
      , s = Object.keys(n || {})
      , l = typeof a == "string" ? a.split(Du) : a;
    if (iO(e.tagName, "a")) {
        const i = cm(e, "href") || "";
        BM.test(i) && s.push(i.replace(FM, ""))
    }
    return Array.prototype.concat.apply([], [r, l]).forEach(i => typeof i == "string" && s.push(i)),
    s.filter( (i, o, u) => i && u.indexOf(i) === o)
}
  , d5 = (t, e) => {
    t.forEach(n => {
        const r = document.getElementById(n);
        r !== null && r.dispatchEvent(new Event("bv-toggle"))
    }
    ),
    setTimeout( () => Q_(t, e), 50)
}
  , Q_ = (t, e) => {
    let n = !1;
    t.forEach(r => {
        const a = document.getElementById(r);
        a != null && a.classList.contains("show") && (n = !0),
        a != null && a.classList.contains("closing") && (n = !1)
    }
    ),
    e.setAttribute("aria-expanded", n ? "true" : "false"),
    e.classList.remove(n ? "collapsed" : "not-collapsed"),
    e.classList.add(n ? "not-collapsed" : "collapsed")
}
  , Rb = (t, e) => {
    const n = u5(e, t);
    t.__toggle && t.removeEventListener("click", t.__toggle),
    t.__toggle = () => d5(n, t),
    t.addEventListener("click", t.__toggle),
    t.setAttribute("aria-controls", n.join(" ")),
    Q_(n, t)
}
  , Np = {
    mounted: Rb,
    updated: Rb,
    unmounted(t) {
        t.removeEventListener("click", t.__toggle),
        t.removeAttribute("aria-controls"),
        t.removeAttribute("aria-expanded")
    }
}
  , c5 = {
    mounted(t, e) {
        if (!Co(e.value))
            return;
        const n = td(e.value, t);
        !n.content && !n.title || (t.$__state = me({
            ...Jl(e, t),
            ...n
        }),
        nd(t, e))
    },
    updated(t, e) {
        if (!Co(e.value))
            return;
        const n = td(e.value, t);
        if (!(!n.content && !n.title)) {
            if (!t.$__state) {
                t.$__state = me({
                    ...Jl(e, t),
                    ...n
                }),
                nd(t, e);
                return
            }
            t.$__state.value = {
                ...Jl(e, t),
                ...n
            }
        }
    },
    beforeUnmount(t) {
        O_(t)
    }
}
  , f5 = {
    mounted(t, e) {
        const n = Co(e.value);
        if (!n)
            return;
        const r = td(e.value, t);
        !r.content && !r.title || (t.$__state = me({
            noninteractive: !0,
            ...Jl(e, t),
            title: r.title ?? r.content ?? "",
            tooltip: n
        }),
        nd(t, e))
    },
    updated(t, e) {
        const n = Co(e.value);
        if (!n)
            return;
        const r = td(e.value, t);
        if (!(!r.content && !r.title)) {
            if (!t.$__state) {
                t.$__state = me({
                    noninteractive: !0,
                    ...Jl(e, t),
                    title: r.title ?? r.content ?? "",
                    tooltip: n
                }),
                nd(t, e);
                return
            }
            t.$__state.value = {
                noninteractive: !0,
                ...Jl(e, t),
                title: r.title ?? r.content ?? "",
                tooltip: n
            }
        }
    },
    beforeUnmount(t) {
        O_(t)
    }
}
  , Lb = Object.freeze(Object.defineProperty({
    __proto__: null,
    vBColorMode: o5,
    vBModal: Np,
    vBPopover: c5,
    vBToggle: Np,
    vBTooltip: f5
}, Symbol.toStringTag, {
    value: "Module"
}))
  , p5 = ["disabled", "aria-label"]
  , h5 = c("span", {
    class: "navbar-toggler-icon"
}, null, -1)
  , m5 = Se({
    __name: "BNavbarToggle",
    props: {
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        label: {
            default: "Toggle navigation"
        },
        target: {
            default: void 0
        }
    },
    emits: ["click"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.disabled)
          , a = K( () => ({
            disabled: r.value
        }))
          , s = l => {
            r.value || e("click", l)
        }
        ;
        return (l, i) => ft((g(),
        _("button", {
            class: ye(["navbar-toggler", a.value]),
            type: "button",
            disabled: A(r),
            "aria-label": l.label,
            onClick: s
        }, [Z(l.$slots, "default", {}, () => [h5])], 10, p5)), [[A(Np), A(r) ? void 0 : l.target]])
    }
})
  , v5 = ["id", "aria-labelledby"]
  , g5 = ["id"]
  , b5 = Se({
    inheritAttrs: !1,
    __name: "BOffcanvas",
    props: {
        modelValue: {
            type: [String, Boolean],
            default: !1
        },
        bodyScrolling: {
            type: [String, Boolean],
            default: !1
        },
        backdrop: {
            type: [String, Boolean],
            default: !0
        },
        noCloseOnBackdrop: {
            type: [String, Boolean],
            default: !1
        },
        noCloseOnEsc: {
            type: [String, Boolean],
            default: !1
        },
        placement: {
            default: "start"
        },
        title: {
            default: void 0
        },
        noHeaderClose: {
            type: [String, Boolean],
            default: !1
        },
        noHeader: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        id: {
            default: void 0
        },
        noFocus: {
            type: [String, Boolean],
            default: !1
        },
        backdropVariant: {
            default: "dark"
        },
        headerClass: {
            default: void 0
        },
        headerCloseClass: {
            default: void 0
        },
        headerCloseLabel: {
            default: "Close"
        },
        headerCloseVariant: {
            default: "secondary"
        },
        bodyClass: {
            default: void 0
        },
        footerClass: {
            default: void 0
        },
        teleportDisabled: {
            type: [String, Boolean],
            default: !1
        },
        teleportTo: {
            default: "body"
        }
    },
    emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = qt(r, "modelValue", n, {
            passive: !0
        })
          , l = H(s)
          , i = H( () => r.bodyScrolling)
          , o = H( () => r.backdrop)
          , u = H( () => r.noHeaderClose)
          , d = H( () => r.noHeader)
          , f = H( () => r.noFocus)
          , p = H( () => r.noCloseOnBackdrop)
          , h = H( () => r.noCloseOnEsc)
          , v = H( () => r.lazy)
          , y = H( () => r.teleportDisabled)
          , k = an( () => r.id, "offcanvas");
        M_(l, i);
        const w = me(null);
        Cr("Escape", () => {
            G("esc")
        }
        , {
            target: w
        });
        const {focused: $} = ar(w, {
            initialValue: l.value && f.value === !1
        })
          , M = me(l.value)
          , S = me(!1)
          , T = _e( () => o.value === !0 && l.value === !0)
          , E = _e( () => v.value === !1 || v.value === !0 && S.value === !0 || v.value === !0 && l.value === !0)
          , O = _e( () => !Mn(a["header-close"]))
          , U = K( () => [{
            "text-reset": !O.value
        }, r.headerCloseClass])
          , L = K( () => ({
            variant: O.value ? r.headerCloseVariant : void 0,
            class: U.value
        }))
          , C = _e( () => !Mn(a.footer))
          , W = K( () => ["offcanvas", `offcanvas-${r.placement}`, {
            show: l.value && M.value === !0
        }])
          , R = (j, re={}) => new Wo(j,{
            cancelable: !1,
            target: w.value || null,
            relatedTarget: null,
            trigger: null,
            ...re,
            componentId: k.value
        })
          , G = (j="") => {
            const re = R("hide", {
                cancelable: j !== "",
                trigger: j
            });
            if (j === "close" && n(j, re),
            j === "esc" && n(j, re),
            n("hide", re),
            re.defaultPrevented || j === "backdrop" && p.value || j === "esc" && h.value) {
                n("hide-prevented");
                return
            }
            s.value = !1
        }
          , te = () => {
            const j = R("show", {
                cancelable: !0
            });
            if (n("show", j),
            j.defaultPrevented) {
                s.value = !1,
                n("show-prevented");
                return
            }
            s.value = !0
        }
          , J = () => {
            Ot( () => {
                f.value === !1 && ($.value = !0)
            }
            )
        }
          , ae = () => te()
          , oe = () => {
            M.value = !0,
            J(),
            n("shown", R("shown")),
            v.value === !0 && (S.value = !0)
        }
          , ne = () => {
            M.value = !1
        }
          , I = () => {
            n("hidden", R("hidden")),
            v.value === !0 && (S.value = !1)
        }
        ;
        return on(w, "bv-toggle", () => {
            l.value ? G() : te()
        }
        ),
        e({
            hide: G,
            show: te
        }),
        (j, re) => (g(),
        de(Ti, {
            to: j.teleportTo,
            disabled: A(y)
        }, [x(Ei, {
            "no-fade": !0,
            "trans-props": {
                enterToClass: "showing",
                enterFromClass: "",
                leaveToClass: "hiding show",
                leaveFromClass: "show"
            },
            onBeforeEnter: ae,
            onAfterEnter: oe,
            onLeave: ne,
            onAfterLeave: I
        }, {
            default: N( () => [ft(c("div", Ve({
                id: A(k),
                ref_key: "element",
                ref: w,
                "aria-modal": "true",
                role: "dialog",
                class: W.value,
                tabindex: "-1",
                "aria-labelledby": `${A(k)}-offcanvas-label`,
                "data-bs-backdrop": "false"
            }, j.$attrs), [E.value ? (g(),
            _(we, {
                key: 0
            }, [A(d) ? q("", !0) : (g(),
            _("div", {
                key: 0,
                class: ye(["offcanvas-header", j.headerClass])
            }, [Z(j.$slots, "header", {
                visible: A(l),
                placement: j.placement,
                hide: G
            }, () => [c("h5", {
                id: `${A(k)}-offcanvas-label`,
                class: "offcanvas-title"
            }, [Z(j.$slots, "title", {
                visible: A(l),
                placement: j.placement,
                hide: G
            }, () => [ve(Q(j.title), 1)])], 8, g5), A(u) ? q("", !0) : (g(),
            _(we, {
                key: 0
            }, [O.value ? (g(),
            de(is, Ve({
                key: 0
            }, L.value, {
                onClick: re[0] || (re[0] = le => G("close"))
            }), {
                default: N( () => [Z(j.$slots, "header-close")]),
                _: 3
            }, 16)) : (g(),
            de(Ai, Ve({
                key: 1,
                "aria-label": j.headerCloseLabel
            }, L.value, {
                onClick: re[1] || (re[1] = le => G("close"))
            }), null, 16, ["aria-label"]))], 64))])], 2)), c("div", {
                class: ye(["offcanvas-body", j.bodyClass])
            }, [Z(j.$slots, "default", {
                visible: A(l),
                placement: j.placement,
                hide: G
            })], 2), C.value ? (g(),
            _("div", {
                key: 1,
                class: ye(j.footerClass)
            }, [Z(j.$slots, "footer", {
                visible: A(l),
                placement: j.placement,
                hide: G
            })], 2)) : q("", !0)], 64)) : q("", !0)], 16, v5), [[jn, A(s)]])]),
            _: 3
        }), Z(j.$slots, "backdrop", {}, () => [x(Mm, {
            variant: j.backdropVariant,
            show: T.value,
            fixed: "",
            "no-wrap": "",
            "no-spinner": "",
            onClick: re[2] || (re[2] = le => G("backdrop"))
        }, null, 8, ["variant", "show"])])], 8, ["to", "disabled"]))
    }
})
  , y5 = 5
  , Z_ = 20
  , ew = 0
  , zr = 3
  , k5 = "ellipsis-text"
  , _5 = "first-text"
  , w5 = "last-text"
  , x5 = "next-text"
  , S5 = "page"
  , $5 = "prev-text"
  , jb = t => Math.max(Us(t) || Z_, 1)
  , Ub = t => Math.max(Us(t) || ew, 0)
  , T5 = (t, e) => {
    const n = Us(t) || 1;
    return n > e ? e : n < 1 ? 1 : n
}
  , C5 = Se({
    name: "BPagination",
    props: {
        align: {
            type: String,
            default: "start"
        },
        ariaControls: {
            type: String,
            default: void 0
        },
        ariaLabel: {
            type: String,
            default: "Pagination"
        },
        disabled: {
            type: [Boolean, String],
            default: !1
        },
        ellipsisClass: {
            type: [Array, String],
            default: () => []
        },
        ellipsisText: {
            type: String,
            default: "…"
        },
        firstClass: {
            type: [Array, String],
            default: () => []
        },
        firstNumber: {
            type: [Boolean, String],
            default: !1
        },
        firstText: {
            type: String,
            default: "«"
        },
        hideEllipsis: {
            type: [Boolean, String],
            default: !1
        },
        hideGotoEndButtons: {
            type: [Boolean, String],
            default: !1
        },
        labelFirstPage: {
            type: String,
            default: "Go to first page"
        },
        labelLastPage: {
            type: String,
            default: "Go to last page"
        },
        labelNextPage: {
            type: String,
            default: "Go to next page"
        },
        labelPage: {
            type: String,
            default: "Go to page"
        },
        labelPrevPage: {
            type: String,
            default: "Go to previous page"
        },
        lastClass: {
            type: [Array, String],
            default: () => []
        },
        lastNumber: {
            type: [Boolean, String],
            default: !1
        },
        lastText: {
            type: String,
            default: "»"
        },
        limit: {
            type: Number,
            default: y5
        },
        modelValue: {
            type: Number,
            default: 1
        },
        nextClass: {
            type: [Array, String],
            default: () => []
        },
        nextText: {
            type: String,
            default: "›"
        },
        pageClass: {
            type: [Array, String],
            default: () => []
        },
        perPage: {
            type: Number,
            default: Z_
        },
        pills: {
            type: [Boolean, String],
            default: !1
        },
        prevClass: {
            type: [Array, String],
            default: () => []
        },
        prevText: {
            type: String,
            default: "‹"
        },
        size: {
            type: String,
            default: "md"
        },
        totalRows: {
            type: Number,
            default: ew
        }
    },
    emits: ["update:modelValue", "page-click"],
    setup(t, {emit: e, slots: n}) {
        const r = qt(t, "modelValue", e)
          , a = H( () => t.disabled)
          , s = H( () => t.firstNumber)
          , l = H( () => t.hideEllipsis)
          , i = H( () => t.hideGotoEndButtons)
          , o = H( () => t.lastNumber)
          , u = H( () => t.pills)
          , d = _e( () => t.align === "fill" ? "start" : t.align)
          , f = Jo(d)
          , p = _e( () => Math.ceil(Ub(t.totalRows) / jb(t.perPage)))
          , h = K( () => {
            let E;
            return p.value - r.value + 2 < t.limit && t.limit > zr ? E = p.value - y.value + 1 : E = r.value - Math.floor(y.value / 2),
            E < 1 ? E = 1 : E > p.value - y.value && (E = p.value - y.value + 1),
            t.limit <= zr && o.value && p.value === E + y.value - 1 && (E = Math.max(E - 1, 1)),
            E
        }
        )
          , v = K( () => {
            const E = p.value - r.value;
            let O = !1;
            return E + 2 < t.limit && t.limit > zr ? t.limit > zr && (O = !0) : t.limit > zr && (O = !!(!l.value || s.value)),
            h.value <= 1 && (O = !1),
            O && s.value && h.value < 4 && (O = !1),
            O
        }
        )
          , y = K( () => {
            let E = t.limit;
            return p.value <= t.limit ? E = p.value : r.value < t.limit - 1 && t.limit > zr ? ((!l.value || o.value) && (E = t.limit - (s.value ? 0 : 1)),
            E = Math.min(E, t.limit)) : p.value - r.value + 2 < t.limit && t.limit > zr ? (!l.value || s.value) && (E = t.limit - (o.value ? 0 : 1)) : t.limit > zr && (E = t.limit - (l.value ? 0 : 2)),
            E
        }
        )
          , k = K( () => {
            const E = p.value - y.value;
            let O = !1;
            r.value < t.limit - 1 && t.limit > zr ? (!l.value || o.value) && (O = !0) : t.limit > zr && (O = !!(!l.value || o.value)),
            h.value > E && (O = !1);
            const U = h.value + y.value - 1;
            return O && o.value && U > p.value - 3 && (O = !1),
            O
        }
        )
          , w = Fn({
            pageSize: jb(t.perPage),
            totalRows: Ub(t.totalRows),
            numberOfPages: p.value
        })
          , $ = (E, O) => {
            if (O === r.value)
                return;
            const {target: U} = E
              , L = new si("page-click",{
                cancelable: !0,
                target: U
            });
            e("page-click", L, O),
            !L.defaultPrevented && (r.value = O)
        }
          , M = _e( () => t.size ? `pagination-${t.size}` : "")
          , S = _e( () => u.value ? "b-pagination-pills" : "");
        Ke(r, E => {
            const O = T5(E, p.value);
            O !== r.value && (r.value = O)
        }
        ),
        Ke(w, (E, O) => {
            E != null && (O.pageSize !== E.pageSize && O.totalRows === E.totalRows || O.numberOfPages !== E.numberOfPages && r.value > O.numberOfPages) && (r.value = 1)
        }
        );
        const T = K( () => {
            const E = [];
            for (let O = 0; O < y.value; O++)
                E.push({
                    number: h.value + O,
                    classes: null
                });
            return E
        }
        );
        return () => {
            const E = []
              , O = T.value.map(ae => ae.number)
              , U = ae => ae === r.value
              , L = r.value < 1
              , C = t.align === "fill"
              , W = (ae, oe, ne, I, j, re) => {
                const le = a.value || U(re) || L || ae < 1 || ae > p.value
                  , ce = ae < 1 ? 1 : ae > p.value ? p.value : ae
                  , xe = {
                    disabled: le,
                    page: ce,
                    index: ce - 1
                }
                  , X = wa(ne, xe, n) || I || "";
                return st("li", {
                    class: ["page-item", {
                        disabled: le,
                        "flex-fill": C,
                        "d-flex": C && !le
                    }, j]
                }, st(le ? "span" : "button", {
                    class: ["page-link", {
                        "flex-grow-1": !le && C
                    }],
                    "aria-label": oe,
                    "aria-controls": t.ariaControls || null,
                    "aria-disabled": le ? !0 : null,
                    role: "menuitem",
                    type: le ? null : "button",
                    tabindex: le ? null : "-1",
                    onClick: be => {
                        le || $(be, ce)
                    }
                }, X))
            }
              , R = ae => st("li", {
                class: ["page-item", "disabled", "bv-d-xs-down-none", C ? "flex-fill" : "", t.ellipsisClass],
                role: "separator",
                key: `ellipsis-${ae ? "last" : "first"}`
            }, [st("span", {
                class: ["page-link"]
            }, wa(k5, {}, n) || t.ellipsisText || "...")])
              , G = (ae, oe) => {
                const ne = U(ae.number) && !L
                  , I = a.value ? null : ne || L && oe === 0 ? "0" : "-1"
                  , j = {
                    active: ne,
                    disabled: a.value,
                    page: ae.number,
                    index: ae.number - 1,
                    content: ae.number
                }
                  , re = wa(S5, j, n) || ae.number
                  , le = st(a.value ? "span" : "button", {
                    class: ["page-link", {
                        "flex-grow-1": !a.value && C
                    }],
                    "aria-controls": t.ariaControls || null,
                    "aria-disabled": a.value ? !0 : null,
                    "aria-label": t.labelPage ? `${t.labelPage} ${ae.number}` : null,
                    role: "menuitemradio",
                    type: a.value ? null : "button",
                    tabindex: I,
                    onClick: ce => {
                        a.value || $(ce, ae.number)
                    }
                }, re);
                return st("li", {
                    class: ["page-item", {
                        disabled: a.value,
                        active: ne,
                        "flex-fill": C,
                        "d-flex": C && !a.value
                    }, t.pageClass],
                    role: "presentation",
                    key: `page-${ae.number}`
                }, le)
            }
            ;
            if (!i.value && !s.value) {
                const ae = W(1, t.labelFirstPage, _5, t.firstText, t.firstClass, 1);
                E.push(ae)
            }
            const te = W(r.value - 1, t.labelFirstPage, $5, t.prevText, t.prevClass, 1);
            E.push(te),
            s.value && O[0] !== 1 && E.push(G({
                number: 1
            }, 0)),
            v.value && E.push(R(!1)),
            T.value.forEach( (ae, oe) => {
                const ne = v.value && s.value && O[0] !== 1 ? 1 : 0;
                E.push(G(ae, oe + ne))
            }
            ),
            k.value && E.push(R(!0)),
            o.value && O[O.length - 1] !== p.value && E.push(G({
                number: p.value
            }, -1));
            const J = W(r.value + 1, t.labelNextPage, x5, t.nextText, t.nextClass, p.value);
            if (E.push(J),
            !o.value && !i.value) {
                const ae = W(p.value, t.labelLastPage, w5, t.lastText, t.lastClass, p.value);
                E.push(ae)
            }
            return st("ul", {
                class: ["pagination", M.value, f.value, S.value],
                role: "menubar",
                "aria-disabled": a.value,
                "aria-label": t.ariaLabel || null
            }, E)
        }
    }
})
  , hr = Se({
    inheritAttrs: !1,
    __name: "BPlaceholder",
    props: {
        tag: {
            default: "span"
        },
        wrapperTag: {
            default: "span"
        },
        width: {
            default: void 0
        },
        cols: {
            default: 12
        },
        variant: {
            default: null
        },
        size: {
            default: "md"
        },
        animation: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = K( () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", ""))
          , r = K( () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols)
          , a = K( () => ({
            [`col-${r.value}`]: r.value !== void 0 && n.value === void 0,
            [`bg-${e.variant}`]: e.variant !== null,
            [`placeholder-${e.size}`]: e.size !== "md"
        }))
          , s = K( () => ({
            [`placeholder-${e.animation}`]: e.animation !== void 0
        }))
          , l = K( () => ({
            width: n.value === void 0 ? void 0 : `${n.value}%`
        }));
        return (i, o) => (g(),
        de(qe(i.wrapperTag), {
            class: ye(s.value)
        }, {
            default: N( () => [(g(),
            de(qe(i.tag), Ve(i.$attrs, {
                class: ["placeholder", a.value],
                style: l.value
            }), null, 16, ["class", "style"]))]),
            _: 1
        }, 8, ["class"]))
    }
})
  , tw = Se({
    __name: "BPlaceholderButton",
    props: {
        tag: {
            default: "div"
        },
        width: {
            default: void 0
        },
        cols: {
            default: void 0
        },
        variant: {
            default: "primary"
        },
        animation: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`btn-${e.variant}`]: e.variant !== null
        }));
        return (r, a) => (g(),
        de(hr, {
            class: ye(["btn disabled", n.value]),
            animation: r.animation,
            width: r.width,
            cols: r.cols,
            tag: r.tag
        }, null, 8, ["class", "animation", "width", "cols", "tag"]))
    }
})
  , E5 = Se({
    __name: "BPlaceholderCard",
    props: {
        noHeader: {
            type: [String, Boolean],
            default: !1
        },
        headerWidth: {
            default: 100
        },
        headerVariant: {
            default: void 0
        },
        headerAnimation: {
            default: void 0
        },
        headerSize: {
            default: "md"
        },
        noFooter: {
            type: [String, Boolean],
            default: !1
        },
        footerWidth: {
            default: 100
        },
        footerVariant: {
            default: void 0
        },
        footerAnimation: {
            default: void 0
        },
        footerSize: {
            default: "md"
        },
        animation: {
            default: void 0
        },
        size: {
            default: "md"
        },
        variant: {
            default: void 0
        },
        noButton: {
            type: [String, Boolean],
            default: !1
        },
        imgBottom: {
            type: [String, Boolean],
            default: !1
        },
        imgSrc: {
            default: void 0
        },
        imgBlankColor: {
            default: "#868e96"
        },
        imgHeight: {
            default: 100
        },
        noImg: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.noButton)
          , r = H( () => e.noHeader)
          , a = H( () => e.noFooter)
          , s = H( () => e.noImg)
          , l = K( () => ({
            width: e.footerWidth,
            animation: e.footerAnimation,
            size: n.value ? e.footerSize : void 0,
            variant: e.footerVariant
        }))
          , i = K( () => ({
            animation: e.animation,
            size: e.size,
            variant: e.variant
        }));
        return (o, u) => (g(),
        de($m, {
            "img-bottom": o.imgBottom
        }, gn({
            default: N( () => [Z(o.$slots, "default", {}, () => [x(hr, Ve({
                cols: "7"
            }, i.value), null, 16), x(hr, Ve({
                cols: "4"
            }, i.value), null, 16), x(hr, Ve({
                cols: "4"
            }, i.value), null, 16), x(hr, Ve({
                cols: "6"
            }, i.value), null, 16), x(hr, Ve({
                cols: "8"
            }, i.value), null, 16)])]),
            _: 2
        }, [A(s) ? void 0 : {
            name: "img",
            fn: N( () => [Z(o.$slots, "img", {}, () => [x(rd, {
                blank: !o.imgSrc,
                "blank-color": o.imgBlankColor,
                height: o.imgSrc ? void 0 : o.imgHeight,
                src: o.imgSrc,
                top: !o.imgBottom,
                bottom: o.imgBottom
            }, null, 8, ["blank", "blank-color", "height", "src", "top", "bottom"])])]),
            key: "0"
        }, A(r) ? void 0 : {
            name: "header",
            fn: N( () => [Z(o.$slots, "header", {}, () => [x(hr, {
                width: o.headerWidth,
                variant: o.headerVariant,
                animation: o.headerAnimation,
                size: o.headerSize
            }, null, 8, ["width", "variant", "animation", "size"])])]),
            key: "1"
        }, A(a) ? void 0 : {
            name: "footer",
            fn: N( () => [Z(o.$slots, "footer", {}, () => [A(n) ? (g(),
            de(hr, ut(Ve({
                key: 1
            }, l.value)), null, 16)) : (g(),
            de(tw, ut(Ve({
                key: 0
            }, l.value)), null, 16))])]),
            key: "2"
        }]), 1032, ["img-bottom"]))
    }
})
  , Om = Se({
    __name: "BTableSimple",
    props: {
        bordered: {
            type: [String, Boolean],
            default: !1
        },
        borderless: {
            type: [String, Boolean],
            default: !1
        },
        borderVariant: {
            default: null
        },
        captionTop: {
            type: [String, Boolean],
            default: !1
        },
        dark: {
            type: [String, Boolean],
            default: !1
        },
        hover: {
            type: [String, Boolean],
            default: !1
        },
        responsive: {
            type: [Boolean, String],
            default: !1
        },
        stacked: {
            type: [Boolean, String],
            default: !1
        },
        striped: {
            type: [String, Boolean],
            default: !1
        },
        stripedColumns: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tableClass: {
            default: void 0
        },
        tableVariant: {
            default: null
        },
        stickyHeader: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.captionTop)
          , r = H( () => e.borderless)
          , a = H( () => e.bordered)
          , s = H( () => e.dark)
          , l = H( () => e.hover)
          , i = H( () => e.small)
          , o = H( () => e.striped)
          , u = H( () => e.stickyHeader)
          , d = H( () => e.stripedColumns)
          , f = K( () => [e.tableClass, "table", "b-table", {
            "table-bordered": a.value,
            "table-borderless": r.value,
            [`border-${e.borderVariant}`]: e.borderVariant !== null,
            "caption-top": n.value,
            "table-dark": s.value,
            "table-hover": l.value,
            "b-table-stacked": typeof e.stacked == "boolean" && e.stacked,
            [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
            "table-striped": o.value,
            "table-sm": i.value,
            [`table-${e.tableVariant}`]: e.tableVariant !== null,
            "table-striped-columns": d.value
        }])
          , p = K( () => ({
            "table-responsive": e.responsive === !0,
            [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
            "b-table-sticky-header": u.value
        }));
        return (h, v) => h.responsive ? (g(),
        _("div", {
            key: 1,
            class: ye(p.value)
        }, [c("table", {
            class: ye(f.value)
        }, [Z(h.$slots, "default")], 2)], 2)) : (g(),
        _("table", {
            key: 0,
            class: ye(f.value)
        }, [Z(h.$slots, "default")], 2))
    }
})
  , A5 = Se({
    __name: "BPlaceholderTable",
    props: {
        rows: {
            default: 3
        },
        columns: {
            default: 5
        },
        cellWidth: {
            default: 100
        },
        size: {
            default: "md"
        },
        animation: {
            default: void 0
        },
        variant: {
            default: void 0
        },
        headerColumns: {
            default: void 0
        },
        hideHeader: {
            type: [String, Boolean],
            default: !1
        },
        headerCellWidth: {
            default: 100
        },
        headerSize: {
            default: "md"
        },
        headerAnimation: {
            default: void 0
        },
        headerVariant: {
            default: void 0
        },
        footerColumns: {
            default: void 0
        },
        showFooter: {
            type: [String, Boolean],
            default: !1
        },
        footerCellWidth: {
            default: 100
        },
        footerSize: {
            default: "md"
        },
        footerAnimation: {
            default: void 0
        },
        footerVariant: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = zt( () => e.columns)
          , r = zt( () => e.rows)
          , a = _e( () => e.headerColumns ?? NaN)
          , s = _e( () => e.footerColumns ?? NaN)
          , l = zt(a)
          , i = zt(s)
          , o = _e( () => n.value || 5)
          , u = _e( () => r.value || 3)
          , d = _e( () => e.headerColumns === void 0 ? o.value : l.value)
          , f = _e( () => e.footerColumns === void 0 ? o.value : i.value)
          , p = H( () => e.hideHeader)
          , h = H( () => e.showFooter);
        return (v, y) => (g(),
        de(Om, null, {
            default: N( () => [A(p) ? q("", !0) : Z(v.$slots, "thead", {
                key: 0
            }, () => [c("thead", null, [c("tr", null, [(g(!0),
            _(we, null, Ne(d.value, (k, w) => (g(),
            _("th", {
                key: w
            }, [x(hr, {
                size: v.headerSize,
                variant: v.headerVariant,
                animation: v.headerAnimation,
                width: v.headerCellWidth
            }, null, 8, ["size", "variant", "animation", "width"])]))), 128))])])]), Z(v.$slots, "default", {}, () => [c("tbody", null, [(g(!0),
            _(we, null, Ne(u.value, (k, w) => (g(),
            _("tr", {
                key: w
            }, [(g(!0),
            _(we, null, Ne(o.value, ($, M) => (g(),
            _("td", {
                key: M
            }, [x(hr, {
                size: v.size,
                variant: v.variant,
                animation: v.animation,
                width: v.cellWidth
            }, null, 8, ["size", "variant", "animation", "width"])]))), 128))]))), 128))])]), A(h) ? Z(v.$slots, "tfoot", {
                key: 1
            }, () => [c("tfoot", null, [c("tr", null, [(g(!0),
            _(we, null, Ne(f.value, (k, w) => (g(),
            _("th", {
                key: w
            }, [x(hr, {
                size: v.footerSize,
                variant: v.footerVariant,
                animation: v.footerAnimation,
                width: v.footerCellWidth
            }, null, 8, ["size", "variant", "animation", "width"])]))), 128))])])]) : q("", !0)]),
            _: 3
        }))
    }
})
  , M5 = Se({
    __name: "BPlaceholderWrapper",
    props: {
        loading: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.loading);
        return (r, a) => A(n) ? Z(r.$slots, "loading", {
            key: 0
        }) : Z(r.$slots, "default", {
            key: 1
        })
    }
})
  , O5 = ["aria-valuenow", "aria-valuemax"]
  , nw = Se({
    __name: "BProgressBar",
    props: {
        animated: {
            type: [String, Boolean],
            default: !1
        },
        label: {
            default: void 0
        },
        labelHtml: {
            default: void 0
        },
        max: {
            default: void 0
        },
        precision: {
            default: 0
        },
        showProgress: {
            type: [String, Boolean],
            default: !1
        },
        showValue: {
            type: [String, Boolean],
            default: !1
        },
        striped: {
            type: [String, Boolean],
            default: !1
        },
        value: {
            default: 0
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = Gt(Gk, null)
          , r = H( () => e.animated)
          , a = H( () => e.showProgress)
          , s = H( () => e.showValue)
          , l = H( () => e.striped)
          , i = Nr(e)
          , o = K( () => [i.value, {
            "progress-bar-animated": r.value || (n == null ? void 0 : n.animated.value),
            "progress-bar-striped": l.value || (n == null ? void 0 : n.striped.value) || r.value || (n == null ? void 0 : n.animated.value)
        }])
          , u = zt( () => e.precision)
          , d = zt( () => e.value)
          , f = zt(_e( () => e.max ?? NaN))
          , p = zt(_e( () => (n == null ? void 0 : n.max.value) ?? NaN))
          , h = K( () => e.labelHtml !== void 0 ? e.labelHtml : s.value || n != null && n.showValue.value ? d.value.toFixed(u.value) : a.value || n != null && n.showProgress.value ? (d.value * 100 / (f.value || 100)).toFixed(u.value) : e.label !== void 0 ? e.label : "")
          , v = K( () => p.value ? `${d.value * 100 / p.value}%` : f.value ? `${d.value * 100 / f.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`);
        return (y, k) => (g(),
        _("div", {
            class: ye(["progress-bar", o.value]),
            role: "progressbar",
            "aria-valuenow": y.value,
            "aria-valuemin": "0",
            "aria-valuemax": y.max,
            style: Rt({
                width: v.value
            })
        }, [Z(y.$slots, "default", {}, () => [ve(Q(h.value), 1)])], 14, O5))
    }
})
  , rw = Se({
    __name: "BProgress",
    props: {
        height: {
            default: void 0
        },
        animated: {
            type: [String, Boolean],
            default: !1
        },
        max: {
            default: 100
        },
        precision: {
            default: 0
        },
        showProgress: {
            type: [String, Boolean],
            default: !1
        },
        showValue: {
            type: [String, Boolean],
            default: !1
        },
        striped: {
            type: [String, Boolean],
            default: !1
        },
        value: {
            default: 0
        },
        variant: {
            default: void 0
        },
        bgVariant: {
            default: void 0
        },
        textVariant: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.animated)
          , r = H( () => e.showProgress)
          , a = H( () => e.showValue)
          , s = H( () => e.striped);
        return zn(Gk, {
            animated: n,
            max: _e( () => e.max),
            showProgress: r,
            showValue: a,
            striped: s
        }),
        (l, i) => (g(),
        _("div", {
            class: "progress",
            style: Rt({
                height: l.height
            })
        }, [Z(l.$slots, "default", {}, () => [x(nw, {
            animated: l.animated,
            max: l.max,
            precision: l.precision,
            "show-progress": l.showProgress,
            "show-value": l.showValue,
            striped: l.striped,
            value: l.value,
            variant: l.variant,
            "text-variant": l.textVariant,
            "bg-variant": l.bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])])], 4))
    }
})
  , Hb = rc("cols", [""], {
    type: [String, Number],
    default: null
})
  , N5 = Se({
    name: "BRow",
    slots: Object,
    props: {
        tag: {
            type: String,
            default: "div"
        },
        gutterX: {
            type: String,
            default: null
        },
        gutterY: {
            type: String,
            default: null
        },
        noGutters: {
            type: [Boolean, String],
            default: !1
        },
        alignV: {
            type: String,
            default: null
        },
        alignH: {
            type: String,
            default: null
        },
        alignContent: {
            type: String,
            default: null
        },
        ...Hb
    },
    setup(t) {
        const e = H( () => t.noGutters)
          , n = Jo( () => t.alignH)
          , r = K( () => Kk(t, Hb, "cols", "row-cols"));
        return {
            computedClasses: K( () => [r.value, {
                [`gx-${t.gutterX}`]: t.gutterX !== null,
                [`gy-${t.gutterY}`]: t.gutterY !== null,
                "g-0": e.value,
                [`align-items-${t.alignV}`]: t.alignV !== null,
                [n.value]: t.alignH !== null,
                [`align-content-${t.alignContent}`]: t.alignContent !== null
            }])
        }
    }
});
function D5(t, e, n, r, a, s) {
    return g(),
    de(qe(t.tag), {
        class: ye(["row", t.computedClasses])
    }, {
        default: N( () => [Z(t.$slots, "default")]),
        _: 3
    }, 8, ["class"])
}
const P5 = oc(N5, [["render", D5]])
  , F5 = ["TD", "TH", "TR"]
  , B5 = ["a", "a *", "button", "button *", "input:not(.disabled):not([disabled])", "select:not(.disabled):not([disabled])", "textarea:not(.disabled):not([disabled])", '[role="link"]', '[role="link"] *', '[role="button"]', '[role="button"] *', "[tabindex]:not(.disabled):not([disabled])"].join(",")
  , bu = t => {
    if (!t || !t.target)
        return !1;
    const e = t.target;
    if ("disabled"in e && e.disabled || F5.indexOf(e.tagName) !== -1)
        return !1;
    if (ob(".dropdown-menu", e))
        return !0;
    const n = e.tagName === "LABEL" ? e : ob("label", e);
    if (n) {
        const r = cm(n, "for")
          , a = r ? aO(r) : Uk("input, select, textarea", n);
        if (a && !a.disabled)
            return !0
    }
    return Hk(e, B5)
}
  , V5 = ["title", "abbr", "onClick"]
  , I5 = {
    class: "d-inline-flex flex-nowrap align-items-center gap-1"
}
  , R5 = {
    key: 1
}
  , L5 = {
    key: 0
}
  , j5 = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"]
  , U5 = {
    key: 0,
    class: "b-table-stacked-label"
}
  , H5 = ["colspan"]
  , K5 = {
    key: 1,
    class: "b-table-empty-slot"
}
  , z5 = ["colspan"]
  , q5 = {
    key: 2
}
  , W5 = {
    key: 0
}
  , G5 = ["title", "abbr", "onClick"]
  , Y5 = {
    class: "d-inline-flex flex-nowrap align-items-center gap-1"
}
  , J5 = {
    key: 1
}
  , X5 = {
    key: 2
}
  , Q5 = {
    key: 3
}
  , aw = Se({
    __name: "BTableLite",
    props: {
        align: {
            default: void 0
        },
        caption: {
            default: void 0
        },
        fields: {
            default: () => []
        },
        footClone: {
            type: [String, Boolean],
            default: !1
        },
        items: {
            default: () => []
        },
        labelStacked: {
            type: Boolean,
            default: !1
        },
        variant: {
            default: void 0
        },
        showEmpty: {
            type: [String, Boolean],
            default: !1
        },
        emptyText: {
            default: "There are no records to show"
        },
        emptyFilteredText: {
            default: "There are no records matching your request"
        },
        fieldColumnClass: {
            type: Function,
            default: void 0
        },
        tbodyTrClass: {
            type: Function,
            default: void 0
        },
        virtualFields: {
            default: 0
        },
        bordered: {
            type: [String, Boolean],
            default: !1
        },
        borderless: {
            type: [String, Boolean],
            default: !1
        },
        borderVariant: {
            default: void 0
        },
        captionTop: {
            type: [String, Boolean],
            default: !1
        },
        dark: {
            type: [String, Boolean],
            default: !1
        },
        hover: {
            type: [String, Boolean],
            default: !1
        },
        responsive: {
            type: [Boolean, String],
            default: !1
        },
        stacked: {
            type: [Boolean, String],
            default: !1
        },
        striped: {
            type: [String, Boolean],
            default: !1
        },
        stripedColumns: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tableClass: {
            default: void 0
        },
        stickyHeader: {
            type: [String, Boolean],
            default: !1
        }
    },
    emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
    setup(t, {emit: e}) {
        const n = t
          , r = H( () => n.footClone)
          , a = H( () => n.labelStacked)
          , s = H( () => n.showEmpty)
          , l = zt( () => n.virtualFields)
          , i = K( () => [n.tableClass, {
            [`align-${n.align}`]: n.align !== void 0
        }])
          , o = K( () => f(n.fields, n.items))
          , u = _e( () => o.value.length + l.value)
          , d = O => typeof O == "string" ? sb(O) : O.label !== void 0 ? O.label : typeof O.key == "string" ? sb(O.key) : O.key
          , f = (O, U) => {
            const L = [];
            return !(O != null && O.length) && U != null && U.length ? (Object.keys(U[0]).forEach(C => L.push({
                key: C,
                label: ab(C)
            })),
            L) : (Array.isArray(O) && O.forEach(C => {
                typeof C == "string" ? L.push({
                    key: C,
                    label: ab(C)
                }) : kp(C) && C.key && typeof C.key == "string" && L.push({
                    ...C
                })
            }
            ),
            L)
        }
          , p = (O, U, L) => {
            const C = ub(O, U);
            return L && typeof L == "function" ? L(C, U, O) : C
        }
          , h = (O, U) => p(O, U.key, U.formatter)
          , v = (O, U, L=!1) => {
            const C = typeof O == "string" ? O : O.key;
            e("head-clicked", C, O, U, L)
        }
          , y = (O, U, L) => {
            e("row-clicked", O, U, L)
        }
          , k = (O, U, L) => e("row-dbl-clicked", O, U, L)
          , w = (O, U, L) => e("row-hovered", O, U, L)
          , $ = (O, U, L) => e("row-unhovered", O, U, L)
          , M = O => {
            O._showDetails = !O._showDetails
        }
          , S = O => [O.class, O.thClass, {
            [`table-${O.variant}`]: O.variant !== null,
            "b-table-sticky-column": O.stickyColumn
        }, ...n.fieldColumnClass ? n.fieldColumnClass(O) : []]
          , T = (O, U) => [O.class, O.tdClass, U != null && U._cellVariants && U != null && U._cellVariants[O.key] ? `table-${U == null ? void 0 : U._cellVariants[O.key]}` : void 0, {
            [`table-${O.variant}`]: O.variant !== null,
            "b-table-sticky-column": O.stickyColumn
        }]
          , E = (O, U="row") => {
            const L = [O._rowVariant ? `table-${O._rowVariant}` : null, O._rowVariant ? `table-${O._rowVariant}` : null];
            if (n.tbodyTrClass) {
                const C = n.tbodyTrClass(O, U);
                C && L.push(...typeof C == "string" ? [C] : C)
            }
            return L
        }
        ;
        return (O, U) => (g(),
        de(Om, {
            bordered: O.bordered,
            borderless: O.borderless,
            "border-variant": O.borderVariant,
            "caption-top": O.captionTop,
            dark: O.dark,
            hover: O.hover,
            responsive: O.responsive,
            striped: O.striped,
            stacked: O.stacked,
            small: O.small,
            "table-class": i.value,
            "table-variant": O.variant,
            "sticky-header": O.stickyHeader,
            "striped-columns": O.stripedColumns
        }, {
            default: N( () => {
                var L;
                return [c("thead", null, [O.$slots["thead-top"] ? Z(O.$slots, "thead-top", {
                    key: 0
                }) : q("", !0), c("tr", null, [Z(O.$slots, "thead-tr-prefix"), (g(!0),
                _(we, null, Ne(o.value, C => (g(),
                _("th", Ve({
                    key: C.key,
                    scope: "col",
                    class: S(C),
                    title: C.headerTitle,
                    abbr: C.headerAbbr,
                    style: C.thStyle
                }, C.thAttr, {
                    onClick: W => v(C, W)
                }), [c("div", I5, [Z(O.$slots, "field-prefix", {
                    field: C
                }), c("div", null, [O.$slots[`head(${C.key})`] || O.$slots["head()"] ? Z(O.$slots, O.$slots[`head(${C.key})`] ? `head(${C.key})` : "head()", {
                    key: 0,
                    label: C.label,
                    column: C.key,
                    field: C,
                    isFoot: !1
                }) : (g(),
                _(we, {
                    key: 1
                }, [ve(Q(d(C)), 1)], 64))])])], 16, V5))), 128))]), O.$slots["thead-sub"] ? (g(),
                _("tr", R5, [(g(!0),
                _(we, null, Ne(o.value, C => (g(),
                _("td", {
                    key: C.key,
                    scope: "col",
                    class: ye([C.class, C.thClass, C.variant ? `table-${C.variant}` : ""])
                }, [O.$slots["thead-sub"] ? Z(O.$slots, "thead-sub", Ve({
                    key: 0,
                    items: o.value
                }, C)) : (g(),
                _(we, {
                    key: 1
                }, [ve(Q(C.label), 1)], 64))], 2))), 128))])) : q("", !0)]), c("tbody", null, [!O.stacked && O.$slots["top-row"] ? (g(),
                _("tr", L5, [Z(O.$slots, "top-row")])) : q("", !0), (g(!0),
                _(we, null, Ne(O.items, (C, W) => (g(),
                _(we, {
                    key: W
                }, [c("tr", {
                    class: ye(E(C, "row")),
                    onClick: R => !A(bu)(R) && y(C, W, R),
                    onDblclick: R => !A(bu)(R) && k(C, W, R),
                    onMouseenter: R => !A(bu)(R) && w(C, W, R),
                    onMouseleave: R => !A(bu)(R) && $(C, W, R)
                }, [Z(O.$slots, "tbody-tr-prefix", {
                    item: C
                }), (g(!0),
                _(we, null, Ne(o.value, R => (g(),
                _("td", Ve({
                    key: R.key
                }, R.tdAttr, {
                    class: T(R, C)
                }), [O.stacked && A(a) ? (g(),
                _("label", U5, Q(d(R)), 1)) : q("", !0), O.$slots[`cell(${R.key})`] || O.$slots["cell()"] ? Z(O.$slots, O.$slots[`cell(${R.key})`] ? `cell(${R.key})` : "cell()", {
                    key: 1,
                    value: A(ub)(C, R.key),
                    index: W,
                    item: C,
                    field: R,
                    items: O.items,
                    toggleDetails: () => M(C),
                    detailsShowing: C._showDetails
                }) : (g(),
                _(we, {
                    key: 2
                }, [ve(Q(h(C, R)), 1)], 64))], 16))), 128))], 42, j5), C._showDetails === !0 && O.$slots["row-details"] ? (g(),
                _("tr", {
                    key: 0,
                    class: ye(E(C, "row-details"))
                }, [c("td", {
                    colspan: u.value
                }, [Z(O.$slots, "row-details", {
                    item: C,
                    toggleDetails: () => M(C)
                })], 8, H5)], 2)) : q("", !0)], 64))), 128)), Z(O.$slots, "tbody-prefix", {
                    fieldsTotal: u.value
                }), A(s) && O.items.length === 0 ? (g(),
                _("tr", K5, [c("td", {
                    colspan: u.value
                }, [Z(O.$slots, "empty", {
                    items: O.items
                }, () => [ve(Q(O.emptyText), 1)])], 8, z5)])) : q("", !0), !O.stacked && O.$slots["bottom-row"] ? (g(),
                _("tr", q5, [Z(O.$slots, "bottom-row")])) : q("", !0)]), A(r) ? (g(),
                _("tfoot", W5, [c("tr", null, [Z(O.$slots, "tfoot-tr-prefix"), (g(!0),
                _(we, null, Ne(o.value, C => (g(),
                _("th", Ve({
                    key: C.key,
                    scope: "col",
                    class: S(C),
                    title: C.headerTitle,
                    abbr: C.headerAbbr,
                    style: C.thStyle
                }, C.thAttr, {
                    onClick: W => v(C, W)
                }), [c("div", Y5, [Z(O.$slots, "field-prefix", {
                    field: C
                }), c("div", null, [O.$slots[`foot(${C.key})`] || O.$slots["foot()"] ? Z(O.$slots, O.$slots[`foot(${C.key})`] ? `foot(${C.key})` : "foot()", {
                    key: 0,
                    label: C.label,
                    column: C.key,
                    field: C,
                    isFoot: !0
                }) : (g(),
                _(we, {
                    key: 1
                }, [ve(Q(d(C)), 1)], 64))])])], 16, G5))), 128))])])) : O.$slots["custom-foot"] ? (g(),
                _("tfoot", J5, [Z(O.$slots, "custom-foot", {
                    fields: o.value,
                    items: O.items,
                    columns: (L = o.value) == null ? void 0 : L.length
                })])) : q("", !0), O.$slots["table-caption"] ? (g(),
                _("caption", X5, [Z(O.$slots, "table-caption")])) : O.caption ? (g(),
                _("caption", Q5, Q(O.caption), 1)) : q("", !0)]
            }
            ),
            _: 3
        }, 8, ["bordered", "borderless", "border-variant", "caption-top", "dark", "hover", "responsive", "striped", "stacked", "small", "table-class", "table-variant", "sticky-header", "striped-columns"]))
    }
})
  , Z5 = ["colspan"]
  , e4 = {
    class: "d-flex align-items-center justify-content-center gap-2"
}
  , t4 = Se({
    __name: "BTable",
    props: {
        provider: {
            type: Function,
            default: void 0
        },
        sortCompare: {
            type: Function,
            default: void 0
        },
        noProvider: {
            default: void 0
        },
        noProviderPaging: {
            type: [String, Boolean],
            default: !1
        },
        noProviderSorting: {
            type: [String, Boolean],
            default: !1
        },
        noProviderFiltering: {
            type: [String, Boolean],
            default: !1
        },
        sortBy: {
            default: void 0
        },
        sortDesc: {
            type: [String, Boolean],
            default: !1
        },
        sortInternal: {
            type: [String, Boolean],
            default: !0
        },
        selectable: {
            type: [String, Boolean],
            default: !1
        },
        stickySelect: {
            type: [String, Boolean],
            default: !1
        },
        selectHead: {
            type: [Boolean, String],
            default: !0
        },
        selectMode: {
            default: "single"
        },
        selectionVariant: {
            default: "primary"
        },
        busy: {
            type: [String, Boolean],
            default: !1
        },
        busyLoadingText: {
            default: "Loading..."
        },
        perPage: {
            default: void 0
        },
        currentPage: {
            default: 1
        },
        filter: {
            default: void 0
        },
        filterable: {
            default: void 0
        },
        bordered: {
            type: [String, Boolean],
            default: !1
        },
        borderless: {
            type: [String, Boolean],
            default: !1
        },
        borderVariant: {
            default: void 0
        },
        captionTop: {
            type: [String, Boolean],
            default: !1
        },
        dark: {
            type: [String, Boolean],
            default: !1
        },
        hover: {
            type: [String, Boolean],
            default: !1
        },
        responsive: {
            type: [Boolean, String],
            default: !1
        },
        stacked: {
            type: [Boolean, String],
            default: !1
        },
        striped: {
            type: [String, Boolean],
            default: !1
        },
        stripedColumns: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        stickyHeader: {
            type: [String, Boolean],
            default: !1
        },
        align: {
            default: void 0
        },
        caption: {
            default: void 0
        },
        fields: {
            default: () => []
        },
        footClone: {
            type: [String, Boolean],
            default: !1
        },
        items: {
            default: () => []
        },
        labelStacked: {
            type: Boolean,
            default: !1
        },
        variant: {
            default: void 0
        },
        showEmpty: {
            type: [String, Boolean],
            default: !1
        },
        emptyText: {
            default: "There are no records to show"
        },
        emptyFilteredText: {
            default: "There are no records matching your request"
        },
        fieldColumnClass: {
            type: Function,
            default: void 0
        },
        tbodyTrClass: {
            type: Function,
            default: void 0
        }
    },
    emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = qt(r, "sortBy", n, {
            passive: !0
        })
          , s = qt(r, "busy", n, {
            passive: !0
        })
          , l = qt(r, "sortDesc", n, {
            passive: !0
        })
          , i = en()
          , o = me(null)
          , u = H(l)
          , d = H( () => r.sortInternal)
          , f = H(s)
          , p = H( () => r.noProviderPaging)
          , h = H( () => r.noProviderSorting)
          , v = H( () => r.noProviderFiltering)
          , y = H( () => r.selectable)
          , k = H( () => r.stickySelect)
          , w = _e( () => r.filter !== void 0 && r.filter !== "")
          , $ = me(new Set([]))
          , M = _e( () => $.value.size > 0)
          , S = K( () => r.fields.filter(B => typeof B == "string" ? !1 : B.sortable).length > 0 || r.sortBy !== void 0)
          , T = _e( () => r.provider !== void 0)
          , E = K( () => ({
            "b-table-sortable": S.value,
            "b-table-sort-desc": S.value && u.value === !0,
            "b-table-sort-asc": S.value && u.value === !1,
            "b-table-busy": f.value,
            "b-table-selectable": y.value,
            [`b-table-select-${r.selectMode}`]: y.value,
            "b-table-selecting user-select-none": y.value && M.value
        }))
          , O = _e( () => S.value && d.value === !0 || S.value && T.value || w.value)
          , U = _e( () => y.value && (!!r.selectHead || i.selectHead !== void 0))
          , {computedItems: L, computedDisplayItems: C, updateInternalItems: W, filteredHandler: R, notifyFilteredItems: G} = _N(r, {
            sortInternalBoolean: d,
            isFilterableTable: w,
            noProviderFilteringBoolean: v,
            noProviderPagingBoolean: p,
            noProviderSortingBoolean: h,
            isSortable: S,
            requireItemsMapping: O,
            sortDescBoolean: u
        }, T, a);
        Ke( () => r.items, B => W(B)),
        R.value = async B => {
            if (T.value) {
                await oe();
                return
            }
            n("filtered", B)
        }
        ;
        const te = (B, se, pe) => {
            le(B, se, pe.shiftKey, pe.ctrlKey, pe.metaKey),
            n("row-clicked", B, se, pe)
        }
          , J = (B, se, pe, ie=!1) => {
            n("head-clicked", B, se, pe, ie),
            ae(se)
        }
          , ae = B => {
            if (!S.value)
                return;
            const se = typeof B == "string" ? B : B.key
              , pe = typeof B == "string" ? !1 : B.sortable;
            if (S.value === !0 && pe === !0) {
                const ie = !u.value;
                a.value = se,
                l.value = ie,
                n("sorted", se, ie)
            }
        }
          , oe = async () => {
            if (!T.value || !r.provider || f.value)
                return;
            s.value = !0;
            const B = new Proxy({
                currentPage: r.currentPage,
                filter: r.filter,
                sortBy: r.sortBy,
                sortDesc: r.sortDesc,
                perPage: r.perPage
            },{
                get: (pe, ie) => ie in pe ? pe[ie] : void 0,
                set: () => (console.error("BTable provider context is a read-only object."),
                !0)
            })
              , se = r.provider(B, W);
            if (se !== void 0) {
                if (se instanceof Promise)
                    try {
                        const pe = await se;
                        return Array.isArray(pe) ? await W(pe) : void 0
                    } finally {
                        f.value && (s.value = !1)
                    }
                try {
                    return await W(se)
                } finally {
                    f.value && (s.value = !1)
                }
            }
        }
          , ne = B => [{
            "b-table-sortable-column": S.value && B.sortable
        }]
          , I = (B, se) => {
            const pe = [y.value && B && $.value.has(B) ? `selected table-${r.selectionVariant}` : null];
            if (r.tbodyTrClass) {
                const ie = r.tbodyTrClass(B, se);
                ie && pe.push(...typeof ie == "string" ? [ie] : ie)
            }
            return pe
        }
          , j = () => {
            const B = [{
                "b-table-static-busy": L.value.length === 0
            }];
            if (r.tbodyTrClass) {
                const se = r.tbodyTrClass(null, "table-busy");
                se && B.push(...typeof se == "string" ? [se] : se)
            }
            return B
        }
          , re = () => {
            y.value && n("selection", Array.from($.value))
        }
          , le = (B, se, pe=!1, ie=!1, fe=!1) => {
            if (y.value) {
                if (pe && r.selectMode === "range" && $.value.size > 0) {
                    const F = Array.from($.value).pop()
                      , z = r.items.findIndex(ke => ke === F)
                      , ge = Math.min(z, se)
                      , Te = Math.max(z, se);
                    r.items.slice(ge, Te + 1).forEach(ke => {
                        $.value.has(ke) || ($.value.add(ke),
                        n("row-selected", ke))
                    }
                    )
                } else
                    ie || fe ? $.value.has(B) ? ($.value.delete(B),
                    n("row-unselected", B)) : r.selectMode === "range" || r.selectMode === "multi" ? ($.value.add(B),
                    n("row-selected", B)) : ($.value.forEach(F => {
                        n("row-unselected", F)
                    }
                    ),
                    $.value.clear(),
                    $.value.add(B),
                    n("row-selected", B)) : ($.value.forEach(F => {
                        n("row-unselected", F)
                    }
                    ),
                    $.value.clear(),
                    $.value.add(B),
                    n("row-selected", B));
                re()
            }
        }
          , ce = () => {
            if (!y.value)
                return;
            const B = $.value.size > 0 ? Array.from($.value) : [];
            $.value = new Set([...L.value]),
            $.value.forEach(se => {
                B.includes(se) || n("row-selected", se)
            }
            ),
            re()
        }
          , xe = () => {
            y.value && ($.value.forEach(B => {
                n("row-unselected", B)
            }
            ),
            $.value = new Set([]),
            re())
        }
          , X = B => {
            if (!y.value)
                return;
            const se = r.items[B];
            !se || $.value.has(se) || ($.value.add(se),
            n("row-selected", se),
            re())
        }
          , be = B => {
            if (!y.value)
                return;
            const se = r.items[B];
            !se || !$.value.has(se) || ($.value.delete(se),
            n("row-unselected", se),
            re())
        }
          , ee = async (B, se, pe) => {
            if (se === pe)
                return;
            const ie = Te => r.noProvider && r.noProvider.includes(Te)
              , fe = !["currentPage", "perPage"].includes(B)
              , F = ["currentPage", "perPage"].includes(B) && (ie("paging") || p.value === !0)
              , z = ["filter"].includes(B) && (ie("filtering") || v.value === !0)
              , ge = ["sortBy", "sortDesc"].includes(B) && (ie("sorting") || h.value === !0);
            F || z || ge || (await oe(),
            fe && G())
        }
        ;
        return Ke( () => r.filter, (B, se) => {
            B === se || T.value || B || n("filtered", L.value)
        }
        ),
        Ke( () => r.filter, (B, se) => ee("filter", B, se)),
        Ke( () => r.currentPage, (B, se) => ee("currentPage", B, se)),
        Ke( () => r.perPage, (B, se) => ee("perPage", B, se)),
        Ke( () => r.sortBy, (B, se) => ee("sortBy", B, se)),
        Ke( () => r.sortDesc, (B, se) => ee("sortDesc", B, se)),
        Zt(oe),
        e({
            selectAllRows: ce,
            clearSelected: xe,
            selectRow: X,
            unselectRow: be,
            refresh: oe
        }),
        (B, se) => (g(),
        de(aw, Ve({
            ref_key: "liteTable",
            ref: o
        }, r, {
            busy: A(s),
            "onUpdate:busy": se[0] || (se[0] = pe => Kt(s) ? s.value = pe : null),
            items: A(C),
            "table-class": E.value,
            "tbody-tr-class": I,
            "field-column-class": ne,
            "virtual-fields": A(y) ? 1 : 0,
            onHeadClicked: J,
            onRowClicked: te
        }), gn({
            "field-prefix": N(pe => [Z(B.$slots, "sort-icon", {
                field: pe.field,
                sortBy: A(a),
                selected: pe.field.key === A(a),
                isDesc: A(u),
                direction: A(u) ? "desc" : "asc"
            }, () => [S.value && pe.field.sortable ? (g(),
            _("span", {
                key: 0,
                class: ye(["b-table-sort-icon", {
                    sorted: pe.field.key === A(a),
                    [`sorted-${A(u) ? "desc" : "asc"}`]: pe.field.key === A(a)
                }])
            }, null, 2)) : q("", !0)])]),
            "thead-tr-prefix": N( () => [U.value ? (g(),
            _("th", {
                key: 0,
                class: ye(["b-table-selection-column", {
                    "b-table-sticky-column": A(k)
                }])
            }, [Z(B.$slots, "select-head", {}, () => [ve(Q(typeof B.selectHead == "boolean" ? "Selected" : B.selectHead), 1)])], 2)) : q("", !0)]),
            "tbody-tr-prefix": N(pe => [U.value ? (g(),
            _("td", {
                key: 0,
                class: ye(["b-table-selection-column", {
                    "b-table-sticky-column": A(k)
                }])
            }, [Z(B.$slots, "select-cell", {}, () => [c("span", {
                class: ye(["b-table-selection-icon", $.value.has(pe.item) ? `text-${r.selectionVariant} selected` : ""])
            }, "🗹", 2)])], 2)) : q("", !0)]),
            "tbody-prefix": N(pe => [A(f) ? (g(),
            _("tr", {
                key: 0,
                class: ye(["b-table-busy-slot", j()])
            }, [c("td", {
                colspan: pe.fieldsTotal
            }, [Z(B.$slots, "table-busy", {}, () => [c("div", e4, [x(er, {
                class: "align-middle"
            }), c("strong", null, Q(B.busyLoadingText), 1)])])], 8, Z5)], 2)) : q("", !0)]),
            _: 2
        }, [Ne(B.$slots, (pe, ie) => ({
            name: ie,
            fn: N(fe => [Z(B.$slots, ie, ut(Vt(fe)))])
        }))]), 1040, ["busy", "items", "table-class", "virtual-fields"]))
    }
})
  , n4 = Se({
    __name: "BTbody",
    props: {
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`thead-${e.variant}`]: e.variant !== null
        }));
        return (r, a) => (g(),
        _("tbody", {
            class: ye(n.value)
        }, [Z(r.$slots, "default")], 2))
    }
})
  , r4 = ["scope", "colspan", "rowspan", "data-label"]
  , a4 = {
    key: 0
}
  , s4 = Se({
    __name: "BTd",
    props: {
        colspan: {
            default: void 0
        },
        rowspan: {
            default: void 0
        },
        stackedHeading: {
            default: void 0
        },
        stickyColumn: {
            type: [String, Boolean],
            default: !1
        },
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.stickyColumn)
          , r = K( () => ({
            [`table-${e.variant}`]: e.variant !== null,
            "b-table-sticky-column": n.value,
            "table-b-table-default": n.value && e.variant === null
        }))
          , a = _e( () => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
        return (s, l) => (g(),
        _("td", {
            scope: a.value,
            class: ye(r.value),
            colspan: s.colspan,
            rowspan: s.rowspan,
            "data-label": s.stackedHeading
        }, [s.stackedHeading ? (g(),
        _("div", a4, [Z(s.$slots, "default")])) : Z(s.$slots, "default", {
            key: 1
        })], 10, r4))
    }
})
  , l4 = Se({
    __name: "BTfoot",
    props: {
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`table-${e.variant}`]: e.variant !== null
        }));
        return (r, a) => (g(),
        _("tfoot", {
            class: ye(n.value)
        }, [Z(r.$slots, "default")], 2))
    }
})
  , i4 = ["scope", "colspan", "rowspan", "data-label"]
  , o4 = {
    key: 0
}
  , u4 = Se({
    __name: "BTh",
    props: {
        colspan: {
            default: void 0
        },
        rowspan: {
            default: void 0
        },
        stackedHeading: {
            default: void 0
        },
        stickyColumn: {
            type: [String, Boolean],
            default: !1
        },
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = H( () => e.stickyColumn)
          , r = K( () => ({
            [`table-${e.variant}`]: e.variant !== null,
            "b-table-sticky-column": n.value,
            "table-b-table-default": n.value && e.variant === null
        }))
          , a = _e( () => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
        return (s, l) => (g(),
        _("th", {
            scope: a.value,
            class: ye(r.value),
            colspan: s.colspan,
            rowspan: s.rowspan,
            "data-label": s.stackedHeading
        }, [s.stackedHeading !== void 0 ? (g(),
        _("div", o4, [Z(s.$slots, "default")])) : Z(s.$slots, "default", {
            key: 1
        })], 10, i4))
    }
})
  , d4 = Se({
    __name: "BThead",
    props: {
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`table-${e.variant}`]: e.variant !== null
        }));
        return (r, a) => (g(),
        _("thead", {
            class: ye(n.value)
        }, [Z(r.$slots, "default")], 2))
    }
})
  , c4 = Se({
    __name: "BTr",
    props: {
        variant: {
            default: null
        }
    },
    setup(t) {
        const e = t
          , n = K( () => ({
            [`table-${e.variant}`]: e.variant !== null
        }));
        return (r, a) => (g(),
        _("tr", {
            class: ye(n.value)
        }, [Z(r.$slots, "default")], 2))
    }
})
  , f4 = Se({
    __name: "BTab",
    props: {
        id: {
            default: void 0
        },
        title: {
            default: void 0
        },
        active: {
            type: [String, Boolean],
            default: !1
        },
        buttonId: {
            default: void 0
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: void 0
        },
        lazyOnce: {
            type: [String, Boolean],
            default: void 0
        },
        noBody: {
            type: [Boolean, String],
            default: !1
        },
        tag: {
            default: "div"
        },
        titleItemClass: {
            default: void 0
        },
        titleLinkAttributes: {
            default: void 0
        },
        titleLinkClass: {
            default: void 0
        }
    },
    setup(t) {
        const e = t
          , n = Gt(Wk, null)
          , r = H( () => e.active)
          , a = H( () => e.disabled)
          , s = H(K( () => e.lazyOnce !== void 0 ? e.lazyOnce : e.lazy))
          , l = me(!1)
          , i = _e( () => !!(n != null && n.lazy.value || s.value))
          , o = _e( () => e.lazyOnce !== void 0)
          , u = _e( () => r.value && !a.value)
          , d = K( () => {
            const h = i.value && o.value && l.value;
            return u.value || !i.value || h
        }
        )
          , f = me(r.value);
        Ke(r, h => {
            setTimeout( () => {
                f.value = h
            }
            , 0)
        }
        );
        const p = K( () => ({
            active: r.value,
            show: f.value,
            "card-body": (n == null ? void 0 : n.card.value) && e.noBody === !1
        }));
        return Ke(d, h => {
            h && !l.value && (l.value = !0)
        }
        ),
        (h, v) => (g(),
        de(qe(h.tag), {
            id: h.id,
            class: ye(["tab-pane", p.value]),
            role: "tabpanel",
            "aria-labelledby": h.buttonId
        }, {
            default: N( () => [d.value ? Z(h.$slots, "default", {
                key: 0
            }) : q("", !0)]),
            _: 3
        }, 8, ["id", "class", "aria-labelledby"]))
    }
})
  , p4 = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"]
  , h4 = Se({
    __name: "BTabs",
    props: {
        activeNavItemClass: {
            default: void 0
        },
        activeTabClass: {
            default: void 0
        },
        align: {
            default: void 0
        },
        contentClass: {
            default: void 0
        },
        card: {
            type: [String, Boolean],
            default: !1
        },
        end: {
            type: [String, Boolean],
            default: !1
        },
        fill: {
            type: [String, Boolean],
            default: !1
        },
        id: {
            default: void 0
        },
        justified: {
            type: [String, Boolean],
            default: !1
        },
        lazy: {
            type: [String, Boolean],
            default: !1
        },
        navClass: {
            default: void 0
        },
        navWrapperClass: {
            default: void 0
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        noNavStyle: {
            type: [String, Boolean],
            default: !1
        },
        pills: {
            type: [String, Boolean],
            default: !1
        },
        small: {
            type: [String, Boolean],
            default: !1
        },
        tag: {
            default: "div"
        },
        vertical: {
            type: [String, Boolean],
            default: !1
        },
        modelValue: {
            default: -1
        }
    },
    emits: ["update:modelValue", "activate-tab", "click"],
    setup(t, {emit: e}) {
        const n = t
          , r = qt(n, "modelValue", e)
          , a = en()
          , s = H( () => n.card)
          , l = H( () => n.end)
          , i = H( () => n.fill)
          , o = H( () => n.justified)
          , u = H( () => n.lazy)
          , d = H( () => n.noFade)
          , f = H( () => n.noNavStyle)
          , p = H( () => n.pills)
          , h = H( () => n.small)
          , v = H( () => n.vertical)
          , y = me(r.value)
          , k = me("")
          , w = K({
            get: () => y.value,
            set: C => {
                y.value = C,
                M.value.length > 0 && C >= 0 && C < M.value.length ? k.value = M.value[C].buttonId : k.value = "",
                r.value = C
            }
        })
          , $ = me([]);
        Ke( () => {
            var C;
            return (C = a.default) == null ? void 0 : C.call(a)
        }
        , () => {
            $.value = a.default === void 0 ? [] : wp(a.default, "BTab").map( (C, W) => {
                C.props || (C.props = {});
                const R = C.props["button-id"] || js("tab")
                  , G = C.props.id || js()
                  , te = C.props["title-item-class"]
                  , J = C.props["title-link-attributes"];
                return {
                    buttonId: R,
                    contentId: G,
                    disabled: C.props.disabled === "" || C.props.disabled === !0,
                    target: `#${G}`,
                    title: C.props.title,
                    titleItemClass: te,
                    titleLinkAttributes: J,
                    onClick: C.props.onClick,
                    tab: C,
                    tabComponent: () => wp(a.default, "BTab")[W]
                }
            }
            )
        }
        , {
            immediate: !0
        });
        const M = K( () => $.value.map( (C, W) => {
            const {tab: R} = C;
            R.props || (R.props = {});
            const G = w.value > -1 ? W === w.value : R.props.active === "";
            return {
                ...C,
                active: G,
                navItemClasses: [{
                    active: G,
                    disabled: R.props.disabled === "" || R.props.disabled === !0
                }, G && n.activeNavItemClass ? n.activeNavItemClass : null, R.props["title-link-class"]],
                tabClasses: [{
                    fade: !d.value
                }, G && n.activeTabClass ? n.activeTabClass : null]
            }
        }
        ))
          , S = _e( () => !(M != null && M.value && M.value.length > 0))
          , T = K( () => ({
            "d-flex": v.value,
            "align-items-start": v.value
        }))
          , E = Jo( () => n.align)
          , O = K( () => ({
            "nav-pills": p.value,
            "flex-column me-3": v.value,
            [E.value]: n.align !== void 0,
            "nav-fill": i.value,
            "card-header-tabs": s.value,
            "nav-justified": o.value,
            "nav-tabs": !f.value && !p.value,
            small: h.value
        }))
          , U = C => {
            let W = !1;
            if (C !== void 0 && C > -1 && C < M.value.length && !M.value[C].disabled && (w.value < 0 || M.value[C].buttonId !== k.value)) {
                const R = new si("activate-tab",{
                    cancelable: !0
                });
                e("activate-tab", C, w.value, R),
                R.defaultPrevented || (w.value = C,
                W = !0)
            }
            return !W && r.value !== w.value && (r.value = w.value),
            W
        }
          , L = (C, W) => {
            var R;
            U(W),
            W >= 0 && !M.value[W].disabled && (R = M.value[W]) != null && R.onClick && typeof M.value[W].onClick == "function" && M.value[W].onClick(C)
        }
        ;
        return U(y.value),
        Ke(r, (C, W) => {
            if (C === W)
                return;
            if (C = Math.max(C, -1),
            W = Math.max(W, -1),
            M.value.length <= 0) {
                w.value = -1;
                return
            }
            const R = C > W;
            let G = C;
            const te = M.value.length - 1;
            for (; G >= 0 && G <= te && M.value[G].disabled; )
                G += R ? 1 : -1;
            if (G < 0) {
                U(0);
                return
            }
            if (G >= M.value.length) {
                U(M.value.length - 1);
                return
            }
            U(G)
        }
        ),
        Ke(M, () => {
            let C = M.value.map(W => W.active && !W.disabled).lastIndexOf(!0);
            C < 0 && (w.value >= M.value.length ? C = M.value.map(W => !W.disabled).lastIndexOf(!0) : M.value[w.value] && !M.value[w.value].disabled && (C = w.value)),
            C < 0 && (C = M.value.map(W => !W.disabled).indexOf(!0)),
            M.value.forEach( (W, R) => {
                W.active = R === C
            }
            ),
            U(C)
        }
        ),
        Zt( () => {
            if (w.value < 0 && M.value.length > 0 && !M.value.some(C => C.active)) {
                const C = M.value.map(W => !W.disabled).indexOf(!0);
                U(C >= 0 ? C : -1)
            }
        }
        ),
        zn(Wk, {
            lazy: u,
            card: s
        }),
        (C, W) => (g(),
        de(qe(C.tag), {
            id: C.id,
            class: ye(["tabs", T.value])
        }, {
            default: N( () => [A(l) ? (g(),
            _("div", {
                key: 0,
                class: ye(["tab-content", C.contentClass])
            }, [(g(!0),
            _(we, null, Ne(M.value, ({tabComponent: R, contentId: G, tabClasses: te, active: J}, ae) => (g(),
            de(qe(R()), {
                id: G,
                key: ae,
                class: ye(te),
                active: J
            }, null, 8, ["id", "class", "active"]))), 128)), S.value ? (g(),
            _("div", {
                key: "bv-empty-tab",
                class: ye(["tab-pane active", {
                    "card-body": A(s)
                }])
            }, [Z(C.$slots, "empty")], 2)) : q("", !0)], 2)) : q("", !0), c("div", {
                class: ye([C.navWrapperClass, {
                    "card-header": A(s),
                    "ms-auto": C.vertical && A(l)
                }])
            }, [c("ul", {
                class: ye(["nav", [O.value, C.navClass]]),
                role: "tablist"
            }, [Z(C.$slots, "tabs-start"), (g(!0),
            _(we, null, Ne(M.value, ({tab: R, buttonId: G, contentId: te, navItemClasses: J, active: ae, target: oe}, ne) => {
                var I, j, re;
                return g(),
                _("li", {
                    key: ne,
                    class: ye(["nav-item", (I = R == null ? void 0 : R.props) == null ? void 0 : I["title-item-class"]]),
                    role: "presentation"
                }, [c("button", Ve({
                    id: G,
                    class: ["nav-link", J],
                    "data-bs-toggle": "tab",
                    "data-bs-target": oe,
                    role: "tab",
                    "aria-controls": te,
                    "aria-selected": ae
                }, (j = R == null ? void 0 : R.props) == null ? void 0 : j["title-link-attributes"], {
                    onClick: _t(le => L(le, ne), ["stop", "prevent"])
                }), [R.children && R.children.title ? (g(),
                de(qe(R.children.title), {
                    key: 0
                })) : (g(),
                _(we, {
                    key: 1
                }, [ve(Q((re = R == null ? void 0 : R.props) == null ? void 0 : re.title), 1)], 64))], 16, p4)], 2)
            }
            ), 128)), Z(C.$slots, "tabs-end")], 2)], 2), A(l) ? q("", !0) : (g(),
            _("div", {
                key: 1,
                class: ye(["tab-content", C.contentClass])
            }, [(g(!0),
            _(we, null, Ne(M.value, ({tabComponent: R, contentId: G, tabClasses: te, active: J, buttonId: ae}, oe) => (g(),
            de(qe(R()), {
                id: G,
                key: oe,
                class: ye(te),
                active: J,
                "button-id": ae
            }, null, 8, ["id", "class", "active", "button-id"]))), 128)), S.value ? (g(),
            _("div", {
                key: "bv-empty-tab",
                class: ye(["tab-pane active", {
                    "card-body": A(s)
                }])
            }, [Z(C.$slots, "empty")], 2)) : q("", !0)], 2))]),
            _: 3
        }, 8, ["id", "class"]))
    }
})
  , m4 = ["id", "role", "aria-live", "aria-atomic"]
  , v4 = {
    class: "me-auto"
}
  , sw = Se({
    __name: "BToast",
    props: {
        delay: {
            default: 5e3
        },
        bodyClass: {
            default: void 0
        },
        body: {
            default: void 0
        },
        headerClass: {
            default: void 0
        },
        headerTag: {
            default: "div"
        },
        animation: {
            type: [String, Boolean],
            default: !0
        },
        id: {
            default: void 0
        },
        isStatus: {
            type: [String, Boolean],
            default: !1
        },
        autoHide: {
            type: [String, Boolean],
            default: !0
        },
        noCloseButton: {
            type: [String, Boolean],
            default: !1
        },
        noFade: {
            type: [String, Boolean],
            default: !1
        },
        noHoverPause: {
            type: [String, Boolean],
            default: !1
        },
        solid: {
            type: [String, Boolean],
            default: !1
        },
        title: {
            default: void 0
        },
        modelValue: {
            type: [Boolean, Number],
            default: !1
        },
        toastClass: {
            default: void 0
        },
        showOnPause: {
            type: [String, Boolean],
            default: !0
        },
        interval: {
            default: 1e3
        },
        progressProps: {
            default: void 0
        },
        variant: {
            default: null
        },
        bgVariant: {
            default: null
        },
        textVariant: {
            default: null
        },
        active: {
            type: [String, Boolean],
            default: void 0
        },
        activeClass: {
            default: void 0
        },
        append: {
            type: [String, Boolean],
            default: !1
        },
        disabled: {
            type: [String, Boolean],
            default: !1
        },
        href: {
            default: void 0
        },
        rel: {
            default: void 0
        },
        replace: {
            type: [String, Boolean],
            default: !1
        },
        routerComponentName: {
            default: "router-link"
        },
        target: {
            default: "_self"
        },
        to: {
            default: void 0
        },
        opacity: {
            default: void 0
        },
        opacityHover: {
            default: void 0
        },
        underlineVariant: {
            default: null
        },
        underlineOffset: {
            default: void 0
        },
        underlineOffsetHover: {
            default: void 0
        },
        underlineOpacity: {
            default: void 0
        },
        underlineOpacityHover: {
            default: void 0
        },
        icon: {
            type: [String, Boolean]
        }
    },
    emits: ["destroyed", "close", "closed", "close-countdown", "update:modelValue"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = me(null)
          , s = _m(a)
          , l = qt(r, "modelValue", n)
          , {computedLink: i, computedLinkProps: o} = gl(r);
        H( () => r.animation);
        const u = H( () => r.isStatus);
        H( () => r.autoHide);
        const d = H( () => r.noCloseButton)
          , f = H( () => r.noFade)
          , p = H( () => r.noHoverPause)
          , h = H( () => r.showOnPause)
          , v = zt( () => r.interval);
        H( () => r.solid);
        const y = Nr(r)
          , k = _e( () => typeof l.value == "boolean" ? 0 : l.value)
          , {isActive: w, pause: $, restart: M, resume: S, stop: T, isPaused: E, value: O} = x_(k, v, {
            immediate: typeof l.value == "number"
        });
        Si( () => {
            n("close-countdown", O.value)
        }
        );
        const U = _e( () => i.value ? ha : "div")
          , L = _e( () => typeof l.value == "boolean" ? l.value : w.value || h.value && E.value);
        Ke(w, G => {
            G === !1 && E.value === !1 && n("destroyed")
        }
        );
        const C = K( () => [y.value, {
            show: L.value
        }])
          , W = () => {
            n("close"),
            typeof l.value == "boolean" ? l.value = !1 : (l.value = 0,
            T()),
            n("closed")
        }
          , R = () => {
            p.value || $()
        }
        ;
        return Ke(s, G => {
            if (G) {
                R();
                return
            }
            S()
        }
        ),
        $i(T),
        e({
            pause: $,
            resume: S,
            restart: M,
            stop: T
        }),
        (G, te) => (g(),
        de(Ei, {
            "no-fade": A(f)
        }, {
            default: N( () => [L.value ? (g(),
            _("div", {
                key: 0,
                id: G.id,
                ref_key: "element",
                ref: a,
                class: ye(["toast", [G.toastClass, C.value]]),
                tabindex: "0",
                role: L.value ? A(u) ? "status" : "alert" : void 0,
                "aria-live": L.value ? A(u) ? "polite" : "assertive" : void 0,
                "aria-atomic": L.value ? !0 : void 0
            }, [G.$slots.title || G.title ? (g(),
            de(qe(G.headerTag), {
                key: 0,
                class: "toast-header"
            }, {
                default: N( () => [Z(G.$slots, "title", {
                    hide: W
                }, () => [c("strong", v4, Q(G.title), 1)]), A(d) ? q("", !0) : (g(),
                de(Ai, {
                    key: 0,
                    onClick: W
                }))]),
                _: 3
            })) : q("", !0), G.$slots.default || G.body ? (g(),
            de(qe(U.value), Ve({
                key: 1,
                class: ["toast-body", G.bodyClass],
                style: {
                    display: "block"
                }
            }, A(o), {
                onClick: te[0] || (te[0] = J => A(i) ? W : () => {}
                )
            }), {
                default: N( () => [Z(G.$slots, "default", {
                    hide: W
                }, () => [ve(Q(G.body), 1)])]),
                _: 3
            }, 16, ["class"])) : q("", !0), typeof A(l) == "number" && G.progressProps !== void 0 ? (g(),
            de(rw, {
                key: 2,
                animated: G.progressProps.animated,
                precision: G.progressProps.precision,
                "show-progress": G.progressProps.showProgress,
                "show-value": G.progressProps.showValue,
                striped: G.progressProps.striped,
                variant: G.progressProps.variant,
                max: A(l),
                value: A(O),
                height: "4px"
            }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : q("", !0)], 10, m4)) : q("", !0)]),
            _: 3
        }, 8, ["no-fade"]))
    }
})
  , g4 = {
    id: "__BVID__toaster-container"
}
  , b4 = Se({
    __name: "BToaster",
    props: {
        teleportTo: {
            default: "body"
        },
        teleportDisabled: {
            type: [String, Boolean],
            default: !1
        }
    },
    setup(t, {expose: e}) {
        const n = t
          , r = H( () => n.teleportDisabled)
          , a = {
            "top-left": "top-0 start-0",
            "top-center": "top-0 start-50 translate-middle-x",
            "top-right": "top-0 end-0",
            "middle-left": "top-50 start-0 translate-middle-y",
            "middle-center": "top-50 start-50 translate-middle",
            "middle-right": "top-50 end-0 translate-middle-y",
            "bottom-left": "bottom-0 start-0",
            "bottom-center": "bottom-0 start-50 translate-middle-x",
            "bottom-right": "bottom-0 end-0"
        }
          , {hide: s, toasts: l} = xN()
          , i = o => zk(o, ["value", "self", "pos"]);
        return e({
            hide: s
        }),
        (o, u) => (g(),
        de(Ti, {
            to: o.teleportTo,
            disabled: A(r)
        }, [c("div", g4, [(g(),
        _(we, null, Ne(a, (d, f) => c("div", {
            key: f,
            class: ye([d, "toast-container position-fixed p-3"])
        }, [(g(!0),
        _(we, null, Ne(A(l).filter(p => p.pos === f), p => (g(),
        de(sw, Ve({
            key: p.self,
            modelValue: p.value,
            "onUpdate:modelValue": h => p.value = h
        }, i(p), {
            onDestroyed: h => A(s)(p.self)
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onDestroyed"]))), 128))], 2)), 64))])], 8, ["to", "disabled"]))
    }
})
  , y4 = Se({
    __name: "BTooltip",
    props: {
        modelValue: {
            type: [String, Boolean],
            default: void 0
        },
        container: {
            default: void 0
        },
        target: {
            default: void 0
        },
        reference: {
            default: void 0
        },
        content: {
            default: void 0
        },
        id: {
            default: void 0
        },
        title: {
            default: void 0
        },
        delay: {
            default: void 0
        },
        click: {
            type: [String, Boolean],
            default: void 0
        },
        manual: {
            type: [String, Boolean],
            default: void 0
        },
        variant: {
            default: void 0
        },
        offset: {
            default: void 0
        },
        customClass: {
            default: void 0
        },
        placement: {
            default: void 0
        },
        strategy: {
            default: void 0
        },
        floatingMiddleware: {
            default: void 0
        },
        noFlip: {
            type: [String, Boolean],
            default: void 0
        },
        noShift: {
            type: [String, Boolean],
            default: void 0
        },
        noFade: {
            type: [String, Boolean],
            default: void 0
        },
        noAutoClose: {
            type: [String, Boolean],
            default: void 0
        },
        hide: {
            type: [String, Boolean]
        },
        realtime: {
            type: [String, Boolean],
            default: void 0
        },
        inline: {
            type: [String, Boolean],
            default: void 0
        },
        html: {
            type: [String, Boolean],
            default: void 0
        },
        noninteractive: {
            type: [String, Boolean],
            default: !0
        }
    },
    setup(t, {expose: e}) {
        var n, r, a;
        const s = me(null);
        return e({
            hide: (n = s.value) == null ? void 0 : n.hide,
            show: (r = s.value) == null ? void 0 : r.show,
            toggle: (a = s.value) == null ? void 0 : a.toggle
        }),
        (l, i) => (g(),
        de(xm, Ve({
            ref_key: "popover",
            ref: s,
            tooltip: ""
        }, l.$props), gn({
            _: 2
        }, [Ne(l.$slots, (o, u) => ({
            name: u,
            fn: N(d => [Z(l.$slots, u, ut(Vt(d)))])
        }))]), 1040))
    }
})
  , Kb = Object.freeze(Object.defineProperty({
    __proto__: null,
    BAccordion: MN,
    BAccordionItem: PN,
    BAlert: IN,
    BAvatar: HN,
    BAvatarGroup: KN,
    BBadge: zN,
    BBreadcrumb: GN,
    BBreadcrumbItem: D_,
    BButton: is,
    BButtonGroup: YN,
    BButtonToolbar: XN,
    BCard: $m,
    BCardBody: I_,
    BCardFooter: R_,
    BCardGroup: tD,
    BCardHeader: F_,
    BCardImg: rd,
    BCardSubtitle: V_,
    BCardText: nD,
    BCardTitle: B_,
    BCarousel: dD,
    BCarouselSlide: mD,
    BCloseButton: Ai,
    BCol: zi,
    BCollapse: N_,
    BContainer: bD,
    BDropdown: L_,
    BDropdownDivider: wD,
    BDropdownForm: $D,
    BDropdownGroup: ED,
    BDropdownHeader: MD,
    BDropdownItem: ND,
    BDropdownItemButton: FD,
    BDropdownText: ID,
    BForm: j_,
    BFormCheckbox: $s,
    BFormCheckboxGroup: uc,
    BFormFile: JD,
    BFormFloatingLabel: UD,
    BFormGroup: aP,
    BFormInput: H_,
    BFormInvalidFeedback: Cp,
    BFormRadio: Tm,
    BFormRadioGroup: cP,
    BFormRow: Fu,
    BFormSelect: yl,
    BFormSelectOption: Cm,
    BFormSelectOptionGroup: K_,
    BFormSpinbutton: yP,
    BFormTag: Y_,
    BFormTags: PP,
    BFormText: Ep,
    BFormTextarea: Em,
    BFormValidFeedback: Ap,
    BImg: Sm,
    BInputGroup: UP,
    BInputGroupAddon: Am,
    BInputGroupAppend: X_,
    BInputGroupPrepend: HP,
    BInputGroupText: J_,
    BLink: ha,
    BListGroup: KP,
    BListGroupItem: zP,
    BModal: YP,
    BNav: JP,
    BNavForm: QP,
    BNavItem: e5,
    BNavItemDropdown: n5,
    BNavText: a5,
    BNavbar: s5,
    BNavbarBrand: l5,
    BNavbarNav: i5,
    BNavbarToggle: m5,
    BOffcanvas: b5,
    BOverlay: Mm,
    BPagination: C5,
    BPlaceholder: hr,
    BPlaceholderButton: tw,
    BPlaceholderCard: E5,
    BPlaceholderTable: A5,
    BPlaceholderWrapper: M5,
    BPopover: xm,
    BProgress: rw,
    BProgressBar: nw,
    BRow: P5,
    BSpinner: er,
    BTab: f4,
    BTable: t4,
    BTableLite: aw,
    BTableSimple: Om,
    BTabs: h4,
    BTbody: n4,
    BTd: s4,
    BTfoot: l4,
    BTh: u4,
    BThead: d4,
    BToast: sw,
    BToaster: b4,
    BTooltip: y4,
    BTr: c4,
    BTransition: Ei
}, Symbol.toStringTag, {
    value: "Module"
}))
  , k4 = {
    install(t, e={
        components: !0,
        directives: !0
    }) {
        const n = typeof e.components == "boolean" || typeof e.components > "u" ? {
            all: !0
        } : e.components
          , r = Object.keys(Kb);
        wb(n, r).forEach(l => {
            const i = Kb[l];
            t.component(l, i)
        }
        );
        const a = typeof (e == null ? void 0 : e.directives) == "boolean" || typeof e.directives > "u" ? {
            all: !0
        } : e == null ? void 0 : e.directives
          , s = Object.keys(Lb);
        wb(a, s).forEach(l => {
            const i = l.toLowerCase().startsWith("v") ? l.slice(1) : l
              , o = Lb[l];
            t.directive(i, o)
        }
        )
    }
}
  , _4 = Se({
    name: "FormGroup",
    props: {
        labelFor: {
            type: String,
            default: ""
        },
        label: {
            type: String,
            default: ""
        },
        invalidFeedback: {
            type: String,
            default: ""
        },
        description: {
            type: String,
            default: ""
        }
    }
});
function w4(t, e, n, r, a, s) {
    const l = ue("b-form-group");
    return g(),
    de(l, {
        class: "mb-3",
        label: t.label,
        "label-for": t.labelFor,
        description: t.description,
        "invalid-feedback": t.invalidFeedback,
        "label-cols": "0"
    }, {
        default: N( () => [Z(t.$slots, "default", {}, void 0, !0)]),
        _: 3
    }, 8, ["label", "label-for", "description", "invalid-feedback"])
}
const Na = rt(_4, [["render", w4], ["__scopeId", "data-v-904485c9"]]);
function Ht(t) {
    if (t == "")
        return null;
    if (t.replace(/[^0-9]/g, "").length < 10 || !t.match("^[0-9]{6,8}[-,+]{0,1}[0-9]{4}$"))
        return !1;
    let e = t;
    if (e = e.replaceAll("-", ""),
    e = e.replaceAll("+", ""),
    e.length < 12 && e.charCodeAt(2) < 50)
        return !1;
    e.length == 12 && (e = e.substring(2));
    let n = 0
      , r = 0;
    const a = [2, 1, 2, 1, 2, 1, 2, 1, 2, 1];
    for (r = 0; r < 10; r++)
        a[r] *= parseInt(e.charAt(r));
    for (r = 0; r < 10; r++)
        n += Math.trunc(a[r] / 10),
        n += a[r] % 10;
    return n % 10 == 0
}
function x4(t) {
    return t == "" ? null : !!t.match("^[K,k][0-9]{1,7}[/][0-9]{2}$")
}
function lw(t) {
    const e = ".{1,}[@].{1,}[.].{2,}";
    return !!t.match(e)
}
function S4(t) {
    const e = "^[0-9]{8,9}$";
    return t == "" ? null : !!t.match(e)
}
function iw(t) {
    return t.length == 10 ? t.substring(0, 6) + "-" + t.substring(6, 10) : t.length == 12 ? t.substring(0, 8) + "-" + t.substring(8, 12) : t
}
function zb(t, e) {
    for (let n = 0; n < t.length; n++)
        t[n] ^= e[n & 31] + (e[n + 8 & 31] ^ e[n + 17 & 31]),
        e[n & 31] += e[n + 3 & 31] ^ e[n + 7 & 31],
        e[n & 31] ^= e[n + 12 & 31] + e[n + 18 & 31];
    return t
}
function Vi(t, e) {
    return t.getFullYear() == e.getFullYear() && t.getMonth() == e.getMonth() && t.getDate() == e.getDate()
}
function Mt(t) {
    const e = t.getDay();
    if (e === 0 || e === 6 || [101, 106, 501, 606, 1224, 1225, 1226, 1231].includes(t.getMonth() * 100 + 100 + t.getDate()))
        return !0;
    const r = new Date(t.getFullYear(),5,20);
    for (; r.getDay() != 5; )
        r.setDate(r.getDate() + 1);
    if (r.getTime() === t.getTime() || (r.setDate(r.getDate() + 1),
    r.getTime() === t.getTime()))
        return !0;
    const a = $4(t.getFullYear())
      , s = new Date(a);
    return !!(Vi(s, t) || (s.setTime(a.getTime()),
    s.setDate(a.getDate() - 1),
    Vi(s, t)) || (s.setTime(a.getTime()),
    s.setDate(a.getDate() - 2),
    Vi(s, t)) || (s.setTime(a.getTime()),
    s.setDate(a.getDate() + 1),
    Vi(s, t)) || (s.setTime(a.getTime()),
    s.setDate(a.getDate() + 39),
    Vi(s, t)))
}
function $4(t) {
    const e = new Date(t,0,1)
      , n = 24
      , r = 5
      , a = t % 19
      , s = t % 4
      , l = t % 7
      , i = (19 * a + n) % 30
      , o = (2 * s + 4 * l + 6 * i + r) % 7;
    if (i + o > 9) {
        e.setMonth(3);
        let u = i + o - 9;
        u == 26 && (u = 19),
        u == 25 && i == 28 && o == 6 && (u = 18),
        e.setDate(u)
    } else
        e.setMonth(2),
        e.setDate(22 + i + o);
    return e
}
function qb(t) {
    let e = "";
    for (let n = 0; n < t.length; n++)
        if (t.charCodeAt(n) >= 48 && t.charCodeAt(n) <= 57) {
            let r = t.charCodeAt(n) - 48;
            r = (r + 5) % 10,
            e += String.fromCharCode(r + 48)
        } else
            t.charAt(n) == t.charAt(n).toUpperCase() ? e += t.charAt(n).toLowerCase() : e += t.charAt(n).toUpperCase();
    return e
}
function qi(t) {
    t = t.replaceAll("<strong>", "<b>"),
    t = t.replaceAll("</strong>", "</b>"),
    t = t.replaceAll(`(
)`, " "),
    t = t.replaceAll("(\r)", ""),
    t = t.replaceAll("\\p{Cntrl}", "");
    const e = String.fromCharCode(8211);
    t = t.replace(e, "-");
    const n = String.fromCharCode(8209);
    t = t.replace(n, "-");
    const r = String.fromCharCode(12288);
    t = t.replace(r, " "),
    t = t.replace("å", "å"),
    t = t.replace("ä", "ä"),
    t = t.replace("ö", "ö"),
    t = t.replace("Å", "Å"),
    t = t.replace("Ä", "Ä"),
    t = t.replace("Ö", "Ö"),
    t = t.replace("ü", "ü"),
    t = t.replace("Ü", "Ü"),
    t = t.replace("", "•"),
    t = t.replaceAll(`(<p )((.|
)*?>)`, "<p>"),
    t = t.replaceAll(`(<b )((.|
)*?>)`, "<b>"),
    t = t.replaceAll(`(<ul )((.|
)*?>)`, "<ul>"),
    t = t.replaceAll(`(<li )((.|
)*?>)`, "<li>"),
    t = t.replaceAll(`(<ol )((.|
)*?>)`, "<ol>");
    const a = new RegExp(/(<)(?!(p|\/p|b|\/b|ul|\/ul|ol|\/ol|li|\/li|br(\\s|\\\/|>)))(.*?>)/gm);
    return t = t.replaceAll(a, ""),
    t = t.replaceAll("(&emsp;|&ensp;)", " "),
    t = t.replaceAll("(&rdquo;)", '"'),
    t = t.replaceAll(`(<p>)(
*|\r*)(\\s)*`, "<p>"),
    t = t.replaceAll(`(<li>)(
*|\r*)(\\s)*`, "<li>"),
    t = t.replaceAll(`(<ul>)(
*|\r*)(\\s)*`, "<ul>"),
    t = t.replaceAll(`(
*|\r*)(\\s)*(</ul>)`, "</ul>"),
    t = t.replaceAll(`(<ol>)(
*|\r*)(\\s)*`, "<ol>"),
    t = t.replaceAll(`(
*|\r*)(\\s)*(</ol>)`, "</ol>"),
    t = t.replaceAll("(<p>)", `
<p>`).trim(),
    t
}
function ow() {
    return new Date().toISOString().slice(0, 10)
}
function uw(t) {
    const e = new Date;
    return e.setFullYear(e.getFullYear() - t),
    e.toISOString().slice(0, 10)
}
function qn(t) {
    return t && (t.length == 12 ? t.substr(0, 8) + "-" + t.substr(8, 4) : t.length == 10 ? t.substr(0, 6) + "-" + t.substr(6, 4) : t)
}
function Da(t) {
    const e = ["söndag", "måndag", "tisdag", "onsdag", "torsdag", "fredag", "lördag", "söndag"]
      , n = ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"];
    return e[t.getDay()] + " " + t.getDate() + " " + n[t.getMonth()] + " " + t.getFullYear()
}
function Wi(t, e) {
    for (const [n,r] of t.entries())
        if (r.id === e)
            return r;
    return 0
}
var Dp = {}
  , dc = {};
dc.byteLength = E4;
dc.toByteArray = M4;
dc.fromByteArray = D4;
var Jr = []
  , fr = []
  , T4 = typeof Uint8Array < "u" ? Uint8Array : Array
  , gf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Ml = 0, C4 = gf.length; Ml < C4; ++Ml)
    Jr[Ml] = gf[Ml],
    fr[gf.charCodeAt(Ml)] = Ml;
fr["-".charCodeAt(0)] = 62;
fr["_".charCodeAt(0)] = 63;
function dw(t) {
    var e = t.length;
    if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [n, r]
}
function E4(t) {
    var e = dw(t)
      , n = e[0]
      , r = e[1];
    return (n + r) * 3 / 4 - r
}
function A4(t, e, n) {
    return (e + n) * 3 / 4 - n
}
function M4(t) {
    var e, n = dw(t), r = n[0], a = n[1], s = new T4(A4(t, r, a)), l = 0, i = a > 0 ? r - 4 : r, o;
    for (o = 0; o < i; o += 4)
        e = fr[t.charCodeAt(o)] << 18 | fr[t.charCodeAt(o + 1)] << 12 | fr[t.charCodeAt(o + 2)] << 6 | fr[t.charCodeAt(o + 3)],
        s[l++] = e >> 16 & 255,
        s[l++] = e >> 8 & 255,
        s[l++] = e & 255;
    return a === 2 && (e = fr[t.charCodeAt(o)] << 2 | fr[t.charCodeAt(o + 1)] >> 4,
    s[l++] = e & 255),
    a === 1 && (e = fr[t.charCodeAt(o)] << 10 | fr[t.charCodeAt(o + 1)] << 4 | fr[t.charCodeAt(o + 2)] >> 2,
    s[l++] = e >> 8 & 255,
    s[l++] = e & 255),
    s
}
function O4(t) {
    return Jr[t >> 18 & 63] + Jr[t >> 12 & 63] + Jr[t >> 6 & 63] + Jr[t & 63]
}
function N4(t, e, n) {
    for (var r, a = [], s = e; s < n; s += 3)
        r = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255),
        a.push(O4(r));
    return a.join("")
}
function D4(t) {
    for (var e, n = t.length, r = n % 3, a = [], s = 16383, l = 0, i = n - r; l < i; l += s)
        a.push(N4(t, l, l + s > i ? i : l + s));
    return r === 1 ? (e = t[n - 1],
    a.push(Jr[e >> 2] + Jr[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1],
    a.push(Jr[e >> 10] + Jr[e >> 4 & 63] + Jr[e << 2 & 63] + "=")),
    a.join("")
}
var Nm = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Nm.read = function(t, e, n, r, a) {
    var s, l, i = a * 8 - r - 1, o = (1 << i) - 1, u = o >> 1, d = -7, f = n ? a - 1 : 0, p = n ? -1 : 1, h = t[e + f];
    for (f += p,
    s = h & (1 << -d) - 1,
    h >>= -d,
    d += i; d > 0; s = s * 256 + t[e + f],
    f += p,
    d -= 8)
        ;
    for (l = s & (1 << -d) - 1,
    s >>= -d,
    d += r; d > 0; l = l * 256 + t[e + f],
    f += p,
    d -= 8)
        ;
    if (s === 0)
        s = 1 - u;
    else {
        if (s === o)
            return l ? NaN : (h ? -1 : 1) * (1 / 0);
        l = l + Math.pow(2, r),
        s = s - u
    }
    return (h ? -1 : 1) * l * Math.pow(2, s - r)
}
;
Nm.write = function(t, e, n, r, a, s) {
    var l, i, o, u = s * 8 - a - 1, d = (1 << u) - 1, f = d >> 1, p = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r ? 0 : s - 1, v = r ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e),
    isNaN(e) || e === 1 / 0 ? (i = isNaN(e) ? 1 : 0,
    l = d) : (l = Math.floor(Math.log(e) / Math.LN2),
    e * (o = Math.pow(2, -l)) < 1 && (l--,
    o *= 2),
    l + f >= 1 ? e += p / o : e += p * Math.pow(2, 1 - f),
    e * o >= 2 && (l++,
    o /= 2),
    l + f >= d ? (i = 0,
    l = d) : l + f >= 1 ? (i = (e * o - 1) * Math.pow(2, a),
    l = l + f) : (i = e * Math.pow(2, f - 1) * Math.pow(2, a),
    l = 0)); a >= 8; t[n + h] = i & 255,
    h += v,
    i /= 256,
    a -= 8)
        ;
    for (l = l << a | i,
    u += a; u > 0; t[n + h] = l & 255,
    h += v,
    l /= 256,
    u -= 8)
        ;
    t[n + h - v] |= y * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
    const e = dc
      , n = Nm
      , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = i,
    t.SlowBuffer = $,
    t.INSPECT_MAX_BYTES = 50;
    const a = 2147483647;
    t.kMaxLength = a,
    i.TYPED_ARRAY_SUPPORT = s(),
    !i.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
        try {
            const D = new Uint8Array(1)
              , m = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(m, Uint8Array.prototype),
            Object.setPrototypeOf(D, m),
            D.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(i.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (i.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(i.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (i.isBuffer(this))
                return this.byteOffset
        }
    });
    function l(D) {
        if (D > a)
            throw new RangeError('The value "' + D + '" is invalid for option "size"');
        const m = new Uint8Array(D);
        return Object.setPrototypeOf(m, i.prototype),
        m
    }
    function i(D, m, b) {
        if (typeof D == "number") {
            if (typeof m == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(D)
        }
        return o(D, m, b)
    }
    i.poolSize = 8192;
    function o(D, m, b) {
        if (typeof D == "string")
            return p(D, m);
        if (ArrayBuffer.isView(D))
            return v(D);
        if (D == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D);
        if (Ce(D, ArrayBuffer) || D && Ce(D.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ce(D, SharedArrayBuffer) || D && Ce(D.buffer, SharedArrayBuffer)))
            return y(D, m, b);
        if (typeof D == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const P = D.valueOf && D.valueOf();
        if (P != null && P !== D)
            return i.from(P, m, b);
        const Y = k(D);
        if (Y)
            return Y;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof D[Symbol.toPrimitive] == "function")
            return i.from(D[Symbol.toPrimitive]("string"), m, b);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof D)
    }
    i.from = function(D, m, b) {
        return o(D, m, b)
    }
    ,
    Object.setPrototypeOf(i.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(i, Uint8Array);
    function u(D) {
        if (typeof D != "number")
            throw new TypeError('"size" argument must be of type number');
        if (D < 0)
            throw new RangeError('The value "' + D + '" is invalid for option "size"')
    }
    function d(D, m, b) {
        return u(D),
        D <= 0 ? l(D) : m !== void 0 ? typeof b == "string" ? l(D).fill(m, b) : l(D).fill(m) : l(D)
    }
    i.alloc = function(D, m, b) {
        return d(D, m, b)
    }
    ;
    function f(D) {
        return u(D),
        l(D < 0 ? 0 : w(D) | 0)
    }
    i.allocUnsafe = function(D) {
        return f(D)
    }
    ,
    i.allocUnsafeSlow = function(D) {
        return f(D)
    }
    ;
    function p(D, m) {
        if ((typeof m != "string" || m === "") && (m = "utf8"),
        !i.isEncoding(m))
            throw new TypeError("Unknown encoding: " + m);
        const b = M(D, m) | 0;
        let P = l(b);
        const Y = P.write(D, m);
        return Y !== b && (P = P.slice(0, Y)),
        P
    }
    function h(D) {
        const m = D.length < 0 ? 0 : w(D.length) | 0
          , b = l(m);
        for (let P = 0; P < m; P += 1)
            b[P] = D[P] & 255;
        return b
    }
    function v(D) {
        if (Ce(D, Uint8Array)) {
            const m = new Uint8Array(D);
            return y(m.buffer, m.byteOffset, m.byteLength)
        }
        return h(D)
    }
    function y(D, m, b) {
        if (m < 0 || D.byteLength < m)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (D.byteLength < m + (b || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let P;
        return m === void 0 && b === void 0 ? P = new Uint8Array(D) : b === void 0 ? P = new Uint8Array(D,m) : P = new Uint8Array(D,m,b),
        Object.setPrototypeOf(P, i.prototype),
        P
    }
    function k(D) {
        if (i.isBuffer(D)) {
            const m = w(D.length) | 0
              , b = l(m);
            return b.length === 0 || D.copy(b, 0, 0, m),
            b
        }
        if (D.length !== void 0)
            return typeof D.length != "number" || Be(D.length) ? l(0) : h(D);
        if (D.type === "Buffer" && Array.isArray(D.data))
            return h(D.data)
    }
    function w(D) {
        if (D >= a)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
        return D | 0
    }
    function $(D) {
        return +D != D && (D = 0),
        i.alloc(+D)
    }
    i.isBuffer = function(m) {
        return m != null && m._isBuffer === !0 && m !== i.prototype
    }
    ,
    i.compare = function(m, b) {
        if (Ce(m, Uint8Array) && (m = i.from(m, m.offset, m.byteLength)),
        Ce(b, Uint8Array) && (b = i.from(b, b.offset, b.byteLength)),
        !i.isBuffer(m) || !i.isBuffer(b))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (m === b)
            return 0;
        let P = m.length
          , Y = b.length;
        for (let he = 0, $e = Math.min(P, Y); he < $e; ++he)
            if (m[he] !== b[he]) {
                P = m[he],
                Y = b[he];
                break
            }
        return P < Y ? -1 : Y < P ? 1 : 0
    }
    ,
    i.isEncoding = function(m) {
        switch (String(m).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    i.concat = function(m, b) {
        if (!Array.isArray(m))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (m.length === 0)
            return i.alloc(0);
        let P;
        if (b === void 0)
            for (b = 0,
            P = 0; P < m.length; ++P)
                b += m[P].length;
        const Y = i.allocUnsafe(b);
        let he = 0;
        for (P = 0; P < m.length; ++P) {
            let $e = m[P];
            if (Ce($e, Uint8Array))
                he + $e.length > Y.length ? (i.isBuffer($e) || ($e = i.from($e)),
                $e.copy(Y, he)) : Uint8Array.prototype.set.call(Y, $e, he);
            else if (i.isBuffer($e))
                $e.copy(Y, he);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            he += $e.length
        }
        return Y
    }
    ;
    function M(D, m) {
        if (i.isBuffer(D))
            return D.length;
        if (ArrayBuffer.isView(D) || Ce(D, ArrayBuffer))
            return D.byteLength;
        if (typeof D != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof D);
        const b = D.length
          , P = arguments.length > 2 && arguments[2] === !0;
        if (!P && b === 0)
            return 0;
        let Y = !1;
        for (; ; )
            switch (m) {
            case "ascii":
            case "latin1":
            case "binary":
                return b;
            case "utf8":
            case "utf-8":
                return ke(D).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return b * 2;
            case "hex":
                return b >>> 1;
            case "base64":
                return Oe(D).length;
            default:
                if (Y)
                    return P ? -1 : ke(D).length;
                m = ("" + m).toLowerCase(),
                Y = !0
            }
    }
    i.byteLength = M;
    function S(D, m, b) {
        let P = !1;
        if ((m === void 0 || m < 0) && (m = 0),
        m > this.length || ((b === void 0 || b > this.length) && (b = this.length),
        b <= 0) || (b >>>= 0,
        m >>>= 0,
        b <= m))
            return "";
        for (D || (D = "utf8"); ; )
            switch (D) {
            case "hex":
                return I(this, m, b);
            case "utf8":
            case "utf-8":
                return te(this, m, b);
            case "ascii":
                return oe(this, m, b);
            case "latin1":
            case "binary":
                return ne(this, m, b);
            case "base64":
                return G(this, m, b);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return j(this, m, b);
            default:
                if (P)
                    throw new TypeError("Unknown encoding: " + D);
                D = (D + "").toLowerCase(),
                P = !0
            }
    }
    i.prototype._isBuffer = !0;
    function T(D, m, b) {
        const P = D[m];
        D[m] = D[b],
        D[b] = P
    }
    i.prototype.swap16 = function() {
        const m = this.length;
        if (m % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let b = 0; b < m; b += 2)
            T(this, b, b + 1);
        return this
    }
    ,
    i.prototype.swap32 = function() {
        const m = this.length;
        if (m % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let b = 0; b < m; b += 4)
            T(this, b, b + 3),
            T(this, b + 1, b + 2);
        return this
    }
    ,
    i.prototype.swap64 = function() {
        const m = this.length;
        if (m % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let b = 0; b < m; b += 8)
            T(this, b, b + 7),
            T(this, b + 1, b + 6),
            T(this, b + 2, b + 5),
            T(this, b + 3, b + 4);
        return this
    }
    ,
    i.prototype.toString = function() {
        const m = this.length;
        return m === 0 ? "" : arguments.length === 0 ? te(this, 0, m) : S.apply(this, arguments)
    }
    ,
    i.prototype.toLocaleString = i.prototype.toString,
    i.prototype.equals = function(m) {
        if (!i.isBuffer(m))
            throw new TypeError("Argument must be a Buffer");
        return this === m ? !0 : i.compare(this, m) === 0
    }
    ,
    i.prototype.inspect = function() {
        let m = "";
        const b = t.INSPECT_MAX_BYTES;
        return m = this.toString("hex", 0, b).replace(/(.{2})/g, "$1 ").trim(),
        this.length > b && (m += " ... "),
        "<Buffer " + m + ">"
    }
    ,
    r && (i.prototype[r] = i.prototype.inspect),
    i.prototype.compare = function(m, b, P, Y, he) {
        if (Ce(m, Uint8Array) && (m = i.from(m, m.offset, m.byteLength)),
        !i.isBuffer(m))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m);
        if (b === void 0 && (b = 0),
        P === void 0 && (P = m ? m.length : 0),
        Y === void 0 && (Y = 0),
        he === void 0 && (he = this.length),
        b < 0 || P > m.length || Y < 0 || he > this.length)
            throw new RangeError("out of range index");
        if (Y >= he && b >= P)
            return 0;
        if (Y >= he)
            return -1;
        if (b >= P)
            return 1;
        if (b >>>= 0,
        P >>>= 0,
        Y >>>= 0,
        he >>>= 0,
        this === m)
            return 0;
        let $e = he - Y
          , Je = P - b;
        const wt = Math.min($e, Je)
          , tt = this.slice(Y, he)
          , it = m.slice(b, P);
        for (let ot = 0; ot < wt; ++ot)
            if (tt[ot] !== it[ot]) {
                $e = tt[ot],
                Je = it[ot];
                break
            }
        return $e < Je ? -1 : Je < $e ? 1 : 0
    }
    ;
    function E(D, m, b, P, Y) {
        if (D.length === 0)
            return -1;
        if (typeof b == "string" ? (P = b,
        b = 0) : b > 2147483647 ? b = 2147483647 : b < -2147483648 && (b = -2147483648),
        b = +b,
        Be(b) && (b = Y ? 0 : D.length - 1),
        b < 0 && (b = D.length + b),
        b >= D.length) {
            if (Y)
                return -1;
            b = D.length - 1
        } else if (b < 0)
            if (Y)
                b = 0;
            else
                return -1;
        if (typeof m == "string" && (m = i.from(m, P)),
        i.isBuffer(m))
            return m.length === 0 ? -1 : O(D, m, b, P, Y);
        if (typeof m == "number")
            return m = m & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? Y ? Uint8Array.prototype.indexOf.call(D, m, b) : Uint8Array.prototype.lastIndexOf.call(D, m, b) : O(D, [m], b, P, Y);
        throw new TypeError("val must be string, number or Buffer")
    }
    function O(D, m, b, P, Y) {
        let he = 1
          , $e = D.length
          , Je = m.length;
        if (P !== void 0 && (P = String(P).toLowerCase(),
        P === "ucs2" || P === "ucs-2" || P === "utf16le" || P === "utf-16le")) {
            if (D.length < 2 || m.length < 2)
                return -1;
            he = 2,
            $e /= 2,
            Je /= 2,
            b /= 2
        }
        function wt(it, ot) {
            return he === 1 ? it[ot] : it.readUInt16BE(ot * he)
        }
        let tt;
        if (Y) {
            let it = -1;
            for (tt = b; tt < $e; tt++)
                if (wt(D, tt) === wt(m, it === -1 ? 0 : tt - it)) {
                    if (it === -1 && (it = tt),
                    tt - it + 1 === Je)
                        return it * he
                } else
                    it !== -1 && (tt -= tt - it),
                    it = -1
        } else
            for (b + Je > $e && (b = $e - Je),
            tt = b; tt >= 0; tt--) {
                let it = !0;
                for (let ot = 0; ot < Je; ot++)
                    if (wt(D, tt + ot) !== wt(m, ot)) {
                        it = !1;
                        break
                    }
                if (it)
                    return tt
            }
        return -1
    }
    i.prototype.includes = function(m, b, P) {
        return this.indexOf(m, b, P) !== -1
    }
    ,
    i.prototype.indexOf = function(m, b, P) {
        return E(this, m, b, P, !0)
    }
    ,
    i.prototype.lastIndexOf = function(m, b, P) {
        return E(this, m, b, P, !1)
    }
    ;
    function U(D, m, b, P) {
        b = Number(b) || 0;
        const Y = D.length - b;
        P ? (P = Number(P),
        P > Y && (P = Y)) : P = Y;
        const he = m.length;
        P > he / 2 && (P = he / 2);
        let $e;
        for ($e = 0; $e < P; ++$e) {
            const Je = parseInt(m.substr($e * 2, 2), 16);
            if (Be(Je))
                return $e;
            D[b + $e] = Je
        }
        return $e
    }
    function L(D, m, b, P) {
        return De(ke(m, D.length - b), D, b, P)
    }
    function C(D, m, b, P) {
        return De(Ee(m), D, b, P)
    }
    function W(D, m, b, P) {
        return De(Oe(m), D, b, P)
    }
    function R(D, m, b, P) {
        return De(Fe(m, D.length - b), D, b, P)
    }
    i.prototype.write = function(m, b, P, Y) {
        if (b === void 0)
            Y = "utf8",
            P = this.length,
            b = 0;
        else if (P === void 0 && typeof b == "string")
            Y = b,
            P = this.length,
            b = 0;
        else if (isFinite(b))
            b = b >>> 0,
            isFinite(P) ? (P = P >>> 0,
            Y === void 0 && (Y = "utf8")) : (Y = P,
            P = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const he = this.length - b;
        if ((P === void 0 || P > he) && (P = he),
        m.length > 0 && (P < 0 || b < 0) || b > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        Y || (Y = "utf8");
        let $e = !1;
        for (; ; )
            switch (Y) {
            case "hex":
                return U(this, m, b, P);
            case "utf8":
            case "utf-8":
                return L(this, m, b, P);
            case "ascii":
            case "latin1":
            case "binary":
                return C(this, m, b, P);
            case "base64":
                return W(this, m, b, P);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return R(this, m, b, P);
            default:
                if ($e)
                    throw new TypeError("Unknown encoding: " + Y);
                Y = ("" + Y).toLowerCase(),
                $e = !0
            }
    }
    ,
    i.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function G(D, m, b) {
        return m === 0 && b === D.length ? e.fromByteArray(D) : e.fromByteArray(D.slice(m, b))
    }
    function te(D, m, b) {
        b = Math.min(D.length, b);
        const P = [];
        let Y = m;
        for (; Y < b; ) {
            const he = D[Y];
            let $e = null
              , Je = he > 239 ? 4 : he > 223 ? 3 : he > 191 ? 2 : 1;
            if (Y + Je <= b) {
                let wt, tt, it, ot;
                switch (Je) {
                case 1:
                    he < 128 && ($e = he);
                    break;
                case 2:
                    wt = D[Y + 1],
                    (wt & 192) === 128 && (ot = (he & 31) << 6 | wt & 63,
                    ot > 127 && ($e = ot));
                    break;
                case 3:
                    wt = D[Y + 1],
                    tt = D[Y + 2],
                    (wt & 192) === 128 && (tt & 192) === 128 && (ot = (he & 15) << 12 | (wt & 63) << 6 | tt & 63,
                    ot > 2047 && (ot < 55296 || ot > 57343) && ($e = ot));
                    break;
                case 4:
                    wt = D[Y + 1],
                    tt = D[Y + 2],
                    it = D[Y + 3],
                    (wt & 192) === 128 && (tt & 192) === 128 && (it & 192) === 128 && (ot = (he & 15) << 18 | (wt & 63) << 12 | (tt & 63) << 6 | it & 63,
                    ot > 65535 && ot < 1114112 && ($e = ot))
                }
            }
            $e === null ? ($e = 65533,
            Je = 1) : $e > 65535 && ($e -= 65536,
            P.push($e >>> 10 & 1023 | 55296),
            $e = 56320 | $e & 1023),
            P.push($e),
            Y += Je
        }
        return ae(P)
    }
    const J = 4096;
    function ae(D) {
        const m = D.length;
        if (m <= J)
            return String.fromCharCode.apply(String, D);
        let b = ""
          , P = 0;
        for (; P < m; )
            b += String.fromCharCode.apply(String, D.slice(P, P += J));
        return b
    }
    function oe(D, m, b) {
        let P = "";
        b = Math.min(D.length, b);
        for (let Y = m; Y < b; ++Y)
            P += String.fromCharCode(D[Y] & 127);
        return P
    }
    function ne(D, m, b) {
        let P = "";
        b = Math.min(D.length, b);
        for (let Y = m; Y < b; ++Y)
            P += String.fromCharCode(D[Y]);
        return P
    }
    function I(D, m, b) {
        const P = D.length;
        (!m || m < 0) && (m = 0),
        (!b || b < 0 || b > P) && (b = P);
        let Y = "";
        for (let he = m; he < b; ++he)
            Y += ze[D[he]];
        return Y
    }
    function j(D, m, b) {
        const P = D.slice(m, b);
        let Y = "";
        for (let he = 0; he < P.length - 1; he += 2)
            Y += String.fromCharCode(P[he] + P[he + 1] * 256);
        return Y
    }
    i.prototype.slice = function(m, b) {
        const P = this.length;
        m = ~~m,
        b = b === void 0 ? P : ~~b,
        m < 0 ? (m += P,
        m < 0 && (m = 0)) : m > P && (m = P),
        b < 0 ? (b += P,
        b < 0 && (b = 0)) : b > P && (b = P),
        b < m && (b = m);
        const Y = this.subarray(m, b);
        return Object.setPrototypeOf(Y, i.prototype),
        Y
    }
    ;
    function re(D, m, b) {
        if (D % 1 !== 0 || D < 0)
            throw new RangeError("offset is not uint");
        if (D + m > b)
            throw new RangeError("Trying to access beyond buffer length")
    }
    i.prototype.readUintLE = i.prototype.readUIntLE = function(m, b, P) {
        m = m >>> 0,
        b = b >>> 0,
        P || re(m, b, this.length);
        let Y = this[m]
          , he = 1
          , $e = 0;
        for (; ++$e < b && (he *= 256); )
            Y += this[m + $e] * he;
        return Y
    }
    ,
    i.prototype.readUintBE = i.prototype.readUIntBE = function(m, b, P) {
        m = m >>> 0,
        b = b >>> 0,
        P || re(m, b, this.length);
        let Y = this[m + --b]
          , he = 1;
        for (; b > 0 && (he *= 256); )
            Y += this[m + --b] * he;
        return Y
    }
    ,
    i.prototype.readUint8 = i.prototype.readUInt8 = function(m, b) {
        return m = m >>> 0,
        b || re(m, 1, this.length),
        this[m]
    }
    ,
    i.prototype.readUint16LE = i.prototype.readUInt16LE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 2, this.length),
        this[m] | this[m + 1] << 8
    }
    ,
    i.prototype.readUint16BE = i.prototype.readUInt16BE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 2, this.length),
        this[m] << 8 | this[m + 1]
    }
    ,
    i.prototype.readUint32LE = i.prototype.readUInt32LE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + this[m + 3] * 16777216
    }
    ,
    i.prototype.readUint32BE = i.prototype.readUInt32BE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        this[m] * 16777216 + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3])
    }
    ,
    i.prototype.readBigUInt64LE = Le(function(m) {
        m = m >>> 0,
        F(m, "offset");
        const b = this[m]
          , P = this[m + 7];
        (b === void 0 || P === void 0) && z(m, this.length - 8);
        const Y = b + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24
          , he = this[++m] + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + P * 2 ** 24;
        return BigInt(Y) + (BigInt(he) << BigInt(32))
    }),
    i.prototype.readBigUInt64BE = Le(function(m) {
        m = m >>> 0,
        F(m, "offset");
        const b = this[m]
          , P = this[m + 7];
        (b === void 0 || P === void 0) && z(m, this.length - 8);
        const Y = b * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m]
          , he = this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + P;
        return (BigInt(Y) << BigInt(32)) + BigInt(he)
    }),
    i.prototype.readIntLE = function(m, b, P) {
        m = m >>> 0,
        b = b >>> 0,
        P || re(m, b, this.length);
        let Y = this[m]
          , he = 1
          , $e = 0;
        for (; ++$e < b && (he *= 256); )
            Y += this[m + $e] * he;
        return he *= 128,
        Y >= he && (Y -= Math.pow(2, 8 * b)),
        Y
    }
    ,
    i.prototype.readIntBE = function(m, b, P) {
        m = m >>> 0,
        b = b >>> 0,
        P || re(m, b, this.length);
        let Y = b
          , he = 1
          , $e = this[m + --Y];
        for (; Y > 0 && (he *= 256); )
            $e += this[m + --Y] * he;
        return he *= 128,
        $e >= he && ($e -= Math.pow(2, 8 * b)),
        $e
    }
    ,
    i.prototype.readInt8 = function(m, b) {
        return m = m >>> 0,
        b || re(m, 1, this.length),
        this[m] & 128 ? (255 - this[m] + 1) * -1 : this[m]
    }
    ,
    i.prototype.readInt16LE = function(m, b) {
        m = m >>> 0,
        b || re(m, 2, this.length);
        const P = this[m] | this[m + 1] << 8;
        return P & 32768 ? P | 4294901760 : P
    }
    ,
    i.prototype.readInt16BE = function(m, b) {
        m = m >>> 0,
        b || re(m, 2, this.length);
        const P = this[m + 1] | this[m] << 8;
        return P & 32768 ? P | 4294901760 : P
    }
    ,
    i.prototype.readInt32LE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24
    }
    ,
    i.prototype.readInt32BE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]
    }
    ,
    i.prototype.readBigInt64LE = Le(function(m) {
        m = m >>> 0,
        F(m, "offset");
        const b = this[m]
          , P = this[m + 7];
        (b === void 0 || P === void 0) && z(m, this.length - 8);
        const Y = this[m + 4] + this[m + 5] * 2 ** 8 + this[m + 6] * 2 ** 16 + (P << 24);
        return (BigInt(Y) << BigInt(32)) + BigInt(b + this[++m] * 2 ** 8 + this[++m] * 2 ** 16 + this[++m] * 2 ** 24)
    }),
    i.prototype.readBigInt64BE = Le(function(m) {
        m = m >>> 0,
        F(m, "offset");
        const b = this[m]
          , P = this[m + 7];
        (b === void 0 || P === void 0) && z(m, this.length - 8);
        const Y = (b << 24) + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + this[++m];
        return (BigInt(Y) << BigInt(32)) + BigInt(this[++m] * 2 ** 24 + this[++m] * 2 ** 16 + this[++m] * 2 ** 8 + P)
    }),
    i.prototype.readFloatLE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        n.read(this, m, !0, 23, 4)
    }
    ,
    i.prototype.readFloatBE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 4, this.length),
        n.read(this, m, !1, 23, 4)
    }
    ,
    i.prototype.readDoubleLE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 8, this.length),
        n.read(this, m, !0, 52, 8)
    }
    ,
    i.prototype.readDoubleBE = function(m, b) {
        return m = m >>> 0,
        b || re(m, 8, this.length),
        n.read(this, m, !1, 52, 8)
    }
    ;
    function le(D, m, b, P, Y, he) {
        if (!i.isBuffer(D))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (m > Y || m < he)
            throw new RangeError('"value" argument is out of bounds');
        if (b + P > D.length)
            throw new RangeError("Index out of range")
    }
    i.prototype.writeUintLE = i.prototype.writeUIntLE = function(m, b, P, Y) {
        if (m = +m,
        b = b >>> 0,
        P = P >>> 0,
        !Y) {
            const Je = Math.pow(2, 8 * P) - 1;
            le(this, m, b, P, Je, 0)
        }
        let he = 1
          , $e = 0;
        for (this[b] = m & 255; ++$e < P && (he *= 256); )
            this[b + $e] = m / he & 255;
        return b + P
    }
    ,
    i.prototype.writeUintBE = i.prototype.writeUIntBE = function(m, b, P, Y) {
        if (m = +m,
        b = b >>> 0,
        P = P >>> 0,
        !Y) {
            const Je = Math.pow(2, 8 * P) - 1;
            le(this, m, b, P, Je, 0)
        }
        let he = P - 1
          , $e = 1;
        for (this[b + he] = m & 255; --he >= 0 && ($e *= 256); )
            this[b + he] = m / $e & 255;
        return b + P
    }
    ,
    i.prototype.writeUint8 = i.prototype.writeUInt8 = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 1, 255, 0),
        this[b] = m & 255,
        b + 1
    }
    ,
    i.prototype.writeUint16LE = i.prototype.writeUInt16LE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 2, 65535, 0),
        this[b] = m & 255,
        this[b + 1] = m >>> 8,
        b + 2
    }
    ,
    i.prototype.writeUint16BE = i.prototype.writeUInt16BE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 2, 65535, 0),
        this[b] = m >>> 8,
        this[b + 1] = m & 255,
        b + 2
    }
    ,
    i.prototype.writeUint32LE = i.prototype.writeUInt32LE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 4, 4294967295, 0),
        this[b + 3] = m >>> 24,
        this[b + 2] = m >>> 16,
        this[b + 1] = m >>> 8,
        this[b] = m & 255,
        b + 4
    }
    ,
    i.prototype.writeUint32BE = i.prototype.writeUInt32BE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 4, 4294967295, 0),
        this[b] = m >>> 24,
        this[b + 1] = m >>> 16,
        this[b + 2] = m >>> 8,
        this[b + 3] = m & 255,
        b + 4
    }
    ;
    function ce(D, m, b, P, Y) {
        fe(m, P, Y, D, b, 7);
        let he = Number(m & BigInt(4294967295));
        D[b++] = he,
        he = he >> 8,
        D[b++] = he,
        he = he >> 8,
        D[b++] = he,
        he = he >> 8,
        D[b++] = he;
        let $e = Number(m >> BigInt(32) & BigInt(4294967295));
        return D[b++] = $e,
        $e = $e >> 8,
        D[b++] = $e,
        $e = $e >> 8,
        D[b++] = $e,
        $e = $e >> 8,
        D[b++] = $e,
        b
    }
    function xe(D, m, b, P, Y) {
        fe(m, P, Y, D, b, 7);
        let he = Number(m & BigInt(4294967295));
        D[b + 7] = he,
        he = he >> 8,
        D[b + 6] = he,
        he = he >> 8,
        D[b + 5] = he,
        he = he >> 8,
        D[b + 4] = he;
        let $e = Number(m >> BigInt(32) & BigInt(4294967295));
        return D[b + 3] = $e,
        $e = $e >> 8,
        D[b + 2] = $e,
        $e = $e >> 8,
        D[b + 1] = $e,
        $e = $e >> 8,
        D[b] = $e,
        b + 8
    }
    i.prototype.writeBigUInt64LE = Le(function(m, b=0) {
        return ce(this, m, b, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    i.prototype.writeBigUInt64BE = Le(function(m, b=0) {
        return xe(this, m, b, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    i.prototype.writeIntLE = function(m, b, P, Y) {
        if (m = +m,
        b = b >>> 0,
        !Y) {
            const wt = Math.pow(2, 8 * P - 1);
            le(this, m, b, P, wt - 1, -wt)
        }
        let he = 0
          , $e = 1
          , Je = 0;
        for (this[b] = m & 255; ++he < P && ($e *= 256); )
            m < 0 && Je === 0 && this[b + he - 1] !== 0 && (Je = 1),
            this[b + he] = (m / $e >> 0) - Je & 255;
        return b + P
    }
    ,
    i.prototype.writeIntBE = function(m, b, P, Y) {
        if (m = +m,
        b = b >>> 0,
        !Y) {
            const wt = Math.pow(2, 8 * P - 1);
            le(this, m, b, P, wt - 1, -wt)
        }
        let he = P - 1
          , $e = 1
          , Je = 0;
        for (this[b + he] = m & 255; --he >= 0 && ($e *= 256); )
            m < 0 && Je === 0 && this[b + he + 1] !== 0 && (Je = 1),
            this[b + he] = (m / $e >> 0) - Je & 255;
        return b + P
    }
    ,
    i.prototype.writeInt8 = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 1, 127, -128),
        m < 0 && (m = 255 + m + 1),
        this[b] = m & 255,
        b + 1
    }
    ,
    i.prototype.writeInt16LE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 2, 32767, -32768),
        this[b] = m & 255,
        this[b + 1] = m >>> 8,
        b + 2
    }
    ,
    i.prototype.writeInt16BE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 2, 32767, -32768),
        this[b] = m >>> 8,
        this[b + 1] = m & 255,
        b + 2
    }
    ,
    i.prototype.writeInt32LE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 4, 2147483647, -2147483648),
        this[b] = m & 255,
        this[b + 1] = m >>> 8,
        this[b + 2] = m >>> 16,
        this[b + 3] = m >>> 24,
        b + 4
    }
    ,
    i.prototype.writeInt32BE = function(m, b, P) {
        return m = +m,
        b = b >>> 0,
        P || le(this, m, b, 4, 2147483647, -2147483648),
        m < 0 && (m = 4294967295 + m + 1),
        this[b] = m >>> 24,
        this[b + 1] = m >>> 16,
        this[b + 2] = m >>> 8,
        this[b + 3] = m & 255,
        b + 4
    }
    ,
    i.prototype.writeBigInt64LE = Le(function(m, b=0) {
        return ce(this, m, b, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    i.prototype.writeBigInt64BE = Le(function(m, b=0) {
        return xe(this, m, b, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function X(D, m, b, P, Y, he) {
        if (b + P > D.length)
            throw new RangeError("Index out of range");
        if (b < 0)
            throw new RangeError("Index out of range")
    }
    function be(D, m, b, P, Y) {
        return m = +m,
        b = b >>> 0,
        Y || X(D, m, b, 4),
        n.write(D, m, b, P, 23, 4),
        b + 4
    }
    i.prototype.writeFloatLE = function(m, b, P) {
        return be(this, m, b, !0, P)
    }
    ,
    i.prototype.writeFloatBE = function(m, b, P) {
        return be(this, m, b, !1, P)
    }
    ;
    function ee(D, m, b, P, Y) {
        return m = +m,
        b = b >>> 0,
        Y || X(D, m, b, 8),
        n.write(D, m, b, P, 52, 8),
        b + 8
    }
    i.prototype.writeDoubleLE = function(m, b, P) {
        return ee(this, m, b, !0, P)
    }
    ,
    i.prototype.writeDoubleBE = function(m, b, P) {
        return ee(this, m, b, !1, P)
    }
    ,
    i.prototype.copy = function(m, b, P, Y) {
        if (!i.isBuffer(m))
            throw new TypeError("argument should be a Buffer");
        if (P || (P = 0),
        !Y && Y !== 0 && (Y = this.length),
        b >= m.length && (b = m.length),
        b || (b = 0),
        Y > 0 && Y < P && (Y = P),
        Y === P || m.length === 0 || this.length === 0)
            return 0;
        if (b < 0)
            throw new RangeError("targetStart out of bounds");
        if (P < 0 || P >= this.length)
            throw new RangeError("Index out of range");
        if (Y < 0)
            throw new RangeError("sourceEnd out of bounds");
        Y > this.length && (Y = this.length),
        m.length - b < Y - P && (Y = m.length - b + P);
        const he = Y - P;
        return this === m && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(b, P, Y) : Uint8Array.prototype.set.call(m, this.subarray(P, Y), b),
        he
    }
    ,
    i.prototype.fill = function(m, b, P, Y) {
        if (typeof m == "string") {
            if (typeof b == "string" ? (Y = b,
            b = 0,
            P = this.length) : typeof P == "string" && (Y = P,
            P = this.length),
            Y !== void 0 && typeof Y != "string")
                throw new TypeError("encoding must be a string");
            if (typeof Y == "string" && !i.isEncoding(Y))
                throw new TypeError("Unknown encoding: " + Y);
            if (m.length === 1) {
                const $e = m.charCodeAt(0);
                (Y === "utf8" && $e < 128 || Y === "latin1") && (m = $e)
            }
        } else
            typeof m == "number" ? m = m & 255 : typeof m == "boolean" && (m = Number(m));
        if (b < 0 || this.length < b || this.length < P)
            throw new RangeError("Out of range index");
        if (P <= b)
            return this;
        b = b >>> 0,
        P = P === void 0 ? this.length : P >>> 0,
        m || (m = 0);
        let he;
        if (typeof m == "number")
            for (he = b; he < P; ++he)
                this[he] = m;
        else {
            const $e = i.isBuffer(m) ? m : i.from(m, Y)
              , Je = $e.length;
            if (Je === 0)
                throw new TypeError('The value "' + m + '" is invalid for argument "value"');
            for (he = 0; he < P - b; ++he)
                this[he + b] = $e[he % Je]
        }
        return this
    }
    ;
    const B = {};
    function se(D, m, b) {
        B[D] = class extends b {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: m.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${D}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return D
            }
            set code(Y) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: Y,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${D}]: ${this.message}`
            }
        }
    }
    se("ERR_BUFFER_OUT_OF_BOUNDS", function(D) {
        return D ? `${D} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    se("ERR_INVALID_ARG_TYPE", function(D, m) {
        return `The "${D}" argument must be of type number. Received type ${typeof m}`
    }, TypeError),
    se("ERR_OUT_OF_RANGE", function(D, m, b) {
        let P = `The value of "${D}" is out of range.`
          , Y = b;
        return Number.isInteger(b) && Math.abs(b) > 2 ** 32 ? Y = pe(String(b)) : typeof b == "bigint" && (Y = String(b),
        (b > BigInt(2) ** BigInt(32) || b < -(BigInt(2) ** BigInt(32))) && (Y = pe(Y)),
        Y += "n"),
        P += ` It must be ${m}. Received ${Y}`,
        P
    }, RangeError);
    function pe(D) {
        let m = ""
          , b = D.length;
        const P = D[0] === "-" ? 1 : 0;
        for (; b >= P + 4; b -= 3)
            m = `_${D.slice(b - 3, b)}${m}`;
        return `${D.slice(0, b)}${m}`
    }
    function ie(D, m, b) {
        F(m, "offset"),
        (D[m] === void 0 || D[m + b] === void 0) && z(m, D.length - (b + 1))
    }
    function fe(D, m, b, P, Y, he) {
        if (D > b || D < m) {
            const $e = typeof m == "bigint" ? "n" : "";
            let Je;
            throw he > 3 ? m === 0 || m === BigInt(0) ? Je = `>= 0${$e} and < 2${$e} ** ${(he + 1) * 8}${$e}` : Je = `>= -(2${$e} ** ${(he + 1) * 8 - 1}${$e}) and < 2 ** ${(he + 1) * 8 - 1}${$e}` : Je = `>= ${m}${$e} and <= ${b}${$e}`,
            new B.ERR_OUT_OF_RANGE("value",Je,D)
        }
        ie(P, Y, he)
    }
    function F(D, m) {
        if (typeof D != "number")
            throw new B.ERR_INVALID_ARG_TYPE(m,"number",D)
    }
    function z(D, m, b) {
        throw Math.floor(D) !== D ? (F(D, b),
        new B.ERR_OUT_OF_RANGE(b || "offset","an integer",D)) : m < 0 ? new B.ERR_BUFFER_OUT_OF_BOUNDS : new B.ERR_OUT_OF_RANGE(b || "offset",`>= ${b ? 1 : 0} and <= ${m}`,D)
    }
    const ge = /[^+/0-9A-Za-z-_]/g;
    function Te(D) {
        if (D = D.split("=")[0],
        D = D.trim().replace(ge, ""),
        D.length < 2)
            return "";
        for (; D.length % 4 !== 0; )
            D = D + "=";
        return D
    }
    function ke(D, m) {
        m = m || 1 / 0;
        let b;
        const P = D.length;
        let Y = null;
        const he = [];
        for (let $e = 0; $e < P; ++$e) {
            if (b = D.charCodeAt($e),
            b > 55295 && b < 57344) {
                if (!Y) {
                    if (b > 56319) {
                        (m -= 3) > -1 && he.push(239, 191, 189);
                        continue
                    } else if ($e + 1 === P) {
                        (m -= 3) > -1 && he.push(239, 191, 189);
                        continue
                    }
                    Y = b;
                    continue
                }
                if (b < 56320) {
                    (m -= 3) > -1 && he.push(239, 191, 189),
                    Y = b;
                    continue
                }
                b = (Y - 55296 << 10 | b - 56320) + 65536
            } else
                Y && (m -= 3) > -1 && he.push(239, 191, 189);
            if (Y = null,
            b < 128) {
                if ((m -= 1) < 0)
                    break;
                he.push(b)
            } else if (b < 2048) {
                if ((m -= 2) < 0)
                    break;
                he.push(b >> 6 | 192, b & 63 | 128)
            } else if (b < 65536) {
                if ((m -= 3) < 0)
                    break;
                he.push(b >> 12 | 224, b >> 6 & 63 | 128, b & 63 | 128)
            } else if (b < 1114112) {
                if ((m -= 4) < 0)
                    break;
                he.push(b >> 18 | 240, b >> 12 & 63 | 128, b >> 6 & 63 | 128, b & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return he
    }
    function Ee(D) {
        const m = [];
        for (let b = 0; b < D.length; ++b)
            m.push(D.charCodeAt(b) & 255);
        return m
    }
    function Fe(D, m) {
        let b, P, Y;
        const he = [];
        for (let $e = 0; $e < D.length && !((m -= 2) < 0); ++$e)
            b = D.charCodeAt($e),
            P = b >> 8,
            Y = b % 256,
            he.push(Y),
            he.push(P);
        return he
    }
    function Oe(D) {
        return e.toByteArray(Te(D))
    }
    function De(D, m, b, P) {
        let Y;
        for (Y = 0; Y < P && !(Y + b >= m.length || Y >= D.length); ++Y)
            m[Y + b] = D[Y];
        return Y
    }
    function Ce(D, m) {
        return D instanceof m || D != null && D.constructor != null && D.constructor.name != null && D.constructor.name === m.name
    }
    function Be(D) {
        return D !== D
    }
    const ze = function() {
        const D = "0123456789abcdef"
          , m = new Array(256);
        for (let b = 0; b < 16; ++b) {
            const P = b * 16;
            for (let Y = 0; Y < 16; ++Y)
                m[P + Y] = D[b] + D[Y]
        }
        return m
    }();
    function Le(D) {
        return typeof BigInt > "u" ? Ye : D
    }
    function Ye() {
        throw new Error("BigInt not supported")
    }
}
)(Dp);
const Pe = Lr("root", {
    state: () => ({
        aktivKungorelse: null,
        aktivUppgiftslamnare: null,
        aktivKungorelsetyp: null,
        savedKungorelse: null,
        ersattsAvKungorelse: null,
        senastKoppling: null,
        nyaKungorelser: [],
        kungorelsetyper: [],
        underrubriker: [],
        loadedKungorelse: null,
        loadedKungorelsetyp: null,
        loadedUnderrubrik: null,
        startsida: !1,
        fulvisa: !1,
        rensaSokHistorik: !1
    }),
    getters: {
        getAktivKungorelse: t => t.aktivKungorelse,
        getAktivUppgiftslamnare: t => t.aktivUppgiftslamnare,
        getAktivKungorelsetyp: t => t.aktivKungorelsetyp
    },
    actions: {
        async getKoppling() {
            const t = "/poit/rest/HamtaKoppling"
              , e = await Pt.get(t, {});
            return e.data != this.senastKoppling ? (this.senastKoppling = e.data,
            !0) : !1
        },
        async getKungorelse(t) {
            if (this.loadedKungorelse = null,
            this.ersattsAvKungorelse = null,
            navigator.webdriver == !0)
                throw fetch("/poit-app?l=92300254401", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            if (navigator.languages.length == 0)
                throw fetch("/poit-app?l=92300254402", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            if (window.document.documentElement.getAttribute("webdriver"))
                throw fetch("/poit-app?l=92300254403", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            for (const u in window)
                if (u.match(/^cdc_/ig))
                    throw fetch("/poit-app?l=92300254404", {
                        method: "HEAD",
                        cache: "no-cache"
                    }),
                    new Error("UNKNOWN");
            if ("_Selenium_IDE_Recorder"in window)
                throw fetch("/poit-app?l=92300254405", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            if ("__webdriver_script_fn"in document)
                throw fetch("/poit-app?l=92300254406", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            if (/HeadlessChrome/.test(window.navigator.userAgent))
                throw fetch("/poit-app?l=92300254407", {
                    method: "HEAD",
                    cache: "no-cache"
                }),
                new Error("UNKNOWN");
            const e = "/poit/rest/HamtaKungorelse?kungorelseid=" + t.kungorelseid + "&koppling=" + this.senastKoppling + "&version=4";
            let n = null;
            try {
                n = await Pt.get(e, {})
            } catch (u) {
                throw new Error(u.response.status)
            }
            const r = qb(n.data);
            let a = Dp.Buffer.from(r, "base64");
            const s = new TextEncoder().encode(t.kungorelseid + this.senastKoppling)
              , l = await crypto.subtle.digest("SHA-256", s)
              , o = zb(a, new Uint8Array(l)).toString("utf8");
            if (this.loadedKungorelse = JSON.parse(o),
            this.loadedKungorelse.ersattsAv) {
                const u = "/poit/rest/HamtaKoppling";
                if ((await Pt.get(u, {})).data != this.senastKoppling)
                    throw Error;
                await new Promise(S => setTimeout(S, 250));
                const f = "/poit/rest/HamtaKungorelse?kungorelseid=" + this.loadedKungorelse.ersattsAv + "&koppling=" + this.senastKoppling + "&version=4";
                let p = null;
                try {
                    p = await Pt.get(f)
                } catch (S) {
                    if (S.response.status != "403")
                        throw new Error(S.response.status)
                }
                const h = qb(p.data);
                let v = Dp.Buffer.from(h, "base64");
                const y = new TextEncoder().encode(this.loadedKungorelse.ersattsAv + this.senastKoppling)
                  , k = await crypto.subtle.digest("SHA-256", y)
                  , $ = zb(v, new Uint8Array(k)).toString("utf8");
                this.ersattsAvKungorelse = JSON.parse($);
                const M = "/poit/rest/HamtaKungorelsetyp?externKod=" + this.ersattsAvKungorelse.rubrikExternKod;
                await Pt.get(M, {})
            }
        },
        async registreraKungorelser(t) {
            try {
                const e = dt().getKundanvandare
                  , n = {
                    email: e.email,
                    token: e.token,
                    kungorelser: t
                }
                  , r = "/poit/rest/RegistreraKungorelser";
                return (await Pt.post(r, n)).data
            } catch {
                return []
            }
        },
        async updateraKungorelse(t) {
            try {
                const e = "/poit/rest/UpdateraKungorelse"
                  , n = await Pt.post(e, t);
                return this.setSavedKungorelse(n.data),
                !0
            } catch {
                return !1
            }
        },
        async getKungorelsetyper(t) {
            try {
                const e = "/poit/rest/ListaKungorelseTyper?kundNummer=" + t
                  , n = await Pt.get(e, {});
                this.setKungorelsetyper(n.data)
            } catch {}
        },
        async getKungorelsetyp(t) {
            try {
                const e = "/poit/rest/HamtaKungorelsetyp?externKod=" + t
                  , n = await Pt.get(e, {});
                this.setLoadedKungorelsetyp(n.data)
            } catch {}
        },
        async getUnderrubriker(t) {
            try {
                const e = "/poit/rest/ListaUnderrubriker?rubrikExternKod=" + t
                  , n = await Pt.get(e, {});
                this.setUnderrubriker(n.data)
            } catch {}
        },
        async getUnderrubrik(t) {
            try {
                const e = "/poit/rest/HamtaUnderrubrik?externKod=" + t
                  , n = await Pt.get(e, {});
                this.setLoadedUnderrubrik(n.data)
            } catch {}
        },
        setRensaSokHistorik(t) {
            this.rensaSokHistorik = t
        },
        setAktivKungorelse(t) {
            this.aktivKungorelse = t
        },
        setAktivUppgiftslamnare(t) {
            this.aktivUppgiftslamnare = t
        },
        setAktivKungorelsetyp(t) {
            this.aktivKungorelsetyp = t
        },
        setKungorelsetyper(t) {
            t.sort( (e, n) => e.kungorelseRubrik < n.kungorelseRubrik ? -1 : 1),
            this.kungorelsetyper = t
        },
        setUnderrubriker(t) {
            t.sort( (e, n) => e.beskrivning < n.beskrivning ? -1 : 1),
            this.underrubriker = t
        },
        setLoadedKungorelsetyp(t) {
            this.loadedKungorelsetyp = t
        },
        setLoadedUnderrubrik(t) {
            this.loadedUnderrubrik = t
        },
        setSavedKungorelse(t) {
            this.savedKungorelse = t
        }
    }
})
  , St = Lr("typdata", {
    state: () => ({
        amnesomraden: [],
        amnesomradenLoaded: !1,
        laner: [],
        lander: [],
        uppgiftslamnare: []
    }),
    getters: {},
    actions: {
        async getAmnesomraden() {
            try {
                const t = await Pt.get("/poit/rest/ListaAmnesomraden", {});
                this.setAmnesomraden(t.data)
            } catch {
                throw "Tekniskt fel"
            }
        },
        async getLan() {
            try {
                const t = await Pt.get("/poit/rest/ListaLan", {});
                return this.setLan(t.data),
                !0
            } catch {
                throw "Tekniskt fel"
            }
        },
        async getLander() {
            try {
                const t = await Pt.get("/poit/rest/ListaLander", {});
                this.setLander(t.data)
            } catch {
                throw "Tekniskt fel"
            }
        },
        async getUppgiftslamnare() {
            try {
                const t = await Pt.get("/poit/rest/ListaUppgiftslamnartyper", {});
                this.setUppgiftslamnare(t.data)
            } catch {
                throw "Tekniskt fel"
            }
        },
        setAmnesomraden(t) {
            t.sort( (e, n) => e.namn < n.namn ? -1 : 1);
            for (let e = 0; e < t.length; e++)
                t[e].kungorelserubriker.sort( (n, r) => n.namn < r.namn ? -1 : 1);
            this.amnesomraden = t,
            this.amnesomradenLoaded = !0
        },
        setLan(t) {
            t.sort( (e, n) => e.namn < n.namn ? -1 : 1),
            this.laner = t
        },
        setLander(t) {
            t.sort( (e, n) => e.namn < n.namn ? -1 : 1),
            this.lander = t
        },
        setUppgiftslamnare(t) {
            this.uppgiftslamnare = t
        }
    }
})
  , En = Lr("sokKungorelse", {
    state: () => ({
        sokKungorelseResultat: [],
        sokparametrar: {}
    }),
    getters: {},
    actions: {
        async sokKungorelse(t) {
            try {
                this.setSokparametrar(t);
                const e = await Pt.get("/poit/rest/SokKungorelse", {
                    params: {
                        sokord: t.sokord,
                        kungorelseid: t.kungorelseid,
                        publiceringsdatum: t.publiceringsdatum,
                        kungorelseObjektPersonOrgnummer: t.personOrgnummer,
                        kungorelseObjektNamn: t.namn,
                        tidsperiod: t.valdTidsperiod,
                        tidsperiodFrom: t.tidsperiodFrom,
                        tidsperiodTom: t.tidsperiodTom,
                        amnesomradeId: t.valtAmnesomrade,
                        kungorelsetypId: t.valdKungorelsetyp,
                        underRubrikId: t.valdUnderrubrik,
                        kundanvandarid: t.kundanvandarid,
                        kundid: t.kundid,
                        kundidAgresso: t.kundidAgresso,
                        lanKod: t.lanKod
                    }
                });
                return e.data == "INGA_TRAFFAR" || e.data == "FOR_MANGA_TRAFFAR" ? this.resetSokKungorelseResultatLista() : this.setSokKungorelseResultatLista(e.data),
                e.data
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        resetSokHistorik() {
            this.resetSokKungorelseResultatLista(),
            this.resetSokparametrar()
        },
        setSokKungorelseResultatLista(t) {
            this.sokKungorelseResultat = t
        },
        resetSokKungorelseResultatLista() {
            this.sokKungorelseResultat = []
        },
        setSokparametrar(t) {
            this.sokparametrar = t
        },
        resetSokparametrar() {
            this.sokparametrar = {}
        }
    }
})
  , P4 = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , F4 = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"
}), c("path", {
    d: "M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25c.09-.656.54-1.134 1.342-1.134c.686 0 1.314.343 1.314 1.168c0 .635-.374.927-.965 1.371c-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486c.609-.463 1.244-.977 1.244-2.056c0-1.511-1.276-2.241-2.673-2.241c-1.267 0-2.655.59-2.75 2.286m1.557 5.763c0 .533.425.927 1.01.927c.609 0 1.028-.394 1.028-.927c0-.552-.42-.94-1.029-.94c-.584 0-1.009.388-1.009.94"
})], -1)
  , B4 = [F4];
function V4(t, e) {
    return g(),
    _("svg", P4, [...B4])
}
const I4 = {
    name: "bi-question-circle",
    render: V4
};
var R4 = Object.defineProperty
  , L4 = Object.getOwnPropertyDescriptor
  , cc = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? L4(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && R4(e, n, a),
    a
}
;
let ui = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "kungorelserubrikFaltet");
        V(this, "underrubrikFaltet");
        V(this, "lanFaltet");
        V(this, "loading", !1);
        V(this, "list", [1, 2, 3, 4]);
        V(this, "tidsperiodFrom", "");
        V(this, "tidsperiodTom", "");
        V(this, "tidperiodFromFeltext", "");
        V(this, "tidperiodTomFeltext", "");
        V(this, "personOrgnummer", "");
        V(this, "namn", "");
        V(this, "valdUppgiftslamnare", -1);
        V(this, "valtAmnesomrade", "");
        V(this, "valdKungorelsetyp", "");
        V(this, "valdUnderrubrik", "");
        V(this, "valdLan", "");
        V(this, "kungorelsetyp", "");
        V(this, "underrubrik", "");
        V(this, "kungorelseid", "");
        V(this, "sokord", "");
        V(this, "text", "");
        V(this, "tidsperioder", [{
            namn: "",
            id: null
        }, {
            namn: "Senaste veckan",
            id: "SENASTE_VECKAN"
        }, {
            namn: "Senaste månaden",
            id: "SENASTE_MANADEN"
        }, {
            namn: "Senaste året",
            id: "SENASTE_ARET"
        }, {
            namn: "Annan period",
            id: "ANNAN_PERIOD"
        }]);
        V(this, "valdTidsperiod", "");
        V(this, "kungorelseresultat", []);
        V(this, "visaFler", !1);
        V(this, "visaFlerText", "Visa fler sökalternativ");
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "errors", []);
        V(this, "tidsperiodFelmeddelande", "");
        V(this, "sokordFelmeddelande", "");
        V(this, "namnFelmeddelande", "")
    }
    get amnesomraden() {
        return St().amnesomraden
    }
    get laner() {
        return St().laner
    }
    get sokKungorelseResultat() {
        return En().sokKungorelseResultat
    }
    get sokparametrar() {
        return En().sokparametrar
    }
    get rensaSokHistorik() {
        return Pe().rensaSokHistorik
    }
    setRensaSokHistorik(n) {
        Pe().setRensaSokHistorik(n)
    }
    setFokusKungorelserubrik() {
        this.$nextTick( () => {
            var n;
            (n = this.kungorelserubrikFaltet) == null || n.focus()
        }
        )
    }
    setFokusUnderrubrik() {
        this.$nextTick( () => {
            var n;
            (n = this.underrubrikFaltet) == null || n.focus()
        }
        )
    }
    visaAnnanPeriod() {
        return this.valdTidsperiod == "ANNAN_PERIOD"
    }
    sokKungorelse() {
        En().resetSokKungorelseResultatLista(),
        this.valtAmnesomrade.length === 0 && (this.valdKungorelsetyp = ""),
        this.valdKungorelsetyp.length === 0 && (this.valdUnderrubrik = ""),
        this.loading = !0,
        this.visaMeddelande = !1,
        En().sokKungorelse({
            sokord: this.sokord,
            kungorelseid: this.kungorelseid,
            valdTidsperiod: this.valdTidsperiod,
            tidsperiodFrom: this.tidsperiodFrom,
            tidsperiodTom: this.tidsperiodTom,
            personOrgnummer: this.personOrgnummer,
            valtAmnesomrade: this.valtAmnesomrade.id,
            valdKungorelsetyp: this.valdKungorelsetyp.id,
            valdUnderrubrik: this.valdUnderrubrik.id,
            lanKod: this.valdLan.kod,
            namn: this.namn
        }).then(n => {
            this.loading = !1,
            n == "FOR_MANGA_TRAFFAR" ? (this.visaMeddelande = !0,
            this.meddelande = "Sökningen gav för många träffar.",
            this.meddelandeTyp = "info") : n == "INGA_TRAFFAR" ? (this.visaMeddelande = !0,
            this.meddelande = "Sökningen gav ingen träff.",
            this.meddelandeTyp = "info") : this.sokKungorelseResultat.sort( (r, a) => a.publiceringsdatum > r.publiceringsdatum ? 1 : -1)
        }
        ).catch(n => {
            this.meddelande = n,
            this.loading = !1,
            this.visaMeddelande = !0,
            this.meddelandeTyp = "danger"
        }
        )
    }
    rensaSokparametrar() {
        this.sokord = "",
        this.kungorelseid = "",
        this.valdTidsperiod = "",
        this.tidsperiodFrom = "",
        this.tidsperiodTom = "",
        this.personOrgnummer = "",
        this.namn = "",
        this.visaFler = !1,
        this.visaFlerText = "Visa färre sökalternativ"
    }
    kungorelseidGiltigt() {
        return x4(this.kungorelseid)
    }
    personOrgnummerGiltigt() {
        return Ht(this.personOrgnummer)
    }
    dagensDatum() {
        return ow()
    }
    dagensDatumMinusAr(n) {
        return uw(n)
    }
    onLeavePersonorgnummer() {
        this.personOrgnummer = iw(this.personOrgnummer)
    }
    namnGiltigt() {
        return this.namn.length > 0 && this.namn.length < 3 ? (this.namnFelmeddelande = "Ange minst tre tecken eller lämna fältet tomt",
        !1) : this.namn.startsWith("*") ? (this.namnFelmeddelande = "Söksträngen får inte inledas med *",
        !1) : null
    }
    sokordGiltigt() {
        return this.sokord.length > 0 && this.sokord.length < 3 ? (this.sokordFelmeddelande = "Fältet måste innehålla minst 3 tecken.",
        !1) : null
    }
    tidsperiodGiltig() {
        return this.sokord.length > 0 && this.valdTidsperiod !== "SENASTE_MANADEN" && this.valdTidsperiod !== "SENASTE_VECKAN" ? (this.tidsperiodFelmeddelande = "Välj senaste veckan eller senaste månaden i fältet Publiceringsdatum för att kunna söka i kungörelsetexten",
        !1) : null
    }
    tidsperiodFromGiltigt() {
        return this.tidsperiodFrom == "" ? null : this.tidsperiodFrom < this.dagensDatumMinusAr(6) ? (this.tidperiodFromFeltext = "Du kan bara söka på kungörelser som är upp till två år gamla. (För arvskungörelser gäller sex år)",
        !1) : this.tidsperiodFrom > this.tidsperiodTom && this.tidsperiodTom != "" ? (this.tidperiodFromFeltext = "Från och med får inte vara större än till och med",
        !1) : this.tidsperiodFrom > this.dagensDatum() ? (this.tidperiodFromFeltext = "Från och med får inte vara större än dagens datum",
        !1) : null
    }
    tidsperiodTomGiltigt() {
        return this.tidsperiodTom > this.dagensDatum() ? (this.tidperiodTomFeltext = "Till och med får inte vara större än dagens datum",
        !1) : null
    }
    disableSok() {
        if (this.laner.length == 0 || Pe().senastKoppling == null || this.sokord == "" && this.kungorelseid == "" && this.valdTidsperiod == "" && this.tidsperiodFrom == "" && this.personOrgnummer == "" && this.namn == "" && this.valdTidsperiod == "" && this.valtAmnesomrade == "" || !this.personOrgnummerGiltigt() && this.personOrgnummer.length > 0 || !this.kungorelseidGiltigt() && this.kungorelseid.length > 0)
            return !0;
        var n = this.sokordGiltigt();
        if (n != null && !n && this.sokord.length > 0)
            return !0;
        var r = this.tidsperiodGiltig();
        if (r != null && !r)
            return !0;
        var a = this.namnGiltigt();
        return a != null && !a && this.namn.length > 0
    }
    amnesomradeListChanged() {
        this.valdKungorelsetyp = "",
        this.valdUnderrubrik = ""
    }
    tidsperiodListChanged(n) {
        this.valdTidsperiod = n.id,
        this.valdTidsperiod != "ANNAN_PERIOD" && (this.tidsperiodFrom = "",
        this.tidsperiodTom = "")
    }
    sokordValt(n) {
        this.sokord = n
    }
    toggleVisaFler() {
        return this.visaFler = !this.visaFler,
        this.visaFler ? (this.sokord = "",
        this.valtAmnesomrade = "",
        this.valdKungorelsetyp = "",
        this.valdUnderrubrik = "",
        this.visaFlerText = "Visa färre sökalternativ") : this.visaFlerText = "Visa fler sökalternativ",
        this.visaFler
    }
    aterstallSokparametrar() {
        this.kungorelseid = this.sokparametrar.kungorelseid,
        this.sokord = this.sokparametrar.sokord,
        this.personOrgnummer = this.sokparametrar.personOrgnummer,
        this.namn = this.sokparametrar.namn,
        this.tidsperiodFrom = this.sokparametrar.tidsperiodFrom,
        this.tidsperiodTom = this.sokparametrar.tidsperiodTom,
        this.aterstallListval(),
        this.aterstallVisaFler()
    }
    aterstallListval() {
        this.sokparametrar.valdTidsperiod != null && (this.valdTidsperiod = Wi(this.tidsperioder, this.sokparametrar.valdTidsperiod).id),
        this.sokparametrar.valtAmnesomrade != null && (this.valtAmnesomrade = Wi(this.amnesomraden, this.sokparametrar.valtAmnesomrade),
        this.sokparametrar.valdKungorelsetyp != null ? this.valdKungorelsetyp = Wi(this.valtAmnesomrade.kungorelserubriker, this.sokparametrar.valdKungorelsetyp) : this.valdKungorelsetyp = "",
        this.sokparametrar.valdUnderrubrik != null ? this.valdUnderrubrik = Wi(this.valdKungorelsetyp.underrubriker, this.sokparametrar.valdUnderrubrik) : this.valdUnderrubrik = "")
    }
    aterstallVisaFler() {
        this.kungorelseid != "" || this.sokord != "" || this.valtAmnesomrade != "" ? (this.visaFler = !0,
        this.visaFlerText = "Visa färre sökalternativ") : (this.visaFler = !1,
        this.visaFlerText = "Visa fler sökalternativ")
    }
    beforeCreate() {
        St().getLan(),
        St().getAmnesomraden()
    }
    created() {
        this.rensaSokHistorik ? (En().resetSokKungorelseResultatLista(),
        this.setRensaSokHistorik(!1)) : Object.keys(this.sokparametrar).length && this.aterstallSokparametrar(),
        setTimeout( () => {
            this.$route.meta.savedPosition && window.scrollTo({
                ...this.$route.meta.savedPosition,
                behavior: "instant"
            })
        }
        , 100)
    }
    mounted() {}
}
;
cc([em()], ui.prototype, "kungorelserubrikFaltet", 2);
cc([em()], ui.prototype, "underrubrikFaltet", 2);
cc([em()], ui.prototype, "lanFaltet", 2);
ui = cc([Ct({
    components: {
        Selectlist: Vn,
        Sokresultat: tc,
        BFormCheckboxGroup: uc,
        Meddelande: Ft,
        BFormSelect: yl,
        FormGroup: Na,
        BSpinner: er,
        IBiQuestionCircle: I4
    }
})], ui);
const j4 = Et(ui);
const kl = t => ($t("data-v-5a8736df"),
t = t(),
Tt(),
t)
  , U4 = {
    class: "page"
}
  , H4 = kl( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Sök kungörelse")])], -1))
  , K4 = {
    class: "sok bg-white py-3 px-3"
}
  , z4 = {
    class: "row align-items-start"
}
  , q4 = {
    class: "col-lg-3"
}
  , W4 = {
    class: "col-lg-4",
    style: {
        position: "relative"
    }
}
  , G4 = {
    tabindex: "0",
    class: "d-inline p2 me-4 hastooltip"
}
  , Y4 = {
    class: "col-lg-5"
}
  , J4 = {
    class: "row"
}
  , X4 = {
    key: 0,
    class: "col-md-6"
}
  , Q4 = {
    class: "row"
}
  , Z4 = {
    class: "col"
}
  , eF = {
    class: "col"
}
  , tF = {
    key: 0
}
  , nF = {
    class: "row"
}
  , rF = {
    class: "col-md-6"
}
  , aF = kl( () => c("option", {
    value: "",
    selected: ""
}, "Samtliga", -1))
  , sF = ["value"]
  , lF = {
    key: 0,
    class: "col-md-6"
}
  , iF = kl( () => c("option", {
    value: "",
    selected: ""
}, "Samtliga", -1))
  , oF = ["value"]
  , uF = {
    class: "row"
}
  , dF = {
    key: 0,
    class: "col-md-6"
}
  , cF = kl( () => c("option", {
    value: "",
    selected: ""
}, "Samtliga", -1))
  , fF = ["value"]
  , pF = {
    key: 1,
    class: "col-md-6"
}
  , hF = kl( () => c("option", {
    value: "",
    selected: ""
}, null, -1))
  , mF = ["value"]
  , vF = {
    class: "row"
}
  , gF = {
    class: "col-md-6"
}
  , bF = {
    class: "col-md-6"
}
  , yF = {
    class: "row"
}
  , kF = {
    class: "col-lg-12"
}
  , _F = kl( () => c("span", {
    class: "visually-hidden"
}, "Laddar ...", -1))
  , wF = {
    class: "d-flex justify-content-center"
}
  , xF = {
    class: "visa bg-white py-1 mb-4 rounded-bottom border-end border-start border-bottom"
}
  , SF = kl( () => c("h2", null, "Sökresultat", -1));
function $F(t, e, n, r, a, s) {
    const l = ue("b-form-select")
      , i = ue("form-group")
      , o = ue("i-bi-question-circle")
      , u = ue("b-form-input")
      , d = ue("b-spinner")
      , f = ue("b-button")
      , p = ue("meddelande")
      , h = ue("sokresultat")
      , v = ue("b-form")
      , y = X$("b-tooltip");
    return g(),
    _("div", U4, [H4, x(v, null, {
        default: N( () => [c("div", K4, [c("div", z4, [c("div", q4, [x(i, {
            labelFor: "tidsperiod",
            label: "Publiceringsdatum",
            invalidFeedback: t.tidsperiodFelmeddelande
        }, {
            default: N( () => [x(l, {
                id: "tidsperiod",
                selected: "",
                modelValue: t.valdTidsperiod,
                "onUpdate:modelValue": e[0] || (e[0] = k => t.valdTidsperiod = k),
                options: t.tidsperioder,
                "text-field": "namn",
                "value-field": "id",
                onOnChange: t.tidsperiodListChanged,
                state: t.tidsperiodGiltig()
            }, null, 8, ["modelValue", "options", "onOnChange", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"])]), c("div", W4, [x(i, {
            labelFor: "personOrgnummer",
            label: "Personnummer/organisationsnummer",
            invalidFeedback: "Felaktigt personnummer eller organisationsnummer."
        }, {
            default: N( () => [ft((g(),
            _("span", G4, [x(o, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "question circle",
                focusable: "false"
            })])), [[y, "Personnummer skrivs ÅÅÅÅMMDD-NNNN", void 0, {
                focus: !0,
                top: !0
            }]]), x(u, {
                type: "text",
                modelValue: t.personOrgnummer,
                "onUpdate:modelValue": e[1] || (e[1] = k => t.personOrgnummer = k),
                state: t.personOrgnummerGiltigt(),
                id: "personOrgnummer",
                onBlur: e[2] || (e[2] = k => t.onLeavePersonorgnummer()),
                onKeyup: e[3] || (e[3] = Xe(k => t.sokKungorelse(), ["enter"]))
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), c("div", Y4, [x(i, {
            labelFor: "namn",
            label: "Namn, företagsnamn eller fastighetsbeteckning",
            invalidFeedback: t.namnFelmeddelande
        }, {
            default: N( () => [x(u, {
                type: "text",
                id: "namn",
                modelValue: t.namn,
                "onUpdate:modelValue": e[4] || (e[4] = k => t.namn = k),
                state: t.namnGiltigt(),
                onKeyup: e[5] || (e[5] = Xe(k => t.sokKungorelse(), ["enter"]))
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"])])]), c("div", J4, [t.visaAnnanPeriod() ? (g(),
        _("div", X4, [c("div", Q4, [c("div", Z4, [x(i, {
            labelFor: "publiceringsdatum-from",
            label: "Från och med:",
            invalidFeedback: t.tidperiodFromFeltext
        }, {
            default: N( () => [x(u, {
                type: "date",
                modelValue: t.tidsperiodFrom,
                "onUpdate:modelValue": e[6] || (e[6] = k => t.tidsperiodFrom = k),
                id: "publiceringsdatum-from",
                min: t.dagensDatumMinusAr(6),
                state: t.tidsperiodFromGiltigt(),
                onKeyup: e[7] || (e[7] = Xe(k => t.sokKungorelse(), ["enter"]))
            }, null, 8, ["modelValue", "min", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"])]), c("div", eF, [x(i, {
            labelFor: "publiceringsdatum-tom",
            label: "Till och med:",
            invalidFeedback: t.tidperiodTomFeltext
        }, {
            default: N( () => [x(u, {
                type: "date",
                modelValue: t.tidsperiodTom,
                "onUpdate:modelValue": e[8] || (e[8] = k => t.tidsperiodTom = k),
                id: "publiceringsdatum-tom",
                max: t.dagensDatum(),
                state: t.tidsperiodTomGiltigt(),
                onKeyup: e[9] || (e[9] = Xe(k => t.sokKungorelse(), ["enter"]))
            }, null, 8, ["modelValue", "max", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"])])])])) : q("", !0)]), x(fa, {
            name: "slide"
        }, {
            default: N( () => [t.visaFler ? (g(),
            _("div", tF, [c("div", nF, [c("div", rF, [x(i, {
                labelFor: "amnesomrade",
                label: "Ämnesområde"
            }, {
                default: N( () => [ft(c("select", {
                    id: "amnesomrade",
                    class: "form-select",
                    "onUpdate:modelValue": e[10] || (e[10] = k => t.valtAmnesomrade = k),
                    onChange: e[11] || (e[11] = k => (t.setFokusKungorelserubrik(),
                    t.amnesomradeListChanged()))
                }, [aF, (g(!0),
                _(we, null, Ne(t.amnesomraden, k => (g(),
                _("option", {
                    key: k.id,
                    value: k
                }, Q(k.namn), 9, sF))), 128))], 544), [[Xn, t.valtAmnesomrade]])]),
                _: 1
            })]), Object.keys(t.valtAmnesomrade).length > 0 ? (g(),
            _("div", lF, [x(i, {
                labelFor: "kungorelserubrik",
                label: "Typ av kungörelse"
            }, {
                default: N( () => [ft(c("select", {
                    id: "kungorelserubrik",
                    class: "form-select",
                    "onUpdate:modelValue": e[12] || (e[12] = k => t.valdKungorelsetyp = k),
                    ref: "kungorelserubrikFaltet",
                    onChange: e[13] || (e[13] = k => t.setFokusUnderrubrik())
                }, [iF, (g(!0),
                _(we, null, Ne(t.valtAmnesomrade.kungorelserubriker, k => (g(),
                _("option", {
                    key: k.id,
                    value: k
                }, Q(k.namn), 9, oF))), 128))], 544), [[Xn, t.valdKungorelsetyp]])]),
                _: 1
            })])) : q("", !0)]), c("div", uF, [Object.keys(t.valtAmnesomrade).length > 0 && Object.keys(t.valdKungorelsetyp).length > 0 ? (g(),
            _("div", dF, [x(i, {
                labelFor: "underrubrik",
                label: "Typ av ärende"
            }, {
                default: N( () => [ft(c("select", {
                    id: "underrubrik",
                    class: "form-select",
                    "onUpdate:modelValue": e[14] || (e[14] = k => t.valdUnderrubrik = k),
                    ref: "underrubrikFaltet"
                }, [cF, (g(!0),
                _(we, null, Ne(t.valdKungorelsetyp.underrubriker, k => (g(),
                _("option", {
                    key: k.id,
                    value: k
                }, Q(k.namn), 9, fF))), 128))], 512), [[Xn, t.valdUnderrubrik]])]),
                _: 1
            })])) : q("", !0), Object.keys(t.valtAmnesomrade).length > 0 && Object.keys(t.valdKungorelsetyp).length > 0 && t.valdKungorelsetyp.lanRegel != "ejTillaten" ? (g(),
            _("div", pF, [x(i, {
                labelFor: "valdLan",
                label: "Län"
            }, {
                default: N( () => [ft(c("select", {
                    id: "valdLan",
                    class: "form-select",
                    "onUpdate:modelValue": e[15] || (e[15] = k => t.valdLan = k),
                    ref: "lanFaltet"
                }, [hF, (g(!0),
                _(we, null, Ne(t.laner, k => (g(),
                _("option", {
                    key: k.id,
                    value: k
                }, Q(k.namn), 9, mF))), 128))], 512), [[Xn, t.valdLan]])]),
                _: 1
            })])) : q("", !0)]), c("div", vF, [c("div", gF, [x(i, {
                labelFor: "kungorelseid",
                label: "Kungörelse-id",
                invalidFeedback: "Felaktigt kungörelse-id."
            }, {
                default: N( () => [x(u, {
                    modelValue: t.kungorelseid,
                    "onUpdate:modelValue": e[16] || (e[16] = k => t.kungorelseid = k),
                    state: t.kungorelseidGiltigt(),
                    id: "kungorelseid",
                    onKeyup: e[17] || (e[17] = Xe(k => t.sokKungorelse(), ["enter"]))
                }, null, 8, ["modelValue", "state"])]),
                _: 1
            })]), c("div", bF, [x(i, {
                labelFor: "sokord",
                label: "Sök i kungörelsetext",
                invalidFeedback: t.sokordFelmeddelande
            }, {
                default: N( () => [x(u, {
                    id: "sokord",
                    modelValue: t.sokord,
                    "onUpdate:modelValue": e[18] || (e[18] = k => t.sokord = k),
                    state: t.sokordGiltigt(),
                    onKeyup: e[19] || (e[19] = Xe(k => t.sokKungorelse(), ["enter"]))
                }, null, 8, ["modelValue", "state"])]),
                _: 1
            }, 8, ["invalidFeedback"])])])])) : q("", !0)]),
            _: 1
        }), c("div", yF, [c("div", kF, [x(i, null, {
            default: N( () => [x(f, {
                class: "blv-color",
                variant: t.disableSok() ? "secondary" : "primary",
                disabled: t.disableSok(),
                onClick: e[20] || (e[20] = k => t.sokKungorelse())
            }, {
                default: N( () => [ve("Sök kungörelse "), t.loading ? (g(),
                de(d, {
                    key: 0,
                    small: ""
                })) : q("", !0), _F]),
                _: 1
            }, 8, ["variant", "disabled"])]),
            _: 1
        })])]), t.visaMeddelande ? (g(),
        de(p, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)]), c("div", wF, [c("div", xF, [c("button", {
            type: "button",
            class: "btn btn-link",
            onClick: e[21] || (e[21] = k => t.toggleVisaFler())
        }, Q(t.visaFlerText), 1)])]), t.visaMeddelande ? q("", !0) : (g(),
        de(h, {
            key: 0,
            sokresultat: t.sokKungorelseResultat
        }, {
            default: N( () => [SF]),
            _: 1
        }, 8, ["sokresultat"]))]),
        _: 1
    })])
}
const TF = rt(j4, [["render", $F], ["__scopeId", "data-v-5a8736df"]])
  , CF = {}
  , EF = {
    lang: "sv",
    class: "page"
}
  , AF = Ci('<div class="row justify-content-md-center"><div class="col-md-8"><h1 id="sweden">Sidan finns inte (404)</h1><div lang="sv"><h2>Sidan du sökte kunde inte hittas</h2><p>Gå till startsidan för Post- och Inrikes Tidningar, PoIT <a href="/">via denna länk</a>.</p></div><div lang="en"><h2>The page you requested was not found</h2><p> Go to the English start page for The Official Swedish Gazette (Post- och Inrikes Tidningar, PoIT), <a href="/">thru this link</a>. </p></div></div></div>', 1)
  , MF = [AF];
function OF(t, e) {
    return g(),
    _("div", EF, MF)
}
const NF = rt(CF, [["render", OF]])
  , Sn = Lr("sokArsRedovisning", {
    state: () => ({
        sokArsResultat: [],
        sokArsInfoResultat: [],
        sokArsParametrar: {},
        antalTraffar: 0
    }),
    getters: {},
    actions: {
        async sokArsredovisning(t) {
            try {
                t.namn && (t.namn = t.namn.replaceAll("*", "")),
                (t.info == null || t.info == null || t.info == !1) && this.setSokArsParametrar(t),
                t.organisationsnummer && t.organisationsnummer != "" && (t.organisationsnummer = t.organisationsnummer.replaceAll("-", ""));
                const n = (await Pt.get("/rak-kng-dft-web/rest/kungorelse/sok", {
                    params: {
                        organisationsnummer: t.organisationsnummer,
                        namn: t.namn,
                        lankod: t.lankod,
                        reg_datum: t.reg_datum,
                        info: t.info,
                        sidStorlek: t.sidStorlek,
                        startTraff: t.startTraff
                    }
                })).data;
                if (n.felkod) {
                    if ((t.info == null || t.info == null || t.info == !1) && this.resetSokArsResultatLista(),
                    n.felkod == 2)
                        return "Sökningen gav för många träffar.";
                    if (n.felkod == 1)
                        return "Felaktiga sökparametrar.";
                    throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
                }
                return n.sokresultat.antalTraffar == 0 ? "Sökningen gav ingen träff." : (t.info == null || t.info == null || t.info == !1 ? (this.setSokArsResultatLista(n.sokresultat.kungorelser),
                this.setAntalTraffar(n.sokresultat.antalTraffar)) : this.setSokArsInfoResultatLista(n.sokresultat.kungorelser),
                "")
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        resetSokArsHistorik() {
            this.resetSokArsResultatLista(),
            this.resetSokArsParametrar(),
            this.resetAntalTraffar()
        },
        resetSokArsResultatInfoLista() {
            this.resetSokArsInfoResultatLista()
        },
        async antalNyaArs() {
            try {
                const e = (await Pt.get("/rak-kng-dft-web/rest/kungorelse/antalnya", {})).data;
                return e.felkod ? 0 : e.sokresultat.antalTraffar
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        async hamtaNyaArs() {
            try {
                const e = (await Pt.get("/rak-kng-dft-web/rest/kungorelse/hamtanya", {})).data;
                if (e.felkod)
                    throw "Tekniskt fel hos Bolagsverket. Försök igen senare.";
                return e.sokresultat.antalTraffar == 0 ? [] : e.sokresultat.kungorelser
            } catch {
                throw "Tekniskt fel hos Bolagsverket. Försök igen senare."
            }
        },
        setSokArsResultatLista(t) {
            this.sokArsResultat = t
        },
        resetSokArsResultatLista() {
            this.sokArsResultat = []
        },
        setSokArsParametrar(t) {
            this.sokArsParametrar = t
        },
        resetSokArsParametrar() {
            this.sokArsParametrar = {}
        },
        setSokArsInfoResultatLista(t) {
            this.sokArsInfoResultat = t
        },
        resetSokArsInfoResultatLista() {
            this.sokArsInfoResultat = []
        },
        setAntalTraffar(t) {
            this.antalTraffar = t
        },
        resetAntalTraffar() {
            this.antalTraffar = 0
        }
    }
})
  , DF = Se({
    name: "sokarsresultat",
    props: {
        sokArsResultat: {
            type: Array
        },
        antalTraffar: {
            type: Number,
            default: 0
        }
    },
    components: {
        IBiArrowRightCircle: Dk
    },
    data: function() {
        return {
            sorteringsalternativ: [{
                namn: "Företagsnamn",
                id: "firmaNamn",
                sorteringsordning: "asc"
            }, {
                namn: "Län",
                id: "lanNamn",
                sorteringsordning: "desc"
            }, {
                namn: "Registrerad",
                id: "registreringsdatum",
                sorteringsordning: "desc"
            }]
        }
    },
    methods: {
        sortera: function(t, e) {
            var n = Sn().sokArsResultat;
            n && n.sort( (r, a) => r[t] > a[t] ? 1 : -1)
        },
        fixLink: function(t) {
            return t.replaceAll("/", "-")
        },
        isOrgnummerGiltigt: function(t) {
            return t.length != 10 && t.length != 11 || t.charCodeAt(2) < 50 ? !1 : Ht(t)
        },
        formateraOrgnummer: function(t) {
            return qn(t)
        }
    }
});
const Dm = t => ($t("data-v-b820b86f"),
t = t(),
Tt(),
t)
  , PF = {
    key: 0
}
  , FF = {
    class: "row mt-3 mb-0"
}
  , BF = {
    class: "col-12 col-md-3 align-self-center mx-auto mx-md-0"
}
  , VF = {
    class: "col-12 col-md-9 d-flex flex-wrap justify-content-md-end align-self-center mx-auto mx-md-0 table__actions"
}
  , IF = {
    key: 0
}
  , RF = Dm( () => c("span", {
    class: "btn btn-link-disabled"
}, "Sortera på:", -1))
  , LF = ["title", "onClick"]
  , jF = {
    class: "row mt-1"
}
  , UF = {
    class: "col"
}
  , HF = {
    class: "table-responsive"
}
  , KF = {
    class: "table table-hover table-striped table-bv",
    id: "sokArsresultat"
}
  , zF = Dm( () => c("caption", {
    class: "visually-hidden"
}, " Sökresultat, årsredovisningar ", -1))
  , qF = Dm( () => c("thead", {
    class: "blv-thead"
}, [c("tr", null, [c("th", null, "Företagsnamn"), c("th", null, "Organisationsnummer"), c("th", null, "Län"), c("th", null, "Registrerad"), c("th", {
    class: "text-center"
}, "Visa")])], -1))
  , WF = {
    class: "align-middle"
}
  , GF = {
    class: "align-middle"
}
  , YF = {
    class: "align-middle text-nowrap"
}
  , JF = {
    class: "align-middle text-nowrap"
}
  , XF = {
    class: "align-middle text-center"
};
function QF(t, e, n, r, a, s) {
    const l = ue("router-link")
      , i = ue("i-bi-arrow-right-circle");
    return g(),
    _("div", null, [t.sokArsResultat && t.sokArsResultat.length > 0 ? (g(),
    _("div", PF, [Z(t.$slots, "default", {}, void 0, !0), c("div", FF, [c("div", BF, [c("span", null, [ve(" Antal träffar: "), c("strong", null, Q(t.antalTraffar), 1)])]), c("div", VF, [t.antalTraffar < 1e3 ? (g(),
    _("div", IF, [RF, (g(!0),
    _(we, null, Ne(t.sorteringsalternativ, o => (g(),
    _("button", {
        key: o.id,
        type: "button",
        title: "Sortera på " + o.namn,
        class: "btn btn-link",
        onClick: u => t.sortera(o.id, o.sorteringsordning)
    }, Q(o.namn), 9, LF))), 128))])) : q("", !0)])]), c("div", jF, [c("div", UF, [c("div", HF, [c("table", KF, [zF, qF, c("tbody", null, [(g(!0),
    _(we, null, Ne(t.sokArsResultat, o => (g(),
    _("tr", {
        key: o.id
    }, [c("td", WF, [x(l, {
        title: "Visa kungörelse",
        class: "kungorelse__link",
        to: {
            name: "arsredovisning",
            params: {
                orgnummer: o.organisationsnummer
            }
        }
    }, {
        default: N( () => [ve(Q(o.firmaNamn), 1)]),
        _: 2
    }, 1032, ["to"])]), c("td", GF, Q(o.organisationsnummer != "" ? t.formateraOrgnummer(o.organisationsnummer) : "–"), 1), c("td", YF, Q(o.lanNamn), 1), c("td", JF, Q(o.registreringsdatum), 1), c("td", XF, [x(l, {
        class: "btn btn-link rounded-circle square-40",
        title: "Visa kungörelse",
        to: {
            name: "arsredovisning",
            params: {
                orgnummer: o.organisationsnummer
            }
        }
    }, {
        default: N( () => [x(i, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "arrow right circle",
            focusable: "false"
        })]),
        _: 2
    }, 1032, ["to"])])]))), 128))])])])])])])) : q("", !0)])
}
const cw = rt(DF, [["render", QF], ["__scopeId", "data-v-b820b86f"]]);
var ZF = Object.defineProperty
  , eB = Object.getOwnPropertyDescriptor
  , tB = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? eB(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && ZF(e, n, a),
    a
}
;
let Pp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "arList", [""]);
        V(this, "valdAr", "");
        V(this, "manadList", [{
            namn: "",
            nr: ""
        }, {
            namn: "Januari",
            nr: "01"
        }, {
            namn: "Februari",
            nr: "02"
        }, {
            namn: "Mars",
            nr: "03"
        }, {
            namn: "April",
            nr: "04"
        }, {
            namn: "Maj",
            nr: "05"
        }, {
            namn: "Juni",
            nr: "06"
        }, {
            namn: "Juli",
            nr: "07"
        }, {
            namn: "Augusti",
            nr: "08"
        }, {
            namn: "September",
            nr: "09"
        }, {
            namn: "Oktober",
            nr: "10"
        }, {
            namn: "November",
            nr: "11"
        }, {
            namn: "December",
            nr: "12"
        }]);
        V(this, "valdManad", "");
        V(this, "namnNummer", "");
        V(this, "lanList", [{
            namn: "",
            kod: "",
            aktive: !0
        }]);
        V(this, "valdLan", "");
        V(this, "loading", !1);
        V(this, "sidNr", 1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "sidStorlek", 1e3);
        V(this, "startTraff", 0)
    }
    get laner() {
        return St().laner
    }
    get sokArsResultat() {
        return Sn().sokArsResultat
    }
    get antalTraffar() {
        return Sn().antalTraffar
    }
    sokKungorelse() {
        this.sidNr = 1,
        this.loading = !0,
        this.meddelande = "",
        Sn().resetSokArsResultatLista();
        var e = {};
        this.namnNummer && this.namnNummer != "" && (this.isOrgnummerGiltigt(this.namnNummer) ? e.organisationsnummer = this.namnNummer : e.namn = this.namnNummer),
        this.valdLan && this.valdLan != "" && (e.lankod = this.valdLan),
        !e.organisationsnummer && !e.namn && this.valdAr != "" && this.valdManad != "" && (e.reg_datum = this.valdAr + "-" + this.valdManad,
        e.sidStorlek = this.sidStorlek,
        e.startTraff = this.startTraff),
        Sn().sokArsredovisning(e).then(n => {
            this.loading = !1,
            this.meddelande = n,
            this.meddelandeTyp = "info"
        }
        ).catch(n => {
            this.loading = !1,
            this.meddelande = n,
            this.meddelandeTyp = "danger"
        }
        )
    }
    nastaKungorelser() {
        this.startTraff + this.sidStorlek < Sn().antalTraffar && (this.startTraff = this.startTraff + this.sidStorlek,
        this.sokKungorelse())
    }
    foregaendeKungorelser() {
        this.startTraff > 0 && (this.startTraff = this.startTraff - this.sidStorlek,
        this.sokKungorelse())
    }
    disabledForegaende() {
        return this.startTraff == 0
    }
    disabledNasta() {
        return this.startTraff + this.sidStorlek > Sn().antalTraffar
    }
    slutTraff() {
        return this.startTraff + this.sidStorlek > Sn().antalTraffar ? Sn().antalTraffar : this.startTraff + this.sidStorlek
    }
    disableSok() {
        return this.namnNummer != "" && this.valdAr != "" ? !0 : !(this.namnNummer.length > 2 || this.valdLan != "" && this.valdAr != "" && this.valdManad != "")
    }
    stateNamn() {
        return this.valdLan != "" && this.valdAr == "" && this.namnNummer == "" ? !1 : this.namnNummer == "" ? null : this.namnNummer.length > 2
    }
    disableNamn() {
        return this.valdAr != "" ? (this.namnNummer = "",
        !0) : !1
    }
    stateLan() {
        return (this.valdAr != "" || this.valdManad != "") && this.valdLan == "" ? !1 : this.valdManad != "" && this.valdAr != "" && this.valdLan != "" || this.stateNamn() && !this.isOrgnummerGiltigt(this.namnNummer) && this.valdLan != "" ? !0 : null
    }
    disableLan() {
        return this.isOrgnummerGiltigt(this.namnNummer) ? (this.valdLan = "",
        !0) : !1
    }
    stateAr() {
        return this.valdAr == "" && this.valdManad != "" || this.valdLan != "" && this.valdAr == "" && this.namnNummer == "" ? !1 : this.valdManad != "" && this.valdAr != "" && this.valdLan != "" ? !0 : null
    }
    disableAr() {
        return this.namnNummer != "" ? (this.valdManad = "",
        this.valdAr = "",
        !0) : !1
    }
    stateManad() {
        return this.valdAr != "" && this.valdManad == "" ? !1 : this.valdManad != "" && this.valdAr != "" && this.valdLan != "" ? !0 : null
    }
    disableManad() {
        return this.namnNummer != "" ? (this.valdManad = "",
        this.valdAr = "",
        !0) : this.valdAr == ""
    }
    clear() {
        this.namnNummer = "",
        this.valdLan = "",
        this.valdAr = "",
        this.valdManad = "";
        const e = Sn();
        e.sokArsParametrar = {},
        e.sokArsResultat = [],
        e.antalTraffar = 0,
        this.startTraff = 0
    }
    clearStartTraff() {
        this.startTraff = 0;
        const e = Sn();
        e.sokArsResultat = [],
        e.antalTraffar = 0
    }
    isOrgnummerGiltigt(e) {
        return e.length != 10 && e.length != 11 || e.charCodeAt(2) < 50 ? !1 : Ht(e)
    }
    formateraOrgnummer(e) {
        return qn(e)
    }
    created() {
        St().getLan().then( () => {
            this.lanList = this.lanList.concat(St().laner);
            var n = Sn().sokArsParametrar;
            if (n) {
                n.namn && (this.namnNummer += n.namn),
                n.organisationsnummer && (this.namnNummer += n.organisationsnummer);
                var r = this.lanList.find(a => a.kod == n.lankod);
                r && (this.valdLan = r.kod),
                n.reg_datum && (this.valdAr = n.reg_datum.substr(0, 4),
                this.valdManad = n.reg_datum.substr(5, 7))
            }
            setTimeout( () => {
                this.$route.meta.savedPosition && window.scrollTo({
                    ...this.$route.meta.savedPosition,
                    behavior: "instant"
                })
            }
            , 100)
        }
        );
        var e = new Date;
        this.arList.push((e.getFullYear() - 2).toString()),
        this.arList.push((e.getFullYear() - 1).toString()),
        this.arList.push(e.getFullYear().toString())
    }
}
;
Pp = tB([Ct({
    components: {
        Selectlist: Vn,
        BFormCheckboxGroup: uc,
        Meddelande: Ft,
        BFormSelect: yl,
        FormGroup: Na,
        BSpinner: er,
        Sokarsresultat: cw
    }
})], Pp);
const nB = Et(Pp);
const fw = t => ($t("data-v-85c08d03"),
t = t(),
Tt(),
t)
  , rB = {
    class: "page"
}
  , aB = fw( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Sök kungörelse av årsredovisning")])], -1))
  , sB = {
    class: "sok bg-white arsredovisningar py-3 px-3"
}
  , lB = {
    class: "row align-items-start"
}
  , iB = {
    class: "col-lg-5"
}
  , oB = {
    class: "col-lg-3"
}
  , uB = {
    class: "col-lg-2"
}
  , dB = {
    class: "col-lg-2"
}
  , cB = {
    class: "row"
}
  , fB = {
    class: "col-lg-6"
}
  , pB = fw( () => c("span", {
    class: "visually-hidden"
}, "Laddar ...", -1))
  , hB = {
    class: "mt-2 row d-flex"
}
  , mB = {
    class: "col align-self-center"
}
  , vB = {
    key: 0,
    class: "pt-2"
}
  , gB = {
    class: "col text-end align-self-center"
}
  , bB = {
    key: 0
}
  , yB = {
    key: 1
}
  , kB = {
    class: "mt-2 row d-flex"
}
  , _B = {
    class: "col align-self-center"
}
  , wB = {
    key: 0,
    class: "pt-2"
}
  , xB = {
    class: "col text-end align-self-center"
}
  , SB = {
    key: 0
};
function $B(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("form-group")
      , o = ue("b-form-select")
      , u = ue("b-spinner")
      , d = ue("b-button")
      , f = ue("meddelande")
      , p = ue("sokarsresultat")
      , h = ue("b-form");
    return g(),
    _("div", rB, [aB, x(h, {
        onKeyup: e[14] || (e[14] = Xe(v => t.sokKungorelse(), ["enter"])),
        onSubmit: e[15] || (e[15] = _t( () => {}
        , ["prevent"]))
    }, {
        default: N( () => [c("div", sB, [c("div", lB, [c("div", iB, [x(i, {
            labelFor: "namnNummer",
            label: "Företagsnamn/organisationsnummer",
            invalidFeedback: "Ange minst tre tecken eller lämna fältet tomt"
        }, {
            default: N( () => [x(l, {
                type: "text",
                modelValue: t.namnNummer,
                "onUpdate:modelValue": e[0] || (e[0] = v => t.namnNummer = v),
                id: "namnNummer",
                onKeyup: e[1] || (e[1] = Xe(v => t.sokKungorelse(), ["enter"])),
                state: t.stateNamn(),
                disabled: t.disableNamn()
            }, null, 8, ["modelValue", "state", "disabled"])]),
            _: 1
        })]), c("div", oB, [x(i, {
            labelFor: "lan",
            label: "Län",
            invalidFeedback: "Välj län"
        }, {
            default: N( () => [x(o, {
                id: "lan",
                selected: "",
                modelValue: t.valdLan,
                "onUpdate:modelValue": e[2] || (e[2] = v => t.valdLan = v),
                options: t.lanList,
                "text-field": "namn",
                "value-field": "kod",
                state: t.stateLan(),
                disabled: t.disableLan(),
                onChange: e[3] || (e[3] = v => t.clearStartTraff())
            }, null, 8, ["modelValue", "options", "state", "disabled"])]),
            _: 1
        })]), c("div", uB, [x(i, {
            labelFor: "valdAr",
            label: "År",
            invalidFeedback: "Välj år eller lämna fältet tomt"
        }, {
            default: N( () => [x(o, {
                id: "valdAr",
                selected: "",
                modelValue: t.valdAr,
                "onUpdate:modelValue": e[4] || (e[4] = v => t.valdAr = v),
                options: t.arList,
                state: t.stateAr(),
                disabled: t.disableAr(),
                onChange: e[5] || (e[5] = v => t.clearStartTraff())
            }, null, 8, ["modelValue", "options", "state", "disabled"])]),
            _: 1
        })]), c("div", dB, [x(i, {
            labelFor: "valdManad",
            label: "Månad",
            invalidFeedback: "Välj månad"
        }, {
            default: N( () => [x(o, {
                id: "valdManad",
                selected: "",
                modelValue: t.valdManad,
                "onUpdate:modelValue": e[6] || (e[6] = v => t.valdManad = v),
                options: t.manadList,
                state: t.stateManad(),
                disabled: t.disableManad(),
                "text-field": "namn",
                "value-field": "nr",
                onChange: e[7] || (e[7] = v => t.clearStartTraff())
            }, null, 8, ["modelValue", "options", "state", "disabled"])]),
            _: 1
        })])]), c("div", cB, [c("div", fB, [x(i, null, {
            default: N( () => [x(d, {
                class: "blv-color",
                variant: "primary",
                disabled: t.disableSok(),
                onClick: e[8] || (e[8] = v => t.sokKungorelse())
            }, {
                default: N( () => [ve("Sök kungörelse "), t.loading ? (g(),
                de(u, {
                    key: 0,
                    small: ""
                })) : q("", !0), pB]),
                _: 1
            }, 8, ["disabled"]), x(d, {
                class: "ms-2",
                variant: "link",
                onClick: e[9] || (e[9] = v => t.clear())
            }, {
                default: N( () => [ve(" Ny sökning ")]),
                _: 1
            })]),
            _: 1
        })])])]), t.meddelande != "" ? (g(),
        de(f, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0), c("div", hB, [c("div", mB, [t.antalTraffar > 1e3 ? (g(),
        _("span", vB, [ve(" Visar: "), c("strong", null, Q(t.startTraff + 1) + " – " + Q(t.slutTraff()), 1)])) : q("", !0)]), c("div", gB, [t.antalTraffar > 1e3 ? (g(),
        _("span", bB, [t.disabledForegaende() ? q("", !0) : (g(),
        de(d, {
            key: 0,
            variant: "link",
            onClick: e[10] || (e[10] = v => t.foregaendeKungorelser())
        }, {
            default: N( () => [ve("« Föregående")]),
            _: 1
        })), t.disabledNasta() ? q("", !0) : (g(),
        de(d, {
            key: 1,
            class: "btn btn-link",
            variant: "link",
            onClick: e[11] || (e[11] = v => t.nastaKungorelser())
        }, {
            default: N( () => [ve("Nästa » ")]),
            _: 1
        }))])) : q("", !0)])]), t.meddelande == "" ? (g(),
        _("div", yB, [x(p, {
            sokArsResultat: t.sokArsResultat,
            antalTraffar: t.antalTraffar
        }, null, 8, ["sokArsResultat", "antalTraffar"])])) : q("", !0), c("div", kB, [c("div", _B, [t.antalTraffar > 1e3 ? (g(),
        _("span", wB, [ve(" Visar: "), c("strong", null, Q(t.startTraff + 1) + " – " + Q(t.slutTraff()), 1)])) : q("", !0)]), c("div", xB, [t.antalTraffar > 1e3 ? (g(),
        _("span", SB, [t.disabledForegaende() ? q("", !0) : (g(),
        de(d, {
            key: 0,
            variant: "link",
            onClick: e[12] || (e[12] = v => t.foregaendeKungorelser())
        }, {
            default: N( () => [ve("« Föregående")]),
            _: 1
        })), t.disabledNasta() ? q("", !0) : (g(),
        de(d, {
            key: 1,
            variant: "link",
            onClick: e[13] || (e[13] = v => t.nastaKungorelser())
        }, {
            default: N( () => [ve("Nästa » ")]),
            _: 1
        }))])) : q("", !0)])])]),
        _: 1
    })])
}
const TB = rt(nB, [["render", $B], ["__scopeId", "data-v-85c08d03"]])
  , ad = {
    debug(...t) {},
    info(...t) {},
    error(...t) {}
}
  , Ii = t => Pt.create({
    baseURL: "/poit/rest/",
    headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
    }
})
  , io = {
    listaAmnesomraden(t, e) {
        return Ii().get("ListaAmnesomraden")
    },
    hamtaSenastePubliceringar(t, e) {
        return Ii().get("HamtaSenastePubliceringar")
    },
    hamtaInfotexter(t, e) {
        return Ii().get("HamtaInfotexter")
    },
    hamtaDriftstorning(t, e) {
        return Ii().get("HamtaDriftstorning")
    },
    hamtaInformation(t, e) {
        return Ii().get("HamtaInformation")
    }
}
  , oo = Lr("home", {
    state: () => ({
        amnesomradenLoaded: !1,
        senastePubliseringarLoaded: !1,
        infotexterLoaded: !1,
        amnesomradenError: !1,
        senastePubliseringarError: !1,
        infotexterError: !1,
        amnesomraden: [],
        senastePubliseringar: [],
        infotexter: []
    }),
    getters: {
        gList: t => e => {
            const n = new Set(e)
              , r = [];
            let a = [];
            for (const s in t.amnesomraden)
                if (n.has(t.amnesomraden[s].id)) {
                    const l = {};
                    l.id = t.amnesomraden[s].id,
                    l.namn = t.amnesomraden[s].namn,
                    l.antal = 0;
                    for (const o in t.senastePubliseringar.amnesomraden) {
                        const u = t.senastePubliseringar.amnesomraden[o];
                        l.id === u.id && (l.antal = u.antal)
                    }
                    const i = [];
                    for (const o in t.amnesomraden[s].kungorelserubriker) {
                        const u = t.amnesomraden[s].kungorelserubriker[o]
                          , d = {};
                        d.id = u.id,
                        d.namn = u.namn,
                        d.antal = 0;
                        for (const f in t.senastePubliseringar.amnesomraden) {
                            const p = t.senastePubliseringar.amnesomraden[f];
                            if (l.id === p.id)
                                for (const h in p.kungorelsetyper) {
                                    const v = p.kungorelsetyper[h];
                                    d.id === v.id && (d.antal = v.antal)
                                }
                        }
                        i.push(d)
                    }
                    l.kungorelserubriker = [...i],
                    r.push(l)
                }
            return a = [...r],
            a
        }
        ,
        gLoaded: t => !!(t.amnesomradenLoaded && t.senastePubliseringarLoaded),
        gError: t => !!(t.amnesomradenError && t.senastePubliseringarError),
        gPubliseringsdatum: t => t.senastePubliseringar.publiceringsdatum,
        gInfotexter: t => t.infotexter,
        gGrid: t => e => e + 12 / t.infotexter.length
    },
    actions: {
        aInitHomeStoreModule() {
            this.aLoadAmnesomraden(),
            this.aLoadSenastePubliseringar(),
            this.aLoadInfotexter()
        },
        aLoadAmnesomraden() {
            const t = {}
              , e = {};
            io.listaAmnesomraden(t, e).then(n => {
                this.mAmnesomradenResult(n.data)
            }
            , n => {
                this.mAmnesomradenError()
            }
            )
        },
        aLoadSenastePubliseringar() {
            const t = {}
              , e = {};
            io.hamtaSenastePubliceringar(t, e).then(n => {
                this.mSenastePubliseringarResult(n.data)
            }
            , n => {
                this.mSenastePubliseringarError()
            }
            )
        },
        aLoadInfotexter() {
            const t = {}
              , e = {};
            io.hamtaInfotexter(t, e).then(n => {
                this.mInfotexterResult(n.data)
            }
            , n => {
                this.mInfotexterError()
            }
            )
        },
        mInit() {
            this.amnesomradenLoaded = !1,
            this.senastePubliseringarLoaded = !1,
            this.infotexterLoaded = !1,
            this.amnesomradenError = !1,
            this.senastePubliseringarError = !1,
            this.infotexterError = !1,
            this.amnesomraden = [],
            this.senastePubliseringar = [],
            this.infotexter = []
        },
        mAmnesomradenResult(t) {
            this.amnesomraden = t,
            this.amnesomradenLoaded = !0
        },
        mAmnesomradenError() {
            this.amnesomradenError = !0,
            this.amnesomradenLoaded = !0
        },
        mSenastePubliseringarResult(t) {
            this.senastePubliseringar = t,
            this.senastePubliseringarLoaded = !0
        },
        mSenastePubliseringarError() {
            this.senastePubliseringarError = !0,
            this.senastePubliseringarLoaded = !0
        },
        mInfotexterResult(t) {
            this.infotexter = t,
            this.infotexterLoaded = !0
        },
        mInfotexterError() {
            this.infotexterError = !0,
            this.infotexterLoaded = !0
        }
    }
})
  , Wb = Lr("driftstorning", {
    state: () => ({
        driftstorningLoaded: !1,
        driftstorningError: !1,
        driftstorning: null
    }),
    getters: {
        gAnyDriftstorning: t => !!(t.driftstorning.rubrik && t.driftstorning.text)
    },
    actions: {
        aInitDriftstorningStoreModule() {
            this.mInitStore(),
            this.aLoadDriftstorning()
        },
        aLoadDriftstorning() {
            const t = {}
              , e = {};
            io.hamtaDriftstorning(t, e).then(n => {
                ad.debug(JSON.stringify(n.data)),
                this.mDriftstorningResult(n.data)
            }
            , n => {
                ad.error(JSON.stringify(n)),
                this.mDriftstorningError()
            }
            )
        },
        mInitStore() {
            this.driftstorningLoaded = !1,
            this.driftstorningError = !1,
            this.driftstorning = null
        },
        mDriftstorningResult(t) {
            this.driftstorning = t,
            this.driftstorningLoaded = !0
        },
        mDriftstorningError() {
            this.driftstorningLoaded = !0,
            this.driftstorningError = !0
        }
    }
})
  , Gb = Lr("information", {
    state: () => ({
        informationLoaded: !1,
        informationError: !1,
        information: null
    }),
    getters: {
        gAnyInformation: t => !!(t.information.rubrik && t.information.text)
    },
    actions: {
        aInitInformationStoreModule() {
            this.mInitStore(),
            this.aLoadInformation()
        },
        aLoadInformation() {
            const t = {}
              , e = {};
            io.hamtaInformation(t, e).then(n => {
                ad.debug(JSON.stringify(n.data)),
                this.mInformationResult(n.data)
            }
            , n => {
                ad.error(JSON.stringify(n)),
                this.mInformationError()
            }
            )
        },
        mInitStore() {
            this.informationLoaded = !1,
            this.informationError = !1,
            this.information = null
        },
        mInformationResult(t) {
            this.information = t,
            this.informationLoaded = !0
        },
        mInformationError() {
            this.informationLoaded = !0,
            this.informationError = !0
        }
    }
})
  , CB = Se({
    name: "Home",
    components: {
        BSpinner: er,
        IBiExclamationCircleFill: Pk
    },
    created() {
        this.init(),
        Pe().startsida = !0
    },
    methods: {
        ...uf(oo, ["aInitHomeStoreModule"]),
        ...uf(Wb, ["aInitDriftstorningStoreModule"]),
        ...uf(Gb, ["aInitInformationStoreModule"]),
        init() {
            this.aInitHomeStoreModule(),
            this.aInitDriftstorningStoreModule(),
            this.aInitInformationStoreModule(),
            this.laddaArsredovisningar()
        },
        laddaArsredovisningar() {},
        async autologin() {
            var t = {
                email: "shibboleth",
                losenordsHash: "shibboleth"
            }
              , e = await dt().loggaIn(t);
            return e == "INVALID_REDIRECT_TOKEN" ? (console.log("INVALID_REDIRECT_TOKEN"),
            !1) : !0
        }
    },
    data: function() {
        return {
            nrNyaArsredovisningar: 0
        }
    },
    computed: {
        ...of(oo, ["gList", "gLoaded", "gPubliseringsdatum", "gInfotexter", "gGrid", "infotexterLoaded"]),
        ...of(Wb, ["gAnyDriftstorning", "driftstorning", "driftstorningLoaded", "driftstorningError"]),
        ...of(Gb, ["gAnyInformation", "information", "informationLoaded", "informationError"]),
        bolagsverketsRegistreringar() {
            return this.gList([2])
        },
        kallelser() {
            return this.gList([1])
        },
        konkurser() {
            return this.gList([3])
        },
        skuldsaneringar() {
            return this.gList([5])
        },
        sanktionsbeslut() {
            return this.gList([9])
        },
        familjeratt() {
            return this.gList([4])
        },
        grid() {
            return this.gGrid("col-md-")
        }
    }
});
const pw = t => ($t("data-v-9fd27f0d"),
t = t(),
Tt(),
t)
  , EB = {
    class: "row"
}
  , AB = {
    class: "col col-12"
}
  , MB = pw( () => c("h1", {
    class: "py-3"
}, "Välkommen till Post- och Inrikes Tidningar", -1))
  , OB = {
    key: 0,
    class: "alert blv-alert-danger",
    role: "alert",
    "aria-live": "polite",
    "aria-describedby": "driftmessage"
}
  , NB = {
    class: "d-flex"
}
  , DB = {
    class: "align-self-center text-center ms-3 me-3"
}
  , PB = {
    class: "align-self-center mx-3 mx-md-0"
}
  , FB = ["innerHTML"]
  , BB = ["innerHTML"]
  , VB = {
    key: 1,
    class: "alert blv-alert-info",
    role: "alert",
    "aria-live": "polite",
    "aria-describedby": "infomessage"
}
  , IB = {
    class: "d-flex"
}
  , RB = {
    class: "align-self-center text-center ms-3 me-3"
}
  , LB = {
    class: "align-self-center mx-3 mx-md-0"
}
  , jB = ["innerHTML"]
  , UB = ["innerHTML"]
  , HB = {
    class: "kungorelser bg-white px-3"
}
  , KB = {
    key: 0,
    class: "row"
}
  , zB = {
    class: "kungorelser__heading p-3"
}
  , qB = {
    class: "kungorelser__items col-12 col-md-6 col-lg-3 py-2"
}
  , WB = {
    class: "dotted-div"
}
  , GB = {
    class: "bold bg-white pe-1"
}
  , YB = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , JB = {
    key: 0
}
  , XB = {
    class: "dotted-div"
}
  , QB = {
    class: "bg-white pe-1"
}
  , ZB = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , e3 = {
    class: "kungorelser__items col-12 col-md-6 col-lg-3 py-2"
}
  , t3 = {
    class: "dotted-div"
}
  , n3 = {
    class: "bold bg-white pe-1"
}
  , r3 = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , a3 = {
    key: 0
}
  , s3 = {
    class: "dotted-div"
}
  , l3 = {
    class: "bg-white pe-1"
}
  , i3 = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , o3 = {
    class: "kungorelser__items col-12 col-md-6 col-lg-3 py-2"
}
  , u3 = {
    class: "dotted-div"
}
  , d3 = {
    class: "bold bg-white pe-1"
}
  , c3 = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , f3 = {
    key: 0
}
  , p3 = {
    class: "dotted-div"
}
  , h3 = {
    class: "bg-white pe-1"
}
  , m3 = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , v3 = {
    class: "dotted-div"
}
  , g3 = {
    class: "bold bg-white pe-1"
}
  , b3 = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , y3 = {
    key: 0
}
  , k3 = {
    class: "dotted-div"
}
  , _3 = {
    class: "bg-white pe-1"
}
  , w3 = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , x3 = {
    class: "dotted-div"
}
  , S3 = {
    class: "bold bg-white pe-1"
}
  , $3 = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , T3 = {
    key: 0
}
  , C3 = {
    class: "dotted-div"
}
  , E3 = {
    class: "bg-white pe-1"
}
  , A3 = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , M3 = {
    class: "kungorelser__items col-12 col-md-6 col-lg-3 py-2"
}
  , O3 = {
    class: "dotted-div"
}
  , N3 = {
    class: "bold bg-white pe-1"
}
  , D3 = {
    class: "badge bold badge-custom-bv blv-pos-t-1 pull-right"
}
  , P3 = {
    key: 0
}
  , F3 = {
    class: "dotted-div"
}
  , B3 = {
    class: "bg-white pe-1"
}
  , V3 = {
    class: "badge badge-custom-bv blv-pos-t-1 pull-right"
}
  , I3 = {
    key: 1,
    class: "row"
}
  , R3 = {
    class: "kungorelser__heading p-3"
}
  , L3 = {
    class: "col-12 py-5 d-flex justify-content-center mb-3"
}
  , j3 = pw( () => c("span", {
    class: "visually-hidden"
}, "Laddar ...", -1))
  , U3 = {
    key: 2,
    class: "row row-eq-heigh"
}
  , H3 = {
    class: "infobox"
}
  , K3 = {
    class: "infobox__heading"
}
  , z3 = ["innerHTML"];
function q3(t, e, n, r, a, s) {
    var u, d, f, p;
    const l = ue("i-bi-exclamation-circle-fill")
      , i = ue("router-link")
      , o = ue("b-spinner");
    return g(),
    _("div", EB, [c("div", AB, [MB, t.driftstorningLoaded && t.gAnyDriftstorning && !t.driftstorningError ? (g(),
    _("div", OB, [c("div", NB, [c("div", DB, [x(l, {
        role: "img",
        title: "",
        class: "blv-color-danger x2 me-2 b-icon bi",
        "aria-label": "exclamation circle fill",
        focusable: "false"
    })]), c("div", PB, [c("div", {
        class: "blv-t-bold",
        innerHTML: (u = t.driftstorning) == null ? void 0 : u.rubrik
    }, null, 8, FB), c("div", {
        id: "driftmessage",
        innerHTML: (d = t.driftstorning) == null ? void 0 : d.text
    }, null, 8, BB)])])])) : q("", !0), t.informationLoaded && t.gAnyInformation && !t.informationError ? (g(),
    _("div", VB, [c("div", IB, [c("div", RB, [x(l, {
        role: "img",
        title: "",
        class: "blv-color-info-light x2 me-2 b-icon bi",
        "aria-label": "exclamation circle fill",
        focusable: "false"
    })]), c("div", LB, [c("div", {
        class: "blv-t-bold",
        innerHTML: (f = t.information) == null ? void 0 : f.rubrik
    }, null, 8, jB), c("div", {
        id: "infomessage",
        innerHTML: (p = t.information) == null ? void 0 : p.text
    }, null, 8, UB)])])])) : q("", !0), c("div", HB, [t.gLoaded ? (g(),
    _("div", KB, [c("h2", zB, "Urval av kungörelser " + Q(t.gPubliseringsdatum), 1), c("div", qB, [(g(!0),
    _(we, null, Ne(t.bolagsverketsRegistreringar, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", WB, [c("span", GB, Q(h.namn), 1), c("span", YB, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", JB, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", XB, [c("span", QB, Q(v.namn), 1), c("span", ZB, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256))]), c("div", e3, [(g(!0),
    _(we, null, Ne(t.familjeratt, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", t3, [c("span", n3, Q(h.namn), 1), c("span", r3, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", a3, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", s3, [c("span", l3, Q(v.namn), 1), c("span", i3, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256))]), c("div", o3, [(g(!0),
    _(we, null, Ne(t.konkurser, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", u3, [c("span", d3, Q(h.namn), 1), c("span", c3, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", f3, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", p3, [c("span", h3, Q(v.namn), 1), c("span", m3, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256)), (g(!0),
    _(we, null, Ne(t.skuldsaneringar, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", v3, [c("span", g3, Q(h.namn), 1), c("span", b3, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", y3, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", k3, [c("span", _3, Q(v.namn), 1), c("span", w3, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256)), (g(!0),
    _(we, null, Ne(t.sanktionsbeslut, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", x3, [c("span", S3, Q(h.namn), 1), c("span", $3, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", T3, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", C3, [c("span", E3, Q(v.namn), 1), c("span", A3, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256))]), c("div", M3, [(g(!0),
    _(we, null, Ne(t.kallelser, h => (g(),
    _(we, null, [h.antal > 0 ? (g(),
    _("ul", {
        class: "kungorelser-col",
        key: h.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link",
        title: "Länk till " + h.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id
            }
        }
    }, {
        default: N( () => [c("span", O3, [c("span", N3, Q(h.namn), 1), c("span", D3, Q(h.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])]), h.antal > 0 ? (g(),
    _("li", P3, [(g(!0),
    _(we, null, Ne(h.kungorelserubriker, v => (g(),
    _(we, null, [v.antal > 0 ? (g(),
    _("ul", {
        class: "dotted",
        key: v.id
    }, [c("li", null, [x(i, {
        class: "kungorelser__link--sub",
        title: "Länk till " + v.namn,
        to: {
            name: "visasenastepubliceringar",
            hash: "#search",
            params: {
                amnesomrade: h.id,
                kungorelsetyp: v.id
            }
        }
    }, {
        default: N( () => [c("span", F3, [c("span", B3, Q(v.namn), 1), c("span", V3, Q(v.antal), 1)])]),
        _: 2
    }, 1032, ["title", "to"])])])) : q("", !0)], 64))), 256))])) : q("", !0)])) : q("", !0)], 64))), 256))])])) : (g(),
    _("div", I3, [c("h2", R3, "Urval av kungörelser " + Q(t.gPubliseringsdatum), 1), c("div", L3, [x(o), j3])]))]), t.infotexterLoaded ? (g(),
    _("div", U3, [(g(!0),
    _(we, null, Ne(t.gInfotexter, h => (g(),
    _("div", {
        class: ye(["col-12 mt-2 mt-md-0 py-3 py-md-5", t.grid]),
        key: h.id
    }, [c("article", H3, [c("h2", K3, Q(h.rubrik), 1), c("div", {
        innerHTML: h.text
    }, null, 8, z3)])], 2))), 128))])) : q("", !0)])])
}
const W3 = rt(CB, [["render", q3], ["__scopeId", "data-v-9fd27f0d"]]);
var G3 = Object.defineProperty
  , Y3 = Object.getOwnPropertyDescriptor
  , J3 = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Y3(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && G3(e, n, a),
    a
}
;
let Fp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "skickaBekraftelse", !1);
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "success");
        V(this, "redigeratPersonnummer", "")
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    data() {
        return {}
    }
    skickaBekraftelseCheckboxChanged() {
        this.visaMeddelande = !1
    }
    skaBekraftelseSkickas() {
        var n = {
            email: this.kundanvandare.email,
            token: this.kundanvandare.token,
            skaBekraftelseSkickas: this.skickaBekraftelse
        };
        dt().skaBekraftelseSkickas(n).then( () => {
            this.visaMeddelande = !0,
            this.meddelande = "Sparat",
            this.kundanvandare.skickaBekraftelse = this.skickaBekraftelse,
            this.meddelandeTyp = "success"
        }
        ).catch(r => {
            this.meddelande = r,
            this.meddelandeTyp = "danger",
            this.visaMeddelande = !0
        }
        )
    }
    visaKnapp() {
        return !(this.kundanvandare.skickaBekraftelse.toString() == this.skickaBekraftelse.toString() || this.visaMeddelande)
    }
    created() {
        this.kundanvandare != null && (this.skickaBekraftelse = this.kundanvandare.skickaBekraftelse,
        this.kundanvandare.personnummer === null ? this.redigeratPersonnummer = "" : this.redigeratPersonnummer = iw(this.kundanvandare.personnummer))
    }
}
;
Fp = J3([Ct({
    components: {
        Selectlist: Vn,
        BFormCheckbox: $s,
        Meddelande: Ft
    }
})], Fp);
const X3 = Et(Fp);
const Mi = t => ($t("data-v-a11ef9f2"),
t = t(),
Tt(),
t)
  , Q3 = {
    class: "page"
}
  , Z3 = {
    class: "row justify-content-md-center"
}
  , e6 = {
    class: "col-md-8"
}
  , t6 = {
    class: "minauppgifter"
}
  , n6 = Mi( () => c("h1", {
    class: "py-3"
}, "Mina uppgifter", -1))
  , r6 = {
    class: "list-group"
}
  , a6 = {
    class: "list-group-item"
}
  , s6 = {
    class: "row"
}
  , l6 = Mi( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Namn")], -1))
  , i6 = {
    class: "col-md-9"
}
  , o6 = {
    key: 0,
    class: "list-group-item"
}
  , u6 = {
    class: "row"
}
  , d6 = Mi( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label",
    for: "personnummer"
}, "Personnummer")], -1))
  , c6 = {
    class: "col-md-9"
}
  , f6 = {
    id: "personnummer"
}
  , p6 = {
    class: "list-group-item"
}
  , h6 = {
    class: "row"
}
  , m6 = Mi( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "E-postadress")], -1))
  , v6 = {
    class: "col-md-9"
}
  , g6 = {
    class: "row mt-4"
}
  , b6 = {
    class: "col"
}
  , y6 = {
    class: "row mt-2"
}
  , k6 = {
    class: "col"
}
  , _6 = Mi( () => c("span", {
    class: "me-1"
}, "Jag vill", -1))
  , w6 = Mi( () => c("span", null, "ändra mitt lösenord.", -1));
function x6(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("b-form-checkbox")
      , o = ue("b-button")
      , u = ue("router-link")
      , d = ue("b-form");
    return g(),
    _("div", Q3, [c("div", Z3, [c("div", e6, [c("div", t6, [n6, t.visaMeddelande ? (g(),
    de(l, {
        key: 0,
        meddelande: t.meddelande,
        meddelandeTyp: t.meddelandeTyp
    }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)]), x(d, null, {
        default: N( () => [c("ul", r6, [c("li", a6, [c("div", s6, [l6, c("div", i6, [c("span", null, Q(t.kundanvandare.namn), 1)])])]), t.redigeratPersonnummer != null && t.redigeratPersonnummer.length > 0 ? (g(),
        _("li", o6, [c("div", u6, [d6, c("div", c6, [c("span", f6, Q(t.redigeratPersonnummer), 1)])])])) : q("", !0), c("li", p6, [c("div", h6, [m6, c("div", v6, [c("span", null, Q(t.kundanvandare.email), 1)])])])]), c("div", g6, [c("div", b6, [x(i, {
            modelValue: t.skickaBekraftelse,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.skickaBekraftelse = f),
            class: "mb-2 me-sm-2 mb-sm-0",
            "unchecked-value": "false",
            onInput: e[1] || (e[1] = f => t.skickaBekraftelseCheckboxChanged()),
            "aria-label": "skabekraftelseskickas"
        }, {
            default: N( () => [ve("Skicka en bekräftelse på registrerade kungörelser till min e-postadress. ")]),
            _: 1
        }, 8, ["modelValue"]), t.visaKnapp() ? (g(),
        de(o, {
            key: 0,
            class: "mt-2 blv-color",
            id: "skabekraftelseskickas",
            onClick: e[2] || (e[2] = f => t.skaBekraftelseSkickas()),
            variant: "primary"
        }, {
            default: N( () => [ve("Spara")]),
            _: 1
        })) : q("", !0)])]), c("div", y6, [c("div", k6, [_6, x(u, {
            to: {
                name: "bytlosenord"
            }
        }, {
            default: N( () => [w6]),
            _: 1
        })])])]),
        _: 1
    })])])])
}
const S6 = rt(X3, [["render", x6], ["__scopeId", "data-v-a11ef9f2"]]);
var $6 = Object.defineProperty
  , T6 = Object.getOwnPropertyDescriptor
  , C6 = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? T6(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && $6(e, n, a),
    a
}
;
let Bp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "valdKund", {});
        V(this, "skickaBekraftelse", !1);
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "adress", "");
        V(this, "faktureringsadress", "")
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    data() {
        return {}
    }
    setValdKund(e) {
        this.valdKund = this.kundanvandare.poitkunder[e]
    }
    created() {
        this.kundanvandare != null && this.kundanvandare.poitkunder != null && this.kundanvandare.poitkunder.length > 0 && (this.valdKund = this.kundanvandare.poitkunder[0])
    }
}
;
Bp = C6([Ct({
    components: {
        Selectlist: Vn,
        BFormCheckbox: $s,
        Meddelande: Ft
    }
})], Bp);
const E6 = Et(Bp);
const Pm = t => ($t("data-v-2d113bf7"),
t = t(),
Tt(),
t)
  , A6 = {
    class: "page"
}
  , M6 = {
    class: "row justify-content-md-center"
}
  , O6 = {
    class: "col-lg-8"
}
  , N6 = Pm( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Mina kunder")])], -1))
  , D6 = {
    class: "mb-3 row"
}
  , P6 = {
    key: 0,
    for: "kunder",
    class: "col-sm-2 col-form-label col-form-label-sm"
}
  , F6 = {
    key: 1,
    class: "label col-sm-2 col-form-label col-form-label-sm"
}
  , B6 = {
    key: 2,
    class: "col-lg-10"
}
  , V6 = {
    key: 3,
    class: "col-lg-10"
}
  , I6 = ["value", "selected"]
  , R6 = {
    key: 0,
    class: "row mt-3"
}
  , L6 = {
    class: "col-lg-12"
}
  , j6 = {
    key: 1,
    class: "list-group"
}
  , U6 = {
    class: "list-group-item"
}
  , H6 = {
    class: "row"
}
  , K6 = Pm( () => c("span", {
    class: "label col-lg-6"
}, "Kundnummer", -1))
  , z6 = {
    class: "col-lg-6"
}
  , q6 = {
    class: "list-group-item"
}
  , W6 = {
    class: "row"
}
  , G6 = Pm( () => c("span", {
    class: "label col-lg-6"
}, "Organisationsnummer/personnummer", -1))
  , Y6 = {
    class: "col-lg-6"
};
function J6(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("b-form");
    return g(),
    _("div", A6, [c("div", M6, [c("div", O6, [N6, x(i, null, {
        default: N( () => [c("div", D6, [t.kundanvandare.poitkunder.length != 1 ? (g(),
        _("label", P6, "Namn")) : (g(),
        _("span", F6, "Namn")), t.kundanvandare.poitkunder.length == 1 ? (g(),
        _("div", B6, Q(t.kundanvandare.poitkunder[0].namn), 1)) : (g(),
        _("div", V6, [c("select", {
            id: "kunder",
            class: "form-select",
            onChange: e[0] || (e[0] = o => t.setValdKund(o.target.selectedIndex))
        }, [(g(!0),
        _(we, null, Ne(t.kundanvandare.poitkunder, (o, u) => (g(),
        _("option", {
            key: o.id,
            value: o,
            selected: u === 0
        }, Q(o.namn), 9, I6))), 128))], 32)]))]), t.valdKund.kundstatus == "Avslutad" ? (g(),
        _("div", R6, [c("div", L6, [x(l, {
            meddelande: "Uppdragsgivaren är inaktiverad",
            meddelandeTyp: "danger"
        })])])) : q("", !0), t.valdKund.kundstatus != "Avslutad" ? (g(),
        _("ul", j6, [c("li", U6, [c("div", H6, [K6, c("span", z6, Q(t.valdKund.kundnummer), 1)])]), c("li", q6, [c("div", W6, [G6, c("span", Y6, Q(t.valdKund.organisationsnummer), 1)])])])) : q("", !0)]),
        _: 1
    })])])])
}
const X6 = rt(E6, [["render", J6], ["__scopeId", "data-v-2d113bf7"]]);
var Q6 = Object.defineProperty
  , Z6 = Object.getOwnPropertyDescriptor
  , eV = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Z6(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Q6(e, n, a),
    a
}
;
let Vp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "email", "");
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "felmeddelande", "");
        V(this, "emailOk", !0);
        V(this, "valdKund", "");
        V(this, "valdTidsperiodFrom", "");
        V(this, "valdTidsperiodTom", "");
        V(this, "loading", !1)
    }
    get sokKungorelseResultat() {
        return En().sokKungorelseResultat
    }
    get sokparametrar() {
        return En().sokparametrar
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get rensaSokHistorik() {
        return Pe().rensaSokHistorik
    }
    setRensaSokHistorik(n) {
        Pe().setRensaSokHistorik(n)
    }
    get disableSok() {
        return this.valdTidsperiodFrom == "" || this.valdTidsperiodTom == ""
    }
    dagensDatum() {
        return ow()
    }
    dagensDatumMinusAr(n) {
        return uw(n)
    }
    sokKungorelse() {
        En().resetSokKungorelseResultatLista(),
        this.loading = !0,
        this.visaMeddelande = !1,
        St().getLan().then( () => {
            En().sokKungorelse({
                kundid: this.valdKund,
                tidsperiodFrom: this.valdTidsperiodFrom,
                tidsperiodTom: this.valdTidsperiodTom
            }).then(n => {
                this.loading = !1,
                n == "FOR_MANGA_TRAFFAR" ? (this.visaMeddelande = !0,
                this.meddelande = "Sökningen gav för många träffar.",
                this.meddelandeTyp = "info") : n == "INGA_TRAFFAR" ? (this.visaMeddelande = !0,
                this.meddelande = "Sökningen gav ingen träff.",
                this.meddelandeTyp = "info") : this.sokKungorelseResultat.sort( (r, a) => a.publiceringsdatum > r.publiceringsdatum ? 1 : -1)
            }
            ).catch(n => {
                this.meddelande = n,
                this.loading = !1,
                this.visaMeddelande = !0,
                this.meddelandeTyp = "danger"
            }
            )
        }
        )
    }
    aterstallSokparametrar() {
        this.valdTidsperiodFrom = this.sokparametrar.tidsperiodFrom,
        this.valdTidsperiodTom = this.sokparametrar.tidsperiodTom,
        this.aterstallListval()
    }
    aterstallListval() {
        this.valdKund = Wi(this.kundanvandare.poitkunder, this.sokparametrar.kundid).id
    }
    created() {
        this.rensaSokHistorik ? (En().resetSokHistorik(),
        this.setRensaSokHistorik(!1),
        this.kundanvandare != null && this.kundanvandare.poitkunder != null && this.kundanvandare.poitkunder.length > 0 && (this.valdKund = this.kundanvandare.poitkunder[0].id)) : Object.keys(this.sokparametrar).length && this.aterstallSokparametrar()
    }
}
;
Vp = eV([Ct({
    components: {
        Meddelande: Ft,
        FormGroup: Na,
        Sokresultat: tc,
        BSpinner: er,
        BFormSelect: yl
    }
})], Vp);
const tV = Et(Vp);
const Fm = t => ($t("data-v-51923b82"),
t = t(),
Tt(),
t)
  , nV = {
    class: "page"
}
  , rV = Fm( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Sök eller rätta publicerade kungörelser")])], -1))
  , aV = {
    class: "sok bg-white pt-3 pb-0 px-3"
}
  , sV = {
    class: "row align-items-end"
}
  , lV = {
    class: "col-lg-3"
}
  , iV = {
    class: "col-lg-3"
}
  , oV = {
    class: "col-lg-3"
}
  , uV = {
    class: "col-lg-3"
}
  , dV = {
    class: "mb-3"
}
  , cV = Fm( () => c("span", {
    class: "visually-hidden"
}, "Laddar ...", -1))
  , fV = {
    class: "row mt-3"
}
  , pV = {
    class: "col-sm-12"
}
  , hV = Fm( () => c("h2", null, "Sökresultat", -1));
function mV(t, e, n, r, a, s) {
    const l = ue("b-form-select")
      , i = ue("form-group")
      , o = ue("b-form-input")
      , u = ue("b-spinner")
      , d = ue("b-button")
      , f = ue("sokresultat")
      , p = ue("meddelande")
      , h = ue("b-form");
    return g(),
    _("div", nV, [rV, x(h, null, {
        default: N( () => [c("div", aV, [c("div", sV, [c("div", lV, [x(i, {
            labelFor: "uppdragsgivare",
            label: "Mina kunder"
        }, {
            default: N( () => [x(l, {
                id: "uppdragsgivare",
                selected: "",
                modelValue: t.valdKund,
                "onUpdate:modelValue": e[0] || (e[0] = v => t.valdKund = v),
                options: t.kundanvandare.poitkunder,
                "text-field": "namn",
                "value-field": "id"
            }, null, 8, ["modelValue", "options"])]),
            _: 1
        })]), c("div", iV, [x(i, {
            labelFor: "publiceringsdatum-from",
            label: "Från och med",
            invalidFeedback: "Ange ett datumintervall på maximalt ett år"
        }, {
            default: N( () => [x(o, {
                type: "date",
                id: "publiceringsdatum-from",
                modelValue: t.valdTidsperiodFrom,
                "onUpdate:modelValue": e[1] || (e[1] = v => t.valdTidsperiodFrom = v),
                min: t.dagensDatumMinusAr(5),
                max: t.dagensDatum()
            }, null, 8, ["modelValue", "min", "max"])]),
            _: 1
        })]), c("div", oV, [x(i, {
            labelFor: "publiceringsdatum-tom",
            label: "Till och med"
        }, {
            default: N( () => [x(o, {
                type: "date",
                modelValue: t.valdTidsperiodTom,
                "onUpdate:modelValue": e[2] || (e[2] = v => t.valdTidsperiodTom = v),
                id: "publiceringsdatum-tom",
                max: t.dagensDatum()
            }, null, 8, ["modelValue", "max"])]),
            _: 1
        })]), c("div", uV, [c("div", dV, [x(d, {
            class: "blv-color",
            variant: t.disableSok ? "secondary" : "primary",
            disabled: t.disableSok,
            onClick: e[3] || (e[3] = v => t.sokKungorelse())
        }, {
            default: N( () => [ve("Sök "), t.loading ? (g(),
            de(u, {
                key: 0,
                small: ""
            })) : q("", !0), cV]),
            _: 1
        }, 8, ["variant", "disabled"])])])]), c("div", fV, [c("div", pV, [t.visaMeddelande ? (g(),
        de(p, {
            key: 1,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : (g(),
        de(f, {
            key: 0,
            sokresultat: t.sokKungorelseResultat,
            inloggad: !0
        }, {
            default: N( () => [hV]),
            _: 1
        }, 8, ["sokresultat"]))])])])]),
        _: 1
    })])
}
const vV = rt(tV, [["render", mV], ["__scopeId", "data-v-51923b82"]])
  , gV = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , bV = c("path", {
    fill: "currentColor",
    d: "M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8L4.646 5.354a.5.5 0 0 1 0-.708"
}, null, -1)
  , yV = [bV];
function kV(t, e) {
    return g(),
    _("svg", gV, [...yV])
}
const _l = {
    name: "bi-x",
    render: kV
};
var _V = Object.defineProperty
  , wV = Object.getOwnPropertyDescriptor
  , xV = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? wV(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && _V(e, n, a),
    a
}
;
let Ip = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "nuvarandeLosenord", "");
        V(this, "nyttLosenord", "");
        V(this, "bekraftaLosenord", "");
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "felmeddelande1", "");
        V(this, "felmeddelande2", "");
        V(this, "losenordOk", !0);
        V(this, "variant", "secondary")
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    disableKnapp() {
        return this.nyttLosenordGiltigt() ? (this.variant = "primary",
        !1) : (this.variant = "secondary",
        !0)
    }
    nyttLosenordGiltigt() {
        if (this.nyttLosenord === "" && this.bekraftaLosenord == "")
            return null;
        if (this.nyttLosenord === "" && this.bekraftaLosenord != "")
            return !1;
        if (this.nyttLosenord.length < 8)
            return this.felmeddelande1 = "Ange minst åtta tecken",
            !1;
        if (this.nyttLosenord == this.nyttLosenord.toLowerCase() || this.nyttLosenord == this.nyttLosenord.toUpperCase())
            return this.felmeddelande1 = "Blanda stora och små bokstäver",
            !1;
        for (var n = -1, r = 0, a = "0123456789"; n == -1 && r < a.length; )
            n = this.nyttLosenord.indexOf(a.charAt(r++));
        if (n == -1)
            return this.felmeddelande1 = "Nytt lösenord måste innehålla minst en siffra.",
            !1;
        for (n = -1,
        r = 0,
        a = "!#¤%&/()=?^¨*-_.:,;@£$+?´`"; n == -1 && r < a.length; )
            n = this.nyttLosenord.indexOf(a.charAt(r++));
        return n == -1 ? (this.felmeddelande1 = "Nytt lösenord måste innehålla minst ett specialtecken.",
        !1) : this.nyttLosenord == this.nuvarandeLosenord ? (this.felmeddelande1 = "Nytt lösenord får inte vara samma som nuvarande lösenord",
        !1) : !0
    }
    bekrNyttLosenordGiltigt() {
        return this.nyttLosenord === "" || this.bekraftaLosenord == "" ? null : this.nyttLosenord != this.bekraftaLosenord ? (this.felmeddelande2 = "Ange samma lösenord i båda fälten",
        !1) : !0
    }
    nuvarandeLosenordGiltigt() {
        return this.losenordOk ? null : (this.felmeddelande2 = "Felaktigt lösenord angivet",
        !1)
    }
    nuvarandeLosenChanged() {
        this.visaMeddelande = !1,
        this.losenordOk = !0
    }
    nyttLosenChanged() {
        this.visaMeddelande = !1
    }
    bekraftaLosenChanged() {
        this.visaMeddelande = !1
    }
    tillbaka() {
        this.$router.go(-1)
    }
    hex(n) {
        return n.map(a => a.toString(16).padStart(2, "0")).join("")
    }
    async sha256x2_low(n) {
        const r = new TextEncoder().encode(n)
          , a = await crypto.subtle.digest("SHA-256", r)
          , s = await crypto.subtle.digest("SHA-256", a);
        return Array.from(new Uint8Array(s))
    }
    async sha256x2(n) {
        const r = await this.sha256x2_low(n);
        return this.hex(r)
    }
    async nyPwdHash(n, r, a) {
        const s = await this.sha256x2_low(n + a)
          , l = await this.sha256x2(r + a)
          , i = await this.sha256x2_low(l + a);
        var o = 0;
        for (o = 0; o < s.length; o++)
            s[o] = s[o] ^ i[o];
        return this.hex(s)
    }
    async skapaBytLosen(n, r, a, s) {
        const l = await this.sha256x2(r + a)
          , o = (await this.sha256x2(l + "Validering")).substr(0, 48)
          , d = await this.nyPwdHash(n, r, a);
        return {
            email: a,
            token: s,
            nyttLosenord: d,
            validering: o
        }
    }
    bytLosenord() {
        this.skapaBytLosen(this.nyttLosenord, this.nuvarandeLosenord, this.kundanvandare.email, this.kundanvandare.token).then(n => {
            dt().bytLosenord(n).then(r => {
                r == "OK" ? (this.meddelande = "Ditt lösenord är ändrat.",
                this.meddelandeTyp = "success",
                this.visaMeddelande = !0) : r == "FEL_LOSEN" ? this.losenordOk = !1 : (this.meddelande = r,
                this.meddelandeTyp = "danger",
                this.visaMeddelande = !0,
                this.losenordOk = !0)
            }
            ).catch(r => {
                this.meddelande = r,
                this.meddelandeTyp = "danger",
                this.visaMeddelande = !0
            }
            )
        }
        )
    }
}
;
Ip = xV([Ct({
    components: {
        Meddelande: Ft,
        FormGroup: Na,
        IBiX: _l
    }
})], Ip);
const SV = Et(Ip)
  , $V = {
    class: "page"
}
  , TV = {
    class: "row justify-content-md-center"
}
  , CV = {
    class: "col-md-8"
}
  , EV = {
    class: "bytlosenord"
}
  , AV = c("h1", {
    class: "py-3"
}, "Ändra lösenord", -1)
  , MV = {
    class: "row d-flex flex-wrap justify-content-between"
}
  , OV = {
    class: "col-6"
};
function NV(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("b-form-input")
      , o = ue("form-group")
      , u = ue("b-button")
      , d = ue("i-bi-x")
      , f = ue("b-form");
    return g(),
    _("div", $V, [c("div", TV, [c("div", CV, [c("div", EV, [AV, t.visaMeddelande ? (g(),
    de(l, {
        key: 0,
        meddelande: t.meddelande,
        meddelandeTyp: t.meddelandeTyp
    }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)]), x(f, {
        class: "mt-3"
    }, {
        default: N( () => [x(o, {
            labelFor: "nuvarandeLosen",
            label: "Nuvarande lösenord",
            invalidFeedback: t.meddelande
        }, {
            default: N( () => [x(i, {
                class: "mb-2",
                type: "password",
                id: "nuvarandeLosen",
                modelValue: t.nuvarandeLosenord,
                "onUpdate:modelValue": e[0] || (e[0] = p => t.nuvarandeLosenord = p),
                state: t.nuvarandeLosenordGiltigt(),
                onInput: e[1] || (e[1] = p => t.nuvarandeLosenChanged())
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"]), x(o, {
            labelFor: "nyttLosen",
            label: "Nytt lösenord",
            invalidFeedback: t.felmeddelande1
        }, {
            default: N( () => [x(i, {
                type: "password",
                id: "nyttLosen",
                modelValue: t.nyttLosenord,
                "onUpdate:modelValue": e[2] || (e[2] = p => t.nyttLosenord = p),
                state: t.nyttLosenordGiltigt(),
                onInput: e[3] || (e[3] = p => t.nyttLosenChanged())
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"]), x(o, {
            labelFor: "bekraftaLosen",
            label: "Bekräfta lösenordet",
            invalidFeedback: t.felmeddelande2
        }, {
            default: N( () => [x(i, {
                type: "password",
                id: "bekraftaLosen",
                modelValue: t.bekraftaLosenord,
                "onUpdate:modelValue": e[4] || (e[4] = p => t.bekraftaLosenord = p),
                state: t.bekrNyttLosenordGiltigt(),
                onInput: e[5] || (e[5] = p => t.bekraftaLosenChanged())
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"]), c("div", MV, [c("div", OV, [x(u, {
            class: "blv-color",
            disabled: t.disableKnapp(),
            onClick: e[6] || (e[6] = p => t.bytLosenord())
        }, {
            default: N( () => [ve("Spara")]),
            _: 1
        }, 8, ["disabled"]), x(u, {
            class: "blv-btn-abort ms-2",
            variant: "light",
            onClick: e[7] || (e[7] = p => t.tillbaka())
        }, {
            default: N( () => [x(d, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "x",
                focusable: "false"
            }), ve(" Avbryt ")]),
            _: 1
        })])])]),
        _: 1
    })])])])
}
const DV = rt(SV, [["render", NV]])
  , uo = Lr("faktura", {
    state: () => ({
        faktura: "",
        fakturaspecifikation: []
    }),
    getters: {},
    actions: {
        async sokFaktura(t) {
            try {
                const e = "/poit/rest/SokFaktura"
                  , n = await Pt.post(e, t);
                this.setFaktura(n.data)
            } catch {
                throw "Ingen faktura hittades med detta fakturanummer för dina kunder"
            }
        },
        async hamtaFakturaspecifikation(t) {
            try {
                const e = "/poit/rest/HamtaFakturaspecifikation"
                  , n = await Pt.post(e, t);
                this.setFakturaspecifikation(n.data)
            } catch {
                throw "Ingen fakturaspecifikation hittades för detta fakturanummer"
            }
        },
        setFaktura(t) {
            this.faktura = t
        },
        setFakturaspecifikation(t) {
            this.fakturaspecifikation = t
        },
        resetFaktura() {
            this.faktura = ""
        },
        resetFakturaspecifikation() {
            this.fakturaspecifikation = []
        }
    }
});
var PV = Object.defineProperty
  , FV = Object.getOwnPropertyDescriptor
  , BV = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? FV(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && PV(e, n, a),
    a
}
;
let Rp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "fakturanummer", "");
        V(this, "variant", "primary")
    }
    get faktura() {
        return uo().faktura
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    disableSok() {
        return this.fakturanummer == "" || !this.fakturanummerGiltigt()
    }
    fakturanummerGiltigt() {
        return S4(this.fakturanummer)
    }
    sokFaktura() {
        var n = {
            email: this.kundanvandare.email,
            token: this.kundanvandare.token,
            fakturanummer: this.fakturanummer
        };
        this.visaMeddelande = !1,
        uo().sokFaktura(n).then( () => {
            this.$router.push({
                name: "visafaktura"
            })
        }
        ).catch(r => {
            this.meddelande = r,
            this.visaMeddelande = !0,
            this.meddelandeTyp = "info"
        }
        )
    }
}
;
Rp = BV([Ct({
    components: {
        Meddelande: Ft,
        FormGroup: Na,
        BInputGroupAppend: X_
    }
})], Rp);
const VV = Et(Rp);
const IV = t => ($t("data-v-845d4a15"),
t = t(),
Tt(),
t)
  , RV = {
    class: "page"
}
  , LV = {
    class: "row justify-content-md-center"
}
  , jV = {
    class: "col-md-10"
}
  , UV = IV( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Sök faktura")])], -1))
  , HV = {
    class: "sok bg-white pt-3 pb-0 px-3"
}
  , KV = {
    class: "row align-items-end"
}
  , zV = {
    class: "col-lg-3"
}
  , qV = {
    class: "d-flex"
}
  , WV = {
    class: "row mt-3"
}
  , GV = {
    key: 0,
    class: "col-sm-12"
};
function YV(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-button")
      , o = ue("form-group")
      , u = ue("meddelande")
      , d = ue("b-form");
    return g(),
    _("div", RV, [c("div", LV, [c("div", jV, [UV, x(d, null, {
        default: N( () => [c("div", HV, [c("div", KV, [c("div", zV, [x(o, {
            labelFor: "fakturanummer",
            label: "Fakturanummer",
            invalidFeedback: "Ange åtta eller nio siffror"
        }, {
            default: N( () => [c("div", qV, [x(l, {
                type: "text",
                id: "fakturanummer",
                modelValue: t.fakturanummer,
                "onUpdate:modelValue": e[0] || (e[0] = f => t.fakturanummer = f),
                state: t.fakturanummerGiltigt()
            }, null, 8, ["modelValue", "state"]), x(i, {
                class: "blv-color ms-3",
                variant: t.disableSok() ? "secondary" : "primary",
                disabled: t.disableSok(),
                onClick: e[1] || (e[1] = f => t.sokFaktura())
            }, {
                default: N( () => [ve(" Sök ")]),
                _: 1
            }, 8, ["variant", "disabled"])])]),
            _: 1
        })])]), c("div", WV, [t.visaMeddelande ? (g(),
        _("div", GV, [x(u, {
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])])) : q("", !0)])])]),
        _: 1
    })])])])
}
const JV = rt(VV, [["render", YV], ["__scopeId", "data-v-845d4a15"]]);
var XV = Object.defineProperty
  , QV = Object.getOwnPropertyDescriptor
  , ZV = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? QV(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && XV(e, n, a),
    a
}
;
let Lp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "visaFakturaspec", !1);
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info")
    }
    get faktura() {
        return uo().faktura
    }
    get fakturaspecifikation() {
        return uo().fakturaspecifikation
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    tillbaka() {
        this.$router.go(-1)
    }
    toggleFakturaspecifikation() {
        this.visaFakturaspec = !this.visaFakturaspec
    }
    hamtaFakturaspecifikation() {
        var n = {
            email: this.kundanvandare.email,
            token: this.kundanvandare.token,
            fakturanummer: this.faktura.fakturanummer
        };
        uo().hamtaFakturaspecifikation(n).then( () => {}
        ).catch(r => {
            this.meddelande = r,
            this.visaMeddelande = !0,
            this.meddelandeTyp = "danger"
        }
        )
    }
    created() {
        this.hamtaFakturaspecifikation()
    }
}
;
Lp = ZV([Ct({
    components: {
        Meddelande: Ft
    }
})], Lp);
const eI = Et(Lp);
const ur = t => ($t("data-v-bd9f0840"),
t = t(),
Tt(),
t)
  , tI = {
    class: "page"
}
  , nI = {
    class: "row justify-content-md-center"
}
  , rI = {
    class: "col-md-10"
}
  , aI = ur( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Fakturauppgifter")])], -1))
  , sI = {
    class: "list-group mb-md-3"
}
  , lI = {
    class: "list-group-item"
}
  , iI = {
    class: "row"
}
  , oI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Kundnummer", -1))
  , uI = {
    class: "col-lg-8"
}
  , dI = {
    class: "list-group-item"
}
  , cI = {
    class: "row"
}
  , fI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Namn", -1))
  , pI = {
    class: "col-lg-8"
}
  , hI = {
    class: "list-group-item"
}
  , mI = {
    class: "row"
}
  , vI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Fakturanummer", -1))
  , gI = {
    class: "col-lg-8"
}
  , bI = {
    class: "list-group-item"
}
  , yI = {
    class: "row"
}
  , kI = ur( () => c("span", {
    class: "label col-lg-4"
}, "OCR-nummer", -1))
  , _I = {
    class: "col-lg-8"
}
  , wI = {
    class: "list-group-item"
}
  , xI = {
    class: "row"
}
  , SI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Fakturadatum", -1))
  , $I = {
    class: "col-lg-8"
}
  , TI = {
    class: "list-group-item"
}
  , CI = {
    class: "row"
}
  , EI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Förfallodatum", -1))
  , AI = {
    class: "col-lg-8"
}
  , MI = {
    class: "list-group-item"
}
  , OI = {
    class: "row"
}
  , NI = ur( () => c("span", {
    class: "label col-lg-4"
}, [ve("Belopp "), c("i", null, "(inkl moms 25%)")], -1))
  , DI = {
    class: "col-lg-8"
}
  , PI = {
    class: "list-group-item"
}
  , FI = {
    class: "row"
}
  , BI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Kvar att betala", -1))
  , VI = {
    class: "col-lg-8"
}
  , II = {
    class: "list-group-item"
}
  , RI = {
    class: "row"
}
  , LI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Faktureringsadress", -1))
  , jI = {
    class: "col-lg-8"
}
  , UI = {
    class: "list-group-item"
}
  , HI = {
    class: "row"
}
  , KI = ur( () => c("span", {
    class: "label col-lg-4"
}, "Fakturaspecifikation", -1))
  , zI = {
    class: "col-lg-8"
}
  , qI = {
    key: 0,
    class: "row mt-1"
}
  , WI = {
    class: "col"
}
  , GI = {
    class: "table-responsive"
}
  , YI = {
    class: "table table-hover table-striped table-bv",
    id: "fakturaorder"
}
  , JI = ur( () => c("caption", {
    class: "visually-hidden"
}, " Fakturaspecifikation ", -1))
  , XI = ur( () => c("thead", {
    class: "blv-thead"
}, [c("tr", null, [c("th", null, "Kungörelse-id"), c("th", null, "Publicerad"), c("th", null, "Referens"), c("th", null, "Ämnesområde"), c("th", null, "Antal"), c("th", null, "Á pris"), c("th", null, [ve("Belopp "), c("i", null, "(inkl moms 25%)")])])], -1))
  , QI = {
    class: "align-middle"
}
  , ZI = {
    class: "align-middle text-nowrap"
}
  , e8 = {
    class: "align-middle"
}
  , t8 = {
    class: "align-middle"
}
  , n8 = {
    class: "align-middle"
}
  , r8 = {
    class: "align-middle"
}
  , a8 = {
    class: "align-middle"
};
function s8(t, e, n, r, a, s) {
    const l = ue("router-link")
      , i = ue("b-button");
    return g(),
    _("div", tI, [c("div", nI, [c("div", rI, [aI, c("ul", sI, [c("li", lI, [c("div", iI, [oI, c("span", uI, Q(t.faktura.kundnummer), 1)])]), c("li", dI, [c("div", cI, [fI, c("span", pI, Q(t.faktura.kundnamn), 1)])]), c("li", hI, [c("div", mI, [vI, c("span", gI, Q(t.faktura.fakturanummer), 1)])]), c("li", bI, [c("div", yI, [kI, c("span", _I, Q(t.faktura.ocrnummer), 1)])]), c("li", wI, [c("div", xI, [SI, c("span", $I, Q(t.faktura.fakturadatum), 1)])]), c("li", TI, [c("div", CI, [EI, c("span", AI, Q(t.faktura.forfallodatum), 1)])]), c("li", MI, [c("div", OI, [NI, c("span", DI, Q(t.faktura.fakturabelopp), 1)])]), c("li", PI, [c("div", FI, [BI, c("span", VI, Q(t.faktura.kvarAttBetala), 1)])]), c("li", II, [c("div", RI, [LI, c("span", jI, [c("pre", null, Q(t.fakturaspecifikation[0].faktureringsadress), 1)])])]), c("li", UI, [c("div", HI, [KI, c("span", zI, [c("button", {
        type: "button",
        class: "btn btn-link",
        onClick: e[0] || (e[0] = o => t.toggleFakturaspecifikation())
    }, " Visa fakturaspecifikation ")])])])]), t.visaFakturaspec ? (g(),
    _("div", qI, [c("div", WI, [c("div", GI, [c("table", YI, [JI, XI, c("tbody", null, [(g(!0),
    _(we, null, Ne(t.fakturaspecifikation, (o, u) => (g(),
    _("tr", {
        key: t.fakturaspecifikation.kungorelseid + u
    }, [c("td", QI, [x(l, {
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: o.kungorelseid
            }
        }
    }, {
        default: N( () => [ve(Q(o.kungorelseid), 1)]),
        _: 2
    }, 1032, ["to"])]), c("td", ZI, Q(o.publiceringsdatum), 1), c("td", e8, Q(o.referens), 1), c("td", t8, Q(o.kungorelsetyp), 1), c("td", n8, Q(o.antal), 1), c("td", r8, Q(o.apris), 1), c("td", a8, Q(Math.round(parseInt(o.belopp) + parseInt(o.belopp) * .25).toFixed(2)), 1)]))), 128))])])])])])) : q("", !0), x(i, {
        variant: "link",
        onClick: e[1] || (e[1] = o => t.tillbaka())
    }, {
        default: N( () => [ve(" « Tillbaka ")]),
        _: 1
    })])])])
}
const l8 = rt(eI, [["render", s8], ["__scopeId", "data-v-bd9f0840"]]);
var i8 = Object.defineProperty
  , o8 = Object.getOwnPropertyDescriptor
  , u8 = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? o8(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && i8(e, n, a),
    a
}
;
let jp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "meddelandeModal", !1);
        V(this, "aktivKungorelse", {});
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "kungorelsetyp", {});
        V(this, "oldArg", "");
        V(this, "ersattAvKG", null);
        V(this, "meddelandeModalText", "")
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    formateraPersOrgNr(n) {
        return n && qn(n)
    }
    fixLink(n) {
        return n.replaceAll("/", "-")
    }
    showTillbaka() {
        return window.history.length > 1
    }
    tillbaka() {
        this.$router.back()
    }
    print() {
        window.print()
    }
    get isErsattsAvPub() {
        if (this.ersattAvKG == null || !this.aktivKungorelse.ersattsAv || !this.ersattAvKG.publiceringsDatum)
            return !1;
        var n = new Date(this.ersattAvKG.publiceringsDatum)
          , r = new Date(Date.now());
        return n.setUTCHours(0, 0, 0, 0),
        r.setUTCHours(0, 0, 0, 0),
        !(n.getTime() > r.getTime())
    }
    forceUpdate() {
        const n = this.$route.params.kungorelseid;
        this.$route.params.kungorelseid = "",
        this.$route.params.kungorelseid = n
    }
    kanEditera() {
        if (this.kundanvandare == null || this.kundanvandare.poitkunder == null || this.aktivKungorelse.kundNummer == null)
            return !1;
        if (!this.aktivKungorelse.kungorelseid || this.aktivKungorelse.kungorelseid == "")
            return !0;
        if (this.aktivKungorelse.ersattsAv)
            return !1;
        if (this.aktivKungorelse.publiceringsDatum) {
            var n = new Date(this.aktivKungorelse.publiceringsDatum)
              , r = new Date(Date.now());
            if (n.setUTCHours(0, 0, 0, 0),
            r.setUTCHours(0, 0, 0, 0),
            n.getTime() > r.getTime())
                return !1
        }
        var a = 0;
        for (a = 0; a < this.kundanvandare.poitkunder.length; a++)
            if (this.kundanvandare.poitkunder[a].kundnummer == this.aktivKungorelse.kundNummer)
                return !0;
        return !1
    }
    editera() {
        Pe().aktivKungorelse = this.aktivKungorelse,
        this.$router.push({
            name: "editera"
        })
    }
    loadKungorelsetyp(n) {
        Pe().getKungorelsetyp(n).then( () => {
            this.kungorelsetyp = Pe().loadedKungorelsetyp
        }
        )
    }
    beforeCreate() {
        Pe().startsida != !0 && Pe().fulvisa != !0 && this.$router.push({
            name: "enskild",
            params: {
                kungorelseid: this.$route.params.kungorelseid
            }
        })
    }
    created() {
        if (!(Pe().startsida != !0 && Pe().fulvisa != !0)) {
            if (Pe().fulvisa = !1,
            dt().isLoggedin,
            this.$route.params.kungorelseid) {
                this.aktivKungorelse = {};
                var n = this.$route.params.kungorelseid.replaceAll("-", "/");
                Pe().getKoppling().then(r => {
                    r ? (location.reload(),
                    this.$router.replace({
                        name: "home"
                    })) : Pe().getKungorelse({
                        kungorelseid: n
                    }).then( () => {
                        this.aktivKungorelse = Pe().loadedKungorelse,
                        this.ersattAvKG = Pe().ersattsAvKungorelse,
                        this.loadKungorelsetyp(this.aktivKungorelse.rubrikExternKod)
                    }
                    ).catch(a => {
                        a.message == "429" ? (this.meddelandeModalText = "Du kan inte se på fler kungörelser idag. Försök igen imorgon.",
                        this.meddelandeModal = !0) : a.message == "500" ? (this.meddelandeModalText = "Tekniskt fel hos Bolagsverket. Försök igen senare.",
                        this.meddelandeModal = !0) : a.message == "UNKNOWN" ? (this.meddelandeModalText = "Okänt fel. Försök igen senare.",
                        this.meddelandeModal = !0) : this.$router.back()
                    }
                    )
                }
                )
            } else
                Pe().aktivKungorelse != null ? (this.aktivKungorelse = Pe().aktivKungorelse,
                this.loadKungorelsetyp(this.aktivKungorelse.rubrikExternKod)) : (this.meddelande = "Felaktig Kungörelse",
                this.visaMeddelande = !0,
                this.meddelandeTyp = "danger");
            this.oldArg = this.$route.params.kungorelseid
        }
    }
    updated() {
        if (this.$route.params.kungorelseid && this.oldArg != this.$route.params.kungorelseid) {
            this.oldArg = this.$route.params.kungorelseid,
            this.aktivKungorelse = {};
            var n = this.$route.params.kungorelseid.replaceAll("-", "/");
            Pe().getKoppling().then(r => {
                r ? location.reload() : Pe().getKungorelse({
                    kungorelseid: n
                }).then( () => {
                    this.aktivKungorelse = Pe().loadedKungorelse,
                    this.ersattAvKG = Pe().ersattsAvKungorelse,
                    this.loadKungorelsetyp(this.aktivKungorelse.rubrikExternKod)
                }
                ).catch(a => {
                    a.message == "429" ? (this.meddelandeModalText = "Du kan inte se på fler kungörelser idag. Försök igen imorgon.",
                    this.meddelandeModal = !0) : a.message == "500" ? (this.meddelandeModalText = "Tekniskt fel hos Bolagsverket. Försök igen senare.",
                    this.meddelandeModal = !0) : a.message == "UNKNOWN" ? (this.meddelandeModalText = "Okänt fel. Försök igen senare.",
                    this.meddelandeModal = !0) : this.$router.back()
                }
                )
            }
            )
        }
    }
}
;
jp = u8([Ct({
    components: {
        Meddelande: Ft,
        BSpinner: er
    }
})], jp);
const d8 = Et(jp);
const wl = t => ($t("data-v-19e8b2a4"),
t = t(),
Tt(),
t)
  , c8 = {
    class: "page"
}
  , f8 = {
    key: 0
}
  , p8 = {
    class: "d-flex justify-content-center mb-3"
}
  , h8 = {
    key: 1
}
  , m8 = {
    key: 0
}
  , v8 = {
    class: "alert blv-alert-info blv-alert-print"
}
  , g8 = {
    key: 1
}
  , b8 = {
    class: "alert blv-alert-info blv-alert-print"
}
  , y8 = {
    key: 2,
    class: "row"
}
  , k8 = {
    class: "col-md-12"
}
  , _8 = {
    class: "py-3"
}
  , w8 = {
    class: "d-md-inline py-1 me-md-3"
}
  , x8 = {
    key: 0,
    class: "mt-3"
}
  , S8 = {
    class: "row"
}
  , $8 = {
    class: "col-12 col-lg-10 col-xl-8 pt-4"
}
  , T8 = {
    key: 0,
    class: "row"
}
  , C8 = wl( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Namn/fastighetsbeteckning")], -1))
  , E8 = {
    class: "col-md-8"
}
  , A8 = {
    class: "nowrap"
}
  , M8 = {
    key: 1,
    class: "row"
}
  , O8 = {
    class: "col-md-4"
}
  , N8 = {
    class: "label"
}
  , D8 = {
    class: "col-md-8"
}
  , P8 = {
    id: "datum"
}
  , F8 = {
    key: 2,
    class: "row"
}
  , B8 = wl( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Län")], -1))
  , V8 = {
    class: "col-md-8"
}
  , I8 = {
    id: "lan"
}
  , R8 = {
    key: 3,
    class: "row"
}
  , L8 = wl( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Publiceringsdatum")], -1))
  , j8 = {
    class: "col-md-8"
}
  , U8 = {
    id: "publiceringsdatum"
}
  , H8 = {
    key: 4,
    class: "row"
}
  , K8 = wl( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Kungörelse-id")], -1))
  , z8 = {
    class: "col-md-8"
}
  , q8 = {
    id: "kungorelseid"
}
  , W8 = {
    class: "row"
}
  , G8 = wl( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Uppgiftslämnare")], -1))
  , Y8 = {
    class: "col-md-8"
}
  , J8 = {
    id: "kund"
}
  , X8 = {
    class: "col-12"
}
  , Q8 = {
    class: "mt-3"
}
  , Z8 = {
    class: "infobox p-4 border blv-border-light bg-white"
}
  , eR = wl( () => c("h4", null, "Kungörelsetext", -1))
  , tR = ["innerHTML"]
  , nR = wl( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("hr")])], -1))
  , rR = {
    key: 0,
    class: "d-flex mb-2"
}
  , aR = {
    key: 0
}
  , sR = {
    key: 0
}
  , lR = {
    key: 1
}
  , iR = {
    key: 1
}
  , oR = {
    key: 1,
    class: "d-flex mb-2"
}
  , uR = {
    key: 0
}
  , dR = {
    key: 1
}
  , cR = {
    class: "d-flex mt-2 mb-2"
};
function fR(t, e, n, r, a, s) {
    const l = ue("BModal")
      , i = ue("b-spinner")
      , o = ue("router-link")
      , u = ue("b-button")
      , d = ue("meddelande")
      , f = ue("b-form");
    return g(),
    _("div", c8, [ve(Q(t.forceUpdate()) + " ", 1), x(l, {
        modelValue: t.meddelandeModal,
        "onUpdate:modelValue": e[0] || (e[0] = p => t.meddelandeModal = p),
        "hide-header-close": "",
        "no-close-on-esc": "",
        "no-close-on-backdrop": "",
        onOk: e[1] || (e[1] = () => t.$router.back()),
        centered: "true",
        okTitle: "Ok",
        okOnly: "true"
    }, {
        default: N( () => [ve(Q(t.meddelandeModalText), 1)]),
        _: 1
    }, 8, ["modelValue"]), t.aktivKungorelse == null || Object.keys(t.aktivKungorelse).length == 0 ? (g(),
    _("div", f8, [c("div", p8, [x(i, {
        label: "Laddar..."
    })])])) : (g(),
    _("div", h8, [t.isErsattsAvPub ? (g(),
    _("div", m8, [c("p", v8, [ve(" Denna kungörelse har en rättelse: "), x(o, {
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: t.fixLink(t.aktivKungorelse.ersattsAv)
            }
        }
    }, {
        default: N( () => [ve(Q(t.aktivKungorelse.ersattsAv), 1)]),
        _: 1
    }, 8, ["to"])])])) : q("", !0), t.aktivKungorelse.ersatter ? (g(),
    _("div", g8, [c("p", b8, [ve(" Rättelse av tidigare kungörelse: "), x(o, {
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: t.fixLink(t.aktivKungorelse.ersatter)
            }
        }
    }, {
        default: N( () => [ve(Q(t.aktivKungorelse.ersatter), 1)]),
        _: 1
    }, 8, ["to"])])])) : q("", !0), Object.keys(t.kungorelsetyp).length && Object.keys(t.kungorelsetyp.amnesOmrade).length && t.kungorelsetyp.amnesOmrade.namn != null ? (g(),
    _("div", y8, [c("div", k8, [c("h1", _8, Q(t.kungorelsetyp.amnesOmrade.namn), 1), c("h2", w8, Q(t.aktivKungorelse.rubrik), 1), t.aktivKungorelse.underrubrik != null && t.aktivKungorelse.underrubrik != "" ? (g(),
    _("h3", x8, Q(t.aktivKungorelse.underrubrik), 1)) : q("", !0)])])) : q("", !0), x(f, null, {
        default: N( () => [c("div", S8, [c("div", $8, [t.aktivKungorelse.fysiskaJuridiskaPersoner != null && t.aktivKungorelse.fysiskaJuridiskaPersoner.length > 0 ? (g(),
        _("div", T8, [C8, c("div", E8, [(g(!0),
        _(we, null, Ne(t.aktivKungorelse.fysiskaJuridiskaPersoner, (p, h) => (g(),
        _("p", {
            id: "fysjur",
            key: h
        }, [ve(Q(p.namn) + ", ", 1), c("span", A8, Q(t.formateraPersOrgNr(p.nummer)), 1)]))), 128))])])) : q("", !0), Object.keys(t.kungorelsetyp).length && t.aktivKungorelse.typDatum != null && t.aktivKungorelse.typDatum != "" ? (g(),
        _("div", M8, [c("div", O8, [c("p", N8, Q(t.kungorelsetyp.datumTyp), 1)]), c("div", D8, [c("p", P8, Q(t.aktivKungorelse.typDatum), 1)])])) : q("", !0), t.aktivKungorelse.lan != null && t.aktivKungorelse.lan != "" ? (g(),
        _("div", F8, [B8, c("div", V8, [c("p", I8, Q(t.aktivKungorelse.lan), 1)])])) : q("", !0), t.aktivKungorelse.publiceringsDatum != null && t.aktivKungorelse.publiceringsDatum != "" ? (g(),
        _("div", R8, [L8, c("div", j8, [c("p", U8, Q(t.aktivKungorelse.publiceringsDatum), 1)])])) : q("", !0), t.aktivKungorelse.kungorelseid != null && t.aktivKungorelse.kungorelseid != "" ? (g(),
        _("div", H8, [K8, c("div", z8, [c("p", q8, Q(t.aktivKungorelse.kungorelseid), 1)])])) : q("", !0), c("div", W8, [G8, c("div", Y8, [c("p", J8, Q(t.aktivKungorelse.uppgiftslamnare), 1)])])]), c("div", X8, [c("div", Q8, [c("div", Z8, [eR, c("div", {
            innerHTML: t.aktivKungorelse.kungorelseText
        }, null, 8, tR)])])])]), nR, t.kanEditera() ? (g(),
        _("div", rR, [t.showTillbaka() ? (g(),
        _("div", aR, [x(u, {
            class: "ms-2",
            variant: "link",
            onClick: e[2] || (e[2] = p => t.tillbaka())
        }, {
            default: N( () => [ve("« Tillbaka ")]),
            _: 1
        })])) : q("", !0), c("button", {
            type: "button",
            class: "btn blv-color btn-primary ms-2",
            onClick: e[3] || (e[3] = p => t.editera())
        }, [!t.aktivKungorelse.kungorelseid || t.aktivKungorelse.kungorelseid == "" ? (g(),
        _("span", sR, " Ändra ")) : (g(),
        _("span", lR, " Rätta "))]), t.aktivKungorelse.kungorelseid && t.aktivKungorelse.kungorelseid != "" ? (g(),
        _("div", iR, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary ms-2",
            onClick: e[4] || (e[4] = p => t.print())
        }, "Skriv ut")])) : q("", !0)])) : (g(),
        _("div", oR, [t.showTillbaka() ? (g(),
        _("div", uR, [c("button", {
            type: "button",
            class: "btn btn-link",
            onClick: e[5] || (e[5] = p => t.tillbaka())
        }, "« Tillbaka")])) : q("", !0), t.aktivKungorelse.kungorelseid && t.aktivKungorelse.kungorelseid != "" ? (g(),
        _("div", dR, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary ms-2",
            onClick: e[6] || (e[6] = p => t.print())
        }, "Skriv ut")])) : q("", !0)])), c("div", cR, [t.visaMeddelande ? (g(),
        de(d, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)])]),
        _: 1
    })]))])
}
const Yb = rt(d8, [["render", fR], ["__scopeId", "data-v-19e8b2a4"]]);
var pR = Object.defineProperty
  , hR = Object.getOwnPropertyDescriptor
  , mR = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? hR(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && pR(e, n, a),
    a
}
;
let Up = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "loading", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "errors", [])
    }
    get amnesomraden() {
        return St().amnesomraden
    }
    get laner() {
        return St().laner
    }
    get sokKungorelseResultat() {
        return En().sokKungorelseResultat
    }
    get sokparametrar() {
        return En().sokparametrar
    }
    sokKungorelse(e) {
        En().resetSokKungorelseResultatLista(),
        this.loading = !0,
        this.meddelande = "",
        En().sokKungorelse({
            kungorelseid: e
        }).then(n => {
            this.loading = !1,
            n == "FOR_MANGA_TRAFFAR" ? (this.meddelande = "Sökningen gav för många träffar.",
            this.meddelandeTyp = "info") : n == "INGA_TRAFFAR" ? (this.meddelande = "Sökningen gav ingen träff.",
            this.meddelandeTyp = "info") : (Pe().fulvisa = !0,
            this.sokKungorelseResultat.sort( (r, a) => a.publiceringsdatum > r.publiceringsdatum ? 1 : -1))
        }
        ).catch(n => {
            this.meddelande = n,
            this.loading = !1,
            this.meddelandeTyp = "danger"
        }
        )
    }
    beforeCreate() {
        St().getLan().then(e => St().getAmnesomraden()).then(e => this.sokKungorelse(this.$route.params.kungorelseid.replaceAll("-", "/")))
    }
}
;
Up = mR([Ct({
    components: {
        Selectlist: Vn,
        Sokresultat: tc,
        BFormCheckboxGroup: uc,
        Meddelande: Ft,
        BFormSelect: yl,
        FormGroup: Na,
        BSpinner: er
    }
})], Up);
const vR = Et(Up);
const hw = t => ($t("data-v-d43d31e4"),
t = t(),
Tt(),
t)
  , gR = {
    class: "page"
}
  , bR = hw( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Sök enskild kungörelse")])], -1))
  , yR = hw( () => c("h2", null, "Sökresultat", -1));
function kR(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("sokresultat")
      , o = ue("b-form");
    return g(),
    _("div", gR, [bR, x(o, null, {
        default: N( () => [t.meddelande.length != 0 ? (g(),
        de(l, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0), x(i, {
            sokresultat: t.sokKungorelseResultat
        }, {
            default: N( () => [yR]),
            _: 1
        }, 8, ["sokresultat"])]),
        _: 1
    })])
}
const _R = rt(vR, [["render", kR], ["__scopeId", "data-v-d43d31e4"]]);
var wR = Object.defineProperty
  , xR = Object.getOwnPropertyDescriptor
  , SR = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? xR(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && wR(e, n, a),
    a
}
;
let Hp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "arsRedovisning", {});
        V(this, "arsRedovisningar", []);
        V(this, "felMeddelande", "")
    }
    get sokArsInfoResultat() {
        return Sn().sokArsInfoResultat
    }
    created() {
        var n = {
            organisationsnummer: this.$route.params.orgnummer,
            namn: null,
            lankod: null,
            reg_datum: null,
            info: !0
        };
        this.felMeddelande = "",
        this.arsRedovisningar = [],
        Sn().sokArsredovisning(n).then(r => {
            this.arsRedovisningar = Sn().sokArsInfoResultat
        }
        ).catch(r => {
            this.felMeddelande = "Tekniskt fel hos Bolagsverket. Försök igen senare."
        }
        )
    }
    formateraOrgnummer(n) {
        return qn(n)
    }
    tillbaka() {
        this.$router.back()
    }
    print() {
        window.print()
    }
    showTillbaka() {
        return window.history.length > 1
    }
}
;
Hp = SR([Ct({
    components: {
        Meddelande: Ft,
        BSpinner: er
    }
})], Hp);
const $R = Et(Hp);
const Pa = t => ($t("data-v-feec0e83"),
t = t(),
Tt(),
t)
  , TR = {
    class: "page"
}
  , CR = {
    key: 0
}
  , ER = {
    class: "d-flex justify-content-center mb-3"
}
  , AR = ["value"]
  , MR = {
    class: "row"
}
  , OR = {
    class: "col-12 col-lg-8 pt-1 pb-1 arsredovisningar__container"
}
  , NR = {
    key: 0,
    class: "row"
}
  , DR = {
    class: "col-md-12"
}
  , PR = {
    id: "firmaNamn"
}
  , FR = {
    key: 1,
    class: "row"
}
  , BR = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Organisationsnummer:")], -1))
  , VR = {
    class: "col-md-8"
}
  , IR = {
    id: "organisationsnummer"
}
  , RR = {
    key: 2,
    class: "row"
}
  , LR = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Län:")], -1))
  , jR = {
    class: "col-md-8"
}
  , UR = {
    id: "lanNamn"
}
  , HR = {
    key: 3,
    class: "row"
}
  , KR = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Räkenskapsår:")], -1))
  , zR = {
    class: "col-md-8"
}
  , qR = {
    id: "Rakenskapsar"
}
  , WR = {
    key: 4,
    class: "row"
}
  , GR = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Ärendenummer:")], -1))
  , YR = {
    class: "col-md-8"
}
  , JR = {
    id: "Arendenummer"
}
  , XR = {
    key: 5,
    class: "row"
}
  , QR = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Ärendet kom in:")], -1))
  , ZR = {
    class: "col-md-8"
}
  , eL = {
    id: "ankomstdatum"
}
  , tL = {
    key: 6,
    class: "row"
}
  , nL = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Registreringsdatum:")], -1))
  , rL = {
    class: "col-md-8"
}
  , aL = {
    id: "registreringsdatum"
}
  , sL = {
    key: 7,
    class: "row"
}
  , lL = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Koncernredovisning:")], -1))
  , iL = {
    class: "col-md-8"
}
  , oL = {
    id: "Koncernredovisning"
}
  , uL = {
    key: 8,
    class: "row"
}
  , dL = Pa( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Vinstutdelning:")], -1))
  , cL = {
    class: "col-md-8"
}
  , fL = {
    id: "Vinstutdelning"
}
  , pL = Pa( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("hr")])], -1))
  , hL = {
    class: "d-flex mb-2"
}
  , mL = {
    key: 1
};
function vL(t, e, n, r, a, s) {
    const l = ue("b-spinner")
      , i = ue("meddelande")
      , o = ue("b-button")
      , u = ue("b-form");
    return g(),
    _("div", TR, [x(u, null, {
        default: N( () => [t.arsRedovisningar.length == 0 ? (g(),
        _("div", CR, [c("div", ER, [x(l, {
            label: "Laddar..."
        })])])) : q("", !0), (g(!0),
        _(we, null, Ne(t.arsRedovisningar, (d, f) => (g(),
        _("div", {
            key: f,
            value: d
        }, [c("div", MR, [c("div", OR, [t.arsRedovisningar[f].firmaNamn != null && t.arsRedovisningar[f].firmaNamn != "" ? (g(),
        _("div", NR, [c("div", DR, [c("h2", PR, Q(t.arsRedovisningar[f].firmaNamn), 1)])])) : q("", !0), t.arsRedovisningar[f].organisationsnummer != null && t.arsRedovisningar[f].organisationsnummer != "" ? (g(),
        _("div", FR, [BR, c("div", VR, [c("p", IR, Q(t.formateraOrgnummer(t.arsRedovisningar[f].organisationsnummer)), 1)])])) : q("", !0), t.arsRedovisningar[f].lanNamn != null && t.arsRedovisningar[f].lanNamn != "" ? (g(),
        _("div", RR, [LR, c("div", jR, [c("p", UR, Q(t.arsRedovisningar[f].lanNamn), 1)])])) : q("", !0), t.arsRedovisningar[f].rakArFrom && t.arsRedovisningar[f].rakArTom ? (g(),
        _("div", HR, [KR, c("div", zR, [c("p", qR, Q(t.arsRedovisningar[f].rakArFrom + "–" + t.arsRedovisningar[f].rakArTom), 1)])])) : q("", !0), t.arsRedovisningar[f].dinr && t.arsRedovisningar[f].dinrar ? (g(),
        _("div", WR, [GR, c("div", YR, [c("p", JR, Q(t.arsRedovisningar[f].dinr + "/" + t.arsRedovisningar[f].dinrar), 1)])])) : q("", !0), t.arsRedovisningar[f].ankomstdatum != null && t.arsRedovisningar[f].ankomstdatum != "" ? (g(),
        _("div", XR, [QR, c("div", ZR, [c("p", eL, Q(t.arsRedovisningar[f].ankomstdatum), 1)])])) : q("", !0), d.registreringsdatum != null && d.registreringsdatum != "" ? (g(),
        _("div", tL, [nL, c("div", rL, [c("p", aL, Q(d.registreringsdatum), 1)])])) : q("", !0), d.koncernredovisning != null && d.koncernredovisning != null ? (g(),
        _("div", sL, [lL, c("div", iL, [c("p", oL, Q(d.koncernredovisning ? "Ja" : "Nej"), 1)])])) : q("", !0), d.vinstutdelning != null && d.vinstutdelning != null ? (g(),
        _("div", uL, [dL, c("div", cL, [c("p", fL, Q(d.vinstutdelning ? "Ja" : "Nej"), 1)])])) : q("", !0)])]), pL], 8, AR))), 128)), t.felMeddelande != "" ? (g(),
        de(i, {
            key: 1,
            meddelande: t.felMeddelande,
            meddelandeTyp: "danger"
        }, null, 8, ["meddelande"])) : q("", !0), c("div", hL, [t.showTillbaka() ? (g(),
        de(o, {
            key: 0,
            class: "ms-2",
            variant: "link",
            onClick: e[0] || (e[0] = d => t.tillbaka())
        }, {
            default: N( () => [ve(" « Tillbaka ")]),
            _: 1
        })) : q("", !0), t.arsRedovisning ? (g(),
        _("div", mL, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary ms-2",
            onClick: e[1] || (e[1] = d => t.print())
        }, "Skriv ut")])) : q("", !0)])]),
        _: 1
    })])
}
const gL = rt($R, [["render", vL], ["__scopeId", "data-v-feec0e83"]]);
var bL = Object.defineProperty
  , yL = Object.getOwnPropertyDescriptor
  , kL = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? yL(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && bL(e, n, a),
    a
}
;
let Kp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "amnesomrade");
        V(this, "kungorelsetyp");
        V(this, "laddar", !0);
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info")
    }
    get sokKungorelseResultat() {
        return En().sokKungorelseResultat
    }
    get amnesomraden() {
        return oo().amnesomraden
    }
    get gPubliseringsdatum() {
        return oo().gPubliseringsdatum
    }
    async aInitHomeStoreModule() {
        await oo().aInitHomeStoreModule()
    }
    tillbaka() {
        this.$router.push({
            name: "home"
        })
    }
    created() {
        this.$route.hash == "#search" ? this.aInitHomeStoreModule().then( () => {
            this.hamtaAmnesomradeOchKungorelsetyp() ? (this.gorSokning(),
            this.$router.replace({
                hash: ""
            })) : this.$router.push({
                name: "home"
            })
        }
        ) : (this.hamtaAmnesomradeOchKungorelsetyp(),
        St().getLan().then(n => {
            this.laddar = !1,
            setTimeout( () => {
                this.$route.meta.savedPosition && window.scrollTo({
                    ...this.$route.meta.savedPosition,
                    behavior: "instant"
                })
            }
            , 100)
        }
        ))
    }
    gorSokning() {
        En().resetSokHistorik(),
        St().getLan().then(n => {
            En().sokKungorelse({
                valtAmnesomrade: this.amnesomrade.id,
                valdKungorelsetyp: this.kungorelsetyp ? this.kungorelsetyp.id : void 0,
                tidsperiodFrom: this.gPubliseringsdatum,
                tidsperiodTom: this.gPubliseringsdatum
            }).then(r => {
                this.laddar = !1,
                r == "FOR_MANGA_TRAFFAR" && (this.visaMeddelande = !0,
                this.meddelande = "Vi kan inte visa kungörelserna eftersom det finns fler än 1 000 träffar. Sök den kungörelse du vill se.",
                this.meddelandeTyp = "info")
            }
            )
        }
        )
    }
    hamtaAmnesomradeOchKungorelsetyp() {
        return this.amnesomrade = this.amnesomraden.find(n => n.id == this.$route.params.amnesomrade),
        !(typeof this.amnesomrade > "u" || this.$route.params.kungorelsetyp && (this.kungorelsetyp = this.amnesomrade.kungorelserubriker.find(n => n.id == this.$route.params.kungorelsetyp),
        typeof this.kungorelsetyp > "u"))
    }
}
;
Kp = kL([Ct({
    components: {
        Sokresultat: tc,
        Meddelande: Ft,
        BSpinner: er
    }
})], Kp);
const _L = Et(Kp);
const wL = t => ($t("data-v-c0d80cdf"),
t = t(),
Tt(),
t)
  , xL = {
    key: 0,
    class: "d-flex justify-content-center mb-3"
}
  , SL = wL( () => c("span", {
    class: "visually-hidden"
}, "Laddar ...", -1))
  , $L = {
    key: 0
}
  , TL = {
    class: "mt-3"
}
  , CL = {
    class: "row"
}
  , EL = {
    class: "col-12"
};
function AL(t, e, n, r, a, s) {
    const l = ue("b-spinner")
      , i = ue("sokresultat")
      , o = ue("meddelande")
      , u = ue("b-form");
    return t.laddar ? (g(),
    _("div", xL, [x(l, {
        label: "Laddar..."
    }), SL])) : (g(),
    de(u, {
        key: 1
    }, {
        default: N( () => [c("h1", null, Q(t.amnesomrade.namn), 1), t.kungorelsetyp != null ? (g(),
        _("h2", $L, Q(t.kungorelsetyp.namn), 1)) : q("", !0), x(i, {
            sokresultat: t.sokKungorelseResultat
        }, null, 8, ["sokresultat"]), c("div", TL, [t.visaMeddelande ? (g(),
        de(o, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)]), c("div", CL, [c("div", EL, [c("button", {
            type: "button",
            class: "btn btn-link",
            onClick: e[0] || (e[0] = d => t.tillbaka())
        }, "« Tillbaka")])])]),
        _: 1
    }))
}
const ML = rt(_L, [["render", AL], ["__scopeId", "data-v-c0d80cdf"]]);
var OL = Object.defineProperty
  , NL = Object.getOwnPropertyDescriptor
  , DL = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? NL(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && OL(e, n, a),
    a
}
;
let zp = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "sokArsResultat", [])
    }
    tillbaka() {
        this.$router.push({
            name: "home"
        })
    }
    created() {
        Sn().antalNyaArs().then(n => {
            n > 1e3 ? (this.meddelande = "Sökningen gav för många träffar.",
            this.meddelandeTyp = "info") : Sn().hamtaNyaArs().then(r => {
                this.sokArsResultat = r,
                this.meddelande = "",
                this.meddelandeTyp = "info"
            }
            ).catch(r => {
                this.meddelande = "Tekniskt fel hos Bolagsverket. Försök igen senare.",
                this.meddelandeTyp = "danger"
            }
            )
        }
        ).catch(n => {
            this.meddelande = "Tekniskt fel hos Bolagsverket. Försök igen senare.",
            this.meddelandeTyp = "danger"
        }
        )
    }
}
;
zp = DL([Ct({
    components: {
        Sokarsresultat: cw,
        Meddelande: Ft
    }
})], zp);
const PL = Et(zp);
const FL = t => ($t("data-v-3111d7ca"),
t = t(),
Tt(),
t)
  , BL = FL( () => c("h1", null, "Senaste Årsredovsingar", -1))
  , VL = {
    key: 0
}
  , IL = {
    class: "d-flex justify-content-center mb-3"
}
  , RL = {
    key: 1
}
  , LL = {
    class: "mt-3"
}
  , jL = {
    class: "row"
}
  , UL = {
    class: "col-12"
};
function HL(t, e, n, r, a, s) {
    const l = ue("b-spinner")
      , i = ue("sokarsresultat")
      , o = ue("meddelande")
      , u = ue("b-form");
    return g(),
    de(u, null, {
        default: N( () => [BL, t.sokArsResultat.length == 0 && t.meddelande == "" ? (g(),
        _("div", VL, [c("div", IL, [x(l, {
            label: "Laddar..."
        })])])) : q("", !0), t.sokArsResultat.length > 0 ? (g(),
        _("div", RL, [x(i, {
            sokArsResultat: t.sokArsResultat,
            antalTraffar: t.sokArsResultat.length
        }, null, 8, ["sokArsResultat", "antalTraffar"])])) : q("", !0), c("div", LL, [t.meddelande != "" ? (g(),
        de(o, {
            key: 0,
            meddelande: t.meddelande,
            meddelandeTyp: t.meddelandeTyp
        }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0)]), c("div", jL, [c("div", UL, [c("button", {
            type: "button",
            class: "btn btn-link",
            onClick: e[0] || (e[0] = d => t.tillbaka())
        }, "« Tillbaka")])])]),
        _: 1
    })
}
const KL = rt(PL, [["render", HL], ["__scopeId", "data-v-3111d7ca"]]);
class Fa extends Jt {
    mapToKungorelse(e) {
        return e
    }
    mapFromKungorelse(e) {}
    valideraFormular() {
        return !1
    }
    rensaFormular() {}
    clS(e) {
        return e ? (e.replace("'", " ").replace(".", " ").replace(",", " ").replace(/<[^>]+>/g, "").trim,
        e) : ""
    }
}
function xn(t) {
    this.content = t
}
xn.prototype = {
    constructor: xn,
    find: function(t) {
        for (var e = 0; e < this.content.length; e += 2)
            if (this.content[e] === t)
                return e;
        return -1
    },
    get: function(t) {
        var e = this.find(t);
        return e == -1 ? void 0 : this.content[e + 1]
    },
    update: function(t, e, n) {
        var r = n && n != t ? this.remove(n) : this
          , a = r.find(t)
          , s = r.content.slice();
        return a == -1 ? s.push(n || t, e) : (s[a + 1] = e,
        n && (s[a] = n)),
        new xn(s)
    },
    remove: function(t) {
        var e = this.find(t);
        if (e == -1)
            return this;
        var n = this.content.slice();
        return n.splice(e, 2),
        new xn(n)
    },
    addToStart: function(t, e) {
        return new xn([t, e].concat(this.remove(t).content))
    },
    addToEnd: function(t, e) {
        var n = this.remove(t).content.slice();
        return n.push(t, e),
        new xn(n)
    },
    addBefore: function(t, e, n) {
        var r = this.remove(e)
          , a = r.content.slice()
          , s = r.find(t);
        return a.splice(s == -1 ? a.length : s, 0, e, n),
        new xn(a)
    },
    forEach: function(t) {
        for (var e = 0; e < this.content.length; e += 2)
            t(this.content[e], this.content[e + 1])
    },
    prepend: function(t) {
        return t = xn.from(t),
        t.size ? new xn(t.content.concat(this.subtract(t).content)) : this
    },
    append: function(t) {
        return t = xn.from(t),
        t.size ? new xn(this.subtract(t).content.concat(t.content)) : this
    },
    subtract: function(t) {
        var e = this;
        t = xn.from(t);
        for (var n = 0; n < t.content.length; n += 2)
            e = e.remove(t.content[n]);
        return e
    },
    toObject: function() {
        var t = {};
        return this.forEach(function(e, n) {
            t[e] = n
        }),
        t
    },
    get size() {
        return this.content.length >> 1
    }
};
xn.from = function(t) {
    if (t instanceof xn)
        return t;
    var e = [];
    if (t)
        for (var n in t)
            e.push(n, t[n]);
    return new xn(e)
}
;
function mw(t, e, n) {
    for (let r = 0; ; r++) {
        if (r == t.childCount || r == e.childCount)
            return t.childCount == e.childCount ? null : n;
        let a = t.child(r)
          , s = e.child(r);
        if (a == s) {
            n += a.nodeSize;
            continue
        }
        if (!a.sameMarkup(s))
            return n;
        if (a.isText && a.text != s.text) {
            for (let l = 0; a.text[l] == s.text[l]; l++)
                n++;
            return n
        }
        if (a.content.size || s.content.size) {
            let l = mw(a.content, s.content, n + 1);
            if (l != null)
                return l
        }
        n += a.nodeSize
    }
}
function vw(t, e, n, r) {
    for (let a = t.childCount, s = e.childCount; ; ) {
        if (a == 0 || s == 0)
            return a == s ? null : {
                a: n,
                b: r
            };
        let l = t.child(--a)
          , i = e.child(--s)
          , o = l.nodeSize;
        if (l == i) {
            n -= o,
            r -= o;
            continue
        }
        if (!l.sameMarkup(i))
            return {
                a: n,
                b: r
            };
        if (l.isText && l.text != i.text) {
            let u = 0
              , d = Math.min(l.text.length, i.text.length);
            for (; u < d && l.text[l.text.length - u - 1] == i.text[i.text.length - u - 1]; )
                u++,
                n--,
                r--;
            return {
                a: n,
                b: r
            }
        }
        if (l.content.size || i.content.size) {
            let u = vw(l.content, i.content, n - 1, r - 1);
            if (u)
                return u
        }
        n -= o,
        r -= o
    }
}
class Ae {
    constructor(e, n) {
        if (this.content = e,
        this.size = n || 0,
        n == null)
            for (let r = 0; r < e.length; r++)
                this.size += e[r].nodeSize
    }
    nodesBetween(e, n, r, a=0, s) {
        for (let l = 0, i = 0; i < n; l++) {
            let o = this.content[l]
              , u = i + o.nodeSize;
            if (u > e && r(o, a + i, s || null, l) !== !1 && o.content.size) {
                let d = i + 1;
                o.nodesBetween(Math.max(0, e - d), Math.min(o.content.size, n - d), r, a + d)
            }
            i = u
        }
    }
    descendants(e) {
        this.nodesBetween(0, this.size, e)
    }
    textBetween(e, n, r, a) {
        let s = ""
          , l = !0;
        return this.nodesBetween(e, n, (i, o) => {
            let u = i.isText ? i.text.slice(Math.max(e, o) - o, n - o) : i.isLeaf ? a ? typeof a == "function" ? a(i) : a : i.type.spec.leafText ? i.type.spec.leafText(i) : "" : "";
            i.isBlock && (i.isLeaf && u || i.isTextblock) && r && (l ? l = !1 : s += r),
            s += u
        }
        , 0),
        s
    }
    append(e) {
        if (!e.size)
            return this;
        if (!this.size)
            return e;
        let n = this.lastChild
          , r = e.firstChild
          , a = this.content.slice()
          , s = 0;
        for (n.isText && n.sameMarkup(r) && (a[a.length - 1] = n.withText(n.text + r.text),
        s = 1); s < e.content.length; s++)
            a.push(e.content[s]);
        return new Ae(a,this.size + e.size)
    }
    cut(e, n=this.size) {
        if (e == 0 && n == this.size)
            return this;
        let r = []
          , a = 0;
        if (n > e)
            for (let s = 0, l = 0; l < n; s++) {
                let i = this.content[s]
                  , o = l + i.nodeSize;
                o > e && ((l < e || o > n) && (i.isText ? i = i.cut(Math.max(0, e - l), Math.min(i.text.length, n - l)) : i = i.cut(Math.max(0, e - l - 1), Math.min(i.content.size, n - l - 1))),
                r.push(i),
                a += i.nodeSize),
                l = o
            }
        return new Ae(r,a)
    }
    cutByIndex(e, n) {
        return e == n ? Ae.empty : e == 0 && n == this.content.length ? this : new Ae(this.content.slice(e, n))
    }
    replaceChild(e, n) {
        let r = this.content[e];
        if (r == n)
            return this;
        let a = this.content.slice()
          , s = this.size + n.nodeSize - r.nodeSize;
        return a[e] = n,
        new Ae(a,s)
    }
    addToStart(e) {
        return new Ae([e].concat(this.content),this.size + e.nodeSize)
    }
    addToEnd(e) {
        return new Ae(this.content.concat(e),this.size + e.nodeSize)
    }
    eq(e) {
        if (this.content.length != e.content.length)
            return !1;
        for (let n = 0; n < this.content.length; n++)
            if (!this.content[n].eq(e.content[n]))
                return !1;
        return !0
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null
    }
    get childCount() {
        return this.content.length
    }
    child(e) {
        let n = this.content[e];
        if (!n)
            throw new RangeError("Index " + e + " out of range for " + this);
        return n
    }
    maybeChild(e) {
        return this.content[e] || null
    }
    forEach(e) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let a = this.content[n];
            e(a, r, n),
            r += a.nodeSize
        }
    }
    findDiffStart(e, n=0) {
        return mw(this, e, n)
    }
    findDiffEnd(e, n=this.size, r=e.size) {
        return vw(this, e, n, r)
    }
    findIndex(e, n=-1) {
        if (e == 0)
            return yu(0, e);
        if (e == this.size)
            return yu(this.content.length, e);
        if (e > this.size || e < 0)
            throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let r = 0, a = 0; ; r++) {
            let s = this.child(r)
              , l = a + s.nodeSize;
            if (l >= e)
                return l == e || n > 0 ? yu(r + 1, l) : yu(r, a);
            a = l
        }
    }
    toString() {
        return "<" + this.toStringInner() + ">"
    }
    toStringInner() {
        return this.content.join(", ")
    }
    toJSON() {
        return this.content.length ? this.content.map(e => e.toJSON()) : null
    }
    static fromJSON(e, n) {
        if (!n)
            return Ae.empty;
        if (!Array.isArray(n))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new Ae(n.map(e.nodeFromJSON))
    }
    static fromArray(e) {
        if (!e.length)
            return Ae.empty;
        let n, r = 0;
        for (let a = 0; a < e.length; a++) {
            let s = e[a];
            r += s.nodeSize,
            a && s.isText && e[a - 1].sameMarkup(s) ? (n || (n = e.slice(0, a)),
            n[n.length - 1] = s.withText(n[n.length - 1].text + s.text)) : n && n.push(s)
        }
        return new Ae(n || e,r)
    }
    static from(e) {
        if (!e)
            return Ae.empty;
        if (e instanceof Ae)
            return e;
        if (Array.isArray(e))
            return this.fromArray(e);
        if (e.attrs)
            return new Ae([e],e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    }
}
Ae.empty = new Ae([],0);
const bf = {
    index: 0,
    offset: 0
};
function yu(t, e) {
    return bf.index = t,
    bf.offset = e,
    bf
}
function sd(t, e) {
    if (t === e)
        return !0;
    if (!(t && typeof t == "object") || !(e && typeof e == "object"))
        return !1;
    let n = Array.isArray(t);
    if (Array.isArray(e) != n)
        return !1;
    if (n) {
        if (t.length != e.length)
            return !1;
        for (let r = 0; r < t.length; r++)
            if (!sd(t[r], e[r]))
                return !1
    } else {
        for (let r in t)
            if (!(r in e) || !sd(t[r], e[r]))
                return !1;
        for (let r in e)
            if (!(r in t))
                return !1
    }
    return !0
}
let Bt = class qp {
    constructor(e, n) {
        this.type = e,
        this.attrs = n
    }
    addToSet(e) {
        let n, r = !1;
        for (let a = 0; a < e.length; a++) {
            let s = e[a];
            if (this.eq(s))
                return e;
            if (this.type.excludes(s.type))
                n || (n = e.slice(0, a));
            else {
                if (s.type.excludes(this.type))
                    return e;
                !r && s.type.rank > this.type.rank && (n || (n = e.slice(0, a)),
                n.push(this),
                r = !0),
                n && n.push(s)
            }
        }
        return n || (n = e.slice()),
        r || n.push(this),
        n
    }
    removeFromSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return e.slice(0, n).concat(e.slice(n + 1));
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return !0;
        return !1
    }
    eq(e) {
        return this == e || this.type == e.type && sd(this.attrs, e.attrs)
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let r = e.marks[n.type];
        if (!r)
            throw new RangeError(`There is no mark type ${n.type} in this schema`);
        return r.create(n.attrs)
    }
    static sameSet(e, n) {
        if (e == n)
            return !0;
        if (e.length != n.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!e[r].eq(n[r]))
                return !1;
        return !0
    }
    static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
            return qp.none;
        if (e instanceof qp)
            return [e];
        let n = e.slice();
        return n.sort( (r, a) => r.type.rank - a.type.rank),
        n
    }
}
;
Bt.none = [];
class ld extends Error {
}
class Ie {
    constructor(e, n, r) {
        this.content = e,
        this.openStart = n,
        this.openEnd = r
    }
    get size() {
        return this.content.size - this.openStart - this.openEnd
    }
    insertAt(e, n) {
        let r = bw(this.content, e + this.openStart, n);
        return r && new Ie(r,this.openStart,this.openEnd)
    }
    removeBetween(e, n) {
        return new Ie(gw(this.content, e + this.openStart, n + this.openStart),this.openStart,this.openEnd)
    }
    eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd
    }
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    }
    toJSON() {
        if (!this.content.size)
            return null;
        let e = {
            content: this.content.toJSON()
        };
        return this.openStart > 0 && (e.openStart = this.openStart),
        this.openEnd > 0 && (e.openEnd = this.openEnd),
        e
    }
    static fromJSON(e, n) {
        if (!n)
            return Ie.empty;
        let r = n.openStart || 0
          , a = n.openEnd || 0;
        if (typeof r != "number" || typeof a != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new Ie(Ae.fromJSON(e, n.content),r,a)
    }
    static maxOpen(e, n=!0) {
        let r = 0
          , a = 0;
        for (let s = e.firstChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.firstChild)
            r++;
        for (let s = e.lastChild; s && !s.isLeaf && (n || !s.type.spec.isolating); s = s.lastChild)
            a++;
        return new Ie(e,r,a)
    }
}
Ie.empty = new Ie(Ae.empty,0,0);
function gw(t, e, n) {
    let {index: r, offset: a} = t.findIndex(e)
      , s = t.maybeChild(r)
      , {index: l, offset: i} = t.findIndex(n);
    if (a == e || s.isText) {
        if (i != n && !t.child(l).isText)
            throw new RangeError("Removing non-flat range");
        return t.cut(0, e).append(t.cut(n))
    }
    if (r != l)
        throw new RangeError("Removing non-flat range");
    return t.replaceChild(r, s.copy(gw(s.content, e - a - 1, n - a - 1)))
}
function bw(t, e, n, r) {
    let {index: a, offset: s} = t.findIndex(e)
      , l = t.maybeChild(a);
    if (s == e || l.isText)
        return r && !r.canReplace(a, a, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
    let i = bw(l.content, e - s - 1, n);
    return i && t.replaceChild(a, l.copy(i))
}
function zL(t, e, n) {
    if (n.openStart > t.depth)
        throw new ld("Inserted content deeper than insertion position");
    if (t.depth - n.openStart != e.depth - n.openEnd)
        throw new ld("Inconsistent open depths");
    return yw(t, e, n, 0)
}
function yw(t, e, n, r) {
    let a = t.index(r)
      , s = t.node(r);
    if (a == e.index(r) && r < t.depth - n.openStart) {
        let l = yw(t, e, n, r + 1);
        return s.copy(s.content.replaceChild(a, l))
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
            let l = t.parent
              , i = l.content;
            return Js(l, i.cut(0, t.parentOffset).append(n.content).append(i.cut(e.parentOffset)))
        } else {
            let {start: l, end: i} = qL(n, t);
            return Js(s, _w(t, l, i, e, r))
        }
    else
        return Js(s, id(t, e, r))
}
function kw(t, e) {
    if (!e.type.compatibleContent(t.type))
        throw new ld("Cannot join " + e.type.name + " onto " + t.type.name)
}
function Wp(t, e, n) {
    let r = t.node(n);
    return kw(r, e.node(n)),
    r
}
function Ys(t, e) {
    let n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t)
}
function co(t, e, n, r) {
    let a = (e || t).node(n)
      , s = 0
      , l = e ? e.index(n) : a.childCount;
    t && (s = t.index(n),
    t.depth > n ? s++ : t.textOffset && (Ys(t.nodeAfter, r),
    s++));
    for (let i = s; i < l; i++)
        Ys(a.child(i), r);
    e && e.depth == n && e.textOffset && Ys(e.nodeBefore, r)
}
function Js(t, e) {
    return t.type.checkContent(e),
    t.copy(e)
}
function _w(t, e, n, r, a) {
    let s = t.depth > a && Wp(t, e, a + 1)
      , l = r.depth > a && Wp(n, r, a + 1)
      , i = [];
    return co(null, t, a, i),
    s && l && e.index(a) == n.index(a) ? (kw(s, l),
    Ys(Js(s, _w(t, e, n, r, a + 1)), i)) : (s && Ys(Js(s, id(t, e, a + 1)), i),
    co(e, n, a, i),
    l && Ys(Js(l, id(n, r, a + 1)), i)),
    co(r, null, a, i),
    new Ae(i)
}
function id(t, e, n) {
    let r = [];
    if (co(null, t, n, r),
    t.depth > n) {
        let a = Wp(t, e, n + 1);
        Ys(Js(a, id(t, e, n + 1)), r)
    }
    return co(e, null, n, r),
    new Ae(r)
}
function qL(t, e) {
    let n = e.depth - t.openStart
      , a = e.node(n).copy(t.content);
    for (let s = n - 1; s >= 0; s--)
        a = e.node(s).copy(Ae.from(a));
    return {
        start: a.resolveNoCache(t.openStart + n),
        end: a.resolveNoCache(a.content.size - t.openEnd - n)
    }
}
class Eo {
    constructor(e, n, r) {
        this.pos = e,
        this.path = n,
        this.parentOffset = r,
        this.depth = n.length / 3 - 1
    }
    resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e
    }
    get parent() {
        return this.node(this.depth)
    }
    get doc() {
        return this.node(0)
    }
    node(e) {
        return this.path[this.resolveDepth(e) * 3]
    }
    index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1]
    }
    indexAfter(e) {
        return e = this.resolveDepth(e),
        this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    }
    start(e) {
        return e = this.resolveDepth(e),
        e == 0 ? 0 : this.path[e * 3 - 1] + 1
    }
    end(e) {
        return e = this.resolveDepth(e),
        this.start(e) + this.node(e).content.size
    }
    before(e) {
        if (e = this.resolveDepth(e),
        !e)
            throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1]
    }
    after(e) {
        if (e = this.resolveDepth(e),
        !e)
            throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize
    }
    get textOffset() {
        return this.pos - this.path[this.path.length - 1]
    }
    get nodeAfter() {
        let e = this.parent
          , n = this.index(this.depth);
        if (n == e.childCount)
            return null;
        let r = this.pos - this.path[this.path.length - 1]
          , a = e.child(n);
        return r ? e.child(n).cut(r) : a
    }
    get nodeBefore() {
        let e = this.index(this.depth)
          , n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1)
    }
    posAtIndex(e, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3]
          , a = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let s = 0; s < e; s++)
            a += r.child(s).nodeSize;
        return a
    }
    marks() {
        let e = this.parent
          , n = this.index();
        if (e.content.size == 0)
            return Bt.none;
        if (this.textOffset)
            return e.child(n).marks;
        let r = e.maybeChild(n - 1)
          , a = e.maybeChild(n);
        if (!r) {
            let i = r;
            r = a,
            a = i
        }
        let s = r.marks;
        for (var l = 0; l < s.length; l++)
            s[l].type.spec.inclusive === !1 && (!a || !s[l].isInSet(a.marks)) && (s = s[l--].removeFromSet(s));
        return s
    }
    marksAcross(e) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
            return null;
        let r = n.marks
          , a = e.parent.maybeChild(e.index());
        for (var s = 0; s < r.length; s++)
            r[s].type.spec.inclusive === !1 && (!a || !r[s].isInSet(a.marks)) && (r = r[s--].removeFromSet(r));
        return r
    }
    sharedDepth(e) {
        for (let n = this.depth; n > 0; n--)
            if (this.start(n) <= e && this.end(n) >= e)
                return n;
        return 0
    }
    blockRange(e=this, n) {
        if (e.pos < this.pos)
            return e.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
            if (e.pos <= this.end(r) && (!n || n(this.node(r))))
                return new od(this,e,r);
        return null
    }
    sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset
    }
    max(e) {
        return e.pos > this.pos ? e : this
    }
    min(e) {
        return e.pos < this.pos ? e : this
    }
    toString() {
        let e = "";
        for (let n = 1; n <= this.depth; n++)
            e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return e + ":" + this.parentOffset
    }
    static resolve(e, n) {
        if (!(n >= 0 && n <= e.content.size))
            throw new RangeError("Position " + n + " out of range");
        let r = []
          , a = 0
          , s = n;
        for (let l = e; ; ) {
            let {index: i, offset: o} = l.content.findIndex(s)
              , u = s - o;
            if (r.push(l, i, a + o),
            !u || (l = l.child(i),
            l.isText))
                break;
            s = u - 1,
            a += o + 1
        }
        return new Eo(n,r,s)
    }
    static resolveCached(e, n) {
        for (let a = 0; a < yf.length; a++) {
            let s = yf[a];
            if (s.pos == n && s.doc == e)
                return s
        }
        let r = yf[kf] = Eo.resolve(e, n);
        return kf = (kf + 1) % WL,
        r
    }
}
let yf = []
  , kf = 0
  , WL = 12;
class od {
    constructor(e, n, r) {
        this.$from = e,
        this.$to = n,
        this.depth = r
    }
    get start() {
        return this.$from.before(this.depth + 1)
    }
    get end() {
        return this.$to.after(this.depth + 1)
    }
    get parent() {
        return this.$from.node(this.depth)
    }
    get startIndex() {
        return this.$from.index(this.depth)
    }
    get endIndex() {
        return this.$to.indexAfter(this.depth)
    }
}
const GL = Object.create(null);
let Xs = class Gp {
    constructor(e, n, r, a=Bt.none) {
        this.type = e,
        this.attrs = n,
        this.marks = a,
        this.content = r || Ae.empty
    }
    get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size
    }
    get childCount() {
        return this.content.childCount
    }
    child(e) {
        return this.content.child(e)
    }
    maybeChild(e) {
        return this.content.maybeChild(e)
    }
    forEach(e) {
        this.content.forEach(e)
    }
    nodesBetween(e, n, r, a=0) {
        this.content.nodesBetween(e, n, r, a, this)
    }
    descendants(e) {
        this.nodesBetween(0, this.content.size, e)
    }
    get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
    }
    textBetween(e, n, r, a) {
        return this.content.textBetween(e, n, r, a)
    }
    get firstChild() {
        return this.content.firstChild
    }
    get lastChild() {
        return this.content.lastChild
    }
    eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content)
    }
    sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks)
    }
    hasMarkup(e, n, r) {
        return this.type == e && sd(this.attrs, n || e.defaultAttrs || GL) && Bt.sameSet(this.marks, r || Bt.none)
    }
    copy(e=null) {
        return e == this.content ? this : new Gp(this.type,this.attrs,e,this.marks)
    }
    mark(e) {
        return e == this.marks ? this : new Gp(this.type,this.attrs,this.content,e)
    }
    cut(e, n=this.content.size) {
        return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n))
    }
    slice(e, n=this.content.size, r=!1) {
        if (e == n)
            return Ie.empty;
        let a = this.resolve(e)
          , s = this.resolve(n)
          , l = r ? 0 : a.sharedDepth(n)
          , i = a.start(l)
          , u = a.node(l).content.cut(a.pos - i, s.pos - i);
        return new Ie(u,a.depth - l,s.depth - l)
    }
    replace(e, n, r) {
        return zL(this.resolve(e), this.resolve(n), r)
    }
    nodeAt(e) {
        for (let n = this; ; ) {
            let {index: r, offset: a} = n.content.findIndex(e);
            if (n = n.maybeChild(r),
            !n)
                return null;
            if (a == e || n.isText)
                return n;
            e -= a + 1
        }
    }
    childAfter(e) {
        let {index: n, offset: r} = this.content.findIndex(e);
        return {
            node: this.content.maybeChild(n),
            index: n,
            offset: r
        }
    }
    childBefore(e) {
        if (e == 0)
            return {
                node: null,
                index: 0,
                offset: 0
            };
        let {index: n, offset: r} = this.content.findIndex(e);
        if (r < e)
            return {
                node: this.content.child(n),
                index: n,
                offset: r
            };
        let a = this.content.child(n - 1);
        return {
            node: a,
            index: n - 1,
            offset: r - a.nodeSize
        }
    }
    resolve(e) {
        return Eo.resolveCached(this, e)
    }
    resolveNoCache(e) {
        return Eo.resolve(this, e)
    }
    rangeHasMark(e, n, r) {
        let a = !1;
        return n > e && this.nodesBetween(e, n, s => (r.isInSet(s.marks) && (a = !0),
        !a)),
        a
    }
    get isBlock() {
        return this.type.isBlock
    }
    get isTextblock() {
        return this.type.isTextblock
    }
    get inlineContent() {
        return this.type.inlineContent
    }
    get isInline() {
        return this.type.isInline
    }
    get isText() {
        return this.type.isText
    }
    get isLeaf() {
        return this.type.isLeaf
    }
    get isAtom() {
        return this.type.isAtom
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"),
        ww(this.marks, e)
    }
    contentMatchAt(e) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!n)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return n
    }
    canReplace(e, n, r=Ae.empty, a=0, s=r.childCount) {
        let l = this.contentMatchAt(e).matchFragment(r, a, s)
          , i = l && l.matchFragment(this.content, n);
        if (!i || !i.validEnd)
            return !1;
        for (let o = a; o < s; o++)
            if (!this.type.allowsMarks(r.child(o).marks))
                return !1;
        return !0
    }
    canReplaceWith(e, n, r, a) {
        if (a && !this.type.allowsMarks(a))
            return !1;
        let s = this.contentMatchAt(e).matchType(r)
          , l = s && s.matchFragment(this.content, n);
        return l ? l.validEnd : !1
    }
    canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type)
    }
    check() {
        this.type.checkContent(this.content);
        let e = Bt.none;
        for (let n = 0; n < this.marks.length; n++)
            e = this.marks[n].addToSet(e);
        if (!Bt.sameSet(e, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`);
        this.content.forEach(n => n.check())
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return this.content.size && (e.content = this.content.toJSON()),
        this.marks.length && (e.marks = this.marks.map(n => n.toJSON())),
        e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Node.fromJSON");
        let r = null;
        if (n.marks) {
            if (!Array.isArray(n.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            r = n.marks.map(e.markFromJSON)
        }
        if (n.type == "text") {
            if (typeof n.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return e.text(n.text, r)
        }
        let a = Ae.fromJSON(e, n.content);
        return e.nodeType(n.type).create(n.attrs, a, r)
    }
}
;
Xs.prototype.text = void 0;
class ud extends Xs {
    constructor(e, n, r, a) {
        if (super(e, n, null, a),
        !r)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = r
    }
    toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : ww(this.marks, JSON.stringify(this.text))
    }
    get textContent() {
        return this.text
    }
    textBetween(e, n) {
        return this.text.slice(e, n)
    }
    get nodeSize() {
        return this.text.length
    }
    mark(e) {
        return e == this.marks ? this : new ud(this.type,this.attrs,this.text,e)
    }
    withText(e) {
        return e == this.text ? this : new ud(this.type,this.attrs,e,this.marks)
    }
    cut(e=0, n=this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n))
    }
    eq(e) {
        return this.sameMarkup(e) && this.text == e.text
    }
    toJSON() {
        let e = super.toJSON();
        return e.text = this.text,
        e
    }
}
function ww(t, e) {
    for (let n = t.length - 1; n >= 0; n--)
        e = t[n].type.name + "(" + e + ")";
    return e
}
class ll {
    constructor(e) {
        this.validEnd = e,
        this.next = [],
        this.wrapCache = []
    }
    static parse(e, n) {
        let r = new YL(e,n);
        if (r.next == null)
            return ll.empty;
        let a = xw(r);
        r.next && r.err("Unexpected trailing text");
        let s = nj(tj(a));
        return rj(s, r),
        s
    }
    matchType(e) {
        for (let n = 0; n < this.next.length; n++)
            if (this.next[n].type == e)
                return this.next[n].next;
        return null
    }
    matchFragment(e, n=0, r=e.childCount) {
        let a = this;
        for (let s = n; a && s < r; s++)
            a = a.matchType(e.child(s).type);
        return a
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline
    }
    get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
            let {type: n} = this.next[e];
            if (!(n.isText || n.hasRequiredAttrs()))
                return n
        }
        return null
    }
    compatible(e) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < e.next.length; r++)
                if (this.next[n].type == e.next[r].type)
                    return !0;
        return !1
    }
    fillBefore(e, n=!1, r=0) {
        let a = [this];
        function s(l, i) {
            let o = l.matchFragment(e, r);
            if (o && (!n || o.validEnd))
                return Ae.from(i.map(u => u.createAndFill()));
            for (let u = 0; u < l.next.length; u++) {
                let {type: d, next: f} = l.next[u];
                if (!(d.isText || d.hasRequiredAttrs()) && a.indexOf(f) == -1) {
                    a.push(f);
                    let p = s(f, i.concat(d));
                    if (p)
                        return p
                }
            }
            return null
        }
        return s(this, [])
    }
    findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
            if (this.wrapCache[r] == e)
                return this.wrapCache[r + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n),
        n
    }
    computeWrapping(e) {
        let n = Object.create(null)
          , r = [{
            match: this,
            type: null,
            via: null
        }];
        for (; r.length; ) {
            let a = r.shift()
              , s = a.match;
            if (s.matchType(e)) {
                let l = [];
                for (let i = a; i.type; i = i.via)
                    l.push(i.type);
                return l.reverse()
            }
            for (let l = 0; l < s.next.length; l++) {
                let {type: i, next: o} = s.next[l];
                !i.isLeaf && !i.hasRequiredAttrs() && !(i.name in n) && (!a.type || o.validEnd) && (r.push({
                    match: i.contentMatch,
                    type: i,
                    via: a
                }),
                n[i.name] = !0)
            }
        }
        return null
    }
    get edgeCount() {
        return this.next.length
    }
    edge(e) {
        if (e >= this.next.length)
            throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e]
    }
    toString() {
        let e = [];
        function n(r) {
            e.push(r);
            for (let a = 0; a < r.next.length; a++)
                e.indexOf(r.next[a].next) == -1 && n(r.next[a].next)
        }
        return n(this),
        e.map( (r, a) => {
            let s = a + (r.validEnd ? "*" : " ") + " ";
            for (let l = 0; l < r.next.length; l++)
                s += (l ? ", " : "") + r.next[l].type.name + "->" + e.indexOf(r.next[l].next);
            return s
        }
        ).join(`
`)
    }
}
ll.empty = new ll(!0);
class YL {
    constructor(e, n) {
        this.string = e,
        this.nodeTypes = n,
        this.inline = null,
        this.pos = 0,
        this.tokens = e.split(/\s*(?=\b|\W|$)/),
        this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
        this.tokens[0] == "" && this.tokens.shift()
    }
    get next() {
        return this.tokens[this.pos]
    }
    eat(e) {
        return this.next == e && (this.pos++ || !0)
    }
    err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')")
    }
}
function xw(t) {
    let e = [];
    do
        e.push(JL(t));
    while (t.eat("|"));
    return e.length == 1 ? e[0] : {
        type: "choice",
        exprs: e
    }
}
function JL(t) {
    let e = [];
    do
        e.push(XL(t));
    while (t.next && t.next != ")" && t.next != "|");
    return e.length == 1 ? e[0] : {
        type: "seq",
        exprs: e
    }
}
function XL(t) {
    let e = ej(t);
    for (; ; )
        if (t.eat("+"))
            e = {
                type: "plus",
                expr: e
            };
        else if (t.eat("*"))
            e = {
                type: "star",
                expr: e
            };
        else if (t.eat("?"))
            e = {
                type: "opt",
                expr: e
            };
        else if (t.eat("{"))
            e = QL(t, e);
        else
            break;
    return e
}
function Jb(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    let e = Number(t.next);
    return t.pos++,
    e
}
function QL(t, e) {
    let n = Jb(t)
      , r = n;
    return t.eat(",") && (t.next != "}" ? r = Jb(t) : r = -1),
    t.eat("}") || t.err("Unclosed braced range"),
    {
        type: "range",
        min: n,
        max: r,
        expr: e
    }
}
function ZL(t, e) {
    let n = t.nodeTypes
      , r = n[e];
    if (r)
        return [r];
    let a = [];
    for (let s in n) {
        let l = n[s];
        l.groups.indexOf(e) > -1 && a.push(l)
    }
    return a.length == 0 && t.err("No node type or group '" + e + "' found"),
    a
}
function ej(t) {
    if (t.eat("(")) {
        let e = xw(t);
        return t.eat(")") || t.err("Missing closing paren"),
        e
    } else if (/\W/.test(t.next))
        t.err("Unexpected token '" + t.next + "'");
    else {
        let e = ZL(t, t.next).map(n => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"),
        {
            type: "name",
            value: n
        }));
        return t.pos++,
        e.length == 1 ? e[0] : {
            type: "choice",
            exprs: e
        }
    }
}
function tj(t) {
    let e = [[]];
    return a(s(t, 0), n()),
    e;
    function n() {
        return e.push([]) - 1
    }
    function r(l, i, o) {
        let u = {
            term: o,
            to: i
        };
        return e[l].push(u),
        u
    }
    function a(l, i) {
        l.forEach(o => o.to = i)
    }
    function s(l, i) {
        if (l.type == "choice")
            return l.exprs.reduce( (o, u) => o.concat(s(u, i)), []);
        if (l.type == "seq")
            for (let o = 0; ; o++) {
                let u = s(l.exprs[o], i);
                if (o == l.exprs.length - 1)
                    return u;
                a(u, i = n())
            }
        else if (l.type == "star") {
            let o = n();
            return r(i, o),
            a(s(l.expr, o), o),
            [r(o)]
        } else if (l.type == "plus") {
            let o = n();
            return a(s(l.expr, i), o),
            a(s(l.expr, o), o),
            [r(o)]
        } else {
            if (l.type == "opt")
                return [r(i)].concat(s(l.expr, i));
            if (l.type == "range") {
                let o = i;
                for (let u = 0; u < l.min; u++) {
                    let d = n();
                    a(s(l.expr, o), d),
                    o = d
                }
                if (l.max == -1)
                    a(s(l.expr, o), o);
                else
                    for (let u = l.min; u < l.max; u++) {
                        let d = n();
                        r(o, d),
                        a(s(l.expr, o), d),
                        o = d
                    }
                return [r(o)]
            } else {
                if (l.type == "name")
                    return [r(i, void 0, l.value)];
                throw new Error("Unknown expr type")
            }
        }
    }
}
function Sw(t, e) {
    return e - t
}
function Xb(t, e) {
    let n = [];
    return r(e),
    n.sort(Sw);
    function r(a) {
        let s = t[a];
        if (s.length == 1 && !s[0].term)
            return r(s[0].to);
        n.push(a);
        for (let l = 0; l < s.length; l++) {
            let {term: i, to: o} = s[l];
            !i && n.indexOf(o) == -1 && r(o)
        }
    }
}
function nj(t) {
    let e = Object.create(null);
    return n(Xb(t, 0));
    function n(r) {
        let a = [];
        r.forEach(l => {
            t[l].forEach( ({term: i, to: o}) => {
                if (!i)
                    return;
                let u;
                for (let d = 0; d < a.length; d++)
                    a[d][0] == i && (u = a[d][1]);
                Xb(t, o).forEach(d => {
                    u || a.push([i, u = []]),
                    u.indexOf(d) == -1 && u.push(d)
                }
                )
            }
            )
        }
        );
        let s = e[r.join(",")] = new ll(r.indexOf(t.length - 1) > -1);
        for (let l = 0; l < a.length; l++) {
            let i = a[l][1].sort(Sw);
            s.next.push({
                type: a[l][0],
                next: e[i.join(",")] || n(i)
            })
        }
        return s
    }
}
function rj(t, e) {
    for (let n = 0, r = [t]; n < r.length; n++) {
        let a = r[n]
          , s = !a.validEnd
          , l = [];
        for (let i = 0; i < a.next.length; i++) {
            let {type: o, next: u} = a.next[i];
            l.push(o.name),
            s && !(o.isText || o.hasRequiredAttrs()) && (s = !1),
            r.indexOf(u) == -1 && r.push(u)
        }
        s && e.err("Only non-generatable nodes (" + l.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
    }
}
function $w(t) {
    let e = Object.create(null);
    for (let n in t) {
        let r = t[n];
        if (!r.hasDefault)
            return null;
        e[n] = r.default
    }
    return e
}
function Tw(t, e) {
    let n = Object.create(null);
    for (let r in t) {
        let a = e && e[r];
        if (a === void 0) {
            let s = t[r];
            if (s.hasDefault)
                a = s.default;
            else
                throw new RangeError("No value supplied for attribute " + r)
        }
        n[r] = a
    }
    return n
}
function Cw(t) {
    let e = Object.create(null);
    if (t)
        for (let n in t)
            e[n] = new aj(t[n]);
    return e
}
let Qb = class Ew {
    constructor(e, n, r) {
        this.name = e,
        this.schema = n,
        this.spec = r,
        this.markSet = null,
        this.groups = r.group ? r.group.split(" ") : [],
        this.attrs = Cw(r.attrs),
        this.defaultAttrs = $w(this.attrs),
        this.contentMatch = null,
        this.inlineContent = null,
        this.isBlock = !(r.inline || e == "text"),
        this.isText = e == "text"
    }
    get isInline() {
        return !this.isBlock
    }
    get isTextblock() {
        return this.isBlock && this.inlineContent
    }
    get isLeaf() {
        return this.contentMatch == ll.empty
    }
    get isAtom() {
        return this.isLeaf || !!this.spec.atom
    }
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
    }
    hasRequiredAttrs() {
        for (let e in this.attrs)
            if (this.attrs[e].isRequired)
                return !0;
        return !1
    }
    compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch)
    }
    computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : Tw(this.attrs, e)
    }
    create(e=null, n, r) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new Xs(this,this.computeAttrs(e),Ae.from(n),Bt.setFrom(r))
    }
    createChecked(e=null, n, r) {
        return n = Ae.from(n),
        this.checkContent(n),
        new Xs(this,this.computeAttrs(e),n,Bt.setFrom(r))
    }
    createAndFill(e=null, n, r) {
        if (e = this.computeAttrs(e),
        n = Ae.from(n),
        n.size) {
            let l = this.contentMatch.fillBefore(n);
            if (!l)
                return null;
            n = l.append(n)
        }
        let a = this.contentMatch.matchFragment(n)
          , s = a && a.fillBefore(Ae.empty, !0);
        return s ? new Xs(this,e,n.append(s),Bt.setFrom(r)) : null
    }
    validContent(e) {
        let n = this.contentMatch.matchFragment(e);
        if (!n || !n.validEnd)
            return !1;
        for (let r = 0; r < e.childCount; r++)
            if (!this.allowsMarks(e.child(r).marks))
                return !1;
        return !0
    }
    checkContent(e) {
        if (!this.validContent(e))
            throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`)
    }
    allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1
    }
    allowsMarks(e) {
        if (this.markSet == null)
            return !0;
        for (let n = 0; n < e.length; n++)
            if (!this.allowsMarkType(e[n].type))
                return !1;
        return !0
    }
    allowedMarks(e) {
        if (this.markSet == null)
            return e;
        let n;
        for (let r = 0; r < e.length; r++)
            this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
        return n ? n.length ? n : Bt.none : e
    }
    static compile(e, n) {
        let r = Object.create(null);
        e.forEach( (s, l) => r[s] = new Ew(s,n,l));
        let a = n.spec.topNode || "doc";
        if (!r[a])
            throw new RangeError("Schema is missing its top node type ('" + a + "')");
        if (!r.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let s in r.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return r
    }
}
;
class aj {
    constructor(e) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"),
        this.default = e.default
    }
    get isRequired() {
        return !this.hasDefault
    }
}
class fc {
    constructor(e, n, r, a) {
        this.name = e,
        this.rank = n,
        this.schema = r,
        this.spec = a,
        this.attrs = Cw(a.attrs),
        this.excluded = null;
        let s = $w(this.attrs);
        this.instance = s ? new Bt(this,s) : null
    }
    create(e=null) {
        return !e && this.instance ? this.instance : new Bt(this,Tw(this.attrs, e))
    }
    static compile(e, n) {
        let r = Object.create(null)
          , a = 0;
        return e.forEach( (s, l) => r[s] = new fc(s,a++,n,l)),
        r
    }
    removeFromSet(e) {
        for (var n = 0; n < e.length; n++)
            e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)),
            n--);
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (e[n].type == this)
                return e[n]
    }
    excludes(e) {
        return this.excluded.indexOf(e) > -1
    }
}
class sj {
    constructor(e) {
        this.cached = Object.create(null);
        let n = this.spec = {};
        for (let a in e)
            n[a] = e[a];
        n.nodes = xn.from(e.nodes),
        n.marks = xn.from(e.marks || {}),
        this.nodes = Qb.compile(this.spec.nodes, this),
        this.marks = fc.compile(this.spec.marks, this);
        let r = Object.create(null);
        for (let a in this.nodes) {
            if (a in this.marks)
                throw new RangeError(a + " can not be both a node and a mark");
            let s = this.nodes[a]
              , l = s.spec.content || ""
              , i = s.spec.marks;
            s.contentMatch = r[l] || (r[l] = ll.parse(l, this.nodes)),
            s.inlineContent = s.contentMatch.inlineContent,
            s.markSet = i == "_" ? null : i ? Zb(this, i.split(" ")) : i == "" || !s.inlineContent ? [] : null
        }
        for (let a in this.marks) {
            let s = this.marks[a]
              , l = s.spec.excludes;
            s.excluded = l == null ? [s] : l == "" ? [] : Zb(this, l.split(" "))
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this),
        this.markFromJSON = this.markFromJSON.bind(this),
        this.topNodeType = this.nodes[this.spec.topNode || "doc"],
        this.cached.wrappings = Object.create(null)
    }
    node(e, n=null, r, a) {
        if (typeof e == "string")
            e = this.nodeType(e);
        else if (e instanceof Qb) {
            if (e.schema != this)
                throw new RangeError("Node type from different schema used (" + e.name + ")")
        } else
            throw new RangeError("Invalid node type: " + e);
        return e.createChecked(n, r, a)
    }
    text(e, n) {
        let r = this.nodes.text;
        return new ud(r,r.defaultAttrs,e,Bt.setFrom(n))
    }
    mark(e, n) {
        return typeof e == "string" && (e = this.marks[e]),
        e.create(n)
    }
    nodeFromJSON(e) {
        return Xs.fromJSON(this, e)
    }
    markFromJSON(e) {
        return Bt.fromJSON(this, e)
    }
    nodeType(e) {
        let n = this.nodes[e];
        if (!n)
            throw new RangeError("Unknown node type: " + e);
        return n
    }
}
function Zb(t, e) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let a = e[r]
          , s = t.marks[a]
          , l = s;
        if (s)
            n.push(s);
        else
            for (let i in t.marks) {
                let o = t.marks[i];
                (a == "_" || o.spec.group && o.spec.group.split(" ").indexOf(a) > -1) && n.push(l = o)
            }
        if (!l)
            throw new SyntaxError("Unknown mark type: '" + e[r] + "'")
    }
    return n
}
function lj(t) {
    return t.tag != null
}
function ij(t) {
    return t.style != null
}
class di {
    constructor(e, n) {
        this.schema = e,
        this.rules = n,
        this.tags = [],
        this.styles = [],
        n.forEach(r => {
            lj(r) ? this.tags.push(r) : ij(r) && this.styles.push(r)
        }
        ),
        this.normalizeLists = !this.tags.some(r => {
            if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
                return !1;
            let a = e.nodes[r.node];
            return a.contentMatch.matchType(a)
        }
        )
    }
    parse(e, n={}) {
        let r = new t0(this,n,!1);
        return r.addAll(e, n.from, n.to),
        r.finish()
    }
    parseSlice(e, n={}) {
        let r = new t0(this,n,!0);
        return r.addAll(e, n.from, n.to),
        Ie.maxOpen(r.finish())
    }
    matchTag(e, n, r) {
        for (let a = r ? this.tags.indexOf(r) + 1 : 0; a < this.tags.length; a++) {
            let s = this.tags[a];
            if (dj(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || n.matchesContext(s.context))) {
                if (s.getAttrs) {
                    let l = s.getAttrs(e);
                    if (l === !1)
                        continue;
                    s.attrs = l || void 0
                }
                return s
            }
        }
    }
    matchStyle(e, n, r, a) {
        for (let s = a ? this.styles.indexOf(a) + 1 : 0; s < this.styles.length; s++) {
            let l = this.styles[s]
              , i = l.style;
            if (!(i.indexOf(e) != 0 || l.context && !r.matchesContext(l.context) || i.length > e.length && (i.charCodeAt(e.length) != 61 || i.slice(e.length + 1) != n))) {
                if (l.getAttrs) {
                    let o = l.getAttrs(n);
                    if (o === !1)
                        continue;
                    l.attrs = o || void 0
                }
                return l
            }
        }
    }
    static schemaRules(e) {
        let n = [];
        function r(a) {
            let s = a.priority == null ? 50 : a.priority
              , l = 0;
            for (; l < n.length; l++) {
                let i = n[l];
                if ((i.priority == null ? 50 : i.priority) < s)
                    break
            }
            n.splice(l, 0, a)
        }
        for (let a in e.marks) {
            let s = e.marks[a].spec.parseDOM;
            s && s.forEach(l => {
                r(l = n0(l)),
                l.mark || l.ignore || l.clearMark || (l.mark = a)
            }
            )
        }
        for (let a in e.nodes) {
            let s = e.nodes[a].spec.parseDOM;
            s && s.forEach(l => {
                r(l = n0(l)),
                l.node || l.ignore || l.mark || (l.node = a)
            }
            )
        }
        return n
    }
    static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new di(e,di.schemaRules(e)))
    }
}
const Aw = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
}
  , oj = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
}
  , Mw = {
    ol: !0,
    ul: !0
}
  , dd = 1
  , cd = 2
  , fo = 4;
function e0(t, e, n) {
    return e != null ? (e ? dd : 0) | (e === "full" ? cd : 0) : t && t.whitespace == "pre" ? dd | cd : n & ~fo
}
class ku {
    constructor(e, n, r, a, s, l, i) {
        this.type = e,
        this.attrs = n,
        this.marks = r,
        this.pendingMarks = a,
        this.solid = s,
        this.options = i,
        this.content = [],
        this.activeMarks = Bt.none,
        this.stashMarks = [],
        this.match = l || (i & fo ? null : e.contentMatch)
    }
    findWrapping(e) {
        if (!this.match) {
            if (!this.type)
                return [];
            let n = this.type.contentMatch.fillBefore(Ae.from(e));
            if (n)
                this.match = this.type.contentMatch.matchFragment(n);
            else {
                let r = this.type.contentMatch, a;
                return (a = r.findWrapping(e.type)) ? (this.match = r,
                a) : null
            }
        }
        return this.match.findWrapping(e.type)
    }
    finish(e) {
        if (!(this.options & dd)) {
            let r = this.content[this.content.length - 1], a;
            if (r && r.isText && (a = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                let s = r;
                r.text.length == a[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - a[0].length))
            }
        }
        let n = Ae.from(this.content);
        return !e && this.match && (n = n.append(this.match.fillBefore(Ae.empty, !0))),
        this.type ? this.type.create(this.attrs, n, this.marks) : n
    }
    popFromStashMark(e) {
        for (let n = this.stashMarks.length - 1; n >= 0; n--)
            if (e.eq(this.stashMarks[n]))
                return this.stashMarks.splice(n, 1)[0]
    }
    applyPending(e) {
        for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
            let a = r[n];
            (this.type ? this.type.allowsMarkType(a.type) : fj(a.type, e)) && !a.isInSet(this.activeMarks) && (this.activeMarks = a.addToSet(this.activeMarks),
            this.pendingMarks = a.removeFromSet(this.pendingMarks))
        }
    }
    inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Aw.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
    }
}
class t0 {
    constructor(e, n, r) {
        this.parser = e,
        this.options = n,
        this.isOpen = r,
        this.open = 0;
        let a = n.topNode, s, l = e0(null, n.preserveWhitespace, 0) | (r ? fo : 0);
        a ? s = new ku(a.type,a.attrs,Bt.none,Bt.none,!0,n.topMatch || a.type.contentMatch,l) : r ? s = new ku(null,null,Bt.none,Bt.none,!0,null,l) : s = new ku(e.schema.topNodeType,null,Bt.none,Bt.none,!0,null,l),
        this.nodes = [s],
        this.find = n.findPositions,
        this.needsBlock = !1
    }
    get top() {
        return this.nodes[this.open]
    }
    addDOM(e) {
        e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e)
    }
    withStyleRules(e, n) {
        let r = e.getAttribute("style");
        if (!r)
            return n();
        let a = this.readStyles(cj(r));
        if (!a)
            return;
        let[s,l] = a
          , i = this.top;
        for (let o = 0; o < l.length; o++)
            this.removePendingMark(l[o], i);
        for (let o = 0; o < s.length; o++)
            this.addPendingMark(s[o]);
        n();
        for (let o = 0; o < s.length; o++)
            this.removePendingMark(s[o], i);
        for (let o = 0; o < l.length; o++)
            this.addPendingMark(l[o])
    }
    addTextNode(e) {
        let n = e.nodeValue
          , r = this.top;
        if (r.options & cd || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) {
            if (r.options & dd)
                r.options & cd ? n = n.replace(/\r\n?/g, `
`) : n = n.replace(/\r?\n|\r/g, " ");
            else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "),
            /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) {
                let a = r.content[r.content.length - 1]
                  , s = e.previousSibling;
                (!a || s && s.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (n = n.slice(1))
            }
            n && this.insertNode(this.parser.schema.text(n)),
            this.findInText(e)
        } else
            this.findInside(e)
    }
    addElement(e, n) {
        let r = e.nodeName.toLowerCase(), a;
        Mw.hasOwnProperty(r) && this.parser.normalizeLists && uj(e);
        let s = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, n));
        if (s ? s.ignore : oj.hasOwnProperty(r))
            this.findInside(e),
            this.ignoreFallback(e);
        else if (!s || s.skip || s.closeParent) {
            s && s.closeParent ? this.open = Math.max(0, this.open - 1) : s && s.skip.nodeType && (e = s.skip);
            let l, i = this.top, o = this.needsBlock;
            if (Aw.hasOwnProperty(r))
                i.content.length && i.content[0].isInline && this.open && (this.open--,
                i = this.top),
                l = !0,
                i.type || (this.needsBlock = !0);
            else if (!e.firstChild) {
                this.leafFallback(e);
                return
            }
            s && s.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)),
            l && this.sync(i),
            this.needsBlock = o
        } else
            this.withStyleRules(e, () => {
                this.addElementByRule(e, s, s.consuming === !1 ? a : void 0)
            }
            )
    }
    leafFallback(e) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`))
    }
    ignoreFallback(e) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"))
    }
    readStyles(e) {
        let n = Bt.none
          , r = Bt.none;
        for (let a = 0; a < e.length; a += 2)
            for (let s = void 0; ; ) {
                let l = this.parser.matchStyle(e[a], e[a + 1], this, s);
                if (!l)
                    break;
                if (l.ignore)
                    return null;
                if (l.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach(i => {
                    l.clearMark(i) && (r = i.addToSet(r))
                }
                ) : n = this.parser.schema.marks[l.mark].create(l.attrs).addToSet(n),
                l.consuming === !1)
                    s = l;
                else
                    break
            }
        return [n, r]
    }
    addElementByRule(e, n, r) {
        let a, s, l;
        n.node ? (s = this.parser.schema.nodes[n.node],
        s.isLeaf ? this.insertNode(s.create(n.attrs)) || this.leafFallback(e) : a = this.enter(s, n.attrs || null, n.preserveWhitespace)) : (l = this.parser.schema.marks[n.mark].create(n.attrs),
        this.addPendingMark(l));
        let i = this.top;
        if (s && s.isLeaf)
            this.findInside(e);
        else if (r)
            this.addElement(e, r);
        else if (n.getContent)
            this.findInside(e),
            n.getContent(e, this.parser.schema).forEach(o => this.insertNode(o));
        else {
            let o = e;
            typeof n.contentElement == "string" ? o = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? o = n.contentElement(e) : n.contentElement && (o = n.contentElement),
            this.findAround(e, o, !0),
            this.addAll(o)
        }
        a && this.sync(i) && this.open--,
        l && this.removePendingMark(l, i)
    }
    addAll(e, n, r) {
        let a = n || 0;
        for (let s = n ? e.childNodes[n] : e.firstChild, l = r == null ? null : e.childNodes[r]; s != l; s = s.nextSibling,
        ++a)
            this.findAtPoint(e, a),
            this.addDOM(s);
        this.findAtPoint(e, a)
    }
    findPlace(e) {
        let n, r;
        for (let a = this.open; a >= 0; a--) {
            let s = this.nodes[a]
              , l = s.findWrapping(e);
            if (l && (!n || n.length > l.length) && (n = l,
            r = s,
            !l.length) || s.solid)
                break
        }
        if (!n)
            return !1;
        this.sync(r);
        for (let a = 0; a < n.length; a++)
            this.enterInner(n[a], null, !1);
        return !0
    }
    insertNode(e) {
        if (e.isInline && this.needsBlock && !this.top.type) {
            let n = this.textblockFromContext();
            n && this.enterInner(n)
        }
        if (this.findPlace(e)) {
            this.closeExtra();
            let n = this.top;
            n.applyPending(e.type),
            n.match && (n.match = n.match.matchType(e.type));
            let r = n.activeMarks;
            for (let a = 0; a < e.marks.length; a++)
                (!n.type || n.type.allowsMarkType(e.marks[a].type)) && (r = e.marks[a].addToSet(r));
            return n.content.push(e.mark(r)),
            !0
        }
        return !1
    }
    enter(e, n, r) {
        let a = this.findPlace(e.create(n));
        return a && this.enterInner(e, n, !0, r),
        a
    }
    enterInner(e, n=null, r=!1, a) {
        this.closeExtra();
        let s = this.top;
        s.applyPending(e),
        s.match = s.match && s.match.matchType(e);
        let l = e0(e, a, s.options);
        s.options & fo && s.content.length == 0 && (l |= fo),
        this.nodes.push(new ku(e,n,s.activeMarks,s.pendingMarks,r,null,l)),
        this.open++
    }
    closeExtra(e=!1) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
            for (; n > this.open; n--)
                this.nodes[n - 1].content.push(this.nodes[n].finish(e));
            this.nodes.length = this.open + 1
        }
    }
    finish() {
        return this.open = 0,
        this.closeExtra(this.isOpen),
        this.nodes[0].finish(this.isOpen || this.options.topOpen)
    }
    sync(e) {
        for (let n = this.open; n >= 0; n--)
            if (this.nodes[n] == e)
                return this.open = n,
                !0;
        return !1
    }
    get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let n = this.open; n >= 0; n--) {
            let r = this.nodes[n].content;
            for (let a = r.length - 1; a >= 0; a--)
                e += r[a].nodeSize;
            n && e++
        }
        return e
    }
    findAtPoint(e, n) {
        if (this.find)
            for (let r = 0; r < this.find.length; r++)
                this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
    }
    findInside(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos)
    }
    findAround(e, n, r) {
        if (e != n && this.find)
            for (let a = 0; a < this.find.length; a++)
                this.find[a].pos == null && e.nodeType == 1 && e.contains(this.find[a].node) && n.compareDocumentPosition(this.find[a].node) & (r ? 2 : 4) && (this.find[a].pos = this.currentPos)
    }
    findInText(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset))
    }
    matchesContext(e) {
        if (e.indexOf("|") > -1)
            return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = e.split("/")
          , r = this.options.context
          , a = !this.isOpen && (!r || r.parent.type == this.nodes[0].type)
          , s = -(r ? r.depth + 1 : 0) + (a ? 0 : 1)
          , l = (i, o) => {
            for (; i >= 0; i--) {
                let u = n[i];
                if (u == "") {
                    if (i == n.length - 1 || i == 0)
                        continue;
                    for (; o >= s; o--)
                        if (l(i - 1, o))
                            return !0;
                    return !1
                } else {
                    let d = o > 0 || o == 0 && a ? this.nodes[o].type : r && o >= s ? r.node(o - s).type : null;
                    if (!d || d.name != u && d.groups.indexOf(u) == -1)
                        return !1;
                    o--
                }
            }
            return !0
        }
        ;
        return l(n.length - 1, this.open)
    }
    textblockFromContext() {
        let e = this.options.context;
        if (e)
            for (let n = e.depth; n >= 0; n--) {
                let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
                if (r && r.isTextblock && r.defaultAttrs)
                    return r
            }
        for (let n in this.parser.schema.nodes) {
            let r = this.parser.schema.nodes[n];
            if (r.isTextblock && r.defaultAttrs)
                return r
        }
    }
    addPendingMark(e) {
        let n = pj(e, this.top.pendingMarks);
        n && this.top.stashMarks.push(n),
        this.top.pendingMarks = e.addToSet(this.top.pendingMarks)
    }
    removePendingMark(e, n) {
        for (let r = this.open; r >= 0; r--) {
            let a = this.nodes[r];
            if (a.pendingMarks.lastIndexOf(e) > -1)
                a.pendingMarks = e.removeFromSet(a.pendingMarks);
            else {
                a.activeMarks = e.removeFromSet(a.activeMarks);
                let l = a.popFromStashMark(e);
                l && a.type && a.type.allowsMarkType(l.type) && (a.activeMarks = l.addToSet(a.activeMarks))
            }
            if (a == n)
                break
        }
    }
}
function uj(t) {
    for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && Mw.hasOwnProperty(r) && n ? (n.appendChild(e),
        e = n) : r == "li" ? n = e : r && (n = null)
    }
}
function dj(t, e) {
    return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e)
}
function cj(t) {
    let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, n, r = [];
    for (; n = e.exec(t); )
        r.push(n[1], n[2].trim());
    return r
}
function n0(t) {
    let e = {};
    for (let n in t)
        e[n] = t[n];
    return e
}
function fj(t, e) {
    let n = e.schema.nodes;
    for (let r in n) {
        let a = n[r];
        if (!a.allowsMarkType(t))
            continue;
        let s = []
          , l = i => {
            s.push(i);
            for (let o = 0; o < i.edgeCount; o++) {
                let {type: u, next: d} = i.edge(o);
                if (u == e || s.indexOf(d) < 0 && l(d))
                    return !0
            }
        }
        ;
        if (l(a.contentMatch))
            return !0
    }
}
function pj(t, e) {
    for (let n = 0; n < e.length; n++)
        if (t.eq(e[n]))
            return e[n]
}
class ea {
    constructor(e, n) {
        this.nodes = e,
        this.marks = n
    }
    serializeFragment(e, n={}, r) {
        r || (r = _f(n).createDocumentFragment());
        let a = r
          , s = [];
        return e.forEach(l => {
            if (s.length || l.marks.length) {
                let i = 0
                  , o = 0;
                for (; i < s.length && o < l.marks.length; ) {
                    let u = l.marks[o];
                    if (!this.marks[u.type.name]) {
                        o++;
                        continue
                    }
                    if (!u.eq(s[i][0]) || u.type.spec.spanning === !1)
                        break;
                    i++,
                    o++
                }
                for (; i < s.length; )
                    a = s.pop()[1];
                for (; o < l.marks.length; ) {
                    let u = l.marks[o++]
                      , d = this.serializeMark(u, l.isInline, n);
                    d && (s.push([u, a]),
                    a.appendChild(d.dom),
                    a = d.contentDOM || d.dom)
                }
            }
            a.appendChild(this.serializeNodeInner(l, n))
        }
        ),
        r
    }
    serializeNodeInner(e, n) {
        let {dom: r, contentDOM: a} = ea.renderSpec(_f(n), this.nodes[e.type.name](e));
        if (a) {
            if (e.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(e.content, n, a)
        }
        return r
    }
    serializeNode(e, n={}) {
        let r = this.serializeNodeInner(e, n);
        for (let a = e.marks.length - 1; a >= 0; a--) {
            let s = this.serializeMark(e.marks[a], e.isInline, n);
            s && ((s.contentDOM || s.dom).appendChild(r),
            r = s.dom)
        }
        return r
    }
    serializeMark(e, n, r={}) {
        let a = this.marks[e.type.name];
        return a && ea.renderSpec(_f(r), a(e, n))
    }
    static renderSpec(e, n, r=null) {
        if (typeof n == "string")
            return {
                dom: e.createTextNode(n)
            };
        if (n.nodeType != null)
            return {
                dom: n
            };
        if (n.dom && n.dom.nodeType != null)
            return n;
        let a = n[0]
          , s = a.indexOf(" ");
        s > 0 && (r = a.slice(0, s),
        a = a.slice(s + 1));
        let l, i = r ? e.createElementNS(r, a) : e.createElement(a), o = n[1], u = 1;
        if (o && typeof o == "object" && o.nodeType == null && !Array.isArray(o)) {
            u = 2;
            for (let d in o)
                if (o[d] != null) {
                    let f = d.indexOf(" ");
                    f > 0 ? i.setAttributeNS(d.slice(0, f), d.slice(f + 1), o[d]) : i.setAttribute(d, o[d])
                }
        }
        for (let d = u; d < n.length; d++) {
            let f = n[d];
            if (f === 0) {
                if (d < n.length - 1 || d > u)
                    throw new RangeError("Content hole must be the only child of its parent node");
                return {
                    dom: i,
                    contentDOM: i
                }
            } else {
                let {dom: p, contentDOM: h} = ea.renderSpec(e, f, r);
                if (i.appendChild(p),
                h) {
                    if (l)
                        throw new RangeError("Multiple content holes");
                    l = h
                }
            }
        }
        return {
            dom: i,
            contentDOM: l
        }
    }
    static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new ea(this.nodesFromSchema(e),this.marksFromSchema(e)))
    }
    static nodesFromSchema(e) {
        let n = r0(e.nodes);
        return n.text || (n.text = r => r.text),
        n
    }
    static marksFromSchema(e) {
        return r0(e.marks)
    }
}
function r0(t) {
    let e = {};
    for (let n in t) {
        let r = t[n].spec.toDOM;
        r && (e[n] = r)
    }
    return e
}
function _f(t) {
    return t.document || window.document
}
const Ow = 65535
  , Nw = Math.pow(2, 16);
function hj(t, e) {
    return t + e * Nw
}
function a0(t) {
    return t & Ow
}
function mj(t) {
    return (t - (t & Ow)) / Nw
}
const Dw = 1
  , Pw = 2
  , Bu = 4
  , Fw = 8;
class Yp {
    constructor(e, n, r) {
        this.pos = e,
        this.delInfo = n,
        this.recover = r
    }
    get deleted() {
        return (this.delInfo & Fw) > 0
    }
    get deletedBefore() {
        return (this.delInfo & (Dw | Bu)) > 0
    }
    get deletedAfter() {
        return (this.delInfo & (Pw | Bu)) > 0
    }
    get deletedAcross() {
        return (this.delInfo & Bu) > 0
    }
}
class nr {
    constructor(e, n=!1) {
        if (this.ranges = e,
        this.inverted = n,
        !e.length && nr.empty)
            return nr.empty
    }
    recover(e) {
        let n = 0
          , r = a0(e);
        if (!this.inverted)
            for (let a = 0; a < r; a++)
                n += this.ranges[a * 3 + 2] - this.ranges[a * 3 + 1];
        return this.ranges[r * 3] + n + mj(e)
    }
    mapResult(e, n=1) {
        return this._map(e, n, !1)
    }
    map(e, n=1) {
        return this._map(e, n, !0)
    }
    _map(e, n, r) {
        let a = 0
          , s = this.inverted ? 2 : 1
          , l = this.inverted ? 1 : 2;
        for (let i = 0; i < this.ranges.length; i += 3) {
            let o = this.ranges[i] - (this.inverted ? a : 0);
            if (o > e)
                break;
            let u = this.ranges[i + s]
              , d = this.ranges[i + l]
              , f = o + u;
            if (e <= f) {
                let p = u ? e == o ? -1 : e == f ? 1 : n : n
                  , h = o + a + (p < 0 ? 0 : d);
                if (r)
                    return h;
                let v = e == (n < 0 ? o : f) ? null : hj(i / 3, e - o)
                  , y = e == o ? Pw : e == f ? Dw : Bu;
                return (n < 0 ? e != o : e != f) && (y |= Fw),
                new Yp(h,y,v)
            }
            a += d - u
        }
        return r ? e + a : new Yp(e + a,0,null)
    }
    touches(e, n) {
        let r = 0
          , a = a0(n)
          , s = this.inverted ? 2 : 1
          , l = this.inverted ? 1 : 2;
        for (let i = 0; i < this.ranges.length; i += 3) {
            let o = this.ranges[i] - (this.inverted ? r : 0);
            if (o > e)
                break;
            let u = this.ranges[i + s]
              , d = o + u;
            if (e <= d && i == a * 3)
                return !0;
            r += this.ranges[i + l] - u
        }
        return !1
    }
    forEach(e) {
        let n = this.inverted ? 2 : 1
          , r = this.inverted ? 1 : 2;
        for (let a = 0, s = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a]
              , i = l - (this.inverted ? s : 0)
              , o = l + (this.inverted ? 0 : s)
              , u = this.ranges[a + n]
              , d = this.ranges[a + r];
            e(i, i + u, o, o + d),
            s += d - u
        }
    }
    invert() {
        return new nr(this.ranges,!this.inverted)
    }
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    }
    static offset(e) {
        return e == 0 ? nr.empty : new nr(e < 0 ? [0, -e, 0] : [0, 0, e])
    }
}
nr.empty = new nr([]);
class Xl {
    constructor(e=[], n, r=0, a=e.length) {
        this.maps = e,
        this.mirror = n,
        this.from = r,
        this.to = a
    }
    slice(e=0, n=this.maps.length) {
        return new Xl(this.maps,this.mirror,e,n)
    }
    copy() {
        return new Xl(this.maps.slice(),this.mirror && this.mirror.slice(),this.from,this.to)
    }
    appendMap(e, n) {
        this.to = this.maps.push(e),
        n != null && this.setMirror(this.maps.length - 1, n)
    }
    appendMapping(e) {
        for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
            let a = e.getMirror(n);
            this.appendMap(e.maps[n], a != null && a < n ? r + a : void 0)
        }
    }
    getMirror(e) {
        if (this.mirror) {
            for (let n = 0; n < this.mirror.length; n++)
                if (this.mirror[n] == e)
                    return this.mirror[n + (n % 2 ? -1 : 1)]
        }
    }
    setMirror(e, n) {
        this.mirror || (this.mirror = []),
        this.mirror.push(e, n)
    }
    appendMappingInverted(e) {
        for (let n = e.maps.length - 1, r = this.maps.length + e.maps.length; n >= 0; n--) {
            let a = e.getMirror(n);
            this.appendMap(e.maps[n].invert(), a != null && a > n ? r - a - 1 : void 0)
        }
    }
    invert() {
        let e = new Xl;
        return e.appendMappingInverted(this),
        e
    }
    map(e, n=1) {
        if (this.mirror)
            return this._map(e, n, !0);
        for (let r = this.from; r < this.to; r++)
            e = this.maps[r].map(e, n);
        return e
    }
    mapResult(e, n=1) {
        return this._map(e, n, !1)
    }
    _map(e, n, r) {
        let a = 0;
        for (let s = this.from; s < this.to; s++) {
            let l = this.maps[s]
              , i = l.mapResult(e, n);
            if (i.recover != null) {
                let o = this.getMirror(s);
                if (o != null && o > s && o < this.to) {
                    s = o,
                    e = this.maps[o].recover(i.recover);
                    continue
                }
            }
            a |= i.delInfo,
            e = i.pos
        }
        return r ? e : new Yp(e,a,null)
    }
}
const wf = Object.create(null);
class In {
    getMap() {
        return nr.empty
    }
    merge(e) {
        return null
    }
    static fromJSON(e, n) {
        if (!n || !n.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let r = wf[n.stepType];
        if (!r)
            throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in wf)
            throw new RangeError("Duplicate use of step JSON ID " + e);
        return wf[e] = n,
        n.prototype.jsonID = e,
        n
    }
}
class un {
    constructor(e, n) {
        this.doc = e,
        this.failed = n
    }
    static ok(e) {
        return new un(e,null)
    }
    static fail(e) {
        return new un(null,e)
    }
    static fromReplace(e, n, r, a) {
        try {
            return un.ok(e.replace(n, r, a))
        } catch (s) {
            if (s instanceof ld)
                return un.fail(s.message);
            throw s
        }
    }
}
function Bm(t, e, n) {
    let r = [];
    for (let a = 0; a < t.childCount; a++) {
        let s = t.child(a);
        s.content.size && (s = s.copy(Bm(s.content, e, s))),
        s.isInline && (s = e(s, n, a)),
        r.push(s)
    }
    return Ae.fromArray(r)
}
class ts extends In {
    constructor(e, n, r) {
        super(),
        this.from = e,
        this.to = n,
        this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
          , r = e.resolve(this.from)
          , a = r.node(r.sharedDepth(this.to))
          , s = new Ie(Bm(n.content, (l, i) => !l.isAtom || !i.type.allowsMarkType(this.mark.type) ? l : l.mark(this.mark.addToSet(l.marks)), a),n.openStart,n.openEnd);
        return un.fromReplace(e, this.from, this.to, s)
    }
    invert() {
        return new ta(this.from,this.to,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new ts(n.pos,r.pos,this.mark)
    }
    merge(e) {
        return e instanceof ts && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ts(Math.min(this.from, e.from),Math.max(this.to, e.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new ts(n.from,n.to,e.markFromJSON(n.mark))
    }
}
In.jsonID("addMark", ts);
class ta extends In {
    constructor(e, n, r) {
        super(),
        this.from = e,
        this.to = n,
        this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
          , r = new Ie(Bm(n.content, a => a.mark(this.mark.removeFromSet(a.marks)), e),n.openStart,n.openEnd);
        return un.fromReplace(e, this.from, this.to, r)
    }
    invert() {
        return new ts(this.from,this.to,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new ta(n.pos,r.pos,this.mark)
    }
    merge(e) {
        return e instanceof ta && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ta(Math.min(this.from, e.from),Math.max(this.to, e.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new ta(n.from,n.to,e.markFromJSON(n.mark))
    }
}
In.jsonID("removeMark", ta);
class ns extends In {
    constructor(e, n) {
        super(),
        this.pos = e,
        this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return un.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return un.fromReplace(e, this.pos, this.pos + 1, new Ie(Ae.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let a = 0; a < n.marks.length; a++)
                    if (!n.marks[a].isInSet(r))
                        return new ns(this.pos,n.marks[a]);
                return new ns(this.pos,this.mark)
            }
        }
        return new ci(this.pos,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new ns(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new ns(n.pos,e.markFromJSON(n.mark))
    }
}
In.jsonID("addNodeMark", ns);
class ci extends In {
    constructor(e, n) {
        super(),
        this.pos = e,
        this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return un.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return un.fromReplace(e, this.pos, this.pos + 1, new Ie(Ae.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new ns(this.pos,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new ci(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new ci(n.pos,e.markFromJSON(n.mark))
    }
}
In.jsonID("removeNodeMark", ci);
class mn extends In {
    constructor(e, n, r, a=!1) {
        super(),
        this.from = e,
        this.to = n,
        this.slice = r,
        this.structure = a
    }
    apply(e) {
        return this.structure && Jp(e, this.from, this.to) ? un.fail("Structure replace would overwrite content") : un.fromReplace(e, this.from, this.to, this.slice)
    }
    getMap() {
        return new nr([this.from, this.to - this.from, this.slice.size])
    }
    invert(e) {
        return new mn(this.from,this.from + this.slice.size,e.slice(this.from, this.to))
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new mn(n.pos,Math.max(n.pos, r.pos),this.slice)
    }
    merge(e) {
        if (!(e instanceof mn) || e.structure || this.structure)
            return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
            let n = this.slice.size + e.slice.size == 0 ? Ie.empty : new Ie(this.slice.content.append(e.slice.content),this.slice.openStart,e.slice.openEnd);
            return new mn(this.from,this.to + (e.to - e.from),n,this.structure)
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
            let n = this.slice.size + e.slice.size == 0 ? Ie.empty : new Ie(e.slice.content.append(this.slice.content),e.slice.openStart,this.slice.openEnd);
            return new mn(e.from,this.to,n,this.structure)
        } else
            return null
    }
    toJSON() {
        let e = {
            stepType: "replace",
            from: this.from,
            to: this.to
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new mn(n.from,n.to,Ie.fromJSON(e, n.slice),!!n.structure)
    }
}
In.jsonID("replace", mn);
class bn extends In {
    constructor(e, n, r, a, s, l, i=!1) {
        super(),
        this.from = e,
        this.to = n,
        this.gapFrom = r,
        this.gapTo = a,
        this.slice = s,
        this.insert = l,
        this.structure = i
    }
    apply(e) {
        if (this.structure && (Jp(e, this.from, this.gapFrom) || Jp(e, this.gapTo, this.to)))
            return un.fail("Structure gap-replace would overwrite content");
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
            return un.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? un.fromReplace(e, this.from, this.to, r) : un.fail("Content does not fit in gap")
    }
    getMap() {
        return new nr([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
    }
    invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new bn(this.from,this.from + this.slice.size + n,this.from + this.insert,this.from + this.insert + n,e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),this.gapFrom - this.from,this.structure)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1)
          , a = e.map(this.gapFrom, -1)
          , s = e.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || a < n.pos || s > r.pos ? null : new bn(n.pos,r.pos,a,s,this.slice,this.insert,this.structure)
    }
    toJSON() {
        let e = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new bn(n.from,n.to,n.gapFrom,n.gapTo,Ie.fromJSON(e, n.slice),n.insert,!!n.structure)
    }
}
In.jsonID("replaceAround", bn);
function Jp(t, e, n) {
    let r = t.resolve(e)
      , a = n - e
      , s = r.depth;
    for (; a > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
        s--,
        a--;
    if (a > 0) {
        let l = r.node(s).maybeChild(r.indexAfter(s));
        for (; a > 0; ) {
            if (!l || l.isLeaf)
                return !0;
            l = l.firstChild,
            a--
        }
    }
    return !1
}
function vj(t, e, n, r) {
    let a = [], s = [], l, i;
    t.doc.nodesBetween(e, n, (o, u, d) => {
        if (!o.isInline)
            return;
        let f = o.marks;
        if (!r.isInSet(f) && d.type.allowsMarkType(r.type)) {
            let p = Math.max(u, e)
              , h = Math.min(u + o.nodeSize, n)
              , v = r.addToSet(f);
            for (let y = 0; y < f.length; y++)
                f[y].isInSet(v) || (l && l.to == p && l.mark.eq(f[y]) ? l.to = h : a.push(l = new ta(p,h,f[y])));
            i && i.to == p ? i.to = h : s.push(i = new ts(p,h,r))
        }
    }
    ),
    a.forEach(o => t.step(o)),
    s.forEach(o => t.step(o))
}
function gj(t, e, n, r) {
    let a = []
      , s = 0;
    t.doc.nodesBetween(e, n, (l, i) => {
        if (!l.isInline)
            return;
        s++;
        let o = null;
        if (r instanceof fc) {
            let u = l.marks, d;
            for (; d = r.isInSet(u); )
                (o || (o = [])).push(d),
                u = d.removeFromSet(u)
        } else
            r ? r.isInSet(l.marks) && (o = [r]) : o = l.marks;
        if (o && o.length) {
            let u = Math.min(i + l.nodeSize, n);
            for (let d = 0; d < o.length; d++) {
                let f = o[d], p;
                for (let h = 0; h < a.length; h++) {
                    let v = a[h];
                    v.step == s - 1 && f.eq(a[h].style) && (p = v)
                }
                p ? (p.to = u,
                p.step = s) : a.push({
                    style: f,
                    from: Math.max(i, e),
                    to: u,
                    step: s
                })
            }
        }
    }
    ),
    a.forEach(l => t.step(new ta(l.from,l.to,l.style)))
}
function bj(t, e, n, r=n.contentMatch) {
    let a = t.doc.nodeAt(e)
      , s = []
      , l = e + 1;
    for (let i = 0; i < a.childCount; i++) {
        let o = a.child(i)
          , u = l + o.nodeSize
          , d = r.matchType(o.type);
        if (!d)
            s.push(new mn(l,u,Ie.empty));
        else {
            r = d;
            for (let f = 0; f < o.marks.length; f++)
                n.allowsMarkType(o.marks[f].type) || t.step(new ta(l,u,o.marks[f]));
            if (o.isText && !n.spec.code) {
                let f, p = /\r?\n|\r/g, h;
                for (; f = p.exec(o.text); )
                    h || (h = new Ie(Ae.from(n.schema.text(" ", n.allowedMarks(o.marks))),0,0)),
                    s.push(new mn(l + f.index,l + f.index + f[0].length,h))
            }
        }
        l = u
    }
    if (!r.validEnd) {
        let i = r.fillBefore(Ae.empty, !0);
        t.replace(l, l, new Ie(i,0,0))
    }
    for (let i = s.length - 1; i >= 0; i--)
        t.step(s[i])
}
function yj(t, e, n) {
    return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n))
}
function Oi(t) {
    let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
    for (let r = t.depth; ; --r) {
        let a = t.$from.node(r)
          , s = t.$from.index(r)
          , l = t.$to.indexAfter(r);
        if (r < t.depth && a.canReplace(s, l, n))
            return r;
        if (r == 0 || a.type.spec.isolating || !yj(a, s, l))
            break
    }
    return null
}
function kj(t, e, n) {
    let {$from: r, $to: a, depth: s} = e
      , l = r.before(s + 1)
      , i = a.after(s + 1)
      , o = l
      , u = i
      , d = Ae.empty
      , f = 0;
    for (let v = s, y = !1; v > n; v--)
        y || r.index(v) > 0 ? (y = !0,
        d = Ae.from(r.node(v).copy(d)),
        f++) : o--;
    let p = Ae.empty
      , h = 0;
    for (let v = s, y = !1; v > n; v--)
        y || a.after(v + 1) < a.end(v) ? (y = !0,
        p = Ae.from(a.node(v).copy(p)),
        h++) : u++;
    t.step(new bn(o,u,l,i,new Ie(d.append(p),f,h),d.size - f,!0))
}
function Vm(t, e, n=null, r=t) {
    let a = _j(t, e)
      , s = a && wj(r, e);
    return s ? a.map(s0).concat({
        type: e,
        attrs: n
    }).concat(s.map(s0)) : null
}
function s0(t) {
    return {
        type: t,
        attrs: null
    }
}
function _j(t, e) {
    let {parent: n, startIndex: r, endIndex: a} = t
      , s = n.contentMatchAt(r).findWrapping(e);
    if (!s)
        return null;
    let l = s.length ? s[0] : e;
    return n.canReplaceWith(r, a, l) ? s : null
}
function wj(t, e) {
    let {parent: n, startIndex: r, endIndex: a} = t
      , s = n.child(r)
      , l = e.contentMatch.findWrapping(s.type);
    if (!l)
        return null;
    let o = (l.length ? l[l.length - 1] : e).contentMatch;
    for (let u = r; o && u < a; u++)
        o = o.matchType(n.child(u).type);
    return !o || !o.validEnd ? null : l
}
function xj(t, e, n) {
    let r = Ae.empty;
    for (let l = n.length - 1; l >= 0; l--) {
        if (r.size) {
            let i = n[l].type.contentMatch.matchFragment(r);
            if (!i || !i.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
        }
        r = Ae.from(n[l].type.create(n[l].attrs, r))
    }
    let a = e.start
      , s = e.end;
    t.step(new bn(a,s,a,s,new Ie(r,0,0),n.length,!0))
}
function Sj(t, e, n, r, a) {
    if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let s = t.steps.length;
    t.doc.nodesBetween(e, n, (l, i) => {
        if (l.isTextblock && !l.hasMarkup(r, a) && $j(t.doc, t.mapping.slice(s).map(i), r)) {
            t.clearIncompatible(t.mapping.slice(s).map(i, 1), r);
            let o = t.mapping.slice(s)
              , u = o.map(i, 1)
              , d = o.map(i + l.nodeSize, 1);
            return t.step(new bn(u,d,u + 1,d - 1,new Ie(Ae.from(r.create(a, null, l.marks)),0,0),1,!0)),
            !1
        }
    }
    )
}
function $j(t, e, n) {
    let r = t.resolve(e)
      , a = r.index();
    return r.parent.canReplaceWith(a, a + 1, n)
}
function Tj(t, e, n, r, a) {
    let s = t.doc.nodeAt(e);
    if (!s)
        throw new RangeError("No node at given position");
    n || (n = s.type);
    let l = n.create(r, null, a || s.marks);
    if (s.isLeaf)
        return t.replaceWith(e, e + s.nodeSize, l);
    if (!n.validContent(s.content))
        throw new RangeError("Invalid content for node type " + n.name);
    t.step(new bn(e,e + s.nodeSize,e + 1,e + s.nodeSize - 1,new Ie(Ae.from(l),0,0),1,!0))
}
function Ql(t, e, n=1, r) {
    let a = t.resolve(e)
      , s = a.depth - n
      , l = r && r[r.length - 1] || a.parent;
    if (s < 0 || a.parent.type.spec.isolating || !a.parent.canReplace(a.index(), a.parent.childCount) || !l.type.validContent(a.parent.content.cutByIndex(a.index(), a.parent.childCount)))
        return !1;
    for (let u = a.depth - 1, d = n - 2; u > s; u--,
    d--) {
        let f = a.node(u)
          , p = a.index(u);
        if (f.type.spec.isolating)
            return !1;
        let h = f.content.cutByIndex(p, f.childCount)
          , v = r && r[d + 1];
        v && (h = h.replaceChild(0, v.type.create(v.attrs)));
        let y = r && r[d] || f;
        if (!f.canReplace(p + 1, f.childCount) || !y.type.validContent(h))
            return !1
    }
    let i = a.indexAfter(s)
      , o = r && r[0];
    return a.node(s).canReplaceWith(i, i, o ? o.type : a.node(s + 1).type)
}
function Cj(t, e, n=1, r) {
    let a = t.doc.resolve(e)
      , s = Ae.empty
      , l = Ae.empty;
    for (let i = a.depth, o = a.depth - n, u = n - 1; i > o; i--,
    u--) {
        s = Ae.from(a.node(i).copy(s));
        let d = r && r[u];
        l = Ae.from(d ? d.type.create(d.attrs, l) : a.node(i).copy(l))
    }
    t.step(new mn(e,e,new Ie(s.append(l),n,n),!0))
}
function Ts(t, e) {
    let n = t.resolve(e)
      , r = n.index();
    return Bw(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function Bw(t, e) {
    return !!(t && e && !t.isLeaf && t.canAppend(e))
}
function pc(t, e, n=-1) {
    let r = t.resolve(e);
    for (let a = r.depth; ; a--) {
        let s, l, i = r.index(a);
        if (a == r.depth ? (s = r.nodeBefore,
        l = r.nodeAfter) : n > 0 ? (s = r.node(a + 1),
        i++,
        l = r.node(a).maybeChild(i)) : (s = r.node(a).maybeChild(i - 1),
        l = r.node(a + 1)),
        s && !s.isTextblock && Bw(s, l) && r.node(a).canReplace(i, i + 1))
            return e;
        if (a == 0)
            break;
        e = n < 0 ? r.before(a) : r.after(a)
    }
}
function Ej(t, e, n) {
    let r = new mn(e - n,e + n,Ie.empty,!0);
    t.step(r)
}
function Aj(t, e, n) {
    let r = t.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return e;
    if (r.parentOffset == 0)
        for (let a = r.depth - 1; a >= 0; a--) {
            let s = r.index(a);
            if (r.node(a).canReplaceWith(s, s, n))
                return r.before(a + 1);
            if (s > 0)
                return null
        }
    if (r.parentOffset == r.parent.content.size)
        for (let a = r.depth - 1; a >= 0; a--) {
            let s = r.indexAfter(a);
            if (r.node(a).canReplaceWith(s, s, n))
                return r.after(a + 1);
            if (s < r.node(a).childCount)
                return null
        }
    return null
}
function Vw(t, e, n) {
    let r = t.resolve(e);
    if (!n.content.size)
        return e;
    let a = n.content;
    for (let s = 0; s < n.openStart; s++)
        a = a.firstChild.content;
    for (let s = 1; s <= (n.openStart == 0 && n.size ? 2 : 1); s++)
        for (let l = r.depth; l >= 0; l--) {
            let i = l == r.depth ? 0 : r.pos <= (r.start(l + 1) + r.end(l + 1)) / 2 ? -1 : 1
              , o = r.index(l) + (i > 0 ? 1 : 0)
              , u = r.node(l)
              , d = !1;
            if (s == 1)
                d = u.canReplace(o, o, a);
            else {
                let f = u.contentMatchAt(o).findWrapping(a.firstChild.type);
                d = f && u.canReplaceWith(o, o, f[0])
            }
            if (d)
                return i == 0 ? r.pos : i < 0 ? r.before(l + 1) : r.after(l + 1)
        }
    return null
}
function hc(t, e, n=e, r=Ie.empty) {
    if (e == n && !r.size)
        return null;
    let a = t.resolve(e)
      , s = t.resolve(n);
    return Iw(a, s, r) ? new mn(e,n,r) : new Mj(a,s,r).fit()
}
function Iw(t, e, n) {
    return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content)
}
class Mj {
    constructor(e, n, r) {
        this.$from = e,
        this.$to = n,
        this.unplaced = r,
        this.frontier = [],
        this.placed = Ae.empty;
        for (let a = 0; a <= e.depth; a++) {
            let s = e.node(a);
            this.frontier.push({
                type: s.type,
                match: s.contentMatchAt(e.indexAfter(a))
            })
        }
        for (let a = e.depth; a > 0; a--)
            this.placed = Ae.from(e.node(a).copy(this.placed))
    }
    get depth() {
        return this.frontier.length - 1
    }
    fit() {
        for (; this.unplaced.size; ) {
            let u = this.findFittable();
            u ? this.placeNodes(u) : this.openMore() || this.dropNode()
        }
        let e = this.mustMoveInline()
          , n = this.placed.size - this.depth - this.$from.depth
          , r = this.$from
          , a = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!a)
            return null;
        let s = this.placed
          , l = r.depth
          , i = a.depth;
        for (; l && i && s.childCount == 1; )
            s = s.firstChild.content,
            l--,
            i--;
        let o = new Ie(s,l,i);
        return e > -1 ? new bn(r.pos,e,this.$to.pos,this.$to.end(),o,n) : o.size || r.pos != this.$to.pos ? new mn(r.pos,a.pos,o) : null
    }
    findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, a = this.unplaced.openEnd; r < e; r++) {
            let s = n.firstChild;
            if (n.childCount > 1 && (a = 0),
            s.type.spec.isolating && a <= r) {
                e = r;
                break
            }
            n = s.content
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
                let a, s = null;
                r ? (s = xf(this.unplaced.content, r - 1).firstChild,
                a = s.content) : a = this.unplaced.content;
                let l = a.firstChild;
                for (let i = this.depth; i >= 0; i--) {
                    let {type: o, match: u} = this.frontier[i], d, f = null;
                    if (n == 1 && (l ? u.matchType(l.type) || (f = u.fillBefore(Ae.from(l), !1)) : s && o.compatibleContent(s.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: i,
                            parent: s,
                            inject: f
                        };
                    if (n == 2 && l && (d = u.findWrapping(l.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: i,
                            parent: s,
                            wrap: d
                        };
                    if (s && u.matchType(s.type))
                        break
                }
            }
    }
    openMore() {
        let {content: e, openStart: n, openEnd: r} = this.unplaced
          , a = xf(e, n);
        return !a.childCount || a.firstChild.isLeaf ? !1 : (this.unplaced = new Ie(e,n + 1,Math.max(r, a.size + n >= e.size - r ? n + 1 : 0)),
        !0)
    }
    dropNode() {
        let {content: e, openStart: n, openEnd: r} = this.unplaced
          , a = xf(e, n);
        if (a.childCount <= 1 && n > 0) {
            let s = e.size - n <= n + a.size;
            this.unplaced = new Ie(Gi(e, n - 1, 1),n - 1,s ? n - 1 : r)
        } else
            this.unplaced = new Ie(Gi(e, n, 1),n,r)
    }
    placeNodes({sliceDepth: e, frontierDepth: n, parent: r, inject: a, wrap: s}) {
        for (; this.depth > n; )
            this.closeFrontierNode();
        if (s)
            for (let y = 0; y < s.length; y++)
                this.openFrontierNode(s[y]);
        let l = this.unplaced
          , i = r ? r.content : l.content
          , o = l.openStart - e
          , u = 0
          , d = []
          , {match: f, type: p} = this.frontier[n];
        if (a) {
            for (let y = 0; y < a.childCount; y++)
                d.push(a.child(y));
            f = f.matchFragment(a)
        }
        let h = i.size + e - (l.content.size - l.openEnd);
        for (; u < i.childCount; ) {
            let y = i.child(u)
              , k = f.matchType(y.type);
            if (!k)
                break;
            u++,
            (u > 1 || o == 0 || y.content.size) && (f = k,
            d.push(Rw(y.mark(p.allowedMarks(y.marks)), u == 1 ? o : 0, u == i.childCount ? h : -1)))
        }
        let v = u == i.childCount;
        v || (h = -1),
        this.placed = Yi(this.placed, n, Ae.from(d)),
        this.frontier[n].match = f,
        v && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let y = 0, k = i; y < h; y++) {
            let w = k.lastChild;
            this.frontier.push({
                type: w.type,
                match: w.contentMatchAt(w.childCount)
            }),
            k = w.content
        }
        this.unplaced = v ? e == 0 ? Ie.empty : new Ie(Gi(l.content, e - 1, 1),e - 1,h < 0 ? l.openEnd : e - 1) : new Ie(Gi(l.content, e, u),l.openStart,l.openEnd)
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let e = this.frontier[this.depth], n;
        if (!e.type.isTextblock || !Sf(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
            return -1;
        let {depth: r} = this.$to
          , a = this.$to.after(r);
        for (; r > 1 && a == this.$to.end(--r); )
            ++a;
        return a
    }
    findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
            let {match: r, type: a} = this.frontier[n]
              , s = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1))
              , l = Sf(e, n, a, r, s);
            if (l) {
                for (let i = n - 1; i >= 0; i--) {
                    let {match: o, type: u} = this.frontier[i]
                      , d = Sf(e, i, u, o, !0);
                    if (!d || d.childCount)
                        continue e
                }
                return {
                    depth: n,
                    fit: l,
                    move: s ? e.doc.resolve(e.after(n + 1)) : e
                }
            }
        }
    }
    close(e) {
        let n = this.findCloseLevel(e);
        if (!n)
            return null;
        for (; this.depth > n.depth; )
            this.closeFrontierNode();
        n.fit.childCount && (this.placed = Yi(this.placed, n.depth, n.fit)),
        e = n.move;
        for (let r = n.depth + 1; r <= e.depth; r++) {
            let a = e.node(r)
              , s = a.type.contentMatch.fillBefore(a.content, !0, e.index(r));
            this.openFrontierNode(a.type, a.attrs, s)
        }
        return e
    }
    openFrontierNode(e, n=null, r) {
        let a = this.frontier[this.depth];
        a.match = a.match.matchType(e),
        this.placed = Yi(this.placed, this.depth, Ae.from(e.create(n, r))),
        this.frontier.push({
            type: e,
            match: e.contentMatch
        })
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(Ae.empty, !0);
        n.childCount && (this.placed = Yi(this.placed, this.frontier.length, n))
    }
}
function Gi(t, e, n) {
    return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Gi(t.firstChild.content, e - 1, n)))
}
function Yi(t, e, n) {
    return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Yi(t.lastChild.content, e - 1, n)))
}
function xf(t, e) {
    for (let n = 0; n < e; n++)
        t = t.firstChild.content;
    return t
}
function Rw(t, e, n) {
    if (e <= 0)
        return t;
    let r = t.content;
    return e > 1 && (r = r.replaceChild(0, Rw(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))),
    e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r),
    n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(Ae.empty, !0)))),
    t.copy(r)
}
function Sf(t, e, n, r, a) {
    let s = t.node(e)
      , l = a ? t.indexAfter(e) : t.index(e);
    if (l == s.childCount && !n.compatibleContent(s.type))
        return null;
    let i = r.fillBefore(s.content, !0, l);
    return i && !Oj(n, s.content, l) ? i : null
}
function Oj(t, e, n) {
    for (let r = n; r < e.childCount; r++)
        if (!t.allowsMarks(e.child(r).marks))
            return !0;
    return !1
}
function Nj(t) {
    return t.spec.defining || t.spec.definingForContent
}
function Dj(t, e, n, r) {
    if (!r.size)
        return t.deleteRange(e, n);
    let a = t.doc.resolve(e)
      , s = t.doc.resolve(n);
    if (Iw(a, s, r))
        return t.step(new mn(e,n,r));
    let l = jw(a, t.doc.resolve(n));
    l[l.length - 1] == 0 && l.pop();
    let i = -(a.depth + 1);
    l.unshift(i);
    for (let p = a.depth, h = a.pos - 1; p > 0; p--,
    h--) {
        let v = a.node(p).type.spec;
        if (v.defining || v.definingAsContext || v.isolating)
            break;
        l.indexOf(p) > -1 ? i = p : a.before(p) == h && l.splice(1, 0, -p)
    }
    let o = l.indexOf(i)
      , u = []
      , d = r.openStart;
    for (let p = r.content, h = 0; ; h++) {
        let v = p.firstChild;
        if (u.push(v),
        h == r.openStart)
            break;
        p = v.content
    }
    for (let p = d - 1; p >= 0; p--) {
        let h = u[p]
          , v = Nj(h.type);
        if (v && !h.sameMarkup(a.node(Math.abs(i) - 1)))
            d = p;
        else if (v || !h.type.isTextblock)
            break
    }
    for (let p = r.openStart; p >= 0; p--) {
        let h = (p + d + 1) % (r.openStart + 1)
          , v = u[h];
        if (v)
            for (let y = 0; y < l.length; y++) {
                let k = l[(y + o) % l.length]
                  , w = !0;
                k < 0 && (w = !1,
                k = -k);
                let $ = a.node(k - 1)
                  , M = a.index(k - 1);
                if ($.canReplaceWith(M, M, v.type, v.marks))
                    return t.replace(a.before(k), w ? s.after(k) : n, new Ie(Lw(r.content, 0, r.openStart, h),h,r.openEnd))
            }
    }
    let f = t.steps.length;
    for (let p = l.length - 1; p >= 0 && (t.replace(e, n, r),
    !(t.steps.length > f)); p--) {
        let h = l[p];
        h < 0 || (e = a.before(h),
        n = s.after(h))
    }
}
function Lw(t, e, n, r, a) {
    if (e < n) {
        let s = t.firstChild;
        t = t.replaceChild(0, s.copy(Lw(s.content, e + 1, n, r, s)))
    }
    if (e > r) {
        let s = a.contentMatchAt(0)
          , l = s.fillBefore(t).append(t);
        t = l.append(s.matchFragment(l).fillBefore(Ae.empty, !0))
    }
    return t
}
function Pj(t, e, n, r) {
    if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
        let a = Aj(t.doc, e, r.type);
        a != null && (e = n = a)
    }
    t.replaceRange(e, n, new Ie(Ae.from(r),0,0))
}
function Fj(t, e, n) {
    let r = t.doc.resolve(e)
      , a = t.doc.resolve(n)
      , s = jw(r, a);
    for (let l = 0; l < s.length; l++) {
        let i = s[l]
          , o = l == s.length - 1;
        if (o && i == 0 || r.node(i).type.contentMatch.validEnd)
            return t.delete(r.start(i), a.end(i));
        if (i > 0 && (o || r.node(i - 1).canReplace(r.index(i - 1), a.indexAfter(i - 1))))
            return t.delete(r.before(i), a.after(i))
    }
    for (let l = 1; l <= r.depth && l <= a.depth; l++)
        if (e - r.start(l) == r.depth - l && n > r.end(l) && a.end(l) - n != a.depth - l)
            return t.delete(r.before(l), n);
    t.delete(e, n)
}
function jw(t, e) {
    let n = []
      , r = Math.min(t.depth, e.depth);
    for (let a = r; a >= 0; a--) {
        let s = t.start(a);
        if (s < t.pos - (t.depth - a) || e.end(a) > e.pos + (e.depth - a) || t.node(a).type.spec.isolating || e.node(a).type.spec.isolating)
            break;
        (s == e.start(a) || a == t.depth && a == e.depth && t.parent.inlineContent && e.parent.inlineContent && a && e.start(a - 1) == s - 1) && n.push(a)
    }
    return n
}
class Zl extends In {
    constructor(e, n, r) {
        super(),
        this.pos = e,
        this.attr = n,
        this.value = r
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return un.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let s in n.attrs)
            r[s] = n.attrs[s];
        r[this.attr] = this.value;
        let a = n.type.create(r, null, n.marks);
        return un.fromReplace(e, this.pos, this.pos + 1, new Ie(Ae.from(a),0,n.isLeaf ? 0 : 1))
    }
    getMap() {
        return nr.empty
    }
    invert(e) {
        return new Zl(this.pos,this.attr,e.nodeAt(this.pos).attrs[this.attr])
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Zl(n.pos,this.attr,this.value)
    }
    toJSON() {
        return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Zl(n.pos,n.attr,n.value)
    }
}
In.jsonID("attr", Zl);
class Ao extends In {
    constructor(e, n) {
        super(),
        this.attr = e,
        this.value = n
    }
    apply(e) {
        let n = Object.create(null);
        for (let a in e.attrs)
            n[a] = e.attrs[a];
        n[this.attr] = this.value;
        let r = e.type.create(n, e.content, e.marks);
        return un.ok(r)
    }
    getMap() {
        return nr.empty
    }
    invert(e) {
        return new Ao(this.attr,e.attrs[this.attr])
    }
    map(e) {
        return this
    }
    toJSON() {
        return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.attr != "string")
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new Ao(n.attr,n.value)
    }
}
In.jsonID("docAttr", Ao);
let fi = class extends Error {
}
;
fi = function t(e) {
    let n = Error.call(this, e);
    return n.__proto__ = t.prototype,
    n
}
;
fi.prototype = Object.create(Error.prototype);
fi.prototype.constructor = fi;
fi.prototype.name = "TransformError";
class Bj {
    constructor(e) {
        this.doc = e,
        this.steps = [],
        this.docs = [],
        this.mapping = new Xl
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc
    }
    step(e) {
        let n = this.maybeStep(e);
        if (n.failed)
            throw new fi(n.failed);
        return this
    }
    maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc),
        n
    }
    get docChanged() {
        return this.steps.length > 0
    }
    addStep(e, n) {
        this.docs.push(this.doc),
        this.steps.push(e),
        this.mapping.appendMap(e.getMap()),
        this.doc = n
    }
    replace(e, n=e, r=Ie.empty) {
        let a = hc(this.doc, e, n, r);
        return a && this.step(a),
        this
    }
    replaceWith(e, n, r) {
        return this.replace(e, n, new Ie(Ae.from(r),0,0))
    }
    delete(e, n) {
        return this.replace(e, n, Ie.empty)
    }
    insert(e, n) {
        return this.replaceWith(e, e, n)
    }
    replaceRange(e, n, r) {
        return Dj(this, e, n, r),
        this
    }
    replaceRangeWith(e, n, r) {
        return Pj(this, e, n, r),
        this
    }
    deleteRange(e, n) {
        return Fj(this, e, n),
        this
    }
    lift(e, n) {
        return kj(this, e, n),
        this
    }
    join(e, n=1) {
        return Ej(this, e, n),
        this
    }
    wrap(e, n) {
        return xj(this, e, n),
        this
    }
    setBlockType(e, n=e, r, a=null) {
        return Sj(this, e, n, r, a),
        this
    }
    setNodeMarkup(e, n, r=null, a) {
        return Tj(this, e, n, r, a),
        this
    }
    setNodeAttribute(e, n, r) {
        return this.step(new Zl(e,n,r)),
        this
    }
    setDocAttribute(e, n) {
        return this.step(new Ao(e,n)),
        this
    }
    addNodeMark(e, n) {
        return this.step(new ns(e,n)),
        this
    }
    removeNodeMark(e, n) {
        if (!(n instanceof Bt)) {
            let r = this.doc.nodeAt(e);
            if (!r)
                throw new RangeError("No node at position " + e);
            if (n = n.isInSet(r.marks),
            !n)
                return this
        }
        return this.step(new ci(e,n)),
        this
    }
    split(e, n=1, r) {
        return Cj(this, e, n, r),
        this
    }
    addMark(e, n, r) {
        return vj(this, e, n, r),
        this
    }
    removeMark(e, n, r) {
        return gj(this, e, n, r),
        this
    }
    clearIncompatible(e, n, r) {
        return bj(this, e, n, r),
        this
    }
}
const $f = Object.create(null);
class lt {
    constructor(e, n, r) {
        this.$anchor = e,
        this.$head = n,
        this.ranges = r || [new Vj(e.min(n),e.max(n))]
    }
    get anchor() {
        return this.$anchor.pos
    }
    get head() {
        return this.$head.pos
    }
    get from() {
        return this.$from.pos
    }
    get to() {
        return this.$to.pos
    }
    get $from() {
        return this.ranges[0].$from
    }
    get $to() {
        return this.ranges[0].$to
    }
    get empty() {
        let e = this.ranges;
        for (let n = 0; n < e.length; n++)
            if (e[n].$from.pos != e[n].$to.pos)
                return !1;
        return !0
    }
    content() {
        return this.$from.doc.slice(this.from, this.to, !0)
    }
    replace(e, n=Ie.empty) {
        let r = n.content.lastChild
          , a = null;
        for (let i = 0; i < n.openEnd; i++)
            a = r,
            r = r.lastChild;
        let s = e.steps.length
          , l = this.ranges;
        for (let i = 0; i < l.length; i++) {
            let {$from: o, $to: u} = l[i]
              , d = e.mapping.slice(s);
            e.replaceRange(d.map(o.pos), d.map(u.pos), i ? Ie.empty : n),
            i == 0 && o0(e, s, (r ? r.isInline : a && a.isTextblock) ? -1 : 1)
        }
    }
    replaceWith(e, n) {
        let r = e.steps.length
          , a = this.ranges;
        for (let s = 0; s < a.length; s++) {
            let {$from: l, $to: i} = a[s]
              , o = e.mapping.slice(r)
              , u = o.map(l.pos)
              , d = o.map(i.pos);
            s ? e.deleteRange(u, d) : (e.replaceRangeWith(u, d, n),
            o0(e, r, n.isInline ? -1 : 1))
        }
    }
    static findFrom(e, n, r=!1) {
        let a = e.parent.inlineContent ? new nt(e) : Vl(e.node(0), e.parent, e.pos, e.index(), n, r);
        if (a)
            return a;
        for (let s = e.depth - 1; s >= 0; s--) {
            let l = n < 0 ? Vl(e.node(0), e.node(s), e.before(s + 1), e.index(s), n, r) : Vl(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, n, r);
            if (l)
                return l
        }
        return null
    }
    static near(e, n=1) {
        return this.findFrom(e, n) || this.findFrom(e, -n) || new Dr(e.node(0))
    }
    static atStart(e) {
        return Vl(e, e, 0, 0, 1) || new Dr(e)
    }
    static atEnd(e) {
        return Vl(e, e, e.content.size, e.childCount, -1) || new Dr(e)
    }
    static fromJSON(e, n) {
        if (!n || !n.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let r = $f[n.type];
        if (!r)
            throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in $f)
            throw new RangeError("Duplicate use of selection JSON ID " + e);
        return $f[e] = n,
        n.prototype.jsonID = e,
        n
    }
    getBookmark() {
        return nt.between(this.$anchor, this.$head).getBookmark()
    }
}
lt.prototype.visible = !0;
class Vj {
    constructor(e, n) {
        this.$from = e,
        this.$to = n
    }
}
let l0 = !1;
function i0(t) {
    !l0 && !t.parent.inlineContent && (l0 = !0,
    console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"))
}
class nt extends lt {
    constructor(e, n=e) {
        i0(e),
        i0(n),
        super(e, n)
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
            return lt.near(r);
        let a = e.resolve(n.map(this.anchor));
        return new nt(a.parent.inlineContent ? a : r,r)
    }
    replace(e, n=Ie.empty) {
        if (super.replace(e, n),
        n == Ie.empty) {
            let r = this.$from.marksAcross(this.$to);
            r && e.ensureMarks(r)
        }
    }
    eq(e) {
        return e instanceof nt && e.anchor == this.anchor && e.head == this.head
    }
    getBookmark() {
        return new mc(this.anchor,this.head)
    }
    toJSON() {
        return {
            type: "text",
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new nt(e.resolve(n.anchor),e.resolve(n.head))
    }
    static create(e, n, r=n) {
        let a = e.resolve(n);
        return new this(a,r == n ? a : e.resolve(r))
    }
    static between(e, n, r) {
        let a = e.pos - n.pos;
        if ((!r || a) && (r = a >= 0 ? 1 : -1),
        !n.parent.inlineContent) {
            let s = lt.findFrom(n, r, !0) || lt.findFrom(n, -r, !0);
            if (s)
                n = s.$head;
            else
                return lt.near(n, r)
        }
        return e.parent.inlineContent || (a == 0 ? e = n : (e = (lt.findFrom(e, -r, !0) || lt.findFrom(e, r, !0)).$anchor,
        e.pos < n.pos != a < 0 && (e = n))),
        new nt(e,n)
    }
}
lt.jsonID("text", nt);
class mc {
    constructor(e, n) {
        this.anchor = e,
        this.head = n
    }
    map(e) {
        return new mc(e.map(this.anchor),e.map(this.head))
    }
    resolve(e) {
        return nt.between(e.resolve(this.anchor), e.resolve(this.head))
    }
}
class Ze extends lt {
    constructor(e) {
        let n = e.nodeAfter
          , r = e.node(0).resolve(e.pos + n.nodeSize);
        super(e, r),
        this.node = n
    }
    map(e, n) {
        let {deleted: r, pos: a} = n.mapResult(this.anchor)
          , s = e.resolve(a);
        return r ? lt.near(s) : new Ze(s)
    }
    content() {
        return new Ie(Ae.from(this.node),0,0)
    }
    eq(e) {
        return e instanceof Ze && e.anchor == this.anchor
    }
    toJSON() {
        return {
            type: "node",
            anchor: this.anchor
        }
    }
    getBookmark() {
        return new Im(this.anchor)
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new Ze(e.resolve(n.anchor))
    }
    static create(e, n) {
        return new Ze(e.resolve(n))
    }
    static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== !1
    }
}
Ze.prototype.visible = !1;
lt.jsonID("node", Ze);
class Im {
    constructor(e) {
        this.anchor = e
    }
    map(e) {
        let {deleted: n, pos: r} = e.mapResult(this.anchor);
        return n ? new mc(r,r) : new Im(r)
    }
    resolve(e) {
        let n = e.resolve(this.anchor)
          , r = n.nodeAfter;
        return r && Ze.isSelectable(r) ? new Ze(n) : lt.near(n)
    }
}
class Dr extends lt {
    constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size))
    }
    replace(e, n=Ie.empty) {
        if (n == Ie.empty) {
            e.delete(0, e.doc.content.size);
            let r = lt.atStart(e.doc);
            r.eq(e.selection) || e.setSelection(r)
        } else
            super.replace(e, n)
    }
    toJSON() {
        return {
            type: "all"
        }
    }
    static fromJSON(e) {
        return new Dr(e)
    }
    map(e) {
        return new Dr(e)
    }
    eq(e) {
        return e instanceof Dr
    }
    getBookmark() {
        return Ij
    }
}
lt.jsonID("all", Dr);
const Ij = {
    map() {
        return this
    },
    resolve(t) {
        return new Dr(t)
    }
};
function Vl(t, e, n, r, a, s=!1) {
    if (e.inlineContent)
        return nt.create(t, n);
    for (let l = r - (a > 0 ? 0 : 1); a > 0 ? l < e.childCount : l >= 0; l += a) {
        let i = e.child(l);
        if (i.isAtom) {
            if (!s && Ze.isSelectable(i))
                return Ze.create(t, n - (a < 0 ? i.nodeSize : 0))
        } else {
            let o = Vl(t, i, n + a, a < 0 ? i.childCount : 0, a, s);
            if (o)
                return o
        }
        n += i.nodeSize * a
    }
    return null
}
function o0(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e)
        return;
    let a = t.steps[r];
    if (!(a instanceof mn || a instanceof bn))
        return;
    let s = t.mapping.maps[r], l;
    s.forEach( (i, o, u, d) => {
        l == null && (l = d)
    }
    ),
    t.setSelection(lt.near(t.doc.resolve(l), n))
}
const u0 = 1
  , _u = 2
  , d0 = 4;
class Rj extends Bj {
    constructor(e) {
        super(e.doc),
        this.curSelectionFor = 0,
        this.updated = 0,
        this.meta = Object.create(null),
        this.time = Date.now(),
        this.curSelection = e.selection,
        this.storedMarks = e.storedMarks
    }
    get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)),
        this.curSelectionFor = this.steps.length),
        this.curSelection
    }
    setSelection(e) {
        if (e.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e,
        this.curSelectionFor = this.steps.length,
        this.updated = (this.updated | u0) & ~_u,
        this.storedMarks = null,
        this
    }
    get selectionSet() {
        return (this.updated & u0) > 0
    }
    setStoredMarks(e) {
        return this.storedMarks = e,
        this.updated |= _u,
        this
    }
    ensureMarks(e) {
        return Bt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e),
        this
    }
    addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()))
    }
    removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()))
    }
    get storedMarksSet() {
        return (this.updated & _u) > 0
    }
    addStep(e, n) {
        super.addStep(e, n),
        this.updated = this.updated & ~_u,
        this.storedMarks = null
    }
    setTime(e) {
        return this.time = e,
        this
    }
    replaceSelection(e) {
        return this.selection.replace(this, e),
        this
    }
    replaceSelectionWith(e, n=!0) {
        let r = this.selection;
        return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Bt.none))),
        r.replaceWith(this, e),
        this
    }
    deleteSelection() {
        return this.selection.replace(this),
        this
    }
    insertText(e, n, r) {
        let a = this.doc.type.schema;
        if (n == null)
            return e ? this.replaceSelectionWith(a.text(e), !0) : this.deleteSelection();
        {
            if (r == null && (r = n),
            r = r ?? n,
            !e)
                return this.deleteRange(n, r);
            let s = this.storedMarks;
            if (!s) {
                let l = this.doc.resolve(n);
                s = r == n ? l.marks() : l.marksAcross(this.doc.resolve(r))
            }
            return this.replaceRangeWith(n, r, a.text(e, s)),
            this.selection.empty || this.setSelection(lt.near(this.selection.$to)),
            this
        }
    }
    setMeta(e, n) {
        return this.meta[typeof e == "string" ? e : e.key] = n,
        this
    }
    getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key]
    }
    get isGeneric() {
        for (let e in this.meta)
            return !1;
        return !0
    }
    scrollIntoView() {
        return this.updated |= d0,
        this
    }
    get scrolledIntoView() {
        return (this.updated & d0) > 0
    }
}
function c0(t, e) {
    return !e || !t ? t : t.bind(e)
}
class Ji {
    constructor(e, n, r) {
        this.name = e,
        this.init = c0(n.init, r),
        this.apply = c0(n.apply, r)
    }
}
const Lj = [new Ji("doc",{
    init(t) {
        return t.doc || t.schema.topNodeType.createAndFill()
    },
    apply(t) {
        return t.doc
    }
}), new Ji("selection",{
    init(t, e) {
        return t.selection || lt.atStart(e.doc)
    },
    apply(t) {
        return t.selection
    }
}), new Ji("storedMarks",{
    init(t) {
        return t.storedMarks || null
    },
    apply(t, e, n, r) {
        return r.selection.$cursor ? t.storedMarks : null
    }
}), new Ji("scrollToSelection",{
    init() {
        return 0
    },
    apply(t, e) {
        return t.scrolledIntoView ? e + 1 : e
    }
})];
class Tf {
    constructor(e, n) {
        this.schema = e,
        this.plugins = [],
        this.pluginsByKey = Object.create(null),
        this.fields = Lj.slice(),
        n && n.forEach(r => {
            if (this.pluginsByKey[r.key])
                throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
            this.plugins.push(r),
            this.pluginsByKey[r.key] = r,
            r.spec.state && this.fields.push(new Ji(r.key,r.spec.state,r))
        }
        )
    }
}
class Ul {
    constructor(e) {
        this.config = e
    }
    get schema() {
        return this.config.schema
    }
    get plugins() {
        return this.config.plugins
    }
    apply(e) {
        return this.applyTransaction(e).state
    }
    filterTransaction(e, n=-1) {
        for (let r = 0; r < this.config.plugins.length; r++)
            if (r != n) {
                let a = this.config.plugins[r];
                if (a.spec.filterTransaction && !a.spec.filterTransaction.call(a, e, this))
                    return !1
            }
        return !0
    }
    applyTransaction(e) {
        if (!this.filterTransaction(e))
            return {
                state: this,
                transactions: []
            };
        let n = [e]
          , r = this.applyInner(e)
          , a = null;
        for (; ; ) {
            let s = !1;
            for (let l = 0; l < this.config.plugins.length; l++) {
                let i = this.config.plugins[l];
                if (i.spec.appendTransaction) {
                    let o = a ? a[l].n : 0
                      , u = a ? a[l].state : this
                      , d = o < n.length && i.spec.appendTransaction.call(i, o ? n.slice(o) : n, u, r);
                    if (d && r.filterTransaction(d, l)) {
                        if (d.setMeta("appendedTransaction", e),
                        !a) {
                            a = [];
                            for (let f = 0; f < this.config.plugins.length; f++)
                                a.push(f < l ? {
                                    state: r,
                                    n: n.length
                                } : {
                                    state: this,
                                    n: 0
                                })
                        }
                        n.push(d),
                        r = r.applyInner(d),
                        s = !0
                    }
                    a && (a[l] = {
                        state: r,
                        n: n.length
                    })
                }
            }
            if (!s)
                return {
                    state: r,
                    transactions: n
                }
        }
    }
    applyInner(e) {
        if (!e.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let n = new Ul(this.config)
          , r = this.config.fields;
        for (let a = 0; a < r.length; a++) {
            let s = r[a];
            n[s.name] = s.apply(e, this[s.name], this, n)
        }
        return n
    }
    get tr() {
        return new Rj(this)
    }
    static create(e) {
        let n = new Tf(e.doc ? e.doc.type.schema : e.schema,e.plugins)
          , r = new Ul(n);
        for (let a = 0; a < n.fields.length; a++)
            r[n.fields[a].name] = n.fields[a].init(e, r);
        return r
    }
    reconfigure(e) {
        let n = new Tf(this.schema,e.plugins)
          , r = n.fields
          , a = new Ul(n);
        for (let s = 0; s < r.length; s++) {
            let l = r[s].name;
            a[l] = this.hasOwnProperty(l) ? this[l] : r[s].init(e, a)
        }
        return a
    }
    toJSON(e) {
        let n = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
        };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())),
        e && typeof e == "object")
            for (let r in e) {
                if (r == "doc" || r == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let a = e[r]
                  , s = a.spec.state;
                s && s.toJSON && (n[r] = s.toJSON.call(a, this[a.key]))
            }
        return n
    }
    static fromJSON(e, n, r) {
        if (!n)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
            throw new RangeError("Required config field 'schema' missing");
        let a = new Tf(e.schema,e.plugins)
          , s = new Ul(a);
        return a.fields.forEach(l => {
            if (l.name == "doc")
                s.doc = Xs.fromJSON(e.schema, n.doc);
            else if (l.name == "selection")
                s.selection = lt.fromJSON(s.doc, n.selection);
            else if (l.name == "storedMarks")
                n.storedMarks && (s.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
            else {
                if (r)
                    for (let i in r) {
                        let o = r[i]
                          , u = o.spec.state;
                        if (o.key == l.name && u && u.fromJSON && Object.prototype.hasOwnProperty.call(n, i)) {
                            s[l.name] = u.fromJSON.call(o, e, n[i], s);
                            return
                        }
                    }
                s[l.name] = l.init(e, s)
            }
        }
        ),
        s
    }
}
function Uw(t, e, n) {
    for (let r in t) {
        let a = t[r];
        a instanceof Function ? a = a.bind(e) : r == "handleDOMEvents" && (a = Uw(a, e, {})),
        n[r] = a
    }
    return n
}
class $r {
    constructor(e) {
        this.spec = e,
        this.props = {},
        e.props && Uw(e.props, this, this.props),
        this.key = e.key ? e.key.key : Hw("plugin")
    }
    getState(e) {
        return e[this.key]
    }
}
const Cf = Object.create(null);
function Hw(t) {
    return t in Cf ? t + "$" + ++Cf[t] : (Cf[t] = 0,
    t + "$")
}
class Cs {
    constructor(e="key") {
        this.key = Hw(e)
    }
    get(e) {
        return e.config.pluginsByKey[this.key]
    }
    getState(e) {
        return e[this.key]
    }
}
const Tn = function(t) {
    for (var e = 0; ; e++)
        if (t = t.previousSibling,
        !t)
            return e
}
  , Mo = function(t) {
    let e = t.assignedSlot || t.parentNode;
    return e && e.nodeType == 11 ? e.host : e
};
let Xp = null;
const ka = function(t, e, n) {
    let r = Xp || (Xp = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length),
    r.setStart(t, e || 0),
    r
}
  , jj = function() {
    Xp = null
}
  , il = function(t, e, n, r) {
    return n && (f0(t, e, n, r, -1) || f0(t, e, n, r, 1))
}
  , Uj = /^(img|br|input|textarea|hr)$/i;
function f0(t, e, n, r, a) {
    for (; ; ) {
        if (t == n && e == r)
            return !0;
        if (e == (a < 0 ? 0 : Xr(t))) {
            let s = t.parentNode;
            if (!s || s.nodeType != 1 || Xo(t) || Uj.test(t.nodeName) || t.contentEditable == "false")
                return !1;
            e = Tn(t) + (a < 0 ? 0 : 1),
            t = s
        } else if (t.nodeType == 1) {
            if (t = t.childNodes[e + (a < 0 ? -1 : 0)],
            t.contentEditable == "false")
                return !1;
            e = a < 0 ? Xr(t) : 0
        } else
            return !1
    }
}
function Xr(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function Hj(t, e) {
    for (; ; ) {
        if (t.nodeType == 3 && e)
            return t;
        if (t.nodeType == 1 && e > 0) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e - 1],
            e = Xr(t)
        } else if (t.parentNode && !Xo(t))
            e = Tn(t),
            t = t.parentNode;
        else
            return null
    }
}
function Kj(t, e) {
    for (; ; ) {
        if (t.nodeType == 3 && e < t.nodeValue.length)
            return t;
        if (t.nodeType == 1 && e < t.childNodes.length) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e],
            e = 0
        } else if (t.parentNode && !Xo(t))
            e = Tn(t) + 1,
            t = t.parentNode;
        else
            return null
    }
}
function zj(t, e, n) {
    for (let r = e == 0, a = e == Xr(t); r || a; ) {
        if (t == n)
            return !0;
        let s = Tn(t);
        if (t = t.parentNode,
        !t)
            return !1;
        r = r && s == 0,
        a = a && s == Xr(t)
    }
}
function Xo(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
        ;
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t)
}
const vc = function(t) {
    return t.focusNode && il(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
};
function Is(t, e) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0),
    n.keyCode = t,
    n.key = n.code = e,
    n
}
function qj(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
    return e
}
function Wj(t, e, n) {
    if (t.caretPositionFromPoint)
        try {
            let r = t.caretPositionFromPoint(e, n);
            if (r)
                return {
                    node: r.offsetNode,
                    offset: r.offset
                }
        } catch {}
    if (t.caretRangeFromPoint) {
        let r = t.caretRangeFromPoint(e, n);
        if (r)
            return {
                node: r.startContainer,
                offset: r.startOffset
            }
    }
}
const oa = typeof navigator < "u" ? navigator : null
  , p0 = typeof document < "u" ? document : null
  , Es = oa && oa.userAgent || ""
  , Qp = /Edge\/(\d+)/.exec(Es)
  , Kw = /MSIE \d/.exec(Es)
  , Zp = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Es)
  , Qn = !!(Kw || Zp || Qp)
  , us = Kw ? document.documentMode : Zp ? +Zp[1] : Qp ? +Qp[1] : 0
  , Rr = !Qn && /gecko\/(\d+)/i.test(Es);
Rr && +(/Firefox\/(\d+)/.exec(Es) || [0, 0])[1];
const eh = !Qn && /Chrome\/(\d+)/.exec(Es)
  , Kn = !!eh
  , Gj = eh ? +eh[1] : 0
  , Wn = !Qn && !!oa && /Apple Computer/.test(oa.vendor)
  , pi = Wn && (/Mobile\/\w+/.test(Es) || !!oa && oa.maxTouchPoints > 2)
  , mr = pi || (oa ? /Mac/.test(oa.platform) : !1)
  , Yj = oa ? /Win/.test(oa.platform) : !1
  , Er = /Android \d/.test(Es)
  , Qo = !!p0 && "webkitFontSmoothing"in p0.documentElement.style
  , Jj = Qo ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Xj(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
    } : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight
    }
}
function ga(t, e) {
    return typeof t == "number" ? t : t[e]
}
function Qj(t) {
    let e = t.getBoundingClientRect()
      , n = e.width / t.offsetWidth || 1
      , r = e.height / t.offsetHeight || 1;
    return {
        left: e.left,
        right: e.left + t.clientWidth * n,
        top: e.top,
        bottom: e.top + t.clientHeight * r
    }
}
function h0(t, e, n) {
    let r = t.someProp("scrollThreshold") || 0
      , a = t.someProp("scrollMargin") || 5
      , s = t.dom.ownerDocument;
    for (let l = n || t.dom; l; l = Mo(l)) {
        if (l.nodeType != 1)
            continue;
        let i = l
          , o = i == s.body
          , u = o ? Xj(s) : Qj(i)
          , d = 0
          , f = 0;
        if (e.top < u.top + ga(r, "top") ? f = -(u.top - e.top + ga(a, "top")) : e.bottom > u.bottom - ga(r, "bottom") && (f = e.bottom - e.top > u.bottom - u.top ? e.top + ga(a, "top") - u.top : e.bottom - u.bottom + ga(a, "bottom")),
        e.left < u.left + ga(r, "left") ? d = -(u.left - e.left + ga(a, "left")) : e.right > u.right - ga(r, "right") && (d = e.right - u.right + ga(a, "right")),
        d || f)
            if (o)
                s.defaultView.scrollBy(d, f);
            else {
                let p = i.scrollLeft
                  , h = i.scrollTop;
                f && (i.scrollTop += f),
                d && (i.scrollLeft += d);
                let v = i.scrollLeft - p
                  , y = i.scrollTop - h;
                e = {
                    left: e.left - v,
                    top: e.top - y,
                    right: e.right - v,
                    bottom: e.bottom - y
                }
            }
        if (o || /^(fixed|sticky)$/.test(getComputedStyle(l).position))
            break
    }
}
function Zj(t) {
    let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, a;
    for (let s = (e.left + e.right) / 2, l = n + 1; l < Math.min(innerHeight, e.bottom); l += 5) {
        let i = t.root.elementFromPoint(s, l);
        if (!i || i == t.dom || !t.dom.contains(i))
            continue;
        let o = i.getBoundingClientRect();
        if (o.top >= n - 20) {
            r = i,
            a = o.top;
            break
        }
    }
    return {
        refDOM: r,
        refTop: a,
        stack: zw(t.dom)
    }
}
function zw(t) {
    let e = []
      , n = t.ownerDocument;
    for (let r = t; r && (e.push({
        dom: r,
        top: r.scrollTop,
        left: r.scrollLeft
    }),
    t != n); r = Mo(r))
        ;
    return e
}
function eU({refDOM: t, refTop: e, stack: n}) {
    let r = t ? t.getBoundingClientRect().top : 0;
    qw(n, r == 0 ? 0 : r - e)
}
function qw(t, e) {
    for (let n = 0; n < t.length; n++) {
        let {dom: r, top: a, left: s} = t[n];
        r.scrollTop != a + e && (r.scrollTop = a + e),
        r.scrollLeft != s && (r.scrollLeft = s)
    }
}
let Ol = null;
function tU(t) {
    if (t.setActive)
        return t.setActive();
    if (Ol)
        return t.focus(Ol);
    let e = zw(t);
    t.focus(Ol == null ? {
        get preventScroll() {
            return Ol = {
                preventScroll: !0
            },
            !0
        }
    } : void 0),
    Ol || (Ol = !1,
    qw(e, 0))
}
function Ww(t, e) {
    let n, r = 2e8, a, s = 0, l = e.top, i = e.top, o, u;
    for (let d = t.firstChild, f = 0; d; d = d.nextSibling,
    f++) {
        let p;
        if (d.nodeType == 1)
            p = d.getClientRects();
        else if (d.nodeType == 3)
            p = ka(d).getClientRects();
        else
            continue;
        for (let h = 0; h < p.length; h++) {
            let v = p[h];
            if (v.top <= l && v.bottom >= i) {
                l = Math.max(v.bottom, l),
                i = Math.min(v.top, i);
                let y = v.left > e.left ? v.left - e.left : v.right < e.left ? e.left - v.right : 0;
                if (y < r) {
                    n = d,
                    r = y,
                    a = y && n.nodeType == 3 ? {
                        left: v.right < e.left ? v.right : v.left,
                        top: e.top
                    } : e,
                    d.nodeType == 1 && y && (s = f + (e.left >= (v.left + v.right) / 2 ? 1 : 0));
                    continue
                }
            } else
                v.top > e.top && !o && v.left <= e.left && v.right >= e.left && (o = d,
                u = {
                    left: Math.max(v.left, Math.min(v.right, e.left)),
                    top: v.top
                });
            !n && (e.left >= v.right && e.top >= v.top || e.left >= v.left && e.top >= v.bottom) && (s = f + 1)
        }
    }
    return !n && o && (n = o,
    a = u,
    r = 0),
    n && n.nodeType == 3 ? nU(n, a) : !n || r && n.nodeType == 1 ? {
        node: t,
        offset: s
    } : Ww(n, a)
}
function nU(t, e) {
    let n = t.nodeValue.length
      , r = document.createRange();
    for (let a = 0; a < n; a++) {
        r.setEnd(t, a + 1),
        r.setStart(t, a);
        let s = Ka(r, 1);
        if (s.top != s.bottom && Rm(e, s))
            return {
                node: t,
                offset: a + (e.left >= (s.left + s.right) / 2 ? 1 : 0)
            }
    }
    return {
        node: t,
        offset: 0
    }
}
function Rm(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1
}
function rU(t, e) {
    let n = t.parentNode;
    return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t
}
function aU(t, e, n) {
    let {node: r, offset: a} = Ww(e, n)
      , s = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let l = r.getBoundingClientRect();
        s = l.left != l.right && n.left > (l.left + l.right) / 2 ? 1 : -1
    }
    return t.docView.posFromDOM(r, a, s)
}
function sU(t, e, n, r) {
    let a = -1;
    for (let s = e, l = !1; s != t.dom; ) {
        let i = t.docView.nearestDesc(s, !0);
        if (!i)
            return null;
        if (i.dom.nodeType == 1 && (i.node.isBlock && i.parent && !l || !i.contentDOM)) {
            let o = i.dom.getBoundingClientRect();
            if (i.node.isBlock && i.parent && !l && (l = !0,
            o.left > r.left || o.top > r.top ? a = i.posBefore : (o.right < r.left || o.bottom < r.top) && (a = i.posAfter)),
            !i.contentDOM && a < 0 && !i.node.isText)
                return (i.node.isBlock ? r.top < (o.top + o.bottom) / 2 : r.left < (o.left + o.right) / 2) ? i.posBefore : i.posAfter
        }
        s = i.dom.parentNode
    }
    return a > -1 ? a : t.docView.posFromDOM(e, n, -1)
}
function Gw(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
        for (let a = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), s = a; ; ) {
            let l = t.childNodes[s];
            if (l.nodeType == 1) {
                let i = l.getClientRects();
                for (let o = 0; o < i.length; o++) {
                    let u = i[o];
                    if (Rm(e, u))
                        return Gw(l, e, u)
                }
            }
            if ((s = (s + 1) % r) == a)
                break
        }
    return t
}
function lU(t, e) {
    let n = t.dom.ownerDocument, r, a = 0, s = Wj(n, e.left, e.top);
    s && ({node: r, offset: a} = s);
    let l = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), i;
    if (!l || !t.dom.contains(l.nodeType != 1 ? l.parentNode : l)) {
        let u = t.dom.getBoundingClientRect();
        if (!Rm(e, u) || (l = Gw(t.dom, e, u),
        !l))
            return null
    }
    if (Wn)
        for (let u = l; r && u; u = Mo(u))
            u.draggable && (r = void 0);
    if (l = rU(l, e),
    r) {
        if (Rr && r.nodeType == 1 && (a = Math.min(a, r.childNodes.length),
        a < r.childNodes.length)) {
            let d = r.childNodes[a], f;
            d.nodeName == "IMG" && (f = d.getBoundingClientRect()).right <= e.left && f.bottom > e.top && a++
        }
        let u;
        Qo && a && r.nodeType == 1 && (u = r.childNodes[a - 1]).nodeType == 1 && u.contentEditable == "false" && u.getBoundingClientRect().top >= e.top && a--,
        r == t.dom && a == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? i = t.state.doc.content.size : (a == 0 || r.nodeType != 1 || r.childNodes[a - 1].nodeName != "BR") && (i = sU(t, r, a, e))
    }
    i == null && (i = aU(t, l, e));
    let o = t.docView.nearestDesc(l, !0);
    return {
        pos: i,
        inside: o ? o.posAtStart - o.border : -1
    }
}
function m0(t) {
    return t.top < t.bottom || t.left < t.right
}
function Ka(t, e) {
    let n = t.getClientRects();
    if (n.length) {
        let r = n[e < 0 ? 0 : n.length - 1];
        if (m0(r))
            return r
    }
    return Array.prototype.find.call(n, m0) || t.getBoundingClientRect()
}
const iU = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Yw(t, e, n) {
    let {node: r, offset: a, atom: s} = t.docView.domFromPos(e, n < 0 ? -1 : 1)
      , l = Qo || Rr;
    if (r.nodeType == 3)
        if (l && (iU.test(r.nodeValue) || (n < 0 ? !a : a == r.nodeValue.length))) {
            let o = Ka(ka(r, a, a), n);
            if (Rr && a && /\s/.test(r.nodeValue[a - 1]) && a < r.nodeValue.length) {
                let u = Ka(ka(r, a - 1, a - 1), -1);
                if (u.top == o.top) {
                    let d = Ka(ka(r, a, a + 1), -1);
                    if (d.top != o.top)
                        return Ri(d, d.left < u.left)
                }
            }
            return o
        } else {
            let o = a
              , u = a
              , d = n < 0 ? 1 : -1;
            return n < 0 && !a ? (u++,
            d = -1) : n >= 0 && a == r.nodeValue.length ? (o--,
            d = 1) : n < 0 ? o-- : u++,
            Ri(Ka(ka(r, o, u), d), d < 0)
        }
    if (!t.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
        if (s == null && a && (n < 0 || a == Xr(r))) {
            let o = r.childNodes[a - 1];
            if (o.nodeType == 1)
                return Ef(o.getBoundingClientRect(), !1)
        }
        if (s == null && a < Xr(r)) {
            let o = r.childNodes[a];
            if (o.nodeType == 1)
                return Ef(o.getBoundingClientRect(), !0)
        }
        return Ef(r.getBoundingClientRect(), n >= 0)
    }
    if (s == null && a && (n < 0 || a == Xr(r))) {
        let o = r.childNodes[a - 1]
          , u = o.nodeType == 3 ? ka(o, Xr(o) - (l ? 0 : 1)) : o.nodeType == 1 && (o.nodeName != "BR" || !o.nextSibling) ? o : null;
        if (u)
            return Ri(Ka(u, 1), !1)
    }
    if (s == null && a < Xr(r)) {
        let o = r.childNodes[a];
        for (; o.pmViewDesc && o.pmViewDesc.ignoreForCoords; )
            o = o.nextSibling;
        let u = o ? o.nodeType == 3 ? ka(o, 0, l ? 0 : 1) : o.nodeType == 1 ? o : null : null;
        if (u)
            return Ri(Ka(u, -1), !0)
    }
    return Ri(Ka(r.nodeType == 3 ? ka(r) : r, -n), n >= 0)
}
function Ri(t, e) {
    if (t.width == 0)
        return t;
    let n = e ? t.left : t.right;
    return {
        top: t.top,
        bottom: t.bottom,
        left: n,
        right: n
    }
}
function Ef(t, e) {
    if (t.height == 0)
        return t;
    let n = e ? t.top : t.bottom;
    return {
        top: n,
        bottom: n,
        left: t.left,
        right: t.right
    }
}
function Jw(t, e, n) {
    let r = t.state
      , a = t.root.activeElement;
    r != e && t.updateState(e),
    a != t.dom && t.focus();
    try {
        return n()
    } finally {
        r != e && t.updateState(r),
        a != t.dom && a && a.focus()
    }
}
function oU(t, e, n) {
    let r = e.selection
      , a = n == "up" ? r.$from : r.$to;
    return Jw(t, e, () => {
        let {node: s} = t.docView.domFromPos(a.pos, n == "up" ? -1 : 1);
        for (; ; ) {
            let i = t.docView.nearestDesc(s, !0);
            if (!i)
                break;
            if (i.node.isBlock) {
                s = i.contentDOM || i.dom;
                break
            }
            s = i.dom.parentNode
        }
        let l = Yw(t, a.pos, 1);
        for (let i = s.firstChild; i; i = i.nextSibling) {
            let o;
            if (i.nodeType == 1)
                o = i.getClientRects();
            else if (i.nodeType == 3)
                o = ka(i, 0, i.nodeValue.length).getClientRects();
            else
                continue;
            for (let u = 0; u < o.length; u++) {
                let d = o[u];
                if (d.bottom > d.top + 1 && (n == "up" ? l.top - d.top > (d.bottom - l.top) * 2 : d.bottom - l.bottom > (l.bottom - d.top) * 2))
                    return !1
            }
        }
        return !0
    }
    )
}
const uU = /[\u0590-\u08ac]/;
function dU(t, e, n) {
    let {$head: r} = e.selection;
    if (!r.parent.isTextblock)
        return !1;
    let a = r.parentOffset
      , s = !a
      , l = a == r.parent.content.size
      , i = t.domSelection();
    return !uU.test(r.parent.textContent) || !i.modify ? n == "left" || n == "backward" ? s : l : Jw(t, e, () => {
        let {focusNode: o, focusOffset: u, anchorNode: d, anchorOffset: f} = t.domSelectionRange()
          , p = i.caretBidiLevel;
        i.modify("move", n, "character");
        let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom
          , {focusNode: v, focusOffset: y} = t.domSelectionRange()
          , k = v && !h.contains(v.nodeType == 1 ? v : v.parentNode) || o == v && u == y;
        try {
            i.collapse(d, f),
            o && (o != d || u != f) && i.extend && i.extend(o, u)
        } catch {}
        return p != null && (i.caretBidiLevel = p),
        k
    }
    )
}
let v0 = null
  , g0 = null
  , b0 = !1;
function cU(t, e, n) {
    return v0 == e && g0 == n ? b0 : (v0 = e,
    g0 = n,
    b0 = n == "up" || n == "down" ? oU(t, e, n) : dU(t, e, n))
}
const _r = 0
  , y0 = 1
  , Hs = 2
  , ua = 3;
class Zo {
    constructor(e, n, r, a) {
        this.parent = e,
        this.children = n,
        this.dom = r,
        this.contentDOM = a,
        this.dirty = _r,
        r.pmViewDesc = this
    }
    matchesWidget(e) {
        return !1
    }
    matchesMark(e) {
        return !1
    }
    matchesNode(e, n, r) {
        return !1
    }
    matchesHack(e) {
        return !1
    }
    parseRule() {
        return null
    }
    stopEvent(e) {
        return !1
    }
    get size() {
        let e = 0;
        for (let n = 0; n < this.children.length; n++)
            e += this.children[n].size;
        return e
    }
    get border() {
        return 0
    }
    destroy() {
        this.parent = void 0,
        this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
            this.children[e].destroy()
    }
    posBeforeChild(e) {
        for (let n = 0, r = this.posAtStart; ; n++) {
            let a = this.children[n];
            if (a == e)
                return r;
            r += a.size
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this)
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    }
    get posAfter() {
        return this.posBefore + this.size
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border
    }
    localPosFromDOM(e, n, r) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
            if (r < 0) {
                let s, l;
                if (e == this.contentDOM)
                    s = e.childNodes[n - 1];
                else {
                    for (; e.parentNode != this.contentDOM; )
                        e = e.parentNode;
                    s = e.previousSibling
                }
                for (; s && !((l = s.pmViewDesc) && l.parent == this); )
                    s = s.previousSibling;
                return s ? this.posBeforeChild(l) + l.size : this.posAtStart
            } else {
                let s, l;
                if (e == this.contentDOM)
                    s = e.childNodes[n];
                else {
                    for (; e.parentNode != this.contentDOM; )
                        e = e.parentNode;
                    s = e.nextSibling
                }
                for (; s && !((l = s.pmViewDesc) && l.parent == this); )
                    s = s.nextSibling;
                return s ? this.posBeforeChild(l) : this.posAtEnd
            }
        let a;
        if (e == this.dom && this.contentDOM)
            a = n > Tn(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
            a = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
            if (n == 0)
                for (let s = e; ; s = s.parentNode) {
                    if (s == this.dom) {
                        a = !1;
                        break
                    }
                    if (s.previousSibling)
                        break
                }
            if (a == null && n == e.childNodes.length)
                for (let s = e; ; s = s.parentNode) {
                    if (s == this.dom) {
                        a = !0;
                        break
                    }
                    if (s.nextSibling)
                        break
                }
        }
        return a ?? r > 0 ? this.posAtEnd : this.posAtStart
    }
    nearestDesc(e, n=!1) {
        for (let r = !0, a = e; a; a = a.parentNode) {
            let s = this.getDesc(a), l;
            if (s && (!n || s.node))
                if (r && (l = s.nodeDOM) && !(l.nodeType == 1 ? l.contains(e.nodeType == 1 ? e : e.parentNode) : l == e))
                    r = !1;
                else
                    return s
        }
    }
    getDesc(e) {
        let n = e.pmViewDesc;
        for (let r = n; r; r = r.parent)
            if (r == this)
                return n
    }
    posFromDOM(e, n, r) {
        for (let a = e; a; a = a.parentNode) {
            let s = this.getDesc(a);
            if (s)
                return s.localPosFromDOM(e, n, r)
        }
        return -1
    }
    descAt(e) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
            let a = this.children[n]
              , s = r + a.size;
            if (r == e && s != r) {
                for (; !a.border && a.children.length; )
                    a = a.children[0];
                return a
            }
            if (e < s)
                return a.descAt(e - r - a.border);
            r = s
        }
    }
    domFromPos(e, n) {
        if (!this.contentDOM)
            return {
                node: this.dom,
                offset: 0,
                atom: e + 1
            };
        let r = 0
          , a = 0;
        for (let s = 0; r < this.children.length; r++) {
            let l = this.children[r]
              , i = s + l.size;
            if (i > e || l instanceof Qw) {
                a = e - s;
                break
            }
            s = i
        }
        if (a)
            return this.children[r].domFromPos(a - this.children[r].border, n);
        for (let s; r && !(s = this.children[r - 1]).size && s instanceof Xw && s.side >= 0; r--)
            ;
        if (n <= 0) {
            let s, l = !0;
            for (; s = r ? this.children[r - 1] : null,
            !(!s || s.dom.parentNode == this.contentDOM); r--,
            l = !1)
                ;
            return s && n && l && !s.border && !s.domAtom ? s.domFromPos(s.size, n) : {
                node: this.contentDOM,
                offset: s ? Tn(s.dom) + 1 : 0
            }
        } else {
            let s, l = !0;
            for (; s = r < this.children.length ? this.children[r] : null,
            !(!s || s.dom.parentNode == this.contentDOM); r++,
            l = !1)
                ;
            return s && l && !s.border && !s.domAtom ? s.domFromPos(0, n) : {
                node: this.contentDOM,
                offset: s ? Tn(s.dom) : this.contentDOM.childNodes.length
            }
        }
    }
    parseRange(e, n, r=0) {
        if (this.children.length == 0)
            return {
                node: this.contentDOM,
                from: e,
                to: n,
                fromOffset: 0,
                toOffset: this.contentDOM.childNodes.length
            };
        let a = -1
          , s = -1;
        for (let l = r, i = 0; ; i++) {
            let o = this.children[i]
              , u = l + o.size;
            if (a == -1 && e <= u) {
                let d = l + o.border;
                if (e >= d && n <= u - o.border && o.node && o.contentDOM && this.contentDOM.contains(o.contentDOM))
                    return o.parseRange(e, n, d);
                e = l;
                for (let f = i; f > 0; f--) {
                    let p = this.children[f - 1];
                    if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(1)) {
                        a = Tn(p.dom) + 1;
                        break
                    }
                    e -= p.size
                }
                a == -1 && (a = 0)
            }
            if (a > -1 && (u > n || i == this.children.length - 1)) {
                n = u;
                for (let d = i + 1; d < this.children.length; d++) {
                    let f = this.children[d];
                    if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(-1)) {
                        s = Tn(f.dom);
                        break
                    }
                    n += f.size
                }
                s == -1 && (s = this.contentDOM.childNodes.length);
                break
            }
            l = u
        }
        return {
            node: this.contentDOM,
            from: e,
            to: n,
            fromOffset: a,
            toOffset: s
        }
    }
    emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
            return !1;
        let n = this.children[e < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(e)
    }
    domAfterPos(e) {
        let {node: n, offset: r} = this.domFromPos(e, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
            throw new RangeError("No node after pos " + e);
        return n.childNodes[r]
    }
    setSelection(e, n, r, a=!1) {
        let s = Math.min(e, n)
          , l = Math.max(e, n);
        for (let p = 0, h = 0; p < this.children.length; p++) {
            let v = this.children[p]
              , y = h + v.size;
            if (s > h && l < y)
                return v.setSelection(e - h - v.border, n - h - v.border, r, a);
            h = y
        }
        let i = this.domFromPos(e, e ? -1 : 1)
          , o = n == e ? i : this.domFromPos(n, n ? -1 : 1)
          , u = r.getSelection()
          , d = !1;
        if ((Rr || Wn) && e == n) {
            let {node: p, offset: h} = i;
            if (p.nodeType == 3) {
                if (d = !!(h && p.nodeValue[h - 1] == `
`),
                d && h == p.nodeValue.length)
                    for (let v = p, y; v; v = v.parentNode) {
                        if (y = v.nextSibling) {
                            y.nodeName == "BR" && (i = o = {
                                node: y.parentNode,
                                offset: Tn(y) + 1
                            });
                            break
                        }
                        let k = v.pmViewDesc;
                        if (k && k.node && k.node.isBlock)
                            break
                    }
            } else {
                let v = p.childNodes[h - 1];
                d = v && (v.nodeName == "BR" || v.contentEditable == "false")
            }
        }
        if (Rr && u.focusNode && u.focusNode != o.node && u.focusNode.nodeType == 1) {
            let p = u.focusNode.childNodes[u.focusOffset];
            p && p.contentEditable == "false" && (a = !0)
        }
        if (!(a || d && Wn) && il(i.node, i.offset, u.anchorNode, u.anchorOffset) && il(o.node, o.offset, u.focusNode, u.focusOffset))
            return;
        let f = !1;
        if ((u.extend || e == n) && !d) {
            u.collapse(i.node, i.offset);
            try {
                e != n && u.extend(o.node, o.offset),
                f = !0
            } catch {}
        }
        if (!f) {
            if (e > n) {
                let h = i;
                i = o,
                o = h
            }
            let p = document.createRange();
            p.setEnd(o.node, o.offset),
            p.setStart(i.node, i.offset),
            u.removeAllRanges(),
            u.addRange(p)
        }
    }
    ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection"
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    }
    markDirty(e, n) {
        for (let r = 0, a = 0; a < this.children.length; a++) {
            let s = this.children[a]
              , l = r + s.size;
            if (r == l ? e <= l && n >= r : e < l && n > r) {
                let i = r + s.border
                  , o = l - s.border;
                if (e >= i && n <= o) {
                    this.dirty = e == r || n == l ? Hs : y0,
                    e == i && n == o && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = ua : s.markDirty(e - i, n - i);
                    return
                } else
                    s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Hs : ua
            }
            r = l
        }
        this.dirty = Hs
    }
    markParentsDirty() {
        let e = 1;
        for (let n = this.parent; n; n = n.parent,
        e++) {
            let r = e == 1 ? Hs : y0;
            n.dirty < r && (n.dirty = r)
        }
    }
    get domAtom() {
        return !1
    }
    get ignoreForCoords() {
        return !1
    }
    isText(e) {
        return !1
    }
}
class Xw extends Zo {
    constructor(e, n, r, a) {
        let s, l = n.type.toDOM;
        if (typeof l == "function" && (l = l(r, () => {
            if (!s)
                return a;
            if (s.parent)
                return s.parent.posBeforeChild(s)
        }
        )),
        !n.type.spec.raw) {
            if (l.nodeType != 1) {
                let i = document.createElement("span");
                i.appendChild(l),
                l = i
            }
            l.contentEditable = "false",
            l.classList.add("ProseMirror-widget")
        }
        super(e, [], l, null),
        this.widget = n,
        this.widget = n,
        s = this
    }
    matchesWidget(e) {
        return this.dirty == _r && e.type.eq(this.widget.type)
    }
    parseRule() {
        return {
            ignore: !0
        }
    }
    stopEvent(e) {
        let n = this.widget.spec.stopEvent;
        return n ? n(e) : !1
    }
    ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection
    }
    destroy() {
        this.widget.type.destroy(this.dom),
        super.destroy()
    }
    get domAtom() {
        return !0
    }
    get side() {
        return this.widget.type.side
    }
}
class fU extends Zo {
    constructor(e, n, r, a) {
        super(e, [], n, null),
        this.textDOM = r,
        this.text = a
    }
    get size() {
        return this.text.length
    }
    localPosFromDOM(e, n) {
        return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
    }
    domFromPos(e) {
        return {
            node: this.textDOM,
            offset: e
        }
    }
    ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue
    }
}
class ol extends Zo {
    constructor(e, n, r, a) {
        super(e, [], r, a),
        this.mark = n
    }
    static create(e, n, r, a) {
        let s = a.nodeViews[n.type.name]
          , l = s && s(n, a, r);
        return (!l || !l.dom) && (l = ea.renderSpec(document, n.type.spec.toDOM(n, r))),
        new ol(e,n,l.dom,l.contentDOM || l.dom)
    }
    parseRule() {
        return this.dirty & ua || this.mark.type.spec.reparseInView ? null : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM
        }
    }
    matchesMark(e) {
        return this.dirty != ua && this.mark.eq(e)
    }
    markDirty(e, n) {
        if (super.markDirty(e, n),
        this.dirty != _r) {
            let r = this.parent;
            for (; !r.node; )
                r = r.parent;
            r.dirty < this.dirty && (r.dirty = this.dirty),
            this.dirty = _r
        }
    }
    slice(e, n, r) {
        let a = ol.create(this.parent, this.mark, !0, r)
          , s = this.children
          , l = this.size;
        n < l && (s = rh(s, n, l, r)),
        e > 0 && (s = rh(s, 0, e, r));
        for (let i = 0; i < s.length; i++)
            s[i].parent = a;
        return a.children = s,
        a
    }
}
class ds extends Zo {
    constructor(e, n, r, a, s, l, i, o, u) {
        super(e, [], s, l),
        this.node = n,
        this.outerDeco = r,
        this.innerDeco = a,
        this.nodeDOM = i
    }
    static create(e, n, r, a, s, l) {
        let i = s.nodeViews[n.type.name], o, u = i && i(n, s, () => {
            if (!o)
                return l;
            if (o.parent)
                return o.parent.posBeforeChild(o)
        }
        , r, a), d = u && u.dom, f = u && u.contentDOM;
        if (n.isText) {
            if (!d)
                d = document.createTextNode(n.text);
            else if (d.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node")
        } else
            d || ({dom: d, contentDOM: f} = ea.renderSpec(document, n.type.spec.toDOM(n)));
        !f && !n.isText && d.nodeName != "BR" && (d.hasAttribute("contenteditable") || (d.contentEditable = "false"),
        n.type.spec.draggable && (d.draggable = !0));
        let p = d;
        return d = tx(d, r, n),
        u ? o = new pU(e,n,r,a,d,f || null,p,u,s,l + 1) : n.isText ? new gc(e,n,r,a,d,p,s) : new ds(e,n,r,a,d,f || null,p,s,l + 1)
    }
    parseRule() {
        if (this.node.type.spec.reparseInView)
            return null;
        let e = {
            node: this.node.type.name,
            attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
        !this.contentDOM)
            e.getContent = () => this.node.content;
        else if (!this.contentLost)
            e.contentElement = this.contentDOM;
        else {
            for (let n = this.children.length - 1; n >= 0; n--) {
                let r = this.children[n];
                if (this.dom.contains(r.dom.parentNode)) {
                    e.contentElement = r.dom.parentNode;
                    break
                }
            }
            e.contentElement || (e.getContent = () => Ae.empty)
        }
        return e
    }
    matchesNode(e, n, r) {
        return this.dirty == _r && e.eq(this.node) && nh(n, this.outerDeco) && r.eq(this.innerDeco)
    }
    get size() {
        return this.node.nodeSize
    }
    get border() {
        return this.node.isLeaf ? 0 : 1
    }
    updateChildren(e, n) {
        let r = this.node.inlineContent
          , a = n
          , s = e.composing ? this.localCompositionInfo(e, n) : null
          , l = s && s.pos > -1 ? s : null
          , i = s && s.pos < 0
          , o = new mU(this,l && l.node,e);
        bU(this.node, this.innerDeco, (u, d, f) => {
            u.spec.marks ? o.syncToMarks(u.spec.marks, r, e) : u.type.side >= 0 && !f && o.syncToMarks(d == this.node.childCount ? Bt.none : this.node.child(d).marks, r, e),
            o.placeWidget(u, e, a)
        }
        , (u, d, f, p) => {
            o.syncToMarks(u.marks, r, e);
            let h;
            o.findNodeMatch(u, d, f, p) || i && e.state.selection.from > a && e.state.selection.to < a + u.nodeSize && (h = o.findIndexWithChild(s.node)) > -1 && o.updateNodeAt(u, d, f, h, e) || o.updateNextNode(u, d, f, e, p, a) || o.addNode(u, d, f, e, a),
            a += u.nodeSize
        }
        ),
        o.syncToMarks([], r, e),
        this.node.isTextblock && o.addTextblockHacks(),
        o.destroyRest(),
        (o.changed || this.dirty == Hs) && (l && this.protectLocalComposition(e, l),
        Zw(this.contentDOM, this.children, e),
        pi && yU(this.dom))
    }
    localCompositionInfo(e, n) {
        let {from: r, to: a} = e.state.selection;
        if (!(e.state.selection instanceof nt) || r < n || a > n + this.node.content.size)
            return null;
        let s = e.input.compositionNode;
        if (!s || !this.dom.contains(s.parentNode))
            return null;
        if (this.node.inlineContent) {
            let l = s.nodeValue
              , i = kU(this.node.content, l, r - n, a - n);
            return i < 0 ? null : {
                node: s,
                pos: i,
                text: l
            }
        } else
            return {
                node: s,
                pos: -1,
                text: ""
            }
    }
    protectLocalComposition(e, {node: n, pos: r, text: a}) {
        if (this.getDesc(n))
            return;
        let s = n;
        for (; s.parentNode != this.contentDOM; s = s.parentNode) {
            for (; s.previousSibling; )
                s.parentNode.removeChild(s.previousSibling);
            for (; s.nextSibling; )
                s.parentNode.removeChild(s.nextSibling);
            s.pmViewDesc && (s.pmViewDesc = void 0)
        }
        let l = new fU(this,s,n,a);
        e.input.compositionNodes.push(l),
        this.children = rh(this.children, r, r + a.length, e, l)
    }
    update(e, n, r, a) {
        return this.dirty == ua || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, a),
        !0)
    }
    updateInner(e, n, r, a) {
        this.updateOuterDeco(n),
        this.node = e,
        this.innerDeco = r,
        this.contentDOM && this.updateChildren(a, this.posAtStart),
        this.dirty = _r
    }
    updateOuterDeco(e) {
        if (nh(e, this.outerDeco))
            return;
        let n = this.nodeDOM.nodeType != 1
          , r = this.dom;
        this.dom = ex(this.dom, this.nodeDOM, th(this.outerDeco, this.node, n), th(e, this.node, n)),
        this.dom != r && (r.pmViewDesc = void 0,
        this.dom.pmViewDesc = this),
        this.outerDeco = e
    }
    selectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0)
    }
    deselectNode() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")
    }
    get domAtom() {
        return this.node.isAtom
    }
}
function k0(t, e, n, r, a) {
    tx(r, e, t);
    let s = new ds(void 0,t,e,n,r,r,r,a,0);
    return s.contentDOM && s.updateChildren(a, 0),
    s
}
class gc extends ds {
    constructor(e, n, r, a, s, l, i) {
        super(e, n, r, a, s, null, l, i, 0)
    }
    parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco; )
            e = e.parentNode;
        return {
            skip: e || !0
        }
    }
    update(e, n, r, a) {
        return this.dirty == ua || this.dirty != _r && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n),
        (this.dirty != _r || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text,
        a.trackWrites == this.nodeDOM && (a.trackWrites = null)),
        this.node = e,
        this.dirty = _r,
        !0)
    }
    inParent() {
        let e = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == e)
                return !0;
        return !1
    }
    domFromPos(e) {
        return {
            node: this.nodeDOM,
            offset: e
        }
    }
    localPosFromDOM(e, n, r) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r)
    }
    ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection"
    }
    slice(e, n, r) {
        let a = this.node.cut(e, n)
          , s = document.createTextNode(a.text);
        return new gc(this.parent,a,this.outerDeco,this.innerDeco,s,s,r)
    }
    markDirty(e, n) {
        super.markDirty(e, n),
        this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = ua)
    }
    get domAtom() {
        return !1
    }
    isText(e) {
        return this.node.text == e
    }
}
class Qw extends Zo {
    parseRule() {
        return {
            ignore: !0
        }
    }
    matchesHack(e) {
        return this.dirty == _r && this.dom.nodeName == e
    }
    get domAtom() {
        return !0
    }
    get ignoreForCoords() {
        return this.dom.nodeName == "IMG"
    }
}
class pU extends ds {
    constructor(e, n, r, a, s, l, i, o, u, d) {
        super(e, n, r, a, s, l, i, u, d),
        this.spec = o
    }
    update(e, n, r, a) {
        if (this.dirty == ua)
            return !1;
        if (this.spec.update) {
            let s = this.spec.update(e, n, r);
            return s && this.updateInner(e, n, r, a),
            s
        } else
            return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, a)
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
    }
    setSelection(e, n, r, a) {
        this.spec.setSelection ? this.spec.setSelection(e, n, r) : super.setSelection(e, n, r, a)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
        super.destroy()
    }
    stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : !1
    }
    ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
    }
}
function Zw(t, e, n) {
    let r = t.firstChild
      , a = !1;
    for (let s = 0; s < e.length; s++) {
        let l = e[s]
          , i = l.dom;
        if (i.parentNode == t) {
            for (; i != r; )
                r = _0(r),
                a = !0;
            r = r.nextSibling
        } else
            a = !0,
            t.insertBefore(i, r);
        if (l instanceof ol) {
            let o = r ? r.previousSibling : t.lastChild;
            Zw(l.contentDOM, l.children, n),
            r = o ? o.nextSibling : t.firstChild
        }
    }
    for (; r; )
        r = _0(r),
        a = !0;
    a && n.trackWrites == t && (n.trackWrites = null)
}
const po = function(t) {
    t && (this.nodeName = t)
};
po.prototype = Object.create(null);
const Ks = [new po];
function th(t, e, n) {
    if (t.length == 0)
        return Ks;
    let r = n ? Ks[0] : new po
      , a = [r];
    for (let s = 0; s < t.length; s++) {
        let l = t[s].type.attrs;
        if (l) {
            l.nodeName && a.push(r = new po(l.nodeName));
            for (let i in l) {
                let o = l[i];
                o != null && (n && a.length == 1 && a.push(r = new po(e.isInline ? "span" : "div")),
                i == "class" ? r.class = (r.class ? r.class + " " : "") + o : i == "style" ? r.style = (r.style ? r.style + ";" : "") + o : i != "nodeName" && (r[i] = o))
            }
        }
    }
    return a
}
function ex(t, e, n, r) {
    if (n == Ks && r == Ks)
        return e;
    let a = e;
    for (let s = 0; s < r.length; s++) {
        let l = r[s]
          , i = n[s];
        if (s) {
            let o;
            i && i.nodeName == l.nodeName && a != t && (o = a.parentNode) && o.nodeName.toLowerCase() == l.nodeName || (o = document.createElement(l.nodeName),
            o.pmIsDeco = !0,
            o.appendChild(a),
            i = Ks[0]),
            a = o
        }
        hU(a, i || Ks[0], l)
    }
    return a
}
function hU(t, e, n) {
    for (let r in e)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
    for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
    if (e.class != n.class) {
        let r = e.class ? e.class.split(" ").filter(Boolean) : []
          , a = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let s = 0; s < r.length; s++)
            a.indexOf(r[s]) == -1 && t.classList.remove(r[s]);
        for (let s = 0; s < a.length; s++)
            r.indexOf(a[s]) == -1 && t.classList.add(a[s]);
        t.classList.length == 0 && t.removeAttribute("class")
    }
    if (e.style != n.style) {
        if (e.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, a;
            for (; a = r.exec(e.style); )
                t.style.removeProperty(a[1])
        }
        n.style && (t.style.cssText += n.style)
    }
}
function tx(t, e, n) {
    return ex(t, t, Ks, th(e, n, t.nodeType != 1))
}
function nh(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (!t[n].type.eq(e[n].type))
            return !1;
    return !0
}
function _0(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t),
    e
}
class mU {
    constructor(e, n, r) {
        this.lock = n,
        this.view = r,
        this.index = 0,
        this.stack = [],
        this.changed = !1,
        this.top = e,
        this.preMatch = vU(e.node.content, e)
    }
    destroyBetween(e, n) {
        if (e != n) {
            for (let r = e; r < n; r++)
                this.top.children[r].destroy();
            this.top.children.splice(e, n - e),
            this.changed = !0
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length)
    }
    syncToMarks(e, n, r) {
        let a = 0
          , s = this.stack.length >> 1
          , l = Math.min(s, e.length);
        for (; a < l && (a == s - 1 ? this.top : this.stack[a + 1 << 1]).matchesMark(e[a]) && e[a].type.spec.spanning !== !1; )
            a++;
        for (; a < s; )
            this.destroyRest(),
            this.top.dirty = _r,
            this.index = this.stack.pop(),
            this.top = this.stack.pop(),
            s--;
        for (; s < e.length; ) {
            this.stack.push(this.top, this.index + 1);
            let i = -1;
            for (let o = this.index; o < Math.min(this.index + 3, this.top.children.length); o++) {
                let u = this.top.children[o];
                if (u.matchesMark(e[s]) && !this.isLocked(u.dom)) {
                    i = o;
                    break
                }
            }
            if (i > -1)
                i > this.index && (this.changed = !0,
                this.destroyBetween(this.index, i)),
                this.top = this.top.children[this.index];
            else {
                let o = ol.create(this.top, e[s], n, r);
                this.top.children.splice(this.index, 0, o),
                this.top = o,
                this.changed = !0
            }
            this.index = 0,
            s++
        }
    }
    findNodeMatch(e, n, r, a) {
        let s = -1, l;
        if (a >= this.preMatch.index && (l = this.preMatch.matches[a - this.preMatch.index]).parent == this.top && l.matchesNode(e, n, r))
            s = this.top.children.indexOf(l, this.index);
        else
            for (let i = this.index, o = Math.min(this.top.children.length, i + 5); i < o; i++) {
                let u = this.top.children[i];
                if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
                    s = i;
                    break
                }
            }
        return s < 0 ? !1 : (this.destroyBetween(this.index, s),
        this.index++,
        !0)
    }
    updateNodeAt(e, n, r, a, s) {
        let l = this.top.children[a];
        return l.dirty == ua && l.dom == l.contentDOM && (l.dirty = Hs),
        l.update(e, n, r, s) ? (this.destroyBetween(this.index, a),
        this.index++,
        !0) : !1
    }
    findIndexWithChild(e) {
        for (; ; ) {
            let n = e.parentNode;
            if (!n)
                return -1;
            if (n == this.top.contentDOM) {
                let r = e.pmViewDesc;
                if (r) {
                    for (let a = this.index; a < this.top.children.length; a++)
                        if (this.top.children[a] == r)
                            return a
                }
                return -1
            }
            e = n
        }
    }
    updateNextNode(e, n, r, a, s, l) {
        for (let i = this.index; i < this.top.children.length; i++) {
            let o = this.top.children[i];
            if (o instanceof ds) {
                let u = this.preMatch.matched.get(o);
                if (u != null && u != s)
                    return !1;
                let d = o.dom, f, p = this.isLocked(d) && !(e.isText && o.node && o.node.isText && o.nodeDOM.nodeValue == e.text && o.dirty != ua && nh(n, o.outerDeco));
                if (!p && o.update(e, n, r, a))
                    return this.destroyBetween(this.index, i),
                    o.dom != d && (this.changed = !0),
                    this.index++,
                    !0;
                if (!p && (f = this.recreateWrapper(o, e, n, r, a, l)))
                    return this.top.children[this.index] = f,
                    f.contentDOM && (f.dirty = Hs,
                    f.updateChildren(a, l + 1),
                    f.dirty = _r),
                    this.changed = !0,
                    this.index++,
                    !0;
                break
            }
        }
        return !1
    }
    recreateWrapper(e, n, r, a, s, l) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content))
            return null;
        let i = ds.create(this.top, n, r, a, s, l);
        if (i.contentDOM) {
            i.children = e.children,
            e.children = [];
            for (let o of i.children)
                o.parent = i
        }
        return e.destroy(),
        i
    }
    addNode(e, n, r, a, s) {
        let l = ds.create(this.top, e, n, r, a, s);
        l.contentDOM && l.updateChildren(a, s + 1),
        this.top.children.splice(this.index++, 0, l),
        this.changed = !0
    }
    placeWidget(e, n, r) {
        let a = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (a && a.matchesWidget(e) && (e == a.widget || !a.widget.type.toDOM.parentNode))
            this.index++;
        else {
            let s = new Xw(this.top,e,n,r);
            this.top.children.splice(this.index++, 0, s),
            this.changed = !0
        }
    }
    addTextblockHacks() {
        let e = this.top.children[this.index - 1]
          , n = this.top;
        for (; e instanceof ol; )
            n = e,
            e = n.children[n.children.length - 1];
        (!e || !(e instanceof gc) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Wn || Kn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n),
        this.addHackNode("BR", this.top))
    }
    addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
            this.index++;
        else {
            let r = document.createElement(e);
            e == "IMG" && (r.className = "ProseMirror-separator",
            r.alt = ""),
            e == "BR" && (r.className = "ProseMirror-trailingBreak");
            let a = new Qw(this.top,[],r,null);
            n != this.top ? n.children.push(a) : n.children.splice(this.index++, 0, a),
            this.changed = !0
        }
    }
    isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode))
    }
}
function vU(t, e) {
    let n = e
      , r = n.children.length
      , a = t.childCount
      , s = new Map
      , l = [];
    e: for (; a > 0; ) {
        let i;
        for (; ; )
            if (r) {
                let u = n.children[r - 1];
                if (u instanceof ol)
                    n = u,
                    r = u.children.length;
                else {
                    i = u,
                    r--;
                    break
                }
            } else {
                if (n == e)
                    break e;
                r = n.parent.children.indexOf(n),
                n = n.parent
            }
        let o = i.node;
        if (o) {
            if (o != t.child(a - 1))
                break;
            --a,
            s.set(i, a),
            l.push(i)
        }
    }
    return {
        index: a,
        matched: s,
        matches: l.reverse()
    }
}
function gU(t, e) {
    return t.type.side - e.type.side
}
function bU(t, e, n, r) {
    let a = e.locals(t)
      , s = 0;
    if (a.length == 0) {
        for (let u = 0; u < t.childCount; u++) {
            let d = t.child(u);
            r(d, a, e.forChild(s, d), u),
            s += d.nodeSize
        }
        return
    }
    let l = 0
      , i = []
      , o = null;
    for (let u = 0; ; ) {
        let d, f;
        for (; l < a.length && a[l].to == s; ) {
            let k = a[l++];
            k.widget && (d ? (f || (f = [d])).push(k) : d = k)
        }
        if (d)
            if (f) {
                f.sort(gU);
                for (let k = 0; k < f.length; k++)
                    n(f[k], u, !!o)
            } else
                n(d, u, !!o);
        let p, h;
        if (o)
            h = -1,
            p = o,
            o = null;
        else if (u < t.childCount)
            h = u,
            p = t.child(u++);
        else
            break;
        for (let k = 0; k < i.length; k++)
            i[k].to <= s && i.splice(k--, 1);
        for (; l < a.length && a[l].from <= s && a[l].to > s; )
            i.push(a[l++]);
        let v = s + p.nodeSize;
        if (p.isText) {
            let k = v;
            l < a.length && a[l].from < k && (k = a[l].from);
            for (let w = 0; w < i.length; w++)
                i[w].to < k && (k = i[w].to);
            k < v && (o = p.cut(k - s),
            p = p.cut(0, k - s),
            v = k,
            h = -1)
        } else
            for (; l < a.length && a[l].to < v; )
                l++;
        let y = p.isInline && !p.isLeaf ? i.filter(k => !k.inline) : i.slice();
        r(p, y, e.forChild(s, p), h),
        s = v
    }
}
function yU(t) {
    if (t.nodeName == "UL" || t.nodeName == "OL") {
        let e = t.style.cssText;
        t.style.cssText = e + "; list-style: square !important",
        window.getComputedStyle(t).listStyle,
        t.style.cssText = e
    }
}
function kU(t, e, n, r) {
    for (let a = 0, s = 0; a < t.childCount && s <= r; ) {
        let l = t.child(a++)
          , i = s;
        if (s += l.nodeSize,
        !l.isText)
            continue;
        let o = l.text;
        for (; a < t.childCount; ) {
            let u = t.child(a++);
            if (s += u.nodeSize,
            !u.isText)
                break;
            o += u.text
        }
        if (s >= n) {
            if (s >= r && o.slice(r - e.length - i, r - i) == e)
                return r - e.length;
            let u = i < r ? o.lastIndexOf(e, r - i - 1) : -1;
            if (u >= 0 && u + e.length + i >= n)
                return i + u;
            if (n == r && o.length >= r + e.length - i && o.slice(r - i, r - i + e.length) == e)
                return r
        }
    }
    return -1
}
function rh(t, e, n, r, a) {
    let s = [];
    for (let l = 0, i = 0; l < t.length; l++) {
        let o = t[l]
          , u = i
          , d = i += o.size;
        u >= n || d <= e ? s.push(o) : (u < e && s.push(o.slice(0, e - u, r)),
        a && (s.push(a),
        a = void 0),
        d > n && s.push(o.slice(n - u, o.size, r)))
    }
    return s
}
function Lm(t, e=null) {
    let n = t.domSelectionRange()
      , r = t.state.doc;
    if (!n.focusNode)
        return null;
    let a = t.docView.nearestDesc(n.focusNode)
      , s = a && a.size == 0
      , l = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (l < 0)
        return null;
    let i = r.resolve(l), o, u;
    if (vc(n)) {
        for (o = i; a && !a.node; )
            a = a.parent;
        let d = a.node;
        if (a && d.isAtom && Ze.isSelectable(d) && a.parent && !(d.isInline && zj(n.focusNode, n.focusOffset, a.dom))) {
            let f = a.posBefore;
            u = new Ze(l == f ? i : r.resolve(f))
        }
    } else {
        let d = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (d < 0)
            return null;
        o = r.resolve(d)
    }
    if (!u) {
        let d = e == "pointer" || t.state.selection.head < i.pos && !s ? 1 : -1;
        u = jm(t, o, i, d)
    }
    return u
}
function nx(t) {
    return t.editable ? t.hasFocus() : ax(t) && document.activeElement && document.activeElement.contains(t.dom)
}
function Ta(t, e=!1) {
    let n = t.state.selection;
    if (rx(t, n),
    !!nx(t)) {
        if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Kn) {
            let r = t.domSelectionRange()
              , a = t.domObserver.currentSelection;
            if (r.anchorNode && a.anchorNode && il(r.anchorNode, r.anchorOffset, a.anchorNode, a.anchorOffset)) {
                t.input.mouseDown.delayedSelectionSync = !0,
                t.domObserver.setCurSelection();
                return
            }
        }
        if (t.domObserver.disconnectSelection(),
        t.cursorWrapper)
            wU(t);
        else {
            let {anchor: r, head: a} = n, s, l;
            w0 && !(n instanceof nt) && (n.$from.parent.inlineContent || (s = x0(t, n.from)),
            !n.empty && !n.$from.parent.inlineContent && (l = x0(t, n.to))),
            t.docView.setSelection(r, a, t.root, e),
            w0 && (s && S0(s),
            l && S0(l)),
            n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange"in document && _U(t))
        }
        t.domObserver.setCurSelection(),
        t.domObserver.connectSelection()
    }
}
const w0 = Wn || Kn && Gj < 63;
function x0(t, e) {
    let {node: n, offset: r} = t.docView.domFromPos(e, 0)
      , a = r < n.childNodes.length ? n.childNodes[r] : null
      , s = r ? n.childNodes[r - 1] : null;
    if (Wn && a && a.contentEditable == "false")
        return Af(a);
    if ((!a || a.contentEditable == "false") && (!s || s.contentEditable == "false")) {
        if (a)
            return Af(a);
        if (s)
            return Af(s)
    }
}
function Af(t) {
    return t.contentEditable = "true",
    Wn && t.draggable && (t.draggable = !1,
    t.wasDraggable = !0),
    t
}
function S0(t) {
    t.contentEditable = "false",
    t.wasDraggable && (t.draggable = !0,
    t.wasDraggable = null)
}
function _U(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
    let n = t.domSelectionRange()
      , r = n.anchorNode
      , a = n.anchorOffset;
    e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != a) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
        setTimeout( () => {
            (!nx(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection")
        }
        , 20))
    }
    )
}
function wU(t) {
    let e = t.domSelection()
      , n = document.createRange()
      , r = t.cursorWrapper.dom
      , a = r.nodeName == "IMG";
    a ? n.setEnd(r.parentNode, Tn(r) + 1) : n.setEnd(r, 0),
    n.collapse(!1),
    e.removeAllRanges(),
    e.addRange(n),
    !a && !t.state.selection.visible && Qn && us <= 11 && (r.disabled = !0,
    r.disabled = !1)
}
function rx(t, e) {
    if (e instanceof Ze) {
        let n = t.docView.descAt(e.from);
        n != t.lastSelectedViewDesc && ($0(t),
        n && n.selectNode(),
        t.lastSelectedViewDesc = n)
    } else
        $0(t)
}
function $0(t) {
    t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
    t.lastSelectedViewDesc = void 0)
}
function jm(t, e, n, r) {
    return t.someProp("createSelectionBetween", a => a(t, e, n)) || nt.between(e, n, r)
}
function T0(t) {
    return t.editable && !t.hasFocus() ? !1 : ax(t)
}
function ax(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode)
        return !1;
    try {
        return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
    } catch {
        return !1
    }
}
function xU(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0)
      , n = t.domSelectionRange();
    return il(e.node, e.offset, n.anchorNode, n.anchorOffset)
}
function ah(t, e) {
    let {$anchor: n, $head: r} = t.selection
      , a = e > 0 ? n.max(r) : n.min(r)
      , s = a.parent.inlineContent ? a.depth ? t.doc.resolve(e > 0 ? a.after() : a.before()) : null : a;
    return s && lt.findFrom(s, e)
}
function Xa(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()),
    !0
}
function C0(t, e, n) {
    let r = t.state.selection;
    if (r instanceof nt)
        if (n.indexOf("s") > -1) {
            let {$head: a} = r
              , s = a.textOffset ? null : e < 0 ? a.nodeBefore : a.nodeAfter;
            if (!s || s.isText || !s.isLeaf)
                return !1;
            let l = t.state.doc.resolve(a.pos + s.nodeSize * (e < 0 ? -1 : 1));
            return Xa(t, new nt(r.$anchor,l))
        } else if (r.empty) {
            if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
                let a = ah(t.state, e);
                return a && a instanceof Ze ? Xa(t, a) : !1
            } else if (!(mr && n.indexOf("m") > -1)) {
                let a = r.$head, s = a.textOffset ? null : e < 0 ? a.nodeBefore : a.nodeAfter, l;
                if (!s || s.isText)
                    return !1;
                let i = e < 0 ? a.pos - s.nodeSize : a.pos;
                return s.isAtom || (l = t.docView.descAt(i)) && !l.contentDOM ? Ze.isSelectable(s) ? Xa(t, new Ze(e < 0 ? t.state.doc.resolve(a.pos - s.nodeSize) : a)) : Qo ? Xa(t, new nt(t.state.doc.resolve(e < 0 ? i : i + s.nodeSize))) : !1 : !1
            }
        } else
            return !1;
    else {
        if (r instanceof Ze && r.node.isInline)
            return Xa(t, new nt(e > 0 ? r.$to : r.$from));
        {
            let a = ah(t.state, e);
            return a ? Xa(t, a) : !1
        }
    }
}
function fd(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function ho(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR")
}
function Nl(t, e) {
    return e < 0 ? SU(t) : $U(t)
}
function SU(t) {
    let e = t.domSelectionRange()
      , n = e.focusNode
      , r = e.focusOffset;
    if (!n)
        return;
    let a, s, l = !1;
    for (Rr && n.nodeType == 1 && r < fd(n) && ho(n.childNodes[r], -1) && (l = !0); ; )
        if (r > 0) {
            if (n.nodeType != 1)
                break;
            {
                let i = n.childNodes[r - 1];
                if (ho(i, -1))
                    a = n,
                    s = --r;
                else if (i.nodeType == 3)
                    n = i,
                    r = n.nodeValue.length;
                else
                    break
            }
        } else {
            if (sx(n))
                break;
            {
                let i = n.previousSibling;
                for (; i && ho(i, -1); )
                    a = n.parentNode,
                    s = Tn(i),
                    i = i.previousSibling;
                if (i)
                    n = i,
                    r = fd(n);
                else {
                    if (n = n.parentNode,
                    n == t.dom)
                        break;
                    r = 0
                }
            }
        }
    l ? sh(t, n, r) : a && sh(t, a, s)
}
function $U(t) {
    let e = t.domSelectionRange()
      , n = e.focusNode
      , r = e.focusOffset;
    if (!n)
        return;
    let a = fd(n), s, l;
    for (; ; )
        if (r < a) {
            if (n.nodeType != 1)
                break;
            let i = n.childNodes[r];
            if (ho(i, 1))
                s = n,
                l = ++r;
            else
                break
        } else {
            if (sx(n))
                break;
            {
                let i = n.nextSibling;
                for (; i && ho(i, 1); )
                    s = i.parentNode,
                    l = Tn(i) + 1,
                    i = i.nextSibling;
                if (i)
                    n = i,
                    r = 0,
                    a = fd(n);
                else {
                    if (n = n.parentNode,
                    n == t.dom)
                        break;
                    r = a = 0
                }
            }
        }
    s && sh(t, s, l)
}
function sx(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock
}
function TU(t, e) {
    for (; t && e == t.childNodes.length && !Xo(t); )
        e = Tn(t) + 1,
        t = t.parentNode;
    for (; t && e < t.childNodes.length; ) {
        let n = t.childNodes[e];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
        e = 0
    }
}
function CU(t, e) {
    for (; t && !e && !Xo(t); )
        e = Tn(t),
        t = t.parentNode;
    for (; t && e; ) {
        let n = t.childNodes[e - 1];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
        e = t.childNodes.length
    }
}
function sh(t, e, n) {
    if (e.nodeType != 3) {
        let s, l;
        (l = TU(e, n)) ? (e = l,
        n = 0) : (s = CU(e, n)) && (e = s,
        n = s.nodeValue.length)
    }
    let r = t.domSelection();
    if (vc(r)) {
        let s = document.createRange();
        s.setEnd(e, n),
        s.setStart(e, n),
        r.removeAllRanges(),
        r.addRange(s)
    } else
        r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let {state: a} = t;
    setTimeout( () => {
        t.state == a && Ta(t)
    }
    , 50)
}
function E0(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(Kn || Yj) && n.parent.inlineContent) {
        let a = t.coordsAtPos(e);
        if (e > n.start()) {
            let s = t.coordsAtPos(e - 1)
              , l = (s.top + s.bottom) / 2;
            if (l > a.top && l < a.bottom && Math.abs(s.left - a.left) > 1)
                return s.left < a.left ? "ltr" : "rtl"
        }
        if (e < n.end()) {
            let s = t.coordsAtPos(e + 1)
              , l = (s.top + s.bottom) / 2;
            if (l > a.top && l < a.bottom && Math.abs(s.left - a.left) > 1)
                return s.left > a.left ? "ltr" : "rtl"
        }
    }
    return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr"
}
function A0(t, e, n) {
    let r = t.state.selection;
    if (r instanceof nt && !r.empty || n.indexOf("s") > -1 || mr && n.indexOf("m") > -1)
        return !1;
    let {$from: a, $to: s} = r;
    if (!a.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
        let l = ah(t.state, e);
        if (l && l instanceof Ze)
            return Xa(t, l)
    }
    if (!a.parent.inlineContent) {
        let l = e < 0 ? a : s
          , i = r instanceof Dr ? lt.near(l, e) : lt.findFrom(l, e);
        return i ? Xa(t, i) : !1
    }
    return !1
}
function M0(t, e) {
    if (!(t.state.selection instanceof nt))
        return !0;
    let {$head: n, $anchor: r, empty: a} = t.state.selection;
    if (!n.sameParent(r))
        return !0;
    if (!a)
        return !1;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
        return !0;
    let s = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (s && !s.isText) {
        let l = t.state.tr;
        return e < 0 ? l.delete(n.pos - s.nodeSize, n.pos) : l.delete(n.pos, n.pos + s.nodeSize),
        t.dispatch(l),
        !0
    }
    return !1
}
function O0(t, e, n) {
    t.domObserver.stop(),
    e.contentEditable = n,
    t.domObserver.start()
}
function EU(t) {
    if (!Wn || t.state.selection.$head.parentOffset > 0)
        return !1;
    let {focusNode: e, focusOffset: n} = t.domSelectionRange();
    if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let r = e.firstChild;
        O0(t, r, "true"),
        setTimeout( () => O0(t, r, "false"), 20)
    }
    return !1
}
function AU(t) {
    let e = "";
    return t.ctrlKey && (e += "c"),
    t.metaKey && (e += "m"),
    t.altKey && (e += "a"),
    t.shiftKey && (e += "s"),
    e
}
function MU(t, e) {
    let n = e.keyCode
      , r = AU(e);
    if (n == 8 || mr && n == 72 && r == "c")
        return M0(t, -1) || Nl(t, -1);
    if (n == 46 && !e.shiftKey || mr && n == 68 && r == "c")
        return M0(t, 1) || Nl(t, 1);
    if (n == 13 || n == 27)
        return !0;
    if (n == 37 || mr && n == 66 && r == "c") {
        let a = n == 37 ? E0(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return C0(t, a, r) || Nl(t, a)
    } else if (n == 39 || mr && n == 70 && r == "c") {
        let a = n == 39 ? E0(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return C0(t, a, r) || Nl(t, a)
    } else {
        if (n == 38 || mr && n == 80 && r == "c")
            return A0(t, -1, r) || Nl(t, -1);
        if (n == 40 || mr && n == 78 && r == "c")
            return EU(t) || A0(t, 1, r) || Nl(t, 1);
        if (r == (mr ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
            return !0
    }
    return !1
}
function lx(t, e) {
    t.someProp("transformCopied", h => {
        e = h(e, t)
    }
    );
    let n = []
      , {content: r, openStart: a, openEnd: s} = e;
    for (; a > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        a--,
        s--;
        let h = r.firstChild;
        n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null),
        r = h.content
    }
    let l = t.someProp("clipboardSerializer") || ea.fromSchema(t.state.schema)
      , i = fx()
      , o = i.createElement("div");
    o.appendChild(l.serializeFragment(r, {
        document: i
    }));
    let u = o.firstChild, d, f = 0;
    for (; u && u.nodeType == 1 && (d = cx[u.nodeName.toLowerCase()]); ) {
        for (let h = d.length - 1; h >= 0; h--) {
            let v = i.createElement(d[h]);
            for (; o.firstChild; )
                v.appendChild(o.firstChild);
            o.appendChild(v),
            f++
        }
        u = o.firstChild
    }
    u && u.nodeType == 1 && u.setAttribute("data-pm-slice", `${a} ${s}${f ? ` -${f}` : ""} ${JSON.stringify(n)}`);
    let p = t.someProp("clipboardTextSerializer", h => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
    return {
        dom: o,
        text: p
    }
}
function ix(t, e, n, r, a) {
    let s = a.parent.type.spec.code, l, i;
    if (!n && !e)
        return null;
    let o = e && (r || s || !n);
    if (o) {
        if (t.someProp("transformPastedText", p => {
            e = p(e, s || r, t)
        }
        ),
        s)
            return e ? new Ie(Ae.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))),0,0) : Ie.empty;
        let f = t.someProp("clipboardTextParser", p => p(e, a, r, t));
        if (f)
            i = f;
        else {
            let p = a.marks()
              , {schema: h} = t.state
              , v = ea.fromSchema(h);
            l = document.createElement("div"),
            e.split(/(?:\r\n?|\n)+/).forEach(y => {
                let k = l.appendChild(document.createElement("p"));
                y && k.appendChild(v.serializeNode(h.text(y, p)))
            }
            )
        }
    } else
        t.someProp("transformPastedHTML", f => {
            n = f(n, t)
        }
        ),
        l = DU(n),
        Qo && PU(l);
    let u = l && l.querySelector("[data-pm-slice]")
      , d = u && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(u.getAttribute("data-pm-slice") || "");
    if (d && d[3])
        for (let f = +d[3]; f > 0; f--) {
            let p = l.firstChild;
            for (; p && p.nodeType != 1; )
                p = p.nextSibling;
            if (!p)
                break;
            l = p
        }
    if (i || (i = (t.someProp("clipboardParser") || t.someProp("domParser") || di.fromSchema(t.state.schema)).parseSlice(l, {
        preserveWhitespace: !!(o || d),
        context: a,
        ruleFromNode(p) {
            return p.nodeName == "BR" && !p.nextSibling && p.parentNode && !OU.test(p.parentNode.nodeName) ? {
                ignore: !0
            } : null
        }
    })),
    d)
        i = FU(N0(i, +d[1], +d[2]), d[4]);
    else if (i = Ie.maxOpen(NU(i.content, a), !0),
    i.openStart || i.openEnd) {
        let f = 0
          , p = 0;
        for (let h = i.content.firstChild; f < i.openStart && !h.type.spec.isolating; f++,
        h = h.firstChild)
            ;
        for (let h = i.content.lastChild; p < i.openEnd && !h.type.spec.isolating; p++,
        h = h.lastChild)
            ;
        i = N0(i, f, p)
    }
    return t.someProp("transformPasted", f => {
        i = f(i, t)
    }
    ),
    i
}
const OU = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function NU(t, e) {
    if (t.childCount < 2)
        return t;
    for (let n = e.depth; n >= 0; n--) {
        let a = e.node(n).contentMatchAt(e.index(n)), s, l = [];
        if (t.forEach(i => {
            if (!l)
                return;
            let o = a.findWrapping(i.type), u;
            if (!o)
                return l = null;
            if (u = l.length && s.length && ux(o, s, i, l[l.length - 1], 0))
                l[l.length - 1] = u;
            else {
                l.length && (l[l.length - 1] = dx(l[l.length - 1], s.length));
                let d = ox(i, o);
                l.push(d),
                a = a.matchType(d.type),
                s = o
            }
        }
        ),
        l)
            return Ae.from(l)
    }
    return t
}
function ox(t, e, n=0) {
    for (let r = e.length - 1; r >= n; r--)
        t = e[r].create(null, Ae.from(t));
    return t
}
function ux(t, e, n, r, a) {
    if (a < t.length && a < e.length && t[a] == e[a]) {
        let s = ux(t, e, n, r.lastChild, a + 1);
        if (s)
            return r.copy(r.content.replaceChild(r.childCount - 1, s));
        if (r.contentMatchAt(r.childCount).matchType(a == t.length - 1 ? n.type : t[a + 1]))
            return r.copy(r.content.append(Ae.from(ox(n, t, a + 1))))
    }
}
function dx(t, e) {
    if (e == 0)
        return t;
    let n = t.content.replaceChild(t.childCount - 1, dx(t.lastChild, e - 1))
      , r = t.contentMatchAt(t.childCount).fillBefore(Ae.empty, !0);
    return t.copy(n.append(r))
}
function lh(t, e, n, r, a, s) {
    let l = e < 0 ? t.firstChild : t.lastChild
      , i = l.content;
    return t.childCount > 1 && (s = 0),
    a < r - 1 && (i = lh(i, e, n, r, a + 1, s)),
    a >= n && (i = e < 0 ? l.contentMatchAt(0).fillBefore(i, s <= a).append(i) : i.append(l.contentMatchAt(l.childCount).fillBefore(Ae.empty, !0))),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, l.copy(i))
}
function N0(t, e, n) {
    return e < t.openStart && (t = new Ie(lh(t.content, -1, e, t.openStart, 0, t.openEnd),e,t.openEnd)),
    n < t.openEnd && (t = new Ie(lh(t.content, 1, n, t.openEnd, 0, 0),t.openStart,n)),
    t
}
const cx = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let D0 = null;
function fx() {
    return D0 || (D0 = document.implementation.createHTMLDocument("title"))
}
function DU(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = fx().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), a;
    if ((a = r && cx[r[1].toLowerCase()]) && (t = a.map(s => "<" + s + ">").join("") + t + a.map(s => "</" + s + ">").reverse().join("")),
    n.innerHTML = t,
    a)
        for (let s = 0; s < a.length; s++)
            n = n.querySelector(a[s]) || n;
    return n
}
function PU(t) {
    let e = t.querySelectorAll(Kn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < e.length; n++) {
        let r = e[n];
        r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r)
    }
}
function FU(t, e) {
    if (!t.size)
        return t;
    let n = t.content.firstChild.type.schema, r;
    try {
        r = JSON.parse(e)
    } catch {
        return t
    }
    let {content: a, openStart: s, openEnd: l} = t;
    for (let i = r.length - 2; i >= 0; i -= 2) {
        let o = n.nodes[r[i]];
        if (!o || o.hasRequiredAttrs())
            break;
        a = Ae.from(o.create(r[i + 1], a)),
        s++,
        l++
    }
    return new Ie(a,s,l)
}
const Gn = {}
  , Yn = {}
  , BU = {
    touchstart: !0,
    touchmove: !0
};
class VU {
    constructor() {
        this.shiftKey = !1,
        this.mouseDown = null,
        this.lastKeyCode = null,
        this.lastKeyCodeTime = 0,
        this.lastClick = {
            time: 0,
            x: 0,
            y: 0,
            type: ""
        },
        this.lastSelectionOrigin = null,
        this.lastSelectionTime = 0,
        this.lastIOSEnter = 0,
        this.lastIOSEnterFallbackTimeout = -1,
        this.lastFocus = 0,
        this.lastTouch = 0,
        this.lastAndroidDelete = 0,
        this.composing = !1,
        this.compositionNode = null,
        this.composingTimeout = -1,
        this.compositionNodes = [],
        this.compositionEndedAt = -2e8,
        this.compositionID = 1,
        this.compositionPendingChanges = 0,
        this.domChangeCount = 0,
        this.eventHandlers = Object.create(null),
        this.hideSelectionGuard = null
    }
}
function IU(t) {
    for (let e in Gn) {
        let n = Gn[e];
        t.dom.addEventListener(e, t.input.eventHandlers[e] = r => {
            LU(t, r) && !Um(t, r) && (t.editable || !(r.type in Yn)) && n(t, r)
        }
        , BU[e] ? {
            passive: !0
        } : void 0)
    }
    Wn && t.dom.addEventListener("input", () => null),
    ih(t)
}
function rs(t, e) {
    t.input.lastSelectionOrigin = e,
    t.input.lastSelectionTime = Date.now()
}
function RU(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers)
        t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout),
    clearTimeout(t.input.lastIOSEnterFallbackTimeout)
}
function ih(t) {
    t.someProp("handleDOMEvents", e => {
        for (let n in e)
            t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = r => Um(t, r))
    }
    )
}
function Um(t, e) {
    return t.someProp("handleDOMEvents", n => {
        let r = n[e.type];
        return r ? r(t, e) || e.defaultPrevented : !1
    }
    )
}
function LU(t, e) {
    if (!e.bubbles)
        return !0;
    if (e.defaultPrevented)
        return !1;
    for (let n = e.target; n != t.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
            return !1;
    return !0
}
function jU(t, e) {
    !Um(t, e) && Gn[e.type] && (t.editable || !(e.type in Yn)) && Gn[e.type](t, e)
}
Yn.keydown = (t, e) => {
    let n = e;
    if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey,
    !hx(t, n) && (t.input.lastKeyCode = n.keyCode,
    t.input.lastKeyCodeTime = Date.now(),
    !(Er && Kn && n.keyCode == 13)))
        if (n.keyCode != 229 && t.domObserver.forceFlush(),
        pi && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
            let r = Date.now();
            t.input.lastIOSEnter = r,
            t.input.lastIOSEnterFallbackTimeout = setTimeout( () => {
                t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", a => a(t, Is(13, "Enter"))),
                t.input.lastIOSEnter = 0)
            }
            , 200)
        } else
            t.someProp("handleKeyDown", r => r(t, n)) || MU(t, n) ? n.preventDefault() : rs(t, "key")
}
;
Yn.keyup = (t, e) => {
    e.keyCode == 16 && (t.input.shiftKey = !1)
}
;
Yn.keypress = (t, e) => {
    let n = e;
    if (hx(t, n) || !n.charCode || n.ctrlKey && !n.altKey || mr && n.metaKey)
        return;
    if (t.someProp("handleKeyPress", a => a(t, n))) {
        n.preventDefault();
        return
    }
    let r = t.state.selection;
    if (!(r instanceof nt) || !r.$from.sameParent(r.$to)) {
        let a = String.fromCharCode(n.charCode);
        !/[\r\n]/.test(a) && !t.someProp("handleTextInput", s => s(t, r.$from.pos, r.$to.pos, a)) && t.dispatch(t.state.tr.insertText(a).scrollIntoView()),
        n.preventDefault()
    }
}
;
function bc(t) {
    return {
        left: t.clientX,
        top: t.clientY
    }
}
function UU(t, e) {
    let n = e.x - t.clientX
      , r = e.y - t.clientY;
    return n * n + r * r < 100
}
function Hm(t, e, n, r, a) {
    if (r == -1)
        return !1;
    let s = t.state.doc.resolve(r);
    for (let l = s.depth + 1; l > 0; l--)
        if (t.someProp(e, i => l > s.depth ? i(t, n, s.nodeAfter, s.before(l), a, !0) : i(t, n, s.node(l), s.before(l), a, !1)))
            return !0;
    return !1
}
function ei(t, e, n) {
    t.focused || t.focus();
    let r = t.state.tr.setSelection(e);
    n == "pointer" && r.setMeta("pointer", !0),
    t.dispatch(r)
}
function HU(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.doc.resolve(e)
      , r = n.nodeAfter;
    return r && r.isAtom && Ze.isSelectable(r) ? (ei(t, new Ze(n), "pointer"),
    !0) : !1
}
function KU(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.selection, r, a;
    n instanceof Ze && (r = n.node);
    let s = t.state.doc.resolve(e);
    for (let l = s.depth + 1; l > 0; l--) {
        let i = l > s.depth ? s.nodeAfter : s.node(l);
        if (Ze.isSelectable(i)) {
            r && n.$from.depth > 0 && l >= n.$from.depth && s.before(n.$from.depth + 1) == n.$from.pos ? a = s.before(n.$from.depth) : a = s.before(l);
            break
        }
    }
    return a != null ? (ei(t, Ze.create(t.state.doc, a), "pointer"),
    !0) : !1
}
function zU(t, e, n, r, a) {
    return Hm(t, "handleClickOn", e, n, r) || t.someProp("handleClick", s => s(t, e, r)) || (a ? KU(t, n) : HU(t, n))
}
function qU(t, e, n, r) {
    return Hm(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", a => a(t, e, r))
}
function WU(t, e, n, r) {
    return Hm(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", a => a(t, e, r)) || GU(t, n, r)
}
function GU(t, e, n) {
    if (n.button != 0)
        return !1;
    let r = t.state.doc;
    if (e == -1)
        return r.inlineContent ? (ei(t, nt.create(r, 0, r.content.size), "pointer"),
        !0) : !1;
    let a = r.resolve(e);
    for (let s = a.depth + 1; s > 0; s--) {
        let l = s > a.depth ? a.nodeAfter : a.node(s)
          , i = a.before(s);
        if (l.inlineContent)
            ei(t, nt.create(r, i + 1, i + 1 + l.content.size), "pointer");
        else if (Ze.isSelectable(l))
            ei(t, Ze.create(r, i), "pointer");
        else
            continue;
        return !0
    }
}
function Km(t) {
    return pd(t)
}
const px = mr ? "metaKey" : "ctrlKey";
Gn.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = Km(t)
      , a = Date.now()
      , s = "singleClick";
    a - t.input.lastClick.time < 500 && UU(n, t.input.lastClick) && !n[px] && (t.input.lastClick.type == "singleClick" ? s = "doubleClick" : t.input.lastClick.type == "doubleClick" && (s = "tripleClick")),
    t.input.lastClick = {
        time: a,
        x: n.clientX,
        y: n.clientY,
        type: s
    };
    let l = t.posAtCoords(bc(n));
    l && (s == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(),
    t.input.mouseDown = new YU(t,l,n,!!r)) : (s == "doubleClick" ? qU : WU)(t, l.pos, l.inside, n) ? n.preventDefault() : rs(t, "pointer"))
}
;
class YU {
    constructor(e, n, r, a) {
        this.view = e,
        this.pos = n,
        this.event = r,
        this.flushed = a,
        this.delayedSelectionSync = !1,
        this.mightDrag = null,
        this.startDoc = e.state.doc,
        this.selectNode = !!r[px],
        this.allowDefault = r.shiftKey;
        let s, l;
        if (n.inside > -1)
            s = e.state.doc.nodeAt(n.inside),
            l = n.inside;
        else {
            let d = e.state.doc.resolve(n.pos);
            s = d.parent,
            l = d.depth ? d.before() : 0
        }
        const i = a ? null : r.target
          , o = i ? e.docView.nearestDesc(i, !0) : null;
        this.target = o ? o.dom : null;
        let {selection: u} = e.state;
        (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || u instanceof Ze && u.from <= l && u.to > l) && (this.mightDrag = {
            node: s,
            pos: l,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && Rr && !this.target.hasAttribute("contentEditable"))
        }),
        this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable && setTimeout( () => {
            this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
        }
        , 20),
        this.view.domObserver.start()),
        e.root.addEventListener("mouseup", this.up = this.up.bind(this)),
        e.root.addEventListener("mousemove", this.move = this.move.bind(this)),
        rs(e, "pointer")
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up),
        this.view.root.removeEventListener("mousemove", this.move),
        this.mightDrag && this.target && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
        this.delayedSelectionSync && setTimeout( () => Ta(this.view)),
        this.view.input.mouseDown = null
    }
    up(e) {
        if (this.done(),
        !this.view.dom.contains(e.target))
            return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(bc(e))),
        this.updateAllowDefault(e),
        this.allowDefault || !n ? rs(this.view, "pointer") : zU(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || Wn && this.mightDrag && !this.mightDrag.node.isAtom || Kn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (ei(this.view, lt.near(this.view.state.doc.resolve(n.pos)), "pointer"),
        e.preventDefault()) : rs(this.view, "pointer")
    }
    move(e) {
        this.updateAllowDefault(e),
        rs(this.view, "pointer"),
        e.buttons == 0 && this.done()
    }
    updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0)
    }
}
Gn.touchstart = t => {
    t.input.lastTouch = Date.now(),
    Km(t),
    rs(t, "pointer")
}
;
Gn.touchmove = t => {
    t.input.lastTouch = Date.now(),
    rs(t, "pointer")
}
;
Gn.contextmenu = t => Km(t);
function hx(t, e) {
    return t.composing ? !0 : Wn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8,
    !0) : !1
}
const JU = Er ? 5e3 : -1;
Yn.compositionstart = Yn.compositionupdate = t => {
    if (!t.composing) {
        t.domObserver.flush();
        let {state: e} = t
          , n = e.selection.$from;
        if (e.selection.empty && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1)))
            t.markCursor = t.state.storedMarks || n.marks(),
            pd(t, !0),
            t.markCursor = null;
        else if (pd(t),
        Rr && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
            let r = t.domSelectionRange();
            for (let a = r.focusNode, s = r.focusOffset; a && a.nodeType == 1 && s != 0; ) {
                let l = s < 0 ? a.lastChild : a.childNodes[s - 1];
                if (!l)
                    break;
                if (l.nodeType == 3) {
                    t.domSelection().collapse(l, l.nodeValue.length);
                    break
                } else
                    a = l,
                    s = -1
            }
        }
        t.input.composing = !0
    }
    mx(t, JU)
}
;
Yn.compositionend = (t, e) => {
    t.composing && (t.input.composing = !1,
    t.input.compositionEndedAt = e.timeStamp,
    t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0,
    t.input.compositionNode = null,
    t.input.compositionPendingChanges && Promise.resolve().then( () => t.domObserver.flush()),
    t.input.compositionID++,
    mx(t, 20))
}
;
function mx(t, e) {
    clearTimeout(t.input.composingTimeout),
    e > -1 && (t.input.composingTimeout = setTimeout( () => pd(t), e))
}
function vx(t) {
    for (t.composing && (t.input.composing = !1,
    t.input.compositionEndedAt = QU()); t.input.compositionNodes.length > 0; )
        t.input.compositionNodes.pop().markParentsDirty()
}
function XU(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode)
        return null;
    let n = Hj(e.focusNode, e.focusOffset)
      , r = Kj(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
        let a = r.pmViewDesc;
        if (!a || !a.isText(r.nodeValue))
            return r;
        if (t.input.compositionNode == r) {
            let s = n.pmViewDesc;
            if (!(!s || !s.isText(n.nodeValue)))
                return r
        }
    }
    return n || r
}
function QU() {
    let t = document.createEvent("Event");
    return t.initEvent("event", !0, !0),
    t.timeStamp
}
function pd(t, e=!1) {
    if (!(Er && t.domObserver.flushingSoon >= 0)) {
        if (t.domObserver.forceFlush(),
        vx(t),
        e || t.docView && t.docView.dirty) {
            let n = Lm(t);
            return n && !n.eq(t.state.selection) ? t.dispatch(t.state.tr.setSelection(n)) : t.updateState(t.state),
            !0
        }
        return !1
    }
}
function ZU(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(e),
    n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection()
      , a = document.createRange();
    a.selectNodeContents(e),
    t.dom.blur(),
    r.removeAllRanges(),
    r.addRange(a),
    setTimeout( () => {
        n.parentNode && n.parentNode.removeChild(n),
        t.focus()
    }
    , 50)
}
const Oo = Qn && us < 15 || pi && Jj < 604;
Gn.copy = Yn.cut = (t, e) => {
    let n = e
      , r = t.state.selection
      , a = n.type == "cut";
    if (r.empty)
        return;
    let s = Oo ? null : n.clipboardData
      , l = r.content()
      , {dom: i, text: o} = lx(t, l);
    s ? (n.preventDefault(),
    s.clearData(),
    s.setData("text/html", i.innerHTML),
    s.setData("text/plain", o)) : ZU(t, i),
    a && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
}
;
function eH(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null
}
function tH(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code
      , r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"),
    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
    r.focus();
    let a = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout( () => {
        t.focus(),
        r.parentNode && r.parentNode.removeChild(r),
        n ? No(t, r.value, null, a, e) : No(t, r.textContent, r.innerHTML, a, e)
    }
    , 50)
}
function No(t, e, n, r, a) {
    let s = ix(t, e, n, r, t.state.selection.$from);
    if (t.someProp("handlePaste", o => o(t, a, s || Ie.empty)))
        return !0;
    if (!s)
        return !1;
    let l = eH(s)
      , i = l ? t.state.tr.replaceSelectionWith(l, r) : t.state.tr.replaceSelection(s);
    return t.dispatch(i.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
    !0
}
function gx(t) {
    let e = t.getData("text/plain") || t.getData("Text");
    if (e)
        return e;
    let n = t.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : ""
}
Yn.paste = (t, e) => {
    let n = e;
    if (t.composing && !Er)
        return;
    let r = Oo ? null : n.clipboardData
      , a = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && No(t, gx(r), r.getData("text/html"), a, n) ? n.preventDefault() : tH(t, n)
}
;
class bx {
    constructor(e, n, r) {
        this.slice = e,
        this.move = n,
        this.node = r
    }
}
const yx = mr ? "altKey" : "ctrlKey";
Gn.dragstart = (t, e) => {
    let n = e
      , r = t.input.mouseDown;
    if (r && r.done(),
    !n.dataTransfer)
        return;
    let a = t.state.selection, s = a.empty ? null : t.posAtCoords(bc(n)), l;
    if (!(s && s.pos >= a.from && s.pos <= (a instanceof Ze ? a.to - 1 : a.to))) {
        if (r && r.mightDrag)
            l = Ze.create(t.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
            let d = t.docView.nearestDesc(n.target, !0);
            d && d.node.type.spec.draggable && d != t.docView && (l = Ze.create(t.state.doc, d.posBefore))
        }
    }
    let i = (l || t.state.selection).content()
      , {dom: o, text: u} = lx(t, i);
    n.dataTransfer.clearData(),
    n.dataTransfer.setData(Oo ? "Text" : "text/html", o.innerHTML),
    n.dataTransfer.effectAllowed = "copyMove",
    Oo || n.dataTransfer.setData("text/plain", u),
    t.dragging = new bx(i,!n[yx],l)
}
;
Gn.dragend = t => {
    let e = t.dragging;
    window.setTimeout( () => {
        t.dragging == e && (t.dragging = null)
    }
    , 50)
}
;
Yn.dragover = Yn.dragenter = (t, e) => e.preventDefault();
Yn.drop = (t, e) => {
    let n = e
      , r = t.dragging;
    if (t.dragging = null,
    !n.dataTransfer)
        return;
    let a = t.posAtCoords(bc(n));
    if (!a)
        return;
    let s = t.state.doc.resolve(a.pos)
      , l = r && r.slice;
    l ? t.someProp("transformPasted", v => {
        l = v(l, t)
    }
    ) : l = ix(t, gx(n.dataTransfer), Oo ? null : n.dataTransfer.getData("text/html"), !1, s);
    let i = !!(r && !n[yx]);
    if (t.someProp("handleDrop", v => v(t, n, l || Ie.empty, i))) {
        n.preventDefault();
        return
    }
    if (!l)
        return;
    n.preventDefault();
    let o = l ? Vw(t.state.doc, s.pos, l) : s.pos;
    o == null && (o = s.pos);
    let u = t.state.tr;
    if (i) {
        let {node: v} = r;
        v ? v.replace(u) : u.deleteSelection()
    }
    let d = u.mapping.map(o)
      , f = l.openStart == 0 && l.openEnd == 0 && l.content.childCount == 1
      , p = u.doc;
    if (f ? u.replaceRangeWith(d, d, l.content.firstChild) : u.replaceRange(d, d, l),
    u.doc.eq(p))
        return;
    let h = u.doc.resolve(d);
    if (f && Ze.isSelectable(l.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(l.content.firstChild))
        u.setSelection(new Ze(h));
    else {
        let v = u.mapping.map(o);
        u.mapping.maps[u.mapping.maps.length - 1].forEach( (y, k, w, $) => v = $),
        u.setSelection(jm(t, h, u.doc.resolve(v)))
    }
    t.focus(),
    t.dispatch(u.setMeta("uiEvent", "drop"))
}
;
Gn.focus = t => {
    t.input.lastFocus = Date.now(),
    t.focused || (t.domObserver.stop(),
    t.dom.classList.add("ProseMirror-focused"),
    t.domObserver.start(),
    t.focused = !0,
    setTimeout( () => {
        t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Ta(t)
    }
    , 20))
}
;
Gn.blur = (t, e) => {
    let n = e;
    t.focused && (t.domObserver.stop(),
    t.dom.classList.remove("ProseMirror-focused"),
    t.domObserver.start(),
    n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
    t.focused = !1)
}
;
Gn.beforeinput = (t, e) => {
    if (Kn && Er && e.inputType == "deleteContentBackward") {
        t.domObserver.flushSoon();
        let {domChangeCount: r} = t.input;
        setTimeout( () => {
            if (t.input.domChangeCount != r || (t.dom.blur(),
            t.focus(),
            t.someProp("handleKeyDown", s => s(t, Is(8, "Backspace")))))
                return;
            let {$cursor: a} = t.state.selection;
            a && a.pos > 0 && t.dispatch(t.state.tr.delete(a.pos - 1, a.pos).scrollIntoView())
        }
        , 50)
    }
}
;
for (let t in Yn)
    Gn[t] = Yn[t];
function Do(t, e) {
    if (t == e)
        return !0;
    for (let n in t)
        if (t[n] !== e[n])
            return !1;
    for (let n in e)
        if (!(n in t))
            return !1;
    return !0
}
class hd {
    constructor(e, n) {
        this.toDOM = e,
        this.spec = n || Qs,
        this.side = this.spec.side || 0
    }
    map(e, n, r, a) {
        let {pos: s, deleted: l} = e.mapResult(n.from + a, this.side < 0 ? -1 : 1);
        return l ? null : new vr(s - r,s - r,this)
    }
    valid() {
        return !0
    }
    eq(e) {
        return this == e || e instanceof hd && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Do(this.spec, e.spec))
    }
    destroy(e) {
        this.spec.destroy && this.spec.destroy(e)
    }
}
class cs {
    constructor(e, n) {
        this.attrs = e,
        this.spec = n || Qs
    }
    map(e, n, r, a) {
        let s = e.map(n.from + a, this.spec.inclusiveStart ? -1 : 1) - r
          , l = e.map(n.to + a, this.spec.inclusiveEnd ? 1 : -1) - r;
        return s >= l ? null : new vr(s,l,this)
    }
    valid(e, n) {
        return n.from < n.to
    }
    eq(e) {
        return this == e || e instanceof cs && Do(this.attrs, e.attrs) && Do(this.spec, e.spec)
    }
    static is(e) {
        return e.type instanceof cs
    }
    destroy() {}
}
class zm {
    constructor(e, n) {
        this.attrs = e,
        this.spec = n || Qs
    }
    map(e, n, r, a) {
        let s = e.mapResult(n.from + a, 1);
        if (s.deleted)
            return null;
        let l = e.mapResult(n.to + a, -1);
        return l.deleted || l.pos <= s.pos ? null : new vr(s.pos - r,l.pos - r,this)
    }
    valid(e, n) {
        let {index: r, offset: a} = e.content.findIndex(n.from), s;
        return a == n.from && !(s = e.child(r)).isText && a + s.nodeSize == n.to
    }
    eq(e) {
        return this == e || e instanceof zm && Do(this.attrs, e.attrs) && Do(this.spec, e.spec)
    }
    destroy() {}
}
class vr {
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.type = r
    }
    copy(e, n) {
        return new vr(e,n,this.type)
    }
    eq(e, n=0) {
        return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
    }
    map(e, n, r) {
        return this.type.map(e, this, n, r)
    }
    static widget(e, n, r) {
        return new vr(e,e,new hd(n,r))
    }
    static inline(e, n, r, a) {
        return new vr(e,n,new cs(r,a))
    }
    static node(e, n, r, a) {
        return new vr(e,n,new zm(r,a))
    }
    get spec() {
        return this.type.spec
    }
    get inline() {
        return this.type instanceof cs
    }
    get widget() {
        return this.type instanceof hd
    }
}
const Il = []
  , Qs = {};
class cn {
    constructor(e, n) {
        this.local = e.length ? e : Il,
        this.children = n.length ? n : Il
    }
    static create(e, n) {
        return n.length ? md(n, e, 0, Qs) : Nn
    }
    find(e, n, r) {
        let a = [];
        return this.findInner(e ?? 0, n ?? 1e9, a, 0, r),
        a
    }
    findInner(e, n, r, a, s) {
        for (let l = 0; l < this.local.length; l++) {
            let i = this.local[l];
            i.from <= n && i.to >= e && (!s || s(i.spec)) && r.push(i.copy(i.from + a, i.to + a))
        }
        for (let l = 0; l < this.children.length; l += 3)
            if (this.children[l] < n && this.children[l + 1] > e) {
                let i = this.children[l] + 1;
                this.children[l + 2].findInner(e - i, n - i, r, a + i, s)
            }
    }
    map(e, n, r) {
        return this == Nn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || Qs)
    }
    mapInner(e, n, r, a, s) {
        let l;
        for (let i = 0; i < this.local.length; i++) {
            let o = this.local[i].map(e, r, a);
            o && o.type.valid(n, o) ? (l || (l = [])).push(o) : s.onRemove && s.onRemove(this.local[i].spec)
        }
        return this.children.length ? nH(this.children, l || [], e, n, r, a, s) : l ? new cn(l.sort(Zs),Il) : Nn
    }
    add(e, n) {
        return n.length ? this == Nn ? cn.create(e, n) : this.addInner(e, n, 0) : this
    }
    addInner(e, n, r) {
        let a, s = 0;
        e.forEach( (i, o) => {
            let u = o + r, d;
            if (d = _x(n, i, u)) {
                for (a || (a = this.children.slice()); s < a.length && a[s] < o; )
                    s += 3;
                a[s] == o ? a[s + 2] = a[s + 2].addInner(i, d, u + 1) : a.splice(s, 0, o, o + i.nodeSize, md(d, i, u + 1, Qs)),
                s += 3
            }
        }
        );
        let l = kx(s ? wx(n) : n, -r);
        for (let i = 0; i < l.length; i++)
            l[i].type.valid(e, l[i]) || l.splice(i--, 1);
        return new cn(l.length ? this.local.concat(l).sort(Zs) : this.local,a || this.children)
    }
    remove(e) {
        return e.length == 0 || this == Nn ? this : this.removeInner(e, 0)
    }
    removeInner(e, n) {
        let r = this.children
          , a = this.local;
        for (let s = 0; s < r.length; s += 3) {
            let l, i = r[s] + n, o = r[s + 1] + n;
            for (let d = 0, f; d < e.length; d++)
                (f = e[d]) && f.from > i && f.to < o && (e[d] = null,
                (l || (l = [])).push(f));
            if (!l)
                continue;
            r == this.children && (r = this.children.slice());
            let u = r[s + 2].removeInner(l, i + 1);
            u != Nn ? r[s + 2] = u : (r.splice(s, 3),
            s -= 3)
        }
        if (a.length) {
            for (let s = 0, l; s < e.length; s++)
                if (l = e[s])
                    for (let i = 0; i < a.length; i++)
                        a[i].eq(l, n) && (a == this.local && (a = this.local.slice()),
                        a.splice(i--, 1))
        }
        return r == this.children && a == this.local ? this : a.length || r.length ? new cn(a,r) : Nn
    }
    forChild(e, n) {
        if (this == Nn)
            return this;
        if (n.isLeaf)
            return cn.empty;
        let r, a;
        for (let i = 0; i < this.children.length; i += 3)
            if (this.children[i] >= e) {
                this.children[i] == e && (r = this.children[i + 2]);
                break
            }
        let s = e + 1
          , l = s + n.content.size;
        for (let i = 0; i < this.local.length; i++) {
            let o = this.local[i];
            if (o.from < l && o.to > s && o.type instanceof cs) {
                let u = Math.max(s, o.from) - s
                  , d = Math.min(l, o.to) - s;
                u < d && (a || (a = [])).push(o.copy(u, d))
            }
        }
        if (a) {
            let i = new cn(a.sort(Zs),Il);
            return r ? new Za([i, r]) : i
        }
        return r || Nn
    }
    eq(e) {
        if (this == e)
            return !0;
        if (!(e instanceof cn) || this.local.length != e.local.length || this.children.length != e.children.length)
            return !1;
        for (let n = 0; n < this.local.length; n++)
            if (!this.local[n].eq(e.local[n]))
                return !1;
        for (let n = 0; n < this.children.length; n += 3)
            if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
                return !1;
        return !0
    }
    locals(e) {
        return qm(this.localsInner(e))
    }
    localsInner(e) {
        if (this == Nn)
            return Il;
        if (e.inlineContent || !this.local.some(cs.is))
            return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
            this.local[r].type instanceof cs || n.push(this.local[r]);
        return n
    }
}
cn.empty = new cn([],[]);
cn.removeOverlap = qm;
const Nn = cn.empty;
class Za {
    constructor(e) {
        this.members = e
    }
    map(e, n) {
        const r = this.members.map(a => a.map(e, n, Qs));
        return Za.from(r)
    }
    forChild(e, n) {
        if (n.isLeaf)
            return cn.empty;
        let r = [];
        for (let a = 0; a < this.members.length; a++) {
            let s = this.members[a].forChild(e, n);
            s != Nn && (s instanceof Za ? r = r.concat(s.members) : r.push(s))
        }
        return Za.from(r)
    }
    eq(e) {
        if (!(e instanceof Za) || e.members.length != this.members.length)
            return !1;
        for (let n = 0; n < this.members.length; n++)
            if (!this.members[n].eq(e.members[n]))
                return !1;
        return !0
    }
    locals(e) {
        let n, r = !0;
        for (let a = 0; a < this.members.length; a++) {
            let s = this.members[a].localsInner(e);
            if (s.length)
                if (!n)
                    n = s;
                else {
                    r && (n = n.slice(),
                    r = !1);
                    for (let l = 0; l < s.length; l++)
                        n.push(s[l])
                }
        }
        return n ? qm(r ? n : n.sort(Zs)) : Il
    }
    static from(e) {
        switch (e.length) {
        case 0:
            return Nn;
        case 1:
            return e[0];
        default:
            return new Za(e.every(n => n instanceof cn) ? e : e.reduce( (n, r) => n.concat(r instanceof cn ? r : r.members), []))
        }
    }
}
function nH(t, e, n, r, a, s, l) {
    let i = t.slice();
    for (let u = 0, d = s; u < n.maps.length; u++) {
        let f = 0;
        n.maps[u].forEach( (p, h, v, y) => {
            let k = y - v - (h - p);
            for (let w = 0; w < i.length; w += 3) {
                let $ = i[w + 1];
                if ($ < 0 || p > $ + d - f)
                    continue;
                let M = i[w] + d - f;
                h >= M ? i[w + 1] = p <= M ? -2 : -1 : p >= d && k && (i[w] += k,
                i[w + 1] += k)
            }
            f += k
        }
        ),
        d = n.maps[u].map(d, -1)
    }
    let o = !1;
    for (let u = 0; u < i.length; u += 3)
        if (i[u + 1] < 0) {
            if (i[u + 1] == -2) {
                o = !0,
                i[u + 1] = -1;
                continue
            }
            let d = n.map(t[u] + s)
              , f = d - a;
            if (f < 0 || f >= r.content.size) {
                o = !0;
                continue
            }
            let p = n.map(t[u + 1] + s, -1)
              , h = p - a
              , {index: v, offset: y} = r.content.findIndex(f)
              , k = r.maybeChild(v);
            if (k && y == f && y + k.nodeSize == h) {
                let w = i[u + 2].mapInner(n, k, d + 1, t[u] + s + 1, l);
                w != Nn ? (i[u] = f,
                i[u + 1] = h,
                i[u + 2] = w) : (i[u + 1] = -2,
                o = !0)
            } else
                o = !0
        }
    if (o) {
        let u = rH(i, t, e, n, a, s, l)
          , d = md(u, r, 0, l);
        e = d.local;
        for (let f = 0; f < i.length; f += 3)
            i[f + 1] < 0 && (i.splice(f, 3),
            f -= 3);
        for (let f = 0, p = 0; f < d.children.length; f += 3) {
            let h = d.children[f];
            for (; p < i.length && i[p] < h; )
                p += 3;
            i.splice(p, 0, d.children[f], d.children[f + 1], d.children[f + 2])
        }
    }
    return new cn(e.sort(Zs),i)
}
function kx(t, e) {
    if (!e || !t.length)
        return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let a = t[r];
        n.push(new vr(a.from + e,a.to + e,a.type))
    }
    return n
}
function rH(t, e, n, r, a, s, l) {
    function i(o, u) {
        for (let d = 0; d < o.local.length; d++) {
            let f = o.local[d].map(r, a, u);
            f ? n.push(f) : l.onRemove && l.onRemove(o.local[d].spec)
        }
        for (let d = 0; d < o.children.length; d += 3)
            i(o.children[d + 2], o.children[d] + u + 1)
    }
    for (let o = 0; o < t.length; o += 3)
        t[o + 1] == -1 && i(t[o + 2], e[o] + s + 1);
    return n
}
function _x(t, e, n) {
    if (e.isLeaf)
        return null;
    let r = n + e.nodeSize
      , a = null;
    for (let s = 0, l; s < t.length; s++)
        (l = t[s]) && l.from > n && l.to < r && ((a || (a = [])).push(l),
        t[s] = null);
    return a
}
function wx(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
        t[n] != null && e.push(t[n]);
    return e
}
function md(t, e, n, r) {
    let a = []
      , s = !1;
    e.forEach( (i, o) => {
        let u = _x(t, i, o + n);
        if (u) {
            s = !0;
            let d = md(u, i, n + o + 1, r);
            d != Nn && a.push(o, o + i.nodeSize, d)
        }
    }
    );
    let l = kx(s ? wx(t) : t, -n).sort(Zs);
    for (let i = 0; i < l.length; i++)
        l[i].type.valid(e, l[i]) || (r.onRemove && r.onRemove(l[i].spec),
        l.splice(i--, 1));
    return l.length || a.length ? new cn(l,a) : Nn
}
function Zs(t, e) {
    return t.from - e.from || t.to - e.to
}
function qm(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
        let r = e[n];
        if (r.from != r.to)
            for (let a = n + 1; a < e.length; a++) {
                let s = e[a];
                if (s.from == r.from) {
                    s.to != r.to && (e == t && (e = t.slice()),
                    e[a] = s.copy(s.from, r.to),
                    P0(e, a + 1, s.copy(r.to, s.to)));
                    continue
                } else {
                    s.from < r.to && (e == t && (e = t.slice()),
                    e[n] = r.copy(r.from, s.from),
                    P0(e, a, r.copy(s.from, r.to)));
                    break
                }
            }
    }
    return e
}
function P0(t, e, n) {
    for (; e < t.length && Zs(n, t[e]) > 0; )
        e++;
    t.splice(e, 0, n)
}
function Mf(t) {
    let e = [];
    return t.someProp("decorations", n => {
        let r = n(t.state);
        r && r != Nn && e.push(r)
    }
    ),
    t.cursorWrapper && e.push(cn.create(t.state.doc, [t.cursorWrapper.deco])),
    Za.from(e)
}
const aH = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
}
  , sH = Qn && us <= 11;
class lH {
    constructor() {
        this.anchorNode = null,
        this.anchorOffset = 0,
        this.focusNode = null,
        this.focusOffset = 0
    }
    set(e) {
        this.anchorNode = e.anchorNode,
        this.anchorOffset = e.anchorOffset,
        this.focusNode = e.focusNode,
        this.focusOffset = e.focusOffset
    }
    clear() {
        this.anchorNode = this.focusNode = null
    }
    eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset
    }
}
class iH {
    constructor(e, n) {
        this.view = e,
        this.handleDOMChange = n,
        this.queue = [],
        this.flushingSoon = -1,
        this.observer = null,
        this.currentSelection = new lH,
        this.onCharData = null,
        this.suppressingSelectionUpdates = !1,
        this.observer = window.MutationObserver && new window.MutationObserver(r => {
            for (let a = 0; a < r.length; a++)
                this.queue.push(r[a]);
            Qn && us <= 11 && r.some(a => a.type == "childList" && a.removedNodes.length || a.type == "characterData" && a.oldValue.length > a.target.nodeValue.length) ? this.flushSoon() : this.flush()
        }
        ),
        sH && (this.onCharData = r => {
            this.queue.push({
                target: r.target,
                type: "characterData",
                oldValue: r.prevValue
            }),
            this.flushSoon()
        }
        ),
        this.onSelectionChange = this.onSelectionChange.bind(this)
    }
    flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout( () => {
            this.flushingSoon = -1,
            this.flush()
        }
        , 20))
    }
    forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon),
        this.flushingSoon = -1,
        this.flush())
    }
    start() {
        this.observer && (this.observer.takeRecords(),
        this.observer.observe(this.view.dom, aH)),
        this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
        this.connectSelection()
    }
    stop() {
        if (this.observer) {
            let e = this.observer.takeRecords();
            if (e.length) {
                for (let n = 0; n < e.length; n++)
                    this.queue.push(e[n]);
                window.setTimeout( () => this.flush(), 20)
            }
            this.observer.disconnect()
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
        this.disconnectSelection()
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = !0,
        setTimeout( () => this.suppressingSelectionUpdates = !1, 50)
    }
    onSelectionChange() {
        if (T0(this.view)) {
            if (this.suppressingSelectionUpdates)
                return Ta(this.view);
            if (Qn && us <= 11 && !this.view.state.selection.empty) {
                let e = this.view.domSelectionRange();
                if (e.focusNode && il(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
                    return this.flushSoon()
            }
            this.flush()
        }
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange())
    }
    ignoreSelectionChange(e) {
        if (!e.focusNode)
            return !0;
        let n = new Set, r;
        for (let s = e.focusNode; s; s = Mo(s))
            n.add(s);
        for (let s = e.anchorNode; s; s = Mo(s))
            if (n.has(s)) {
                r = s;
                break
            }
        let a = r && this.view.docView.nearestDesc(r);
        if (a && a.ignoreMutation({
            type: "selection",
            target: r.nodeType == 3 ? r.parentNode : r
        }))
            return this.setCurSelection(),
            !0
    }
    pendingRecords() {
        if (this.observer)
            for (let e of this.observer.takeRecords())
                this.queue.push(e);
        return this.queue
    }
    flush() {
        let {view: e} = this;
        if (!e.docView || this.flushingSoon > -1)
            return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let r = e.domSelectionRange()
          , a = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && T0(e) && !this.ignoreSelectionChange(r)
          , s = -1
          , l = -1
          , i = !1
          , o = [];
        if (e.editable)
            for (let d = 0; d < n.length; d++) {
                let f = this.registerMutation(n[d], o);
                f && (s = s < 0 ? f.from : Math.min(f.from, s),
                l = l < 0 ? f.to : Math.max(f.to, l),
                f.typeOver && (i = !0))
            }
        if (Rr && o.length > 1) {
            let d = o.filter(f => f.nodeName == "BR");
            if (d.length == 2) {
                let f = d[0]
                  , p = d[1];
                f.parentNode && f.parentNode.parentNode == p.parentNode ? p.remove() : f.remove()
            }
        }
        let u = null;
        s < 0 && a && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && vc(r) && (u = Lm(e)) && u.eq(lt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0,
        Ta(e),
        this.currentSelection.set(r),
        e.scrollToSelection()) : (s > -1 || a) && (s > -1 && (e.docView.markDirty(s, l),
        oH(e)),
        this.handleDOMChange(s, l, i, o),
        e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Ta(e),
        this.currentSelection.set(r))
    }
    registerMutation(e, n) {
        if (n.indexOf(e.target) > -1)
            return null;
        let r = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
            return null;
        if (e.type == "childList") {
            for (let d = 0; d < e.addedNodes.length; d++)
                n.push(e.addedNodes[d]);
            if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
                return {
                    from: r.posBefore,
                    to: r.posAfter
                };
            let a = e.previousSibling
              , s = e.nextSibling;
            if (Qn && us <= 11 && e.addedNodes.length)
                for (let d = 0; d < e.addedNodes.length; d++) {
                    let {previousSibling: f, nextSibling: p} = e.addedNodes[d];
                    (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (a = f),
                    (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) && (s = p)
                }
            let l = a && a.parentNode == e.target ? Tn(a) + 1 : 0
              , i = r.localPosFromDOM(e.target, l, -1)
              , o = s && s.parentNode == e.target ? Tn(s) : e.target.childNodes.length
              , u = r.localPosFromDOM(e.target, o, 1);
            return {
                from: i,
                to: u
            }
        } else
            return e.type == "attributes" ? {
                from: r.posAtStart - r.border,
                to: r.posAtEnd + r.border
            } : {
                from: r.posAtStart,
                to: r.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            }
    }
}
let F0 = new WeakMap
  , B0 = !1;
function oH(t) {
    if (!F0.has(t) && (F0.set(t, null),
    ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
        if (t.requiresGeckoHackNode = Rr,
        B0)
            return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
        B0 = !0
    }
}
function V0(t, e) {
    let n = e.startContainer
      , r = e.startOffset
      , a = e.endContainer
      , s = e.endOffset
      , l = t.domAtPos(t.state.selection.anchor);
    return il(l.node, l.offset, a, s) && ([n,r,a,s] = [a, s, n, r]),
    {
        anchorNode: n,
        anchorOffset: r,
        focusNode: a,
        focusOffset: s
    }
}
function uH(t, e) {
    if (e.getComposedRanges) {
        let a = e.getComposedRanges(t.root)[0];
        if (a)
            return V0(t, a)
    }
    let n;
    function r(a) {
        a.preventDefault(),
        a.stopImmediatePropagation(),
        n = a.getTargetRanges()[0]
    }
    return t.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    t.dom.removeEventListener("beforeinput", r, !0),
    n ? V0(t, n) : null
}
function dH(t, e, n) {
    let {node: r, fromOffset: a, toOffset: s, from: l, to: i} = t.docView.parseRange(e, n), o = t.domSelectionRange(), u, d = o.anchorNode;
    if (d && t.dom.contains(d.nodeType == 1 ? d : d.parentNode) && (u = [{
        node: d,
        offset: o.anchorOffset
    }],
    vc(o) || u.push({
        node: o.focusNode,
        offset: o.focusOffset
    })),
    Kn && t.input.lastKeyCode === 8)
        for (let k = s; k > a; k--) {
            let w = r.childNodes[k - 1]
              , $ = w.pmViewDesc;
            if (w.nodeName == "BR" && !$) {
                s = k;
                break
            }
            if (!$ || $.size)
                break
        }
    let f = t.state.doc
      , p = t.someProp("domParser") || di.fromSchema(t.state.schema)
      , h = f.resolve(l)
      , v = null
      , y = p.parse(r, {
        topNode: h.parent,
        topMatch: h.parent.contentMatchAt(h.index()),
        topOpen: !0,
        from: a,
        to: s,
        preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
        findPositions: u,
        ruleFromNode: cH,
        context: h
    });
    if (u && u[0].pos != null) {
        let k = u[0].pos
          , w = u[1] && u[1].pos;
        w == null && (w = k),
        v = {
            anchor: k + l,
            head: w + l
        }
    }
    return {
        doc: y,
        sel: v,
        from: l,
        to: i
    }
}
function cH(t) {
    let e = t.pmViewDesc;
    if (e)
        return e.parseRule();
    if (t.nodeName == "BR" && t.parentNode) {
        if (Wn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
            let n = document.createElement("div");
            return n.appendChild(document.createElement("li")),
            {
                skip: n
            }
        } else if (t.parentNode.lastChild == t || Wn && /^(tr|table)$/i.test(t.parentNode.nodeName))
            return {
                ignore: !0
            }
    } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
        return {
            ignore: !0
        };
    return null
}
const fH = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function pH(t, e, n, r, a) {
    let s = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
    if (t.input.compositionPendingChanges = 0,
    e < 0) {
        let L = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null
          , C = Lm(t, L);
        if (C && !t.state.selection.eq(C)) {
            if (Kn && Er && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", R => R(t, Is(13, "Enter"))))
                return;
            let W = t.state.tr.setSelection(C);
            L == "pointer" ? W.setMeta("pointer", !0) : L == "key" && W.scrollIntoView(),
            s && W.setMeta("composition", s),
            t.dispatch(W)
        }
        return
    }
    let l = t.state.doc.resolve(e)
      , i = l.sharedDepth(n);
    e = l.before(i + 1),
    n = t.state.doc.resolve(n).after(i + 1);
    let o = t.state.selection, u = dH(t, e, n), d = t.state.doc, f = d.slice(u.from, u.to), p, h;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (p = t.state.selection.to,
    h = "end") : (p = t.state.selection.from,
    h = "start"),
    t.input.lastKeyCode = null;
    let v = vH(f.content, u.doc.content, u.from, p, h);
    if ((pi && t.input.lastIOSEnter > Date.now() - 225 || Er) && a.some(L => L.nodeType == 1 && !fH.test(L.nodeName)) && (!v || v.endA >= v.endB) && t.someProp("handleKeyDown", L => L(t, Is(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (!v)
        if (r && o instanceof nt && !o.empty && o.$head.sameParent(o.$anchor) && !t.composing && !(u.sel && u.sel.anchor != u.sel.head))
            v = {
                start: o.from,
                endA: o.to,
                endB: o.to
            };
        else {
            if (u.sel) {
                let L = I0(t, t.state.doc, u.sel);
                if (L && !L.eq(t.state.selection)) {
                    let C = t.state.tr.setSelection(L);
                    s && C.setMeta("composition", s),
                    t.dispatch(C)
                }
            }
            return
        }
    t.input.domChangeCount++,
    t.state.selection.from < t.state.selection.to && v.start == v.endB && t.state.selection instanceof nt && (v.start > t.state.selection.from && v.start <= t.state.selection.from + 2 && t.state.selection.from >= u.from ? v.start = t.state.selection.from : v.endA < t.state.selection.to && v.endA >= t.state.selection.to - 2 && t.state.selection.to <= u.to && (v.endB += t.state.selection.to - v.endA,
    v.endA = t.state.selection.to)),
    Qn && us <= 11 && v.endB == v.start + 1 && v.endA == v.start && v.start > u.from && u.doc.textBetween(v.start - u.from - 1, v.start - u.from + 1) == "  " && (v.start--,
    v.endA--,
    v.endB--);
    let y = u.doc.resolveNoCache(v.start - u.from), k = u.doc.resolveNoCache(v.endB - u.from), w = d.resolve(v.start), $ = y.sameParent(k) && y.parent.inlineContent && w.end() >= v.endA, M;
    if ((pi && t.input.lastIOSEnter > Date.now() - 225 && (!$ || a.some(L => L.nodeName == "DIV" || L.nodeName == "P")) || !$ && y.pos < u.doc.content.size && !y.sameParent(k) && (M = lt.findFrom(u.doc.resolve(y.pos + 1), 1, !0)) && M.head == k.pos) && t.someProp("handleKeyDown", L => L(t, Is(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (t.state.selection.anchor > v.start && mH(d, v.start, v.endA, y, k) && t.someProp("handleKeyDown", L => L(t, Is(8, "Backspace")))) {
        Er && Kn && t.domObserver.suppressSelectionUpdates();
        return
    }
    Kn && Er && v.endB == v.start && (t.input.lastAndroidDelete = Date.now()),
    Er && !$ && y.start() != k.start() && k.parentOffset == 0 && y.depth == k.depth && u.sel && u.sel.anchor == u.sel.head && u.sel.head == v.endA && (v.endB -= 2,
    k = u.doc.resolveNoCache(v.endB - u.from),
    setTimeout( () => {
        t.someProp("handleKeyDown", function(L) {
            return L(t, Is(13, "Enter"))
        })
    }
    , 20));
    let S = v.start, T = v.endA, E, O, U;
    if ($) {
        if (y.pos == k.pos)
            Qn && us <= 11 && y.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(),
            setTimeout( () => Ta(t), 20)),
            E = t.state.tr.delete(S, T),
            O = d.resolve(v.start).marksAcross(d.resolve(v.endA));
        else if (v.endA == v.endB && (U = hH(y.parent.content.cut(y.parentOffset, k.parentOffset), w.parent.content.cut(w.parentOffset, v.endA - w.start()))))
            E = t.state.tr,
            U.type == "add" ? E.addMark(S, T, U.mark) : E.removeMark(S, T, U.mark);
        else if (y.parent.child(y.index()).isText && y.index() == k.index() - (k.textOffset ? 0 : 1)) {
            let L = y.parent.textBetween(y.parentOffset, k.parentOffset);
            if (t.someProp("handleTextInput", C => C(t, S, T, L)))
                return;
            E = t.state.tr.insertText(L, S, T)
        }
    }
    if (E || (E = t.state.tr.replace(S, T, u.doc.slice(v.start - u.from, v.endB - u.from))),
    u.sel) {
        let L = I0(t, E.doc, u.sel);
        L && !(Kn && Er && t.composing && L.empty && (v.start != v.endB || t.input.lastAndroidDelete < Date.now() - 100) && (L.head == S || L.head == E.mapping.map(T) - 1) || Qn && L.empty && L.head == S) && E.setSelection(L)
    }
    O && E.ensureMarks(O),
    s && E.setMeta("composition", s),
    t.dispatch(E.scrollIntoView())
}
function I0(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : jm(t, e.resolve(n.anchor), e.resolve(n.head))
}
function hH(t, e) {
    let n = t.firstChild.marks, r = e.firstChild.marks, a = n, s = r, l, i, o;
    for (let d = 0; d < r.length; d++)
        a = r[d].removeFromSet(a);
    for (let d = 0; d < n.length; d++)
        s = n[d].removeFromSet(s);
    if (a.length == 1 && s.length == 0)
        i = a[0],
        l = "add",
        o = d => d.mark(i.addToSet(d.marks));
    else if (a.length == 0 && s.length == 1)
        i = s[0],
        l = "remove",
        o = d => d.mark(i.removeFromSet(d.marks));
    else
        return null;
    let u = [];
    for (let d = 0; d < e.childCount; d++)
        u.push(o(e.child(d)));
    if (Ae.from(u).eq(t))
        return {
            mark: i,
            type: l
        }
}
function mH(t, e, n, r, a) {
    if (n - e <= a.pos - r.pos || Of(r, !0, !1) < a.pos)
        return !1;
    let s = t.resolve(e);
    if (!r.parent.isTextblock) {
        let i = s.nodeAfter;
        return i != null && n == e + i.nodeSize
    }
    if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
        return !1;
    let l = t.resolve(Of(s, !0, !0));
    return !l.parent.isTextblock || l.pos > n || Of(l, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(l.parent.content)
}
function Of(t, e, n) {
    let r = t.depth
      , a = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
        r--,
        a++,
        e = !1;
    if (n) {
        let s = t.node(r).maybeChild(t.indexAfter(r));
        for (; s && !s.isLeaf; )
            s = s.firstChild,
            a++
    }
    return a
}
function vH(t, e, n, r, a) {
    let s = t.findDiffStart(e, n);
    if (s == null)
        return null;
    let {a: l, b: i} = t.findDiffEnd(e, n + t.size, n + e.size);
    if (a == "end") {
        let o = Math.max(0, s - Math.min(l, i));
        r -= l + o - s
    }
    if (l < s && t.size < e.size) {
        let o = r <= s && r >= l ? s - r : 0;
        s -= o,
        s && s < e.size && R0(e.textBetween(s - 1, s + 1)) && (s += o ? 1 : -1),
        i = s + (i - l),
        l = s
    } else if (i < s) {
        let o = r <= s && r >= i ? s - r : 0;
        s -= o,
        s && s < t.size && R0(t.textBetween(s - 1, s + 1)) && (s += o ? 1 : -1),
        l = s + (l - i),
        i = s
    }
    return {
        start: s,
        endA: l,
        endB: i
    }
}
function R0(t) {
    if (t.length != 2)
        return !1;
    let e = t.charCodeAt(0)
      , n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319
}
class gH {
    constructor(e, n) {
        this._root = null,
        this.focused = !1,
        this.trackWrites = null,
        this.mounted = !1,
        this.markCursor = null,
        this.cursorWrapper = null,
        this.lastSelectedViewDesc = void 0,
        this.input = new VU,
        this.prevDirectPlugins = [],
        this.pluginViews = [],
        this.requiresGeckoHackNode = !1,
        this.dragging = null,
        this._props = n,
        this.state = n.state,
        this.directPlugins = n.plugins || [],
        this.directPlugins.forEach(K0),
        this.dispatch = this.dispatch.bind(this),
        this.dom = e && e.mount || document.createElement("div"),
        e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)),
        this.editable = U0(this),
        j0(this),
        this.nodeViews = H0(this),
        this.docView = k0(this.state.doc, L0(this), Mf(this), this.dom, this),
        this.domObserver = new iH(this, (r, a, s, l) => pH(this, r, a, s, l)),
        this.domObserver.start(),
        IU(this),
        this.updatePluginViews()
    }
    get composing() {
        return this.input.composing
    }
    get props() {
        if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let n in e)
                this._props[n] = e[n];
            this._props.state = this.state
        }
        return this._props
    }
    update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && ih(this);
        let n = this._props;
        this._props = e,
        e.plugins && (e.plugins.forEach(K0),
        this.directPlugins = e.plugins),
        this.updateStateInner(e.state, n)
    }
    setProps(e) {
        let n = {};
        for (let r in this._props)
            n[r] = this._props[r];
        n.state = this.state;
        for (let r in e)
            n[r] = e[r];
        this.update(n)
    }
    updateState(e) {
        this.updateStateInner(e, this._props)
    }
    updateStateInner(e, n) {
        var r;
        let a = this.state
          , s = !1
          , l = !1;
        e.storedMarks && this.composing && (vx(this),
        l = !0),
        this.state = e;
        let i = a.plugins != e.plugins || this._props.plugins != n.plugins;
        if (i || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let h = H0(this);
            yH(h, this.nodeViews) && (this.nodeViews = h,
            s = !0)
        }
        (i || n.handleDOMEvents != this._props.handleDOMEvents) && ih(this),
        this.editable = U0(this),
        j0(this);
        let o = Mf(this)
          , u = L0(this)
          , d = a.plugins != e.plugins && !a.doc.eq(e.doc) ? "reset" : e.scrollToSelection > a.scrollToSelection ? "to selection" : "preserve"
          , f = s || !this.docView.matchesNode(e.doc, u, o);
        (f || !e.selection.eq(a.selection)) && (l = !0);
        let p = d == "preserve" && l && this.dom.style.overflowAnchor == null && Zj(this);
        if (l) {
            this.domObserver.stop();
            let h = f && (Qn || Kn) && !this.composing && !a.selection.empty && !e.selection.empty && bH(a.selection, e.selection);
            if (f) {
                let v = Kn ? this.trackWrites = this.domSelectionRange().focusNode : null;
                this.composing && (this.input.compositionNode = XU(this)),
                (s || !this.docView.update(e.doc, u, o, this)) && (this.docView.updateOuterDeco(u),
                this.docView.destroy(),
                this.docView = k0(e.doc, u, o, this.dom, this)),
                v && !this.trackWrites && (h = !0)
            }
            h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && xU(this)) ? Ta(this, h) : (rx(this, e.selection),
            this.domObserver.setCurSelection()),
            this.domObserver.start()
        }
        this.updatePluginViews(a),
        !((r = this.dragging) === null || r === void 0) && r.node && !a.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, a),
        d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : p && eU(p)
    }
    scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", n => n(this)))
            if (this.state.selection instanceof Ze) {
                let n = this.docView.domAfterPos(this.state.selection.from);
                n.nodeType == 1 && h0(this, n.getBoundingClientRect(), e)
            } else
                h0(this, this.coordsAtPos(this.state.selection.head, 1), e)
    }
    destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop(); )
            e.destroy && e.destroy()
    }
    updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins,
            this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, e)
            }
    }
    updateDraggedNode(e, n) {
        let r = e.node
          , a = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
            a = r.from;
        else {
            let s = r.from + (this.state.doc.content.size - n.doc.content.size);
            (s > 0 && this.state.doc.nodeAt(s)) == r.node && (a = s)
        }
        this.dragging = new bx(e.slice,e.move,a < 0 ? void 0 : Ze.create(this.state.doc, a))
    }
    someProp(e, n) {
        let r = this._props && this._props[e], a;
        if (r != null && (a = n ? n(r) : r))
            return a;
        for (let l = 0; l < this.directPlugins.length; l++) {
            let i = this.directPlugins[l].props[e];
            if (i != null && (a = n ? n(i) : i))
                return a
        }
        let s = this.state.plugins;
        if (s)
            for (let l = 0; l < s.length; l++) {
                let i = s[l].props[e];
                if (i != null && (a = n ? n(i) : i))
                    return a
            }
    }
    hasFocus() {
        if (Qn) {
            let e = this.root.activeElement;
            if (e == this.dom)
                return !0;
            if (!e || !this.dom.contains(e))
                return !1;
            for (; e && this.dom != e && this.dom.contains(e); ) {
                if (e.contentEditable == "false")
                    return !1;
                e = e.parentElement
            }
            return !0
        }
        return this.root.activeElement == this.dom
    }
    focus() {
        this.domObserver.stop(),
        this.editable && tU(this.dom),
        Ta(this),
        this.domObserver.start()
    }
    get root() {
        let e = this._root;
        if (e == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || n.nodeType == 11 && n.host)
                    return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
                    this._root = n
        }
        return e || document
    }
    updateRoot() {
        this._root = null
    }
    posAtCoords(e) {
        return lU(this, e)
    }
    coordsAtPos(e, n=1) {
        return Yw(this, e, n)
    }
    domAtPos(e, n=0) {
        return this.docView.domFromPos(e, n)
    }
    nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null
    }
    posAtDOM(e, n, r=-1) {
        let a = this.docView.posFromDOM(e, n, r);
        if (a == null)
            throw new RangeError("DOM position not inside the editor");
        return a
    }
    endOfTextblock(e, n) {
        return cU(this, n || this.state, e)
    }
    pasteHTML(e, n) {
        return No(this, "", e, !1, n || new ClipboardEvent("paste"))
    }
    pasteText(e, n) {
        return No(this, e, null, !0, n || new ClipboardEvent("paste"))
    }
    destroy() {
        this.docView && (RU(this),
        this.destroyPluginViews(),
        this.mounted ? (this.docView.update(this.state.doc, [], Mf(this), this),
        this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
        this.docView.destroy(),
        this.docView = null,
        jj())
    }
    get isDestroyed() {
        return this.docView == null
    }
    dispatchEvent(e) {
        return jU(this, e)
    }
    dispatch(e) {
        let n = this._props.dispatchTransaction;
        n ? n.call(this, e) : this.updateState(this.state.apply(e))
    }
    domSelectionRange() {
        let e = this.domSelection();
        return Wn && this.root.nodeType === 11 && qj(this.dom.ownerDocument) == this.dom && uH(this, e) || e
    }
    domSelection() {
        return this.root.getSelection()
    }
}
function L0(t) {
    let e = Object.create(null);
    return e.class = "ProseMirror",
    e.contenteditable = String(t.editable),
    t.someProp("attributes", n => {
        if (typeof n == "function" && (n = n(t.state)),
        n)
            for (let r in n)
                r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]))
    }
    ),
    e.translate || (e.translate = "no"),
    [vr.node(0, t.state.doc.content.size, e)]
}
function j0(t) {
    if (t.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator",
        e.setAttribute("mark-placeholder", "true"),
        e.setAttribute("alt", ""),
        t.cursorWrapper = {
            dom: e,
            deco: vr.widget(t.state.selection.head, e, {
                raw: !0,
                marks: t.markCursor
            })
        }
    } else
        t.cursorWrapper = null
}
function U0(t) {
    return !t.someProp("editable", e => e(t.state) === !1)
}
function bH(t, e) {
    let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
    return t.$anchor.start(n) != e.$anchor.start(n)
}
function H0(t) {
    let e = Object.create(null);
    function n(r) {
        for (let a in r)
            Object.prototype.hasOwnProperty.call(e, a) || (e[a] = r[a])
    }
    return t.someProp("nodeViews", n),
    t.someProp("markViews", n),
    e
}
function yH(t, e) {
    let n = 0
      , r = 0;
    for (let a in t) {
        if (t[a] != e[a])
            return !0;
        n++
    }
    for (let a in e)
        r++;
    return n != r
}
function K0(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component")
}
var _s = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}
  , vd = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
}
  , kH = typeof navigator < "u" && /Mac/.test(navigator.platform)
  , _H = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Cn = 0; Cn < 10; Cn++)
    _s[48 + Cn] = _s[96 + Cn] = String(Cn);
for (var Cn = 1; Cn <= 24; Cn++)
    _s[Cn + 111] = "F" + Cn;
for (var Cn = 65; Cn <= 90; Cn++)
    _s[Cn] = String.fromCharCode(Cn + 32),
    vd[Cn] = String.fromCharCode(Cn);
for (var Nf in _s)
    vd.hasOwnProperty(Nf) || (vd[Nf] = _s[Nf]);
function wH(t) {
    var e = kH && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || _H && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified"
      , n = !e && t.key || (t.shiftKey ? vd : _s)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
}
const xH = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function SH(t) {
    let e = t.split(/-(?!$)/)
      , n = e[e.length - 1];
    n == "Space" && (n = " ");
    let r, a, s, l;
    for (let i = 0; i < e.length - 1; i++) {
        let o = e[i];
        if (/^(cmd|meta|m)$/i.test(o))
            l = !0;
        else if (/^a(lt)?$/i.test(o))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(o))
            a = !0;
        else if (/^s(hift)?$/i.test(o))
            s = !0;
        else if (/^mod$/i.test(o))
            xH ? l = !0 : a = !0;
        else
            throw new Error("Unrecognized modifier name: " + o)
    }
    return r && (n = "Alt-" + n),
    a && (n = "Ctrl-" + n),
    l && (n = "Meta-" + n),
    s && (n = "Shift-" + n),
    n
}
function $H(t) {
    let e = Object.create(null);
    for (let n in t)
        e[SH(n)] = t[n];
    return e
}
function Df(t, e, n=!0) {
    return e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n && e.shiftKey && (t = "Shift-" + t),
    t
}
function TH(t) {
    return new $r({
        props: {
            handleKeyDown: xx(t)
        }
    })
}
function xx(t) {
    let e = $H(t);
    return function(n, r) {
        let a = wH(r), s, l = e[Df(a, r)];
        if (l && l(n.state, n.dispatch, n))
            return !0;
        if (a.length == 1 && a != " ") {
            if (r.shiftKey) {
                let i = e[Df(a, r, !1)];
                if (i && i(n.state, n.dispatch, n))
                    return !0
            }
            if ((r.shiftKey || r.altKey || r.metaKey || a.charCodeAt(0) > 127) && (s = _s[r.keyCode]) && s != a) {
                let i = e[Df(s, r)];
                if (i && i(n.state, n.dispatch, n))
                    return !0
            }
        }
        return !1
    }
}
const CH = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()),
!0);
function Sx(t, e) {
    let {$cursor: n} = t.selection;
    return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n
}
const EH = (t, e, n) => {
    let r = Sx(t, n);
    if (!r)
        return !1;
    let a = Wm(r);
    if (!a) {
        let l = r.blockRange()
          , i = l && Oi(l);
        return i == null ? !1 : (e && e(t.tr.lift(l, i).scrollIntoView()),
        !0)
    }
    let s = a.nodeBefore;
    if (!s.type.spec.isolating && Ex(t, a, e))
        return !0;
    if (r.parent.content.size == 0 && (hi(s, "end") || Ze.isSelectable(s))) {
        let l = hc(t.doc, r.before(), r.after(), Ie.empty);
        if (l && l.slice.size < l.to - l.from) {
            if (e) {
                let i = t.tr.step(l);
                i.setSelection(hi(s, "end") ? lt.findFrom(i.doc.resolve(i.mapping.map(a.pos, -1)), -1) : Ze.create(i.doc, a.pos - s.nodeSize)),
                e(i.scrollIntoView())
            }
            return !0
        }
    }
    return s.isAtom && a.depth == r.depth - 1 ? (e && e(t.tr.delete(a.pos - s.nodeSize, a.pos).scrollIntoView()),
    !0) : !1
}
  , AH = (t, e, n) => {
    let r = Sx(t, n);
    if (!r)
        return !1;
    let a = Wm(r);
    return a ? $x(t, a, e) : !1
}
  , MH = (t, e, n) => {
    let r = Tx(t, n);
    if (!r)
        return !1;
    let a = Gm(r);
    return a ? $x(t, a, e) : !1
}
;
function $x(t, e, n) {
    let r = e.nodeBefore
      , a = r
      , s = e.pos - 1;
    for (; !a.isTextblock; s--) {
        if (a.type.spec.isolating)
            return !1;
        let d = a.lastChild;
        if (!d)
            return !1;
        a = d
    }
    let l = e.nodeAfter
      , i = l
      , o = e.pos + 1;
    for (; !i.isTextblock; o++) {
        if (i.type.spec.isolating)
            return !1;
        let d = i.firstChild;
        if (!d)
            return !1;
        i = d
    }
    let u = hc(t.doc, s, o, Ie.empty);
    if (!u || u.from != s || u instanceof mn && u.slice.size >= o - s)
        return !1;
    if (n) {
        let d = t.tr.step(u);
        d.setSelection(nt.create(d.doc, s)),
        n(d.scrollIntoView())
    }
    return !0
}
function hi(t, e, n=!1) {
    for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
            return !0;
        if (n && r.childCount != 1)
            return !1
    }
    return !1
}
const OH = (t, e, n) => {
    let {$head: r, empty: a} = t.selection
      , s = r;
    if (!a)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
            return !1;
        s = Wm(r)
    }
    let l = s && s.nodeBefore;
    return !l || !Ze.isSelectable(l) ? !1 : (e && e(t.tr.setSelection(Ze.create(t.doc, s.pos - l.nodeSize)).scrollIntoView()),
    !0)
}
;
function Wm(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            if (t.index(e) > 0)
                return t.doc.resolve(t.before(e + 1));
            if (t.node(e).type.spec.isolating)
                break
        }
    return null
}
function Tx(t, e) {
    let {$cursor: n} = t.selection;
    return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n
}
const NH = (t, e, n) => {
    let r = Tx(t, n);
    if (!r)
        return !1;
    let a = Gm(r);
    if (!a)
        return !1;
    let s = a.nodeAfter;
    if (Ex(t, a, e))
        return !0;
    if (r.parent.content.size == 0 && (hi(s, "start") || Ze.isSelectable(s))) {
        let l = hc(t.doc, r.before(), r.after(), Ie.empty);
        if (l && l.slice.size < l.to - l.from) {
            if (e) {
                let i = t.tr.step(l);
                i.setSelection(hi(s, "start") ? lt.findFrom(i.doc.resolve(i.mapping.map(a.pos)), 1) : Ze.create(i.doc, i.mapping.map(a.pos))),
                e(i.scrollIntoView())
            }
            return !0
        }
    }
    return s.isAtom && a.depth == r.depth - 1 ? (e && e(t.tr.delete(a.pos, a.pos + s.nodeSize).scrollIntoView()),
    !0) : !1
}
  , DH = (t, e, n) => {
    let {$head: r, empty: a} = t.selection
      , s = r;
    if (!a)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
            return !1;
        s = Gm(r)
    }
    let l = s && s.nodeAfter;
    return !l || !Ze.isSelectable(l) ? !1 : (e && e(t.tr.setSelection(Ze.create(t.doc, s.pos)).scrollIntoView()),
    !0)
}
;
function Gm(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            let n = t.node(e);
            if (t.index(e) + 1 < n.childCount)
                return t.doc.resolve(t.after(e + 1));
            if (n.type.spec.isolating)
                break
        }
    return null
}
const PH = (t, e) => {
    let n = t.selection, r = n instanceof Ze, a;
    if (r) {
        if (n.node.isTextblock || !Ts(t.doc, n.from))
            return !1;
        a = n.from
    } else if (a = pc(t.doc, n.from, -1),
    a == null)
        return !1;
    if (e) {
        let s = t.tr.join(a);
        r && s.setSelection(Ze.create(s.doc, a - t.doc.resolve(a).nodeBefore.nodeSize)),
        e(s.scrollIntoView())
    }
    return !0
}
  , FH = (t, e) => {
    let n = t.selection, r;
    if (n instanceof Ze) {
        if (n.node.isTextblock || !Ts(t.doc, n.to))
            return !1;
        r = n.to
    } else if (r = pc(t.doc, n.to, 1),
    r == null)
        return !1;
    return e && e(t.tr.join(r).scrollIntoView()),
    !0
}
  , BH = (t, e) => {
    let {$from: n, $to: r} = t.selection
      , a = n.blockRange(r)
      , s = a && Oi(a);
    return s == null ? !1 : (e && e(t.tr.lift(a, s).scrollIntoView()),
    !0)
}
  , VH = (t, e) => {
    let {$head: n, $anchor: r} = t.selection;
    return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()),
    !0)
}
;
function Cx(t) {
    for (let e = 0; e < t.edgeCount; e++) {
        let {type: n} = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
const IH = (t, e) => {
    let {$head: n, $anchor: r} = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
        return !1;
    let a = n.node(-1)
      , s = n.indexAfter(-1)
      , l = Cx(a.contentMatchAt(s));
    if (!l || !a.canReplaceWith(s, s, l))
        return !1;
    if (e) {
        let i = n.after()
          , o = t.tr.replaceWith(i, i, l.createAndFill());
        o.setSelection(lt.near(o.doc.resolve(i), 1)),
        e(o.scrollIntoView())
    }
    return !0
}
  , RH = (t, e) => {
    let n = t.selection
      , {$from: r, $to: a} = n;
    if (n instanceof Dr || r.parent.inlineContent || a.parent.inlineContent)
        return !1;
    let s = Cx(a.parent.contentMatchAt(a.indexAfter()));
    if (!s || !s.isTextblock)
        return !1;
    if (e) {
        let l = (!r.parentOffset && a.index() < a.parent.childCount ? r : a).pos
          , i = t.tr.insert(l, s.createAndFill());
        i.setSelection(nt.create(i.doc, l + 1)),
        e(i.scrollIntoView())
    }
    return !0
}
  , LH = (t, e) => {
    let {$cursor: n} = t.selection;
    if (!n || n.parent.content.size)
        return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
        let s = n.before();
        if (Ql(t.doc, s))
            return e && e(t.tr.split(s).scrollIntoView()),
            !0
    }
    let r = n.blockRange()
      , a = r && Oi(r);
    return a == null ? !1 : (e && e(t.tr.lift(r, a).scrollIntoView()),
    !0)
}
  , jH = (t, e) => {
    let {$from: n, to: r} = t.selection, a, s = n.sharedDepth(r);
    return s == 0 ? !1 : (a = n.before(s),
    e && e(t.tr.setSelection(Ze.create(t.doc, a))),
    !0)
}
;
function UH(t, e, n) {
    let r = e.nodeBefore
      , a = e.nodeAfter
      , s = e.index();
    return !r || !a || !r.type.compatibleContent(a.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()),
    !0) : !e.parent.canReplace(s, s + 1) || !(a.isTextblock || Ts(t.doc, e.pos)) ? !1 : (n && n(t.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()),
    !0)
}
function Ex(t, e, n) {
    let r = e.nodeBefore, a = e.nodeAfter, s, l;
    if (r.type.spec.isolating || a.type.spec.isolating)
        return !1;
    if (UH(t, e, n))
        return !0;
    let i = e.parent.canReplace(e.index(), e.index() + 1);
    if (i && (s = (l = r.contentMatchAt(r.childCount)).findWrapping(a.type)) && l.matchType(s[0] || a.type).validEnd) {
        if (n) {
            let f = e.pos + a.nodeSize
              , p = Ae.empty;
            for (let y = s.length - 1; y >= 0; y--)
                p = Ae.from(s[y].create(null, p));
            p = Ae.from(r.copy(p));
            let h = t.tr.step(new bn(e.pos - 1,f,e.pos,f,new Ie(p,1,0),s.length,!0))
              , v = f + 2 * s.length;
            Ts(h.doc, v) && h.join(v),
            n(h.scrollIntoView())
        }
        return !0
    }
    let o = lt.findFrom(e, 1)
      , u = o && o.$from.blockRange(o.$to)
      , d = u && Oi(u);
    if (d != null && d >= e.depth)
        return n && n(t.tr.lift(u, d).scrollIntoView()),
        !0;
    if (i && hi(a, "start", !0) && hi(r, "end")) {
        let f = r
          , p = [];
        for (; p.push(f),
        !f.isTextblock; )
            f = f.lastChild;
        let h = a
          , v = 1;
        for (; !h.isTextblock; h = h.firstChild)
            v++;
        if (f.canReplace(f.childCount, f.childCount, h.content)) {
            if (n) {
                let y = Ae.empty;
                for (let w = p.length - 1; w >= 0; w--)
                    y = Ae.from(p[w].copy(y));
                let k = t.tr.step(new bn(e.pos - p.length,e.pos + a.nodeSize,e.pos + v,e.pos + a.nodeSize - v,new Ie(y,p.length,0),0,!0));
                n(k.scrollIntoView())
            }
            return !0
        }
    }
    return !1
}
function Ax(t) {
    return function(e, n) {
        let r = e.selection
          , a = t < 0 ? r.$from : r.$to
          , s = a.depth;
        for (; a.node(s).isInline; ) {
            if (!s)
                return !1;
            s--
        }
        return a.node(s).isTextblock ? (n && n(e.tr.setSelection(nt.create(e.doc, t < 0 ? a.start(s) : a.end(s)))),
        !0) : !1
    }
}
const HH = Ax(-1)
  , KH = Ax(1);
function zH(t, e=null) {
    return function(n, r) {
        let {$from: a, $to: s} = n.selection
          , l = a.blockRange(s)
          , i = l && Vm(l, t, e);
        return i ? (r && r(n.tr.wrap(l, i).scrollIntoView()),
        !0) : !1
    }
}
function z0(t, e=null) {
    return function(n, r) {
        let a = !1;
        for (let s = 0; s < n.selection.ranges.length && !a; s++) {
            let {$from: {pos: l}, $to: {pos: i}} = n.selection.ranges[s];
            n.doc.nodesBetween(l, i, (o, u) => {
                if (a)
                    return !1;
                if (!(!o.isTextblock || o.hasMarkup(t, e)))
                    if (o.type == t)
                        a = !0;
                    else {
                        let d = n.doc.resolve(u)
                          , f = d.index();
                        a = d.parent.canReplaceWith(f, f + 1, t)
                    }
            }
            )
        }
        if (!a)
            return !1;
        if (r) {
            let s = n.tr;
            for (let l = 0; l < n.selection.ranges.length; l++) {
                let {$from: {pos: i}, $to: {pos: o}} = n.selection.ranges[l];
                s.setBlockType(i, o, t, e)
            }
            r(s.scrollIntoView())
        }
        return !0
    }
}
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function qH(t, e=null) {
    return function(n, r) {
        let {$from: a, $to: s} = n.selection
          , l = a.blockRange(s)
          , i = !1
          , o = l;
        if (!l)
            return !1;
        if (l.depth >= 2 && a.node(l.depth - 1).type.compatibleContent(t) && l.startIndex == 0) {
            if (a.index(l.depth - 1) == 0)
                return !1;
            let d = n.doc.resolve(l.start - 2);
            o = new od(d,d,l.depth),
            l.endIndex < l.parent.childCount && (l = new od(a,n.doc.resolve(s.end(l.depth)),l.depth)),
            i = !0
        }
        let u = Vm(o, t, e, l);
        return u ? (r && r(WH(n.tr, l, u, i, t).scrollIntoView()),
        !0) : !1
    }
}
function WH(t, e, n, r, a) {
    let s = Ae.empty;
    for (let d = n.length - 1; d >= 0; d--)
        s = Ae.from(n[d].type.create(n[d].attrs, s));
    t.step(new bn(e.start - (r ? 2 : 0),e.end,e.start,e.end,new Ie(s,0,0),n.length,!0));
    let l = 0;
    for (let d = 0; d < n.length; d++)
        n[d].type == a && (l = d + 1);
    let i = n.length - l
      , o = e.start + n.length - (r ? 2 : 0)
      , u = e.parent;
    for (let d = e.startIndex, f = e.endIndex, p = !0; d < f; d++,
    p = !1)
        !p && Ql(t.doc, o, i) && (t.split(o, i),
        o += 2 * i),
        o += u.child(d).nodeSize;
    return t
}
function GH(t) {
    return function(e, n) {
        let {$from: r, $to: a} = e.selection
          , s = r.blockRange(a, l => l.childCount > 0 && l.firstChild.type == t);
        return s ? n ? r.node(s.depth - 1).type == t ? YH(e, n, t, s) : JH(e, n, s) : !0 : !1
    }
}
function YH(t, e, n, r) {
    let a = t.tr
      , s = r.end
      , l = r.$to.end(r.depth);
    s < l && (a.step(new bn(s - 1,l,s,l,new Ie(Ae.from(n.create(null, r.parent.copy())),1,0),1,!0)),
    r = new od(a.doc.resolve(r.$from.pos),a.doc.resolve(l),r.depth));
    const i = Oi(r);
    if (i == null)
        return !1;
    a.lift(r, i);
    let o = a.mapping.map(s, -1) - 1;
    return Ts(a.doc, o) && a.join(o),
    e(a.scrollIntoView()),
    !0
}
function JH(t, e, n) {
    let r = t.tr
      , a = n.parent;
    for (let h = n.end, v = n.endIndex - 1, y = n.startIndex; v > y; v--)
        h -= a.child(v).nodeSize,
        r.delete(h - 1, h + 1);
    let s = r.doc.resolve(n.start)
      , l = s.nodeAfter;
    if (r.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize)
        return !1;
    let i = n.startIndex == 0
      , o = n.endIndex == a.childCount
      , u = s.node(-1)
      , d = s.index(-1);
    if (!u.canReplace(d + (i ? 0 : 1), d + 1, l.content.append(o ? Ae.empty : Ae.from(a))))
        return !1;
    let f = s.pos
      , p = f + l.nodeSize;
    return r.step(new bn(f - (i ? 1 : 0),p + (o ? 1 : 0),f + 1,p - 1,new Ie((i ? Ae.empty : Ae.from(a.copy(Ae.empty))).append(o ? Ae.empty : Ae.from(a.copy(Ae.empty))),i ? 0 : 1,o ? 0 : 1),i ? 0 : 1)),
    e(r.scrollIntoView()),
    !0
}
function XH(t) {
    return function(e, n) {
        let {$from: r, $to: a} = e.selection
          , s = r.blockRange(a, u => u.childCount > 0 && u.firstChild.type == t);
        if (!s)
            return !1;
        let l = s.startIndex;
        if (l == 0)
            return !1;
        let i = s.parent
          , o = i.child(l - 1);
        if (o.type != t)
            return !1;
        if (n) {
            let u = o.lastChild && o.lastChild.type == i.type
              , d = Ae.from(u ? t.create() : null)
              , f = new Ie(Ae.from(t.create(null, Ae.from(i.type.create(null, d)))),u ? 3 : 1,0)
              , p = s.start
              , h = s.end;
            n(e.tr.step(new bn(p - (u ? 3 : 1),h,p,h,f,1,!0)).scrollIntoView())
        }
        return !0
    }
}
function yc(t) {
    const {state: e, transaction: n} = t;
    let {selection: r} = n
      , {doc: a} = n
      , {storedMarks: s} = n;
    return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
            return s
        },
        get selection() {
            return r
        },
        get doc() {
            return a
        },
        get tr() {
            return r = n.selection,
            a = n.doc,
            s = n.storedMarks,
            n
        }
    }
}
class kc {
    constructor(e) {
        this.editor = e.editor,
        this.rawCommands = this.editor.extensionManager.commands,
        this.customState = e.state
    }
    get hasCustomState() {
        return !!this.customState
    }
    get state() {
        return this.customState || this.editor.state
    }
    get commands() {
        const {rawCommands: e, editor: n, state: r} = this
          , {view: a} = n
          , {tr: s} = r
          , l = this.buildProps(s);
        return Object.fromEntries(Object.entries(e).map( ([i,o]) => [i, (...d) => {
            const f = o(...d)(l);
            return !s.getMeta("preventDispatch") && !this.hasCustomState && a.dispatch(s),
            f
        }
        ]))
    }
    get chain() {
        return () => this.createChain()
    }
    get can() {
        return () => this.createCan()
    }
    createChain(e, n=!0) {
        const {rawCommands: r, editor: a, state: s} = this
          , {view: l} = a
          , i = []
          , o = !!e
          , u = e || s.tr
          , d = () => (!o && n && !u.getMeta("preventDispatch") && !this.hasCustomState && l.dispatch(u),
        i.every(p => p === !0))
          , f = {
            ...Object.fromEntries(Object.entries(r).map( ([p,h]) => [p, (...y) => {
                const k = this.buildProps(u, n)
                  , w = h(...y)(k);
                return i.push(w),
                f
            }
            ])),
            run: d
        };
        return f
    }
    createCan(e) {
        const {rawCommands: n, state: r} = this
          , a = !1
          , s = e || r.tr
          , l = this.buildProps(s, a);
        return {
            ...Object.fromEntries(Object.entries(n).map( ([o,u]) => [o, (...d) => u(...d)({
                ...l,
                dispatch: void 0
            })])),
            chain: () => this.createChain(s, a)
        }
    }
    buildProps(e, n=!0) {
        const {rawCommands: r, editor: a, state: s} = this
          , {view: l} = a
          , i = {
            tr: e,
            editor: a,
            view: l,
            state: yc({
                state: s,
                transaction: e
            }),
            dispatch: n ? () => {}
            : void 0,
            chain: () => this.createChain(e, n),
            can: () => this.createCan(e),
            get commands() {
                return Object.fromEntries(Object.entries(r).map( ([o,u]) => [o, (...d) => u(...d)(i)]))
            }
        };
        return i
    }
}
class QH {
    constructor() {
        this.callbacks = {}
    }
    on(e, n) {
        return this.callbacks[e] || (this.callbacks[e] = []),
        this.callbacks[e].push(n),
        this
    }
    emit(e, ...n) {
        const r = this.callbacks[e];
        return r && r.forEach(a => a.apply(this, n)),
        this
    }
    off(e, n) {
        const r = this.callbacks[e];
        return r && (n ? this.callbacks[e] = r.filter(a => a !== n) : delete this.callbacks[e]),
        this
    }
    removeAllListeners() {
        this.callbacks = {}
    }
}
function He(t, e, n) {
    return t.config[e] === void 0 && t.parent ? He(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
        ...n,
        parent: t.parent ? He(t.parent, e, n) : null
    }) : t.config[e]
}
function _c(t) {
    const e = t.filter(a => a.type === "extension")
      , n = t.filter(a => a.type === "node")
      , r = t.filter(a => a.type === "mark");
    return {
        baseExtensions: e,
        nodeExtensions: n,
        markExtensions: r
    }
}
function Mx(t) {
    const e = []
      , {nodeExtensions: n, markExtensions: r} = _c(t)
      , a = [...n, ...r]
      , s = {
        default: null,
        rendered: !0,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: !0,
        isRequired: !1
    };
    return t.forEach(l => {
        const i = {
            name: l.name,
            options: l.options,
            storage: l.storage
        }
          , o = He(l, "addGlobalAttributes", i);
        if (!o)
            return;
        o().forEach(d => {
            d.types.forEach(f => {
                Object.entries(d.attributes).forEach( ([p,h]) => {
                    e.push({
                        type: f,
                        name: p,
                        attribute: {
                            ...s,
                            ...h
                        }
                    })
                }
                )
            }
            )
        }
        )
    }
    ),
    a.forEach(l => {
        const i = {
            name: l.name,
            options: l.options,
            storage: l.storage
        }
          , o = He(l, "addAttributes", i);
        if (!o)
            return;
        const u = o();
        Object.entries(u).forEach( ([d,f]) => {
            const p = {
                ...s,
                ...f
            };
            typeof (p == null ? void 0 : p.default) == "function" && (p.default = p.default()),
            p != null && p.isRequired && (p == null ? void 0 : p.default) === void 0 && delete p.default,
            e.push({
                type: l.name,
                name: d,
                attribute: p
            })
        }
        )
    }
    ),
    e
}
function kn(t, e) {
    if (typeof t == "string") {
        if (!e.nodes[t])
            throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
        return e.nodes[t]
    }
    return t
}
function pn(...t) {
    return t.filter(e => !!e).reduce( (e, n) => {
        const r = {
            ...e
        };
        return Object.entries(n).forEach( ([a,s]) => {
            if (!r[a]) {
                r[a] = s;
                return
            }
            if (a === "class") {
                const i = s ? s.split(" ") : []
                  , o = r[a] ? r[a].split(" ") : []
                  , u = i.filter(d => !o.includes(d));
                r[a] = [...o, ...u].join(" ")
            } else
                a === "style" ? r[a] = [r[a], s].join("; ") : r[a] = s
        }
        ),
        r
    }
    , {})
}
function oh(t, e) {
    return e.filter(n => n.attribute.rendered).map(n => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
        [n.name]: t.attrs[n.name]
    }).reduce( (n, r) => pn(n, r), {})
}
function Ox(t) {
    return typeof t == "function"
}
function at(t, e=void 0, ...n) {
    return Ox(t) ? e ? t.bind(e)(...n) : t(...n) : t
}
function ZH(t={}) {
    return Object.keys(t).length === 0 && t.constructor === Object
}
function e7(t) {
    return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t
}
function q0(t, e) {
    return t.style ? t : {
        ...t,
        getAttrs: n => {
            const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
            if (r === !1)
                return !1;
            const a = e.reduce( (s, l) => {
                const i = l.attribute.parseHTML ? l.attribute.parseHTML(n) : e7(n.getAttribute(l.name));
                return i == null ? s : {
                    ...s,
                    [l.name]: i
                }
            }
            , {});
            return {
                ...r,
                ...a
            }
        }
    }
}
function W0(t) {
    return Object.fromEntries(Object.entries(t).filter( ([e,n]) => e === "attrs" && ZH(n) ? !1 : n != null))
}
function t7(t, e) {
    var n;
    const r = Mx(t)
      , {nodeExtensions: a, markExtensions: s} = _c(t)
      , l = (n = a.find(u => He(u, "topNode"))) === null || n === void 0 ? void 0 : n.name
      , i = Object.fromEntries(a.map(u => {
        const d = r.filter(w => w.type === u.name)
          , f = {
            name: u.name,
            options: u.options,
            storage: u.storage,
            editor: e
        }
          , p = t.reduce( (w, $) => {
            const M = He($, "extendNodeSchema", f);
            return {
                ...w,
                ...M ? M(u) : {}
            }
        }
        , {})
          , h = W0({
            ...p,
            content: at(He(u, "content", f)),
            marks: at(He(u, "marks", f)),
            group: at(He(u, "group", f)),
            inline: at(He(u, "inline", f)),
            atom: at(He(u, "atom", f)),
            selectable: at(He(u, "selectable", f)),
            draggable: at(He(u, "draggable", f)),
            code: at(He(u, "code", f)),
            defining: at(He(u, "defining", f)),
            isolating: at(He(u, "isolating", f)),
            attrs: Object.fromEntries(d.map(w => {
                var $;
                return [w.name, {
                    default: ($ = w == null ? void 0 : w.attribute) === null || $ === void 0 ? void 0 : $.default
                }]
            }
            ))
        })
          , v = at(He(u, "parseHTML", f));
        v && (h.parseDOM = v.map(w => q0(w, d)));
        const y = He(u, "renderHTML", f);
        y && (h.toDOM = w => y({
            node: w,
            HTMLAttributes: oh(w, d)
        }));
        const k = He(u, "renderText", f);
        return k && (h.toText = k),
        [u.name, h]
    }
    ))
      , o = Object.fromEntries(s.map(u => {
        const d = r.filter(k => k.type === u.name)
          , f = {
            name: u.name,
            options: u.options,
            storage: u.storage,
            editor: e
        }
          , p = t.reduce( (k, w) => {
            const $ = He(w, "extendMarkSchema", f);
            return {
                ...k,
                ...$ ? $(u) : {}
            }
        }
        , {})
          , h = W0({
            ...p,
            inclusive: at(He(u, "inclusive", f)),
            excludes: at(He(u, "excludes", f)),
            group: at(He(u, "group", f)),
            spanning: at(He(u, "spanning", f)),
            code: at(He(u, "code", f)),
            attrs: Object.fromEntries(d.map(k => {
                var w;
                return [k.name, {
                    default: (w = k == null ? void 0 : k.attribute) === null || w === void 0 ? void 0 : w.default
                }]
            }
            ))
        })
          , v = at(He(u, "parseHTML", f));
        v && (h.parseDOM = v.map(k => q0(k, d)));
        const y = He(u, "renderHTML", f);
        return y && (h.toDOM = k => y({
            mark: k,
            HTMLAttributes: oh(k, d)
        })),
        [u.name, h]
    }
    ));
    return new sj({
        topNode: l,
        nodes: i,
        marks: o
    })
}
function Pf(t, e) {
    return e.nodes[t] || e.marks[t] || null
}
function G0(t, e) {
    return Array.isArray(e) ? e.some(n => (typeof n == "string" ? n : n.name) === t.name) : e
}
const n7 = (t, e=500) => {
    let n = "";
    const r = t.parentOffset;
    return t.parent.nodesBetween(Math.max(0, r - e), r, (a, s, l, i) => {
        var o, u;
        const d = ((u = (o = a.type.spec).toText) === null || u === void 0 ? void 0 : u.call(o, {
            node: a,
            pos: s,
            parent: l,
            index: i
        })) || a.textContent || "%leaf%";
        n += d.slice(0, Math.max(0, r - s))
    }
    ),
    n
}
;
function Ym(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
class wc {
    constructor(e) {
        this.find = e.find,
        this.handler = e.handler
    }
}
const r7 = (t, e) => {
    if (Ym(e))
        return e.exec(t);
    const n = e(t);
    if (!n)
        return null;
    const r = [n.text];
    return r.index = n.index,
    r.input = t,
    r.data = n.data,
    n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),
    r.push(n.replaceWith)),
    r
}
;
function wu(t) {
    var e;
    const {editor: n, from: r, to: a, text: s, rules: l, plugin: i} = t
      , {view: o} = n;
    if (o.composing)
        return !1;
    const u = o.state.doc.resolve(r);
    if (u.parent.type.spec.code || !((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) && e.marks.find(p => p.type.spec.code))
        return !1;
    let d = !1;
    const f = n7(u) + s;
    return l.forEach(p => {
        if (d)
            return;
        const h = r7(f, p.find);
        if (!h)
            return;
        const v = o.state.tr
          , y = yc({
            state: o.state,
            transaction: v
        })
          , k = {
            from: r - (h[0].length - s.length),
            to: a
        }
          , {commands: w, chain: $, can: M} = new kc({
            editor: n,
            state: y
        });
        p.handler({
            state: y,
            range: k,
            match: h,
            commands: w,
            chain: $,
            can: M
        }) === null || !v.steps.length || (v.setMeta(i, {
            transform: v,
            from: r,
            to: a,
            text: s
        }),
        o.dispatch(v),
        d = !0)
    }
    ),
    d
}
function a7(t) {
    const {editor: e, rules: n} = t
      , r = new $r({
        state: {
            init() {
                return null
            },
            apply(a, s) {
                const l = a.getMeta(r);
                if (l)
                    return l;
                const i = a.getMeta("applyInputRules");
                return !!i && setTimeout( () => {
                    const {from: u, text: d} = i
                      , f = u + d.length;
                    wu({
                        editor: e,
                        from: u,
                        to: f,
                        text: d,
                        rules: n,
                        plugin: r
                    })
                }
                ),
                a.selectionSet || a.docChanged ? null : s
            }
        },
        props: {
            handleTextInput(a, s, l, i) {
                return wu({
                    editor: e,
                    from: s,
                    to: l,
                    text: i,
                    rules: n,
                    plugin: r
                })
            },
            handleDOMEvents: {
                compositionend: a => (setTimeout( () => {
                    const {$cursor: s} = a.state.selection;
                    s && wu({
                        editor: e,
                        from: s.pos,
                        to: s.pos,
                        text: "",
                        rules: n,
                        plugin: r
                    })
                }
                ),
                !1)
            },
            handleKeyDown(a, s) {
                if (s.key !== "Enter")
                    return !1;
                const {$cursor: l} = a.state.selection;
                return l ? wu({
                    editor: e,
                    from: l.pos,
                    to: l.pos,
                    text: `
`,
                    rules: n,
                    plugin: r
                }) : !1
            }
        },
        isInputRules: !0
    });
    return r
}
function s7(t) {
    return typeof t == "number"
}
class l7 {
    constructor(e) {
        this.find = e.find,
        this.handler = e.handler
    }
}
const i7 = (t, e, n) => {
    if (Ym(e))
        return [...t.matchAll(e)];
    const r = e(t, n);
    return r ? r.map(a => {
        const s = [a.text];
        return s.index = a.index,
        s.input = t,
        s.data = a.data,
        a.replaceWith && (a.text.includes(a.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'),
        s.push(a.replaceWith)),
        s
    }
    ) : []
}
;
function o7(t) {
    const {editor: e, state: n, from: r, to: a, rule: s, pasteEvent: l, dropEvent: i} = t
      , {commands: o, chain: u, can: d} = new kc({
        editor: e,
        state: n
    })
      , f = [];
    return n.doc.nodesBetween(r, a, (h, v) => {
        if (!h.isTextblock || h.type.spec.code)
            return;
        const y = Math.max(r, v)
          , k = Math.min(a, v + h.content.size)
          , w = h.textBetween(y - v, k - v, void 0, "￼");
        i7(w, s.find, l).forEach(M => {
            if (M.index === void 0)
                return;
            const S = y + M.index + 1
              , T = S + M[0].length
              , E = {
                from: n.tr.mapping.map(S),
                to: n.tr.mapping.map(T)
            }
              , O = s.handler({
                state: n,
                range: E,
                match: M,
                commands: o,
                chain: u,
                can: d,
                pasteEvent: l,
                dropEvent: i
            });
            f.push(O)
        }
        )
    }
    ),
    f.every(h => h !== null)
}
const u7 = t => {
    var e;
    const n = new ClipboardEvent("paste",{
        clipboardData: new DataTransfer
    });
    return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t),
    n
}
;
function d7(t) {
    const {editor: e, rules: n} = t;
    let r = null
      , a = !1
      , s = !1
      , l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null
      , i = typeof DragEvent < "u" ? new DragEvent("drop") : null;
    const o = ({state: d, from: f, to: p, rule: h, pasteEvt: v}) => {
        const y = d.tr
          , k = yc({
            state: d,
            transaction: y
        });
        if (!(!o7({
            editor: e,
            state: k,
            from: Math.max(f - 1, 0),
            to: p.b - 1,
            rule: h,
            pasteEvent: v,
            dropEvent: i
        }) || !y.steps.length))
            return i = typeof DragEvent < "u" ? new DragEvent("drop") : null,
            l = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
            y
    }
    ;
    return n.map(d => new $r({
        view(f) {
            const p = h => {
                var v;
                r = !((v = f.dom.parentElement) === null || v === void 0) && v.contains(h.target) ? f.dom.parentElement : null
            }
            ;
            return window.addEventListener("dragstart", p),
            {
                destroy() {
                    window.removeEventListener("dragstart", p)
                }
            }
        },
        props: {
            handleDOMEvents: {
                drop: (f, p) => (s = r === f.dom.parentElement,
                i = p,
                !1),
                paste: (f, p) => {
                    var h;
                    const v = (h = p.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/html");
                    return l = p,
                    a = !!(v != null && v.includes("data-pm-slice")),
                    !1
                }
            }
        },
        appendTransaction: (f, p, h) => {
            const v = f[0]
              , y = v.getMeta("uiEvent") === "paste" && !a
              , k = v.getMeta("uiEvent") === "drop" && !s
              , w = v.getMeta("applyPasteRules")
              , $ = !!w;
            if (!y && !k && !$)
                return;
            if ($) {
                const {from: T, text: E} = w
                  , O = T + E.length
                  , U = u7(E);
                return o({
                    rule: d,
                    state: h,
                    from: T,
                    to: {
                        b: O
                    },
                    pasteEvt: U
                })
            }
            const M = p.doc.content.findDiffStart(h.doc.content)
              , S = p.doc.content.findDiffEnd(h.doc.content);
            if (!(!s7(M) || !S || M === S.b))
                return o({
                    rule: d,
                    state: h,
                    from: M,
                    to: S,
                    pasteEvt: l
                })
        }
    }))
}
function c7(t) {
    const e = t.filter( (n, r) => t.indexOf(n) !== r);
    return [...new Set(e)]
}
class Hl {
    constructor(e, n) {
        this.splittableMarks = [],
        this.editor = n,
        this.extensions = Hl.resolve(e),
        this.schema = t7(this.extensions, n),
        this.extensions.forEach(r => {
            var a;
            this.editor.extensionStorage[r.name] = r.storage;
            const s = {
                name: r.name,
                options: r.options,
                storage: r.storage,
                editor: this.editor,
                type: Pf(r.name, this.schema)
            };
            r.type === "mark" && (!((a = at(He(r, "keepOnSplit", s))) !== null && a !== void 0) || a) && this.splittableMarks.push(r.name);
            const l = He(r, "onBeforeCreate", s);
            l && this.editor.on("beforeCreate", l);
            const i = He(r, "onCreate", s);
            i && this.editor.on("create", i);
            const o = He(r, "onUpdate", s);
            o && this.editor.on("update", o);
            const u = He(r, "onSelectionUpdate", s);
            u && this.editor.on("selectionUpdate", u);
            const d = He(r, "onTransaction", s);
            d && this.editor.on("transaction", d);
            const f = He(r, "onFocus", s);
            f && this.editor.on("focus", f);
            const p = He(r, "onBlur", s);
            p && this.editor.on("blur", p);
            const h = He(r, "onDestroy", s);
            h && this.editor.on("destroy", h)
        }
        )
    }
    static resolve(e) {
        const n = Hl.sort(Hl.flatten(e))
          , r = c7(n.map(a => a.name));
        return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(a => `'${a}'`).join(", ")}]. This can lead to issues.`),
        n
    }
    static flatten(e) {
        return e.map(n => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage
            }
              , a = He(n, "addExtensions", r);
            return a ? [n, ...this.flatten(a())] : n
        }
        ).flat(10)
    }
    static sort(e) {
        return e.sort( (r, a) => {
            const s = He(r, "priority") || 100
              , l = He(a, "priority") || 100;
            return s > l ? -1 : s < l ? 1 : 0
        }
        )
    }
    get commands() {
        return this.extensions.reduce( (e, n) => {
            const r = {
                name: n.name,
                options: n.options,
                storage: n.storage,
                editor: this.editor,
                type: Pf(n.name, this.schema)
            }
              , a = He(n, "addCommands", r);
            return a ? {
                ...e,
                ...a()
            } : e
        }
        , {})
    }
    get plugins() {
        const {editor: e} = this
          , n = Hl.sort([...this.extensions].reverse())
          , r = []
          , a = []
          , s = n.map(l => {
            const i = {
                name: l.name,
                options: l.options,
                storage: l.storage,
                editor: e,
                type: Pf(l.name, this.schema)
            }
              , o = []
              , u = He(l, "addKeyboardShortcuts", i);
            let d = {};
            if (l.type === "mark" && l.config.exitable && (d.ArrowRight = () => da.handleExit({
                editor: e,
                mark: l
            })),
            u) {
                const y = Object.fromEntries(Object.entries(u()).map( ([k,w]) => [k, () => w({
                    editor: e
                })]));
                d = {
                    ...d,
                    ...y
                }
            }
            const f = TH(d);
            o.push(f);
            const p = He(l, "addInputRules", i);
            G0(l, e.options.enableInputRules) && p && r.push(...p());
            const h = He(l, "addPasteRules", i);
            G0(l, e.options.enablePasteRules) && h && a.push(...h());
            const v = He(l, "addProseMirrorPlugins", i);
            if (v) {
                const y = v();
                o.push(...y)
            }
            return o
        }
        ).flat();
        return [a7({
            editor: e,
            rules: r
        }), ...d7({
            editor: e,
            rules: a
        }), ...s]
    }
    get attributes() {
        return Mx(this.extensions)
    }
    get nodeViews() {
        const {editor: e} = this
          , {nodeExtensions: n} = _c(this.extensions);
        return Object.fromEntries(n.filter(r => !!He(r, "addNodeView")).map(r => {
            const a = this.attributes.filter(o => o.type === r.name)
              , s = {
                name: r.name,
                options: r.options,
                storage: r.storage,
                editor: e,
                type: kn(r.name, this.schema)
            }
              , l = He(r, "addNodeView", s);
            if (!l)
                return [];
            const i = (o, u, d, f) => {
                const p = oh(o, a);
                return l()({
                    editor: e,
                    node: o,
                    getPos: d,
                    decorations: f,
                    HTMLAttributes: p,
                    extension: r
                })
            }
            ;
            return [r.name, i]
        }
        ))
    }
}
function f7(t) {
    return Object.prototype.toString.call(t).slice(8, -1)
}
function Ff(t) {
    return f7(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype
}
function xc(t, e) {
    const n = {
        ...t
    };
    return Ff(t) && Ff(e) && Object.keys(e).forEach(r => {
        Ff(e[r]) ? r in t ? n[r] = xc(t[r], e[r]) : Object.assign(n, {
            [r]: e[r]
        }) : Object.assign(n, {
            [r]: e[r]
        })
    }
    ),
    n
}
class ir {
    constructor(e={}) {
        this.type = "extension",
        this.name = "extension",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...e
        },
        this.name = this.config.name,
        e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = at(He(this, "addOptions", {
            name: this.name
        }))),
        this.storage = at(He(this, "addStorage", {
            name: this.name,
            options: this.options
        })) || {}
    }
    static create(e={}) {
        return new ir(e)
    }
    configure(e={}) {
        const n = this.extend();
        return n.options = xc(this.options, e),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
    extend(e={}) {
        const n = new ir({
            ...this.config,
            ...e
        });
        return n.parent = this,
        this.child = n,
        n.name = e.name ? e.name : n.parent.name,
        e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = at(He(n, "addOptions", {
            name: n.name
        })),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
}
function Nx(t, e, n) {
    const {from: r, to: a} = e
      , {blockSeparator: s=`

`, textSerializers: l={}} = n || {};
    let i = ""
      , o = !0;
    return t.nodesBetween(r, a, (u, d, f, p) => {
        var h;
        const v = l == null ? void 0 : l[u.type.name];
        if (v)
            return u.isBlock && !o && (i += s,
            o = !0),
            f && (i += v({
                node: u,
                pos: d,
                parent: f,
                index: p,
                range: e
            })),
            !1;
        u.isText ? (i += (h = u == null ? void 0 : u.text) === null || h === void 0 ? void 0 : h.slice(Math.max(r, d) - d, a - d),
        o = !1) : u.isBlock && !o && (i += s,
        o = !0)
    }
    ),
    i
}
function Dx(t) {
    return Object.fromEntries(Object.entries(t.nodes).filter( ([,e]) => e.spec.toText).map( ([e,n]) => [e, n.spec.toText]))
}
const p7 = ir.create({
    name: "clipboardTextSerializer",
    addOptions() {
        return {
            blockSeparator: void 0
        }
    },
    addProseMirrorPlugins() {
        return [new $r({
            key: new Cs("clipboardTextSerializer"),
            props: {
                clipboardTextSerializer: () => {
                    const {editor: t} = this
                      , {state: e, schema: n} = t
                      , {doc: r, selection: a} = e
                      , {ranges: s} = a
                      , l = Math.min(...s.map(d => d.$from.pos))
                      , i = Math.max(...s.map(d => d.$to.pos))
                      , o = Dx(n);
                    return Nx(r, {
                        from: l,
                        to: i
                    }, {
                        ...this.options.blockSeparator !== void 0 ? {
                            blockSeparator: this.options.blockSeparator
                        } : {},
                        textSerializers: o
                    })
                }
            }
        })]
    }
})
  , h7 = () => ({editor: t, view: e}) => (requestAnimationFrame( () => {
    var n;
    t.isDestroyed || (e.dom.blur(),
    (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges())
}
),
!0)
  , m7 = (t=!1) => ({commands: e}) => e.setContent("", t)
  , v7 = () => ({state: t, tr: e, dispatch: n}) => {
    const {selection: r} = e
      , {ranges: a} = r;
    return n && a.forEach( ({$from: s, $to: l}) => {
        t.doc.nodesBetween(s.pos, l.pos, (i, o) => {
            if (i.type.isText)
                return;
            const {doc: u, mapping: d} = e
              , f = u.resolve(d.map(o))
              , p = u.resolve(d.map(o + i.nodeSize))
              , h = f.blockRange(p);
            if (!h)
                return;
            const v = Oi(h);
            if (i.type.isTextblock) {
                const {defaultType: y} = f.parent.contentMatchAt(f.index());
                e.setNodeMarkup(h.start, y)
            }
            (v || v === 0) && e.lift(h, v)
        }
        )
    }
    ),
    !0
}
  , g7 = t => e => t(e)
  , b7 = () => ({state: t, dispatch: e}) => RH(t, e)
  , y7 = (t, e) => ({editor: n, tr: r}) => {
    const {state: a} = n
      , s = a.doc.slice(t.from, t.to);
    r.deleteRange(t.from, t.to);
    const l = r.mapping.map(e);
    return r.insert(l, s.content),
    r.setSelection(new nt(r.doc.resolve(l - 1))),
    !0
}
  , k7 = () => ({tr: t, dispatch: e}) => {
    const {selection: n} = t
      , r = n.$anchor.node();
    if (r.content.size > 0)
        return !1;
    const a = t.selection.$anchor;
    for (let s = a.depth; s > 0; s -= 1)
        if (a.node(s).type === r.type) {
            if (e) {
                const i = a.before(s)
                  , o = a.after(s);
                t.delete(i, o).scrollIntoView()
            }
            return !0
        }
    return !1
}
  , _7 = t => ({tr: e, state: n, dispatch: r}) => {
    const a = kn(t, n.schema)
      , s = e.selection.$anchor;
    for (let l = s.depth; l > 0; l -= 1)
        if (s.node(l).type === a) {
            if (r) {
                const o = s.before(l)
                  , u = s.after(l);
                e.delete(o, u).scrollIntoView()
            }
            return !0
        }
    return !1
}
  , w7 = t => ({tr: e, dispatch: n}) => {
    const {from: r, to: a} = t;
    return n && e.delete(r, a),
    !0
}
  , x7 = () => ({state: t, dispatch: e}) => CH(t, e)
  , S7 = () => ({commands: t}) => t.keyboardShortcut("Enter")
  , $7 = () => ({state: t, dispatch: e}) => IH(t, e);
function gd(t, e, n={
    strict: !0
}) {
    const r = Object.keys(e);
    return r.length ? r.every(a => n.strict ? e[a] === t[a] : Ym(e[a]) ? e[a].test(t[a]) : e[a] === t[a]) : !0
}
function uh(t, e, n={}) {
    return t.find(r => r.type === e && gd(r.attrs, n))
}
function T7(t, e, n={}) {
    return !!uh(t, e, n)
}
function Jm(t, e, n={}) {
    if (!t || !e)
        return;
    let r = t.parent.childAfter(t.parentOffset);
    if (t.parentOffset === r.offset && r.offset !== 0 && (r = t.parent.childBefore(t.parentOffset)),
    !r.node)
        return;
    const a = uh([...r.node.marks], e, n);
    if (!a)
        return;
    let s = r.index
      , l = t.start() + r.offset
      , i = s + 1
      , o = l + r.node.nodeSize;
    for (uh([...r.node.marks], e, n); s > 0 && a.isInSet(t.parent.child(s - 1).marks); )
        s -= 1,
        l -= t.parent.child(s).nodeSize;
    for (; i < t.parent.childCount && T7([...t.parent.child(i).marks], e, n); )
        o += t.parent.child(i).nodeSize,
        i += 1;
    return {
        from: l,
        to: o
    }
}
function As(t, e) {
    if (typeof t == "string") {
        if (!e.marks[t])
            throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
        return e.marks[t]
    }
    return t
}
const C7 = (t, e={}) => ({tr: n, state: r, dispatch: a}) => {
    const s = As(t, r.schema)
      , {doc: l, selection: i} = n
      , {$from: o, from: u, to: d} = i;
    if (a) {
        const f = Jm(o, s, e);
        if (f && f.from <= u && f.to >= d) {
            const p = nt.create(l, f.from, f.to);
            n.setSelection(p)
        }
    }
    return !0
}
  , E7 = t => e => {
    const n = typeof t == "function" ? t(e) : t;
    for (let r = 0; r < n.length; r += 1)
        if (n[r](e))
            return !0;
    return !1
}
;
function Px(t) {
    return t instanceof nt
}
function zs(t=0, e=0, n=0) {
    return Math.min(Math.max(t, e), n)
}
function Fx(t, e=null) {
    if (!e)
        return null;
    const n = lt.atStart(t)
      , r = lt.atEnd(t);
    if (e === "start" || e === !0)
        return n;
    if (e === "end")
        return r;
    const a = n.from
      , s = r.to;
    return e === "all" ? nt.create(t, zs(0, a, s), zs(t.content.size, a, s)) : nt.create(t, zs(e, a, s), zs(e, a, s))
}
function Xm() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document
}
const A7 = (t=null, e={}) => ({editor: n, view: r, tr: a, dispatch: s}) => {
    e = {
        scrollIntoView: !0,
        ...e
    };
    const l = () => {
        Xm() && r.dom.focus(),
        requestAnimationFrame( () => {
            n.isDestroyed || (r.focus(),
            e != null && e.scrollIntoView && n.commands.scrollIntoView())
        }
        )
    }
    ;
    if (r.hasFocus() && t === null || t === !1)
        return !0;
    if (s && t === null && !Px(n.state.selection))
        return l(),
        !0;
    const i = Fx(a.doc, t) || n.state.selection
      , o = n.state.selection.eq(i);
    return s && (o || a.setSelection(i),
    o && a.storedMarks && a.setStoredMarks(a.storedMarks),
    l()),
    !0
}
  , M7 = (t, e) => n => t.every( (r, a) => e(r, {
    ...n,
    index: a
}))
  , O7 = (t, e) => ({tr: n, commands: r}) => r.insertContentAt({
    from: n.selection.from,
    to: n.selection.to
}, t, e)
  , Bx = t => {
    const e = t.childNodes;
    for (let n = e.length - 1; n >= 0; n -= 1) {
        const r = e[n];
        r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && Bx(r)
    }
    return t
}
;
function Y0(t) {
    const e = `<body>${t}</body>`
      , n = new window.DOMParser().parseFromString(e, "text/html").body;
    return Bx(n)
}
function bd(t, e, n) {
    if (n = {
        slice: !0,
        parseOptions: {},
        ...n
    },
    typeof t == "object" && t !== null)
        try {
            return Array.isArray(t) && t.length > 0 ? Ae.fromArray(t.map(r => e.nodeFromJSON(r))) : e.nodeFromJSON(t)
        } catch (r) {
            return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", r),
            bd("", e, n)
        }
    if (typeof t == "string") {
        const r = di.fromSchema(e);
        return n.slice ? r.parseSlice(Y0(t), n.parseOptions).content : r.parse(Y0(t), n.parseOptions)
    }
    return bd("", e, n)
}
function N7(t, e, n) {
    const r = t.steps.length - 1;
    if (r < e)
        return;
    const a = t.steps[r];
    if (!(a instanceof mn || a instanceof bn))
        return;
    const s = t.mapping.maps[r];
    let l = 0;
    s.forEach( (i, o, u, d) => {
        l === 0 && (l = d)
    }
    ),
    t.setSelection(lt.near(t.doc.resolve(l), n))
}
const D7 = t => t.toString().startsWith("<")
  , P7 = (t, e, n) => ({tr: r, dispatch: a, editor: s}) => {
    if (a) {
        n = {
            parseOptions: {},
            updateSelection: !0,
            applyInputRules: !1,
            applyPasteRules: !1,
            ...n
        };
        const l = bd(e, s.schema, {
            parseOptions: {
                preserveWhitespace: "full",
                ...n.parseOptions
            }
        });
        if (l.toString() === "<>")
            return !0;
        let {from: i, to: o} = typeof t == "number" ? {
            from: t,
            to: t
        } : {
            from: t.from,
            to: t.to
        }
          , u = !0
          , d = !0;
        if ((D7(l) ? l : [l]).forEach(h => {
            h.check(),
            u = u ? h.isText && h.marks.length === 0 : !1,
            d = d ? h.isBlock : !1
        }
        ),
        i === o && d) {
            const {parent: h} = r.doc.resolve(i);
            h.isTextblock && !h.type.spec.code && !h.childCount && (i -= 1,
            o += 1)
        }
        let p;
        u ? (Array.isArray(e) ? p = e.map(h => h.text || "").join("") : typeof e == "object" && e && e.text ? p = e.text : p = e,
        r.insertText(p, i, o)) : (p = l,
        r.replaceWith(i, o, p)),
        n.updateSelection && N7(r, r.steps.length - 1, -1),
        n.applyInputRules && r.setMeta("applyInputRules", {
            from: i,
            text: p
        }),
        n.applyPasteRules && r.setMeta("applyPasteRules", {
            from: i,
            text: p
        })
    }
    return !0
}
  , F7 = () => ({state: t, dispatch: e}) => PH(t, e)
  , B7 = () => ({state: t, dispatch: e}) => FH(t, e)
  , V7 = () => ({state: t, dispatch: e}) => EH(t, e)
  , I7 = () => ({state: t, dispatch: e}) => NH(t, e)
  , R7 = () => ({tr: t, state: e, dispatch: n}) => {
    try {
        const r = pc(e.doc, e.selection.$from.pos, -1);
        return r == null ? !1 : (t.join(r, 2),
        n && n(t),
        !0)
    } catch {
        return !1
    }
}
  , L7 = () => ({state: t, dispatch: e, tr: n}) => {
    try {
        const r = pc(t.doc, t.selection.$from.pos, 1);
        return r == null ? !1 : (n.join(r, 2),
        e && e(n),
        !0)
    } catch {
        return !1
    }
}
  , j7 = () => ({state: t, dispatch: e}) => AH(t, e)
  , U7 = () => ({state: t, dispatch: e}) => MH(t, e);
function Qm() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1
}
function H7(t) {
    const e = t.split(/-(?!$)/);
    let n = e[e.length - 1];
    n === "Space" && (n = " ");
    let r, a, s, l;
    for (let i = 0; i < e.length - 1; i += 1) {
        const o = e[i];
        if (/^(cmd|meta|m)$/i.test(o))
            l = !0;
        else if (/^a(lt)?$/i.test(o))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(o))
            a = !0;
        else if (/^s(hift)?$/i.test(o))
            s = !0;
        else if (/^mod$/i.test(o))
            Xm() || Qm() ? l = !0 : a = !0;
        else
            throw new Error(`Unrecognized modifier name: ${o}`)
    }
    return r && (n = `Alt-${n}`),
    a && (n = `Ctrl-${n}`),
    l && (n = `Meta-${n}`),
    s && (n = `Shift-${n}`),
    n
}
const K7 = t => ({editor: e, view: n, tr: r, dispatch: a}) => {
    const s = H7(t).split(/-(?!$)/)
      , l = s.find(u => !["Alt", "Ctrl", "Meta", "Shift"].includes(u))
      , i = new KeyboardEvent("keydown",{
        key: l === "Space" ? " " : l,
        altKey: s.includes("Alt"),
        ctrlKey: s.includes("Ctrl"),
        metaKey: s.includes("Meta"),
        shiftKey: s.includes("Shift"),
        bubbles: !0,
        cancelable: !0
    })
      , o = e.captureTransaction( () => {
        n.someProp("handleKeyDown", u => u(n, i))
    }
    );
    return o == null || o.steps.forEach(u => {
        const d = u.map(r.mapping);
        d && a && r.maybeStep(d)
    }
    ),
    !0
}
;
function Po(t, e, n={}) {
    const {from: r, to: a, empty: s} = t.selection
      , l = e ? kn(e, t.schema) : null
      , i = [];
    t.doc.nodesBetween(r, a, (f, p) => {
        if (f.isText)
            return;
        const h = Math.max(r, p)
          , v = Math.min(a, p + f.nodeSize);
        i.push({
            node: f,
            from: h,
            to: v
        })
    }
    );
    const o = a - r
      , u = i.filter(f => l ? l.name === f.node.type.name : !0).filter(f => gd(f.node.attrs, n, {
        strict: !1
    }));
    return s ? !!u.length : u.reduce( (f, p) => f + p.to - p.from, 0) >= o
}
const z7 = (t, e={}) => ({state: n, dispatch: r}) => {
    const a = kn(t, n.schema);
    return Po(n, a, e) ? BH(n, r) : !1
}
  , q7 = () => ({state: t, dispatch: e}) => LH(t, e)
  , W7 = t => ({state: e, dispatch: n}) => {
    const r = kn(t, e.schema);
    return GH(r)(e, n)
}
  , G7 = () => ({state: t, dispatch: e}) => VH(t, e);
function Sc(t, e) {
    return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null
}
function J0(t, e) {
    const n = typeof e == "string" ? [e] : e;
    return Object.keys(t).reduce( (r, a) => (n.includes(a) || (r[a] = t[a]),
    r), {})
}
const Y7 = (t, e) => ({tr: n, state: r, dispatch: a}) => {
    let s = null
      , l = null;
    const i = Sc(typeof t == "string" ? t : t.name, r.schema);
    return i ? (i === "node" && (s = kn(t, r.schema)),
    i === "mark" && (l = As(t, r.schema)),
    a && n.selection.ranges.forEach(o => {
        r.doc.nodesBetween(o.$from.pos, o.$to.pos, (u, d) => {
            s && s === u.type && n.setNodeMarkup(d, void 0, J0(u.attrs, e)),
            l && u.marks.length && u.marks.forEach(f => {
                l === f.type && n.addMark(d, d + u.nodeSize, l.create(J0(f.attrs, e)))
            }
            )
        }
        )
    }
    ),
    !0) : !1
}
  , J7 = () => ({tr: t, dispatch: e}) => (e && t.scrollIntoView(),
!0)
  , X7 = () => ({tr: t, commands: e}) => e.setTextSelection({
    from: 0,
    to: t.doc.content.size
})
  , Q7 = () => ({state: t, dispatch: e}) => OH(t, e)
  , Z7 = () => ({state: t, dispatch: e}) => DH(t, e)
  , eK = () => ({state: t, dispatch: e}) => jH(t, e)
  , tK = () => ({state: t, dispatch: e}) => KH(t, e)
  , nK = () => ({state: t, dispatch: e}) => HH(t, e);
function Vx(t, e, n={}) {
    return bd(t, e, {
        slice: !1,
        parseOptions: n
    })
}
const rK = (t, e=!1, n={}) => ({tr: r, editor: a, dispatch: s}) => {
    const {doc: l} = r
      , i = Vx(t, a.schema, n);
    return s && r.replaceWith(0, l.content.size, i).setMeta("preventUpdate", !e),
    !0
}
;
function $c(t, e) {
    const n = As(e, t.schema)
      , {from: r, to: a, empty: s} = t.selection
      , l = [];
    s ? (t.storedMarks && l.push(...t.storedMarks),
    l.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, a, o => {
        l.push(...o.marks)
    }
    );
    const i = l.find(o => o.type.name === n.name);
    return i ? {
        ...i.attrs
    } : {}
}
function aK(t) {
    for (let e = 0; e < t.edgeCount; e += 1) {
        const {type: n} = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
function sK(t, e) {
    for (let n = t.depth; n > 0; n -= 1) {
        const r = t.node(n);
        if (e(r))
            return {
                pos: n > 0 ? t.before(n) : 0,
                start: t.start(n),
                depth: n,
                node: r
            }
    }
}
function Zm(t) {
    return e => sK(e.$from, t)
}
function lK(t, e) {
    const n = ea.fromSchema(e).serializeFragment(t)
      , a = document.implementation.createHTMLDocument().createElement("div");
    return a.appendChild(n),
    a.innerHTML
}
function iK(t, e) {
    const n = {
        from: 0,
        to: t.content.size
    };
    return Nx(t, n, e)
}
function oK(t, e) {
    const n = kn(e, t.schema)
      , {from: r, to: a} = t.selection
      , s = [];
    t.doc.nodesBetween(r, a, i => {
        s.push(i)
    }
    );
    const l = s.reverse().find(i => i.type.name === n.name);
    return l ? {
        ...l.attrs
    } : {}
}
function uK(t, e) {
    const n = Sc(typeof e == "string" ? e : e.name, t.schema);
    return n === "node" ? oK(t, e) : n === "mark" ? $c(t, e) : {}
}
function Ix(t, e, n) {
    const r = [];
    return t === e ? n.resolve(t).marks().forEach(a => {
        const s = n.resolve(t - 1)
          , l = Jm(s, a.type);
        l && r.push({
            mark: a,
            ...l
        })
    }
    ) : n.nodesBetween(t, e, (a, s) => {
        !a || (a == null ? void 0 : a.nodeSize) === void 0 || r.push(...a.marks.map(l => ({
            from: s,
            to: s + a.nodeSize,
            mark: l
        })))
    }
    ),
    r
}
function Vu(t, e, n) {
    return Object.fromEntries(Object.entries(n).filter( ([r]) => {
        const a = t.find(s => s.type === e && s.name === r);
        return a ? a.attribute.keepOnSplit : !1
    }
    ))
}
function dh(t, e, n={}) {
    const {empty: r, ranges: a} = t.selection
      , s = e ? As(e, t.schema) : null;
    if (r)
        return !!(t.storedMarks || t.selection.$from.marks()).filter(f => s ? s.name === f.type.name : !0).find(f => gd(f.attrs, n, {
            strict: !1
        }));
    let l = 0;
    const i = [];
    if (a.forEach( ({$from: f, $to: p}) => {
        const h = f.pos
          , v = p.pos;
        t.doc.nodesBetween(h, v, (y, k) => {
            if (!y.isText && !y.marks.length)
                return;
            const w = Math.max(h, k)
              , $ = Math.min(v, k + y.nodeSize)
              , M = $ - w;
            l += M,
            i.push(...y.marks.map(S => ({
                mark: S,
                from: w,
                to: $
            })))
        }
        )
    }
    ),
    l === 0)
        return !1;
    const o = i.filter(f => s ? s.name === f.mark.type.name : !0).filter(f => gd(f.mark.attrs, n, {
        strict: !1
    })).reduce( (f, p) => f + p.to - p.from, 0)
      , u = i.filter(f => s ? f.mark.type !== s && f.mark.type.excludes(s) : !0).reduce( (f, p) => f + p.to - p.from, 0);
    return (o > 0 ? o + u : o) >= l
}
function dK(t, e, n={}) {
    if (!e)
        return Po(t, null, n) || dh(t, null, n);
    const r = Sc(e, t.schema);
    return r === "node" ? Po(t, e, n) : r === "mark" ? dh(t, e, n) : !1
}
function X0(t, e) {
    const {nodeExtensions: n} = _c(e)
      , r = n.find(l => l.name === t);
    if (!r)
        return !1;
    const a = {
        name: r.name,
        options: r.options,
        storage: r.storage
    }
      , s = at(He(r, "group", a));
    return typeof s != "string" ? !1 : s.split(" ").includes("list")
}
function cK(t) {
    var e;
    const n = (e = t.type.createAndFill()) === null || e === void 0 ? void 0 : e.toJSON()
      , r = t.toJSON();
    return JSON.stringify(n) === JSON.stringify(r)
}
function fK(t, e, n) {
    var r;
    const {selection: a} = e;
    let s = null;
    if (Px(a) && (s = a.$cursor),
    s) {
        const i = (r = t.storedMarks) !== null && r !== void 0 ? r : s.marks();
        return !!n.isInSet(i) || !i.some(o => o.type.excludes(n))
    }
    const {ranges: l} = a;
    return l.some( ({$from: i, $to: o}) => {
        let u = i.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
        return t.doc.nodesBetween(i.pos, o.pos, (d, f, p) => {
            if (u)
                return !1;
            if (d.isInline) {
                const h = !p || p.type.allowsMarkType(n)
                  , v = !!n.isInSet(d.marks) || !d.marks.some(y => y.type.excludes(n));
                u = h && v
            }
            return !u
        }
        ),
        u
    }
    )
}
const pK = (t, e={}) => ({tr: n, state: r, dispatch: a}) => {
    const {selection: s} = n
      , {empty: l, ranges: i} = s
      , o = As(t, r.schema);
    if (a)
        if (l) {
            const u = $c(r, o);
            n.addStoredMark(o.create({
                ...u,
                ...e
            }))
        } else
            i.forEach(u => {
                const d = u.$from.pos
                  , f = u.$to.pos;
                r.doc.nodesBetween(d, f, (p, h) => {
                    const v = Math.max(h, d)
                      , y = Math.min(h + p.nodeSize, f);
                    p.marks.find(w => w.type === o) ? p.marks.forEach(w => {
                        o === w.type && n.addMark(v, y, o.create({
                            ...w.attrs,
                            ...e
                        }))
                    }
                    ) : n.addMark(v, y, o.create(e))
                }
                )
            }
            );
    return fK(r, n, o)
}
  , hK = (t, e) => ({tr: n}) => (n.setMeta(t, e),
!0)
  , mK = (t, e={}) => ({state: n, dispatch: r, chain: a}) => {
    const s = kn(t, n.schema);
    return s.isTextblock ? a().command( ({commands: l}) => z0(s, e)(n) ? !0 : l.clearNodes()).command( ({state: l}) => z0(s, e)(l, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
    !1)
}
  , vK = t => ({tr: e, dispatch: n}) => {
    if (n) {
        const {doc: r} = e
          , a = zs(t, 0, r.content.size)
          , s = Ze.create(r, a);
        e.setSelection(s)
    }
    return !0
}
  , gK = t => ({tr: e, dispatch: n}) => {
    if (n) {
        const {doc: r} = e
          , {from: a, to: s} = typeof t == "number" ? {
            from: t,
            to: t
        } : t
          , l = nt.atStart(r).from
          , i = nt.atEnd(r).to
          , o = zs(a, l, i)
          , u = zs(s, l, i)
          , d = nt.create(r, o, u);
        e.setSelection(d)
    }
    return !0
}
  , bK = t => ({state: e, dispatch: n}) => {
    const r = kn(t, e.schema);
    return XH(r)(e, n)
}
;
function Q0(t, e) {
    const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
    if (n) {
        const r = n.filter(a => e == null ? void 0 : e.includes(a.type.name));
        t.tr.ensureMarks(r)
    }
}
const yK = ({keepMarks: t=!0}={}) => ({tr: e, state: n, dispatch: r, editor: a}) => {
    const {selection: s, doc: l} = e
      , {$from: i, $to: o} = s
      , u = a.extensionManager.attributes
      , d = Vu(u, i.node().type.name, i.node().attrs);
    if (s instanceof Ze && s.node.isBlock)
        return !i.parentOffset || !Ql(l, i.pos) ? !1 : (r && (t && Q0(n, a.extensionManager.splittableMarks),
        e.split(i.pos).scrollIntoView()),
        !0);
    if (!i.parent.isBlock)
        return !1;
    if (r) {
        const f = o.parentOffset === o.parent.content.size;
        s instanceof nt && e.deleteSelection();
        const p = i.depth === 0 ? void 0 : aK(i.node(-1).contentMatchAt(i.indexAfter(-1)));
        let h = f && p ? [{
            type: p,
            attrs: d
        }] : void 0
          , v = Ql(e.doc, e.mapping.map(i.pos), 1, h);
        if (!h && !v && Ql(e.doc, e.mapping.map(i.pos), 1, p ? [{
            type: p
        }] : void 0) && (v = !0,
        h = p ? [{
            type: p,
            attrs: d
        }] : void 0),
        v && (e.split(e.mapping.map(i.pos), 1, h),
        p && !f && !i.parentOffset && i.parent.type !== p)) {
            const y = e.mapping.map(i.before())
              , k = e.doc.resolve(y);
            i.node(-1).canReplaceWith(k.index(), k.index() + 1, p) && e.setNodeMarkup(e.mapping.map(i.before()), p)
        }
        t && Q0(n, a.extensionManager.splittableMarks),
        e.scrollIntoView()
    }
    return !0
}
  , kK = t => ({tr: e, state: n, dispatch: r, editor: a}) => {
    var s;
    const l = kn(t, n.schema)
      , {$from: i, $to: o} = n.selection
      , u = n.selection.node;
    if (u && u.isBlock || i.depth < 2 || !i.sameParent(o))
        return !1;
    const d = i.node(-1);
    if (d.type !== l)
        return !1;
    const f = a.extensionManager.attributes;
    if (i.parent.content.size === 0 && i.node(-1).childCount === i.indexAfter(-1)) {
        if (i.depth === 2 || i.node(-3).type !== l || i.index(-2) !== i.node(-2).childCount - 1)
            return !1;
        if (r) {
            let k = Ae.empty;
            const w = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
            for (let O = i.depth - w; O >= i.depth - 3; O -= 1)
                k = Ae.from(i.node(O).copy(k));
            const $ = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3
              , M = Vu(f, i.node().type.name, i.node().attrs)
              , S = ((s = l.contentMatch.defaultType) === null || s === void 0 ? void 0 : s.createAndFill(M)) || void 0;
            k = k.append(Ae.from(l.createAndFill(null, S) || void 0));
            const T = i.before(i.depth - (w - 1));
            e.replace(T, i.after(-$), new Ie(k,4 - w,0));
            let E = -1;
            e.doc.nodesBetween(T, e.doc.content.size, (O, U) => {
                if (E > -1)
                    return !1;
                O.isTextblock && O.content.size === 0 && (E = U + 1)
            }
            ),
            E > -1 && e.setSelection(nt.near(e.doc.resolve(E))),
            e.scrollIntoView()
        }
        return !0
    }
    const p = o.pos === i.end() ? d.contentMatchAt(0).defaultType : null
      , h = Vu(f, d.type.name, d.attrs)
      , v = Vu(f, i.node().type.name, i.node().attrs);
    e.delete(i.pos, o.pos);
    const y = p ? [{
        type: l,
        attrs: h
    }, {
        type: p,
        attrs: v
    }] : [{
        type: l,
        attrs: h
    }];
    if (!Ql(e.doc, i.pos, 2))
        return !1;
    if (r) {
        const {selection: k, storedMarks: w} = n
          , {splittableMarks: $} = a.extensionManager
          , M = w || k.$to.parentOffset && k.$from.marks();
        if (e.split(i.pos, 2, y).scrollIntoView(),
        !M || !r)
            return !0;
        const S = M.filter(T => $.includes(T.type.name));
        e.ensureMarks(S)
    }
    return !0
}
  , Bf = (t, e) => {
    const n = Zm(l => l.type === e)(t.selection);
    if (!n)
        return !0;
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0)
        return !0;
    const a = t.doc.nodeAt(r);
    return n.node.type === (a == null ? void 0 : a.type) && Ts(t.doc, n.pos) && t.join(n.pos),
    !0
}
  , Vf = (t, e) => {
    const n = Zm(l => l.type === e)(t.selection);
    if (!n)
        return !0;
    const r = t.doc.resolve(n.start).after(n.depth);
    if (r === void 0)
        return !0;
    const a = t.doc.nodeAt(r);
    return n.node.type === (a == null ? void 0 : a.type) && Ts(t.doc, r) && t.join(r),
    !0
}
  , _K = (t, e, n, r={}) => ({editor: a, tr: s, state: l, dispatch: i, chain: o, commands: u, can: d}) => {
    const {extensions: f, splittableMarks: p} = a.extensionManager
      , h = kn(t, l.schema)
      , v = kn(e, l.schema)
      , {selection: y, storedMarks: k} = l
      , {$from: w, $to: $} = y
      , M = w.blockRange($)
      , S = k || y.$to.parentOffset && y.$from.marks();
    if (!M)
        return !1;
    const T = Zm(E => X0(E.type.name, f))(y);
    if (M.depth >= 1 && T && M.depth - T.depth <= 1) {
        if (T.node.type === h)
            return u.liftListItem(v);
        if (X0(T.node.type.name, f) && h.validContent(T.node.content) && i)
            return o().command( () => (s.setNodeMarkup(T.pos, h),
            !0)).command( () => Bf(s, h)).command( () => Vf(s, h)).run()
    }
    return !n || !S || !i ? o().command( () => d().wrapInList(h, r) ? !0 : u.clearNodes()).wrapInList(h, r).command( () => Bf(s, h)).command( () => Vf(s, h)).run() : o().command( () => {
        const E = d().wrapInList(h, r)
          , O = S.filter(U => p.includes(U.type.name));
        return s.ensureMarks(O),
        E ? !0 : u.clearNodes()
    }
    ).wrapInList(h, r).command( () => Bf(s, h)).command( () => Vf(s, h)).run()
}
  , wK = (t, e={}, n={}) => ({state: r, commands: a}) => {
    const {extendEmptyMarkRange: s=!1} = n
      , l = As(t, r.schema);
    return dh(r, l, e) ? a.unsetMark(l, {
        extendEmptyMarkRange: s
    }) : a.setMark(l, e)
}
  , xK = (t, e, n={}) => ({state: r, commands: a}) => {
    const s = kn(t, r.schema)
      , l = kn(e, r.schema);
    return Po(r, s, n) ? a.setNode(l) : a.setNode(s, n)
}
  , SK = (t, e={}) => ({state: n, commands: r}) => {
    const a = kn(t, n.schema);
    return Po(n, a, e) ? r.lift(a) : r.wrapIn(a, e)
}
  , $K = () => ({state: t, dispatch: e}) => {
    const n = t.plugins;
    for (let r = 0; r < n.length; r += 1) {
        const a = n[r];
        let s;
        if (a.spec.isInputRules && (s = a.getState(t))) {
            if (e) {
                const l = t.tr
                  , i = s.transform;
                for (let o = i.steps.length - 1; o >= 0; o -= 1)
                    l.step(i.steps[o].invert(i.docs[o]));
                if (s.text) {
                    const o = l.doc.resolve(s.from).marks();
                    l.replaceWith(s.from, s.to, t.schema.text(s.text, o))
                } else
                    l.delete(s.from, s.to)
            }
            return !0
        }
    }
    return !1
}
  , TK = () => ({tr: t, dispatch: e}) => {
    const {selection: n} = t
      , {empty: r, ranges: a} = n;
    return r || e && a.forEach(s => {
        t.removeMark(s.$from.pos, s.$to.pos)
    }
    ),
    !0
}
  , CK = (t, e={}) => ({tr: n, state: r, dispatch: a}) => {
    var s;
    const {extendEmptyMarkRange: l=!1} = e
      , {selection: i} = n
      , o = As(t, r.schema)
      , {$from: u, empty: d, ranges: f} = i;
    if (!a)
        return !0;
    if (d && l) {
        let {from: p, to: h} = i;
        const v = (s = u.marks().find(k => k.type === o)) === null || s === void 0 ? void 0 : s.attrs
          , y = Jm(u, o, v);
        y && (p = y.from,
        h = y.to),
        n.removeMark(p, h, o)
    } else
        f.forEach(p => {
            n.removeMark(p.$from.pos, p.$to.pos, o)
        }
        );
    return n.removeStoredMark(o),
    !0
}
  , EK = (t, e={}) => ({tr: n, state: r, dispatch: a}) => {
    let s = null
      , l = null;
    const i = Sc(typeof t == "string" ? t : t.name, r.schema);
    return i ? (i === "node" && (s = kn(t, r.schema)),
    i === "mark" && (l = As(t, r.schema)),
    a && n.selection.ranges.forEach(o => {
        const u = o.$from.pos
          , d = o.$to.pos;
        r.doc.nodesBetween(u, d, (f, p) => {
            s && s === f.type && n.setNodeMarkup(p, void 0, {
                ...f.attrs,
                ...e
            }),
            l && f.marks.length && f.marks.forEach(h => {
                if (l === h.type) {
                    const v = Math.max(p, u)
                      , y = Math.min(p + f.nodeSize, d);
                    n.addMark(v, y, l.create({
                        ...h.attrs,
                        ...e
                    }))
                }
            }
            )
        }
        )
    }
    ),
    !0) : !1
}
  , AK = (t, e={}) => ({state: n, dispatch: r}) => {
    const a = kn(t, n.schema);
    return zH(a, e)(n, r)
}
  , MK = (t, e={}) => ({state: n, dispatch: r}) => {
    const a = kn(t, n.schema);
    return qH(a, e)(n, r)
}
;
var OK = Object.freeze({
    __proto__: null,
    blur: h7,
    clearContent: m7,
    clearNodes: v7,
    command: g7,
    createParagraphNear: b7,
    cut: y7,
    deleteCurrentNode: k7,
    deleteNode: _7,
    deleteRange: w7,
    deleteSelection: x7,
    enter: S7,
    exitCode: $7,
    extendMarkRange: C7,
    first: E7,
    focus: A7,
    forEach: M7,
    insertContent: O7,
    insertContentAt: P7,
    joinUp: F7,
    joinDown: B7,
    joinBackward: V7,
    joinForward: I7,
    joinItemBackward: R7,
    joinItemForward: L7,
    joinTextblockBackward: j7,
    joinTextblockForward: U7,
    keyboardShortcut: K7,
    lift: z7,
    liftEmptyBlock: q7,
    liftListItem: W7,
    newlineInCode: G7,
    resetAttributes: Y7,
    scrollIntoView: J7,
    selectAll: X7,
    selectNodeBackward: Q7,
    selectNodeForward: Z7,
    selectParentNode: eK,
    selectTextblockEnd: tK,
    selectTextblockStart: nK,
    setContent: rK,
    setMark: pK,
    setMeta: hK,
    setNode: mK,
    setNodeSelection: vK,
    setTextSelection: gK,
    sinkListItem: bK,
    splitBlock: yK,
    splitListItem: kK,
    toggleList: _K,
    toggleMark: wK,
    toggleNode: xK,
    toggleWrap: SK,
    undoInputRule: $K,
    unsetAllMarks: TK,
    unsetMark: CK,
    updateAttributes: EK,
    wrapIn: AK,
    wrapInList: MK
});
const NK = ir.create({
    name: "commands",
    addCommands() {
        return {
            ...OK
        }
    }
})
  , DK = ir.create({
    name: "editable",
    addProseMirrorPlugins() {
        return [new $r({
            key: new Cs("editable"),
            props: {
                editable: () => this.editor.options.editable
            }
        })]
    }
})
  , PK = ir.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
        const {editor: t} = this;
        return [new $r({
            key: new Cs("focusEvents"),
            props: {
                handleDOMEvents: {
                    focus: (e, n) => {
                        t.isFocused = !0;
                        const r = t.state.tr.setMeta("focus", {
                            event: n
                        }).setMeta("addToHistory", !1);
                        return e.dispatch(r),
                        !1
                    }
                    ,
                    blur: (e, n) => {
                        t.isFocused = !1;
                        const r = t.state.tr.setMeta("blur", {
                            event: n
                        }).setMeta("addToHistory", !1);
                        return e.dispatch(r),
                        !1
                    }
                }
            }
        })]
    }
})
  , FK = ir.create({
    name: "keymap",
    addKeyboardShortcuts() {
        const t = () => this.editor.commands.first( ({commands: l}) => [ () => l.undoInputRule(), () => l.command( ({tr: i}) => {
            const {selection: o, doc: u} = i
              , {empty: d, $anchor: f} = o
              , {pos: p, parent: h} = f
              , v = f.parent.isTextblock && p > 0 ? i.doc.resolve(p - 1) : f
              , y = v.parent.type.spec.isolating
              , k = f.pos - f.parentOffset
              , w = y && v.parent.childCount === 1 ? k === f.pos : lt.atStart(u).from === p;
            return !d || !w || !h.type.isTextblock || h.textContent.length ? !1 : l.clearNodes()
        }
        ), () => l.deleteSelection(), () => l.joinBackward(), () => l.selectNodeBackward()])
          , e = () => this.editor.commands.first( ({commands: l}) => [ () => l.deleteSelection(), () => l.deleteCurrentNode(), () => l.joinForward(), () => l.selectNodeForward()])
          , r = {
            Enter: () => this.editor.commands.first( ({commands: l}) => [ () => l.newlineInCode(), () => l.createParagraphNear(), () => l.liftEmptyBlock(), () => l.splitBlock()]),
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: t,
            "Mod-Backspace": t,
            "Shift-Backspace": t,
            Delete: e,
            "Mod-Delete": e,
            "Mod-a": () => this.editor.commands.selectAll()
        }
          , a = {
            ...r
        }
          , s = {
            ...r,
            "Ctrl-h": t,
            "Alt-Backspace": t,
            "Ctrl-d": e,
            "Ctrl-Alt-Backspace": e,
            "Alt-Delete": e,
            "Alt-d": e,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return Xm() || Qm() ? s : a
    },
    addProseMirrorPlugins() {
        return [new $r({
            key: new Cs("clearDocument"),
            appendTransaction: (t, e, n) => {
                if (!(t.some(v => v.docChanged) && !e.doc.eq(n.doc)))
                    return;
                const {empty: a, from: s, to: l} = e.selection
                  , i = lt.atStart(e.doc).from
                  , o = lt.atEnd(e.doc).to;
                if (a || !(s === i && l === o) || !(n.doc.textBetween(0, n.doc.content.size, " ", " ").length === 0))
                    return;
                const f = n.tr
                  , p = yc({
                    state: n,
                    transaction: f
                })
                  , {commands: h} = new kc({
                    editor: this.editor,
                    state: p
                });
                if (h.clearNodes(),
                !!f.steps.length)
                    return f
            }
        })]
    }
})
  , BK = ir.create({
    name: "tabindex",
    addProseMirrorPlugins() {
        return [new $r({
            key: new Cs("tabindex"),
            props: {
                attributes: this.editor.isEditable ? {
                    tabindex: "0"
                } : {}
            }
        })]
    }
});
class Rs {
    constructor(e, n, r=!1, a=null) {
        this.currentNode = null,
        this.actualDepth = null,
        this.isBlock = r,
        this.resolvedPos = e,
        this.editor = n,
        this.currentNode = a
    }
    get name() {
        return this.node.type.name
    }
    get node() {
        return this.currentNode || this.resolvedPos.node()
    }
    get element() {
        return this.editor.view.domAtPos(this.pos).node
    }
    get depth() {
        var e;
        return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth
    }
    get pos() {
        return this.resolvedPos.pos
    }
    get content() {
        return this.node.content
    }
    set content(e) {
        let n = this.from
          , r = this.to;
        if (this.isBlock) {
            if (this.content.size === 0) {
                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
                return
            }
            n = this.from + 1,
            r = this.to - 1
        }
        this.editor.commands.insertContentAt({
            from: n,
            to: r
        }, e)
    }
    get attributes() {
        return this.node.attrs
    }
    get textContent() {
        return this.node.textContent
    }
    get size() {
        return this.node.nodeSize
    }
    get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
    }
    get range() {
        return {
            from: this.from,
            to: this.to
        }
    }
    get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
    }
    get parent() {
        if (this.depth === 0)
            return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1)
          , n = this.resolvedPos.doc.resolve(e);
        return new Rs(n,this.editor)
    }
    get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
        new Rs(e,this.editor)
    }
    get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
        new Rs(e,this.editor)
    }
    get children() {
        const e = [];
        return this.node.content.forEach( (n, r) => {
            const a = n.isBlock && !n.isTextblock
              , s = this.pos + r + 1
              , l = this.resolvedPos.doc.resolve(s);
            if (!a && l.depth <= this.depth)
                return;
            const i = new Rs(l,this.editor,a,a ? n : null);
            a && (i.actualDepth = this.depth + 1),
            e.push(new Rs(l,this.editor,a,a ? n : null))
        }
        ),
        e
    }
    get firstChild() {
        return this.children[0] || null
    }
    get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null
    }
    closest(e, n={}) {
        let r = null
          , a = this.parent;
        for (; a && !r; ) {
            if (a.node.type.name === e)
                if (Object.keys(n).length > 0) {
                    const s = a.node.attrs
                      , l = Object.keys(n);
                    for (let i = 0; i < l.length; i += 1) {
                        const o = l[i];
                        if (s[o] !== n[o])
                            break
                    }
                } else
                    r = a;
            a = a.parent
        }
        return r
    }
    querySelector(e, n={}) {
        return this.querySelectorAll(e, n, !0)[0] || null
    }
    querySelectorAll(e, n={}, r=!1) {
        let a = [];
        return !this.children || this.children.length === 0 || this.children.forEach(s => {
            if (s.node.type.name === e) {
                if (Object.keys(n).length > 0) {
                    const l = s.node.attrs
                      , i = Object.keys(n);
                    for (let o = 0; o < i.length; o += 1) {
                        const u = i[o];
                        if (l[u] !== n[u])
                            return
                    }
                }
                if (a.push(s),
                r)
                    return
            }
            a = a.concat(s.querySelectorAll(e))
        }
        ),
        a
    }
    setAttribute(e) {
        const n = this.editor.state.selection;
        this.editor.chain().setTextSelection(this.from).updateAttributes(this.node.type.name, e).setTextSelection(n.from).run()
    }
}
const VK = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function IK(t, e, n) {
    const r = document.querySelector(`style[data-tiptap-style${n ? `-${n}` : ""}]`);
    if (r !== null)
        return r;
    const a = document.createElement("style");
    return e && a.setAttribute("nonce", e),
    a.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
    a.innerHTML = t,
    document.getElementsByTagName("head")[0].appendChild(a),
    a
}
let RK = class extends QH {
    constructor(e={}) {
        super(),
        this.isFocused = !1,
        this.extensionStorage = {},
        this.options = {
            element: document.createElement("div"),
            content: "",
            injectCSS: !0,
            injectNonce: void 0,
            extensions: [],
            autofocus: !1,
            editable: !0,
            editorProps: {},
            parseOptions: {},
            coreExtensionOptions: {},
            enableInputRules: !0,
            enablePasteRules: !0,
            enableCoreExtensions: !0,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null
        },
        this.isCapturingTransaction = !1,
        this.capturedTransaction = null,
        this.setOptions(e),
        this.createExtensionManager(),
        this.createCommandManager(),
        this.createSchema(),
        this.on("beforeCreate", this.options.onBeforeCreate),
        this.emit("beforeCreate", {
            editor: this
        }),
        this.createView(),
        this.injectCSS(),
        this.on("create", this.options.onCreate),
        this.on("update", this.options.onUpdate),
        this.on("selectionUpdate", this.options.onSelectionUpdate),
        this.on("transaction", this.options.onTransaction),
        this.on("focus", this.options.onFocus),
        this.on("blur", this.options.onBlur),
        this.on("destroy", this.options.onDestroy),
        window.setTimeout( () => {
            this.isDestroyed || (this.commands.focus(this.options.autofocus),
            this.emit("create", {
                editor: this
            }))
        }
        , 0)
    }
    get storage() {
        return this.extensionStorage
    }
    get commands() {
        return this.commandManager.commands
    }
    chain() {
        return this.commandManager.chain()
    }
    can() {
        return this.commandManager.can()
    }
    injectCSS() {
        this.options.injectCSS && document && (this.css = IK(VK, this.options.injectNonce))
    }
    setOptions(e={}) {
        this.options = {
            ...this.options,
            ...e
        },
        !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state))
    }
    setEditable(e, n=!0) {
        this.setOptions({
            editable: e
        }),
        n && this.emit("update", {
            editor: this,
            transaction: this.state.tr
        })
    }
    get isEditable() {
        return this.options.editable && this.view && this.view.editable
    }
    get state() {
        return this.view.state
    }
    registerPlugin(e, n) {
        const r = Ox(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e]
          , a = this.state.reconfigure({
            plugins: r
        });
        this.view.updateState(a)
    }
    unregisterPlugin(e) {
        if (this.isDestroyed)
            return;
        const n = typeof e == "string" ? `${e}$` : e.key
          , r = this.state.reconfigure({
            plugins: this.state.plugins.filter(a => !a.key.startsWith(n))
        });
        this.view.updateState(r)
    }
    createExtensionManager() {
        var e, n;
        const a = [...this.options.enableCoreExtensions ? [DK, p7.configure({
            blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
        }), NK, PK, FK, BK] : [], ...this.options.extensions].filter(s => ["extension", "node", "mark"].includes(s == null ? void 0 : s.type));
        this.extensionManager = new Hl(a,this)
    }
    createCommandManager() {
        this.commandManager = new kc({
            editor: this
        })
    }
    createSchema() {
        this.schema = this.extensionManager.schema
    }
    createView() {
        const e = Vx(this.options.content, this.schema, this.options.parseOptions)
          , n = Fx(e, this.options.autofocus);
        this.view = new gH(this.options.element,{
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: Ul.create({
                doc: e,
                selection: n || void 0
            })
        });
        const r = this.state.reconfigure({
            plugins: this.extensionManager.plugins
        });
        this.view.updateState(r),
        this.createNodeViews(),
        this.prependClass();
        const a = this.view.dom;
        a.editor = this
    }
    createNodeViews() {
        this.view.setProps({
            nodeViews: this.extensionManager.nodeViews
        })
    }
    prependClass() {
        this.view.dom.className = `tiptap ${this.view.dom.className}`
    }
    captureTransaction(e) {
        this.isCapturingTransaction = !0,
        e(),
        this.isCapturingTransaction = !1;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null,
        n
    }
    dispatchTransaction(e) {
        if (this.view.isDestroyed)
            return;
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = e;
                return
            }
            e.steps.forEach(l => {
                var i;
                return (i = this.capturedTransaction) === null || i === void 0 ? void 0 : i.step(l)
            }
            );
            return
        }
        const n = this.state.apply(e)
          , r = !this.state.selection.eq(n.selection);
        this.view.updateState(n),
        this.emit("transaction", {
            editor: this,
            transaction: e
        }),
        r && this.emit("selectionUpdate", {
            editor: this,
            transaction: e
        });
        const a = e.getMeta("focus")
          , s = e.getMeta("blur");
        a && this.emit("focus", {
            editor: this,
            event: a.event,
            transaction: e
        }),
        s && this.emit("blur", {
            editor: this,
            event: s.event,
            transaction: e
        }),
        !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
            editor: this,
            transaction: e
        })
    }
    getAttributes(e) {
        return uK(this.state, e)
    }
    isActive(e, n) {
        const r = typeof e == "string" ? e : null
          , a = typeof e == "string" ? n : e;
        return dK(this.state, r, a)
    }
    getJSON() {
        return this.state.doc.toJSON()
    }
    getHTML() {
        return lK(this.state.doc.content, this.schema)
    }
    getText(e) {
        const {blockSeparator: n=`

`, textSerializers: r={}} = e || {};
        return iK(this.state.doc, {
            blockSeparator: n,
            textSerializers: {
                ...Dx(this.schema),
                ...r
            }
        })
    }
    get isEmpty() {
        return cK(this.state.doc)
    }
    getCharacterCount() {
        return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'),
        this.state.doc.content.size - 2
    }
    destroy() {
        this.emit("destroy"),
        this.view && this.view.destroy(),
        this.removeAllListeners()
    }
    get isDestroyed() {
        var e;
        return !(!((e = this.view) === null || e === void 0) && e.docView)
    }
    $node(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, n)) || null
    }
    $nodes(e, n) {
        var r;
        return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, n)) || null
    }
    $pos(e) {
        const n = this.state.doc.resolve(e);
        return new Rs(n,this)
    }
    get $doc() {
        return this.$pos(0)
    }
}
;
function mi(t) {
    return new wc({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const a = at(t.getAttributes, void 0, r);
            if (a === !1 || a === null)
                return null;
            const {tr: s} = e
              , l = r[r.length - 1]
              , i = r[0];
            if (l) {
                const o = i.search(/\S/)
                  , u = n.from + i.indexOf(l)
                  , d = u + l.length;
                if (Ix(n.from, n.to, e.doc).filter(h => h.mark.type.excluded.find(y => y === t.type && y !== h.mark.type)).filter(h => h.to > u).length)
                    return null;
                d < n.to && s.delete(d, n.to),
                u > n.from && s.delete(n.from + o, u);
                const p = n.from + o + l.length;
                s.addMark(n.from + o, p, t.type.create(a || {})),
                s.removeStoredMark(t.type)
            }
        }
    })
}
function LK(t) {
    return new wc({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const a = at(t.getAttributes, void 0, r) || {}
              , {tr: s} = e
              , l = n.from;
            let i = n.to;
            const o = t.type.create(a);
            if (r[1]) {
                const u = r[0].lastIndexOf(r[1]);
                let d = l + u;
                d > i ? d = i : i = d + r[1].length;
                const f = r[0][r[0].length - 1];
                s.insertText(f, l + r[0].length - 1),
                s.replaceWith(d, i, o)
            } else
                r[0] && s.insert(l - 1, t.type.create(a)).delete(s.mapping.map(l), s.mapping.map(i));
            s.scrollIntoView()
        }
    })
}
function ch(t) {
    return new wc({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const a = e.doc.resolve(n.from)
              , s = at(t.getAttributes, void 0, r) || {};
            if (!a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), t.type))
                return null;
            e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, s)
        }
    })
}
function Fo(t) {
    return new wc({
        find: t.find,
        handler: ({state: e, range: n, match: r, chain: a}) => {
            const s = at(t.getAttributes, void 0, r) || {}
              , l = e.tr.delete(n.from, n.to)
              , o = l.doc.resolve(n.from).blockRange()
              , u = o && Vm(o, t.type, s);
            if (!u)
                return null;
            if (l.wrap(o, u),
            t.keepMarks && t.editor) {
                const {selection: f, storedMarks: p} = e
                  , {splittableMarks: h} = t.editor.extensionManager
                  , v = p || f.$to.parentOffset && f.$from.marks();
                if (v) {
                    const y = v.filter(k => h.includes(k.type.name));
                    l.ensureMarks(y)
                }
            }
            if (t.keepAttributes) {
                const f = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
                a().updateAttributes(f, s).run()
            }
            const d = l.doc.resolve(n.from - 1).nodeBefore;
            d && d.type === t.type && Ts(l.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, d)) && l.join(n.from - 1)
        }
    })
}
class da {
    constructor(e={}) {
        this.type = "mark",
        this.name = "mark",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...e
        },
        this.name = this.config.name,
        e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = at(He(this, "addOptions", {
            name: this.name
        }))),
        this.storage = at(He(this, "addStorage", {
            name: this.name,
            options: this.options
        })) || {}
    }
    static create(e={}) {
        return new da(e)
    }
    configure(e={}) {
        const n = this.extend();
        return n.options = xc(this.options, e),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
    extend(e={}) {
        const n = new da({
            ...this.config,
            ...e
        });
        return n.parent = this,
        this.child = n,
        n.name = e.name ? e.name : n.parent.name,
        e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = at(He(n, "addOptions", {
            name: n.name
        })),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
    static handleExit({editor: e, mark: n}) {
        const {tr: r} = e.state
          , a = e.state.selection.$from;
        if (a.pos === a.end()) {
            const l = a.marks();
            if (!!!l.find(u => (u == null ? void 0 : u.type.name) === n.name))
                return !1;
            const o = l.find(u => (u == null ? void 0 : u.type.name) === n.name);
            return o && r.removeStoredMark(o),
            r.insertText(" ", a.pos),
            e.view.dispatch(r),
            !0
        }
        return !1
    }
}
let dr = class fh {
    constructor(e={}) {
        this.type = "node",
        this.name = "node",
        this.parent = null,
        this.child = null,
        this.config = {
            name: this.name,
            defaultOptions: {}
        },
        this.config = {
            ...this.config,
            ...e
        },
        this.name = this.config.name,
        e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`),
        this.options = this.config.defaultOptions,
        this.config.addOptions && (this.options = at(He(this, "addOptions", {
            name: this.name
        }))),
        this.storage = at(He(this, "addStorage", {
            name: this.name,
            options: this.options
        })) || {}
    }
    static create(e={}) {
        return new fh(e)
    }
    configure(e={}) {
        const n = this.extend();
        return n.options = xc(this.options, e),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
    extend(e={}) {
        const n = new fh({
            ...this.config,
            ...e
        });
        return n.parent = this,
        this.child = n,
        n.name = e.name ? e.name : n.parent.name,
        e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`),
        n.options = at(He(n, "addOptions", {
            name: n.name
        })),
        n.storage = at(He(n, "addStorage", {
            name: n.name,
            options: n.options
        })),
        n
    }
}
;
function vi(t) {
    return new l7({
        find: t.find,
        handler: ({state: e, range: n, match: r, pasteEvent: a}) => {
            const s = at(t.getAttributes, void 0, r, a);
            if (s === !1 || s === null)
                return null;
            const {tr: l} = e
              , i = r[r.length - 1]
              , o = r[0];
            let u = n.to;
            if (i) {
                const d = o.search(/\S/)
                  , f = n.from + o.indexOf(i)
                  , p = f + i.length;
                if (Ix(n.from, n.to, e.doc).filter(v => v.mark.type.excluded.find(k => k === t.type && k !== v.mark.type)).filter(v => v.to > f).length)
                    return null;
                p < n.to && l.delete(p, n.to),
                f > n.from && l.delete(n.from + d, f),
                u = n.from + d + i.length,
                l.addMark(n.from + d, u, t.type.create(s || {})),
                l.removeStoredMark(t.type)
            }
        }
    })
}
function Z0(t) {
    return l1( (e, n) => ({
        get() {
            return e(),
            t
        },
        set(r) {
            t = r,
            requestAnimationFrame( () => {
                requestAnimationFrame( () => {
                    n()
                }
                )
            }
            )
        }
    }))
}
class Rx extends RK {
    constructor(e={}) {
        return super(e),
        this.vueRenderers = Fn(new Map),
        this.contentComponent = null,
        this.reactiveState = Z0(this.view.state),
        this.reactiveExtensionStorage = Z0(this.extensionStorage),
        this.on("transaction", () => {
            this.reactiveState.value = this.view.state,
            this.reactiveExtensionStorage.value = this.extensionStorage
        }
        ),
        Ld(this)
    }
    get state() {
        return this.reactiveState ? this.reactiveState.value : this.view.state
    }
    get storage() {
        return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage
    }
    registerPlugin(e, n) {
        super.registerPlugin(e, n),
        this.reactiveState.value = this.view.state
    }
    unregisterPlugin(e) {
        super.unregisterPlugin(e),
        this.reactiveState.value = this.view.state
    }
}
const Lx = Se({
    name: "EditorContent",
    props: {
        editor: {
            default: null,
            type: Object
        }
    },
    setup(t) {
        const e = me()
          , n = pl();
        return Si( () => {
            const r = t.editor;
            r && r.options.element && e.value && Ot( () => {
                if (!e.value || !r.options.element.firstChild)
                    return;
                const a = A(e.value);
                e.value.append(...r.options.element.childNodes),
                r.contentComponent = n.ctx._,
                r.setOptions({
                    element: a
                }),
                r.createNodeViews()
            }
            )
        }
        ),
        $i( () => {
            const r = t.editor;
            if (!r || (r.isDestroyed || r.view.setProps({
                nodeViews: {}
            }),
            r.contentComponent = null,
            !r.options.element.firstChild))
                return;
            const a = document.createElement("div");
            a.append(...r.options.element.childNodes),
            r.setOptions({
                element: a
            })
        }
        ),
        {
            rootEl: e
        }
    },
    render() {
        const t = [];
        return this.editor && this.editor.vueRenderers.forEach(e => {
            const n = st(Ti, {
                to: e.teleportElement,
                key: e.id
            }, st(e.component, {
                ref: e.id,
                ...e.props
            }));
            t.push(n)
        }
        ),
        st("div", {
            ref: e => {
                this.rootEl = e
            }
        }, ...t)
    }
})
  , jK = /^\s*>\s$/
  , UK = dr.create({
    name: "blockquote",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
        return [{
            tag: "blockquote"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["blockquote", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setBlockquote: () => ({commands: t}) => t.wrapIn(this.name),
            toggleBlockquote: () => ({commands: t}) => t.toggleWrap(this.name),
            unsetBlockquote: () => ({commands: t}) => t.lift(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        }
    },
    addInputRules() {
        return [Fo({
            find: jK,
            type: this.type
        })]
    }
})
  , HK = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/
  , KK = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g
  , zK = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/
  , qK = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g
  , WK = da.create({
    name: "bold",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "strong"
        }, {
            tag: "b",
            getAttrs: t => t.style.fontWeight !== "normal" && null
        }, {
            style: "font-weight",
            getAttrs: t => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["strong", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setBold: () => ({commands: t}) => t.setMark(this.name),
            toggleBold: () => ({commands: t}) => t.toggleMark(this.name),
            unsetBold: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-b": () => this.editor.commands.toggleBold(),
            "Mod-B": () => this.editor.commands.toggleBold()
        }
    },
    addInputRules() {
        return [mi({
            find: HK,
            type: this.type
        }), mi({
            find: zK,
            type: this.type
        })]
    },
    addPasteRules() {
        return [vi({
            find: KK,
            type: this.type
        }), vi({
            find: qK,
            type: this.type
        })]
    }
})
  , GK = dr.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
            tag: "li"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["li", pn(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
})
  , ey = da.create({
    name: "textStyle",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "span",
            getAttrs: t => t.hasAttribute("style") ? {} : !1
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["span", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            removeEmptyTextStyle: () => ({state: t, commands: e}) => {
                const n = $c(t, this.type);
                return Object.entries(n).some( ([,a]) => !!a) ? !0 : e.unsetMark(this.name)
            }
        }
    }
})
  , ty = /^\s*([-+*])\s$/
  , YK = dr.create({
    name: "bulletList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    parseHTML() {
        return [{
            tag: "ul"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["ul", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            toggleBulletList: () => ({commands: t, chain: e}) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(GK.name, this.editor.getAttributes(ey.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        }
    },
    addInputRules() {
        let t = Fo({
            find: ty,
            type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t = Fo({
            find: ty,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(ey.name),
            editor: this.editor
        })),
        [t]
    }
})
  , JK = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/
  , XK = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g
  , QK = da.create({
    name: "code",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
        return [{
            tag: "code"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["code", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setCode: () => ({commands: t}) => t.setMark(this.name),
            toggleCode: () => ({commands: t}) => t.toggleMark(this.name),
            unsetCode: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-e": () => this.editor.commands.toggleCode()
        }
    },
    addInputRules() {
        return [mi({
            find: JK,
            type: this.type
        })]
    },
    addPasteRules() {
        return [vi({
            find: XK,
            type: this.type
        })]
    }
})
  , ZK = /^```([a-z]+)?[\s\n]$/
  , ez = /^~~~([a-z]+)?[\s\n]$/
  , tz = dr.create({
    name: "codeBlock",
    addOptions() {
        return {
            languageClassPrefix: "language-",
            exitOnTripleEnter: !0,
            exitOnArrowDown: !0,
            HTMLAttributes: {}
        }
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
        return {
            language: {
                default: null,
                parseHTML: t => {
                    var e;
                    const {languageClassPrefix: n} = this.options
                      , s = [...((e = t.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(l => l.startsWith(n)).map(l => l.replace(n, ""))[0];
                    return s || null
                }
                ,
                rendered: !1
            }
        }
    },
    parseHTML() {
        return [{
            tag: "pre",
            preserveWhitespace: "full"
        }]
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        return ["pre", pn(this.options.HTMLAttributes, e), ["code", {
            class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        }, 0]]
    },
    addCommands() {
        return {
            setCodeBlock: t => ({commands: e}) => e.setNode(this.name, t),
            toggleCodeBlock: t => ({commands: e}) => e.toggleNode(this.name, "paragraph", t)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
            Backspace: () => {
                const {empty: t, $anchor: e} = this.editor.state.selection
                  , n = e.pos === 1;
                return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1
            }
            ,
            Enter: ({editor: t}) => {
                if (!this.options.exitOnTripleEnter)
                    return !1;
                const {state: e} = t
                  , {selection: n} = e
                  , {$from: r, empty: a} = n;
                if (!a || r.parent.type !== this.type)
                    return !1;
                const s = r.parentOffset === r.parent.nodeSize - 2
                  , l = r.parent.textContent.endsWith(`

`);
                return !s || !l ? !1 : t.chain().command( ({tr: i}) => (i.delete(r.pos - 2, r.pos),
                !0)).exitCode().run()
            }
            ,
            ArrowDown: ({editor: t}) => {
                if (!this.options.exitOnArrowDown)
                    return !1;
                const {state: e} = t
                  , {selection: n, doc: r} = e
                  , {$from: a, empty: s} = n;
                if (!s || a.parent.type !== this.type || !(a.parentOffset === a.parent.nodeSize - 2))
                    return !1;
                const i = a.after();
                return i === void 0 || r.nodeAt(i) ? !1 : t.commands.exitCode()
            }
        }
    },
    addInputRules() {
        return [ch({
            find: ZK,
            type: this.type,
            getAttributes: t => ({
                language: t[1]
            })
        }), ch({
            find: ez,
            type: this.type,
            getAttributes: t => ({
                language: t[1]
            })
        })]
    },
    addProseMirrorPlugins() {
        return [new $r({
            key: new Cs("codeBlockVSCodeHandler"),
            props: {
                handlePaste: (t, e) => {
                    if (!e.clipboardData || this.editor.isActive(this.type.name))
                        return !1;
                    const n = e.clipboardData.getData("text/plain")
                      , r = e.clipboardData.getData("vscode-editor-data")
                      , a = r ? JSON.parse(r) : void 0
                      , s = a == null ? void 0 : a.mode;
                    if (!n || !s)
                        return !1;
                    const {tr: l} = t.state;
                    return l.replaceSelectionWith(this.type.create({
                        language: s
                    })),
                    l.setSelection(nt.near(l.doc.resolve(Math.max(0, l.selection.from - 2)))),
                    l.insertText(n.replace(/\r\n?/g, `
`)),
                    l.setMeta("paste", !0),
                    t.dispatch(l),
                    !0
                }
            }
        })]
    }
})
  , nz = dr.create({
    name: "doc",
    topNode: !0,
    content: "block+"
});
function rz(t={}) {
    return new $r({
        view(e) {
            return new az(e,t)
        }
    })
}
class az {
    constructor(e, n) {
        var r;
        this.editorView = e,
        this.cursorPos = null,
        this.element = null,
        this.timeout = -1,
        this.width = (r = n.width) !== null && r !== void 0 ? r : 1,
        this.color = n.color === !1 ? void 0 : n.color || "black",
        this.class = n.class,
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(a => {
            let s = l => {
                this[a](l)
            }
            ;
            return e.dom.addEventListener(a, s),
            {
                name: a,
                handler: s
            }
        }
        )
    }
    destroy() {
        this.handlers.forEach( ({name: e, handler: n}) => this.editorView.dom.removeEventListener(e, n))
    }
    update(e, n) {
        this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
    }
    setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e,
        e == null ? (this.element.parentNode.removeChild(this.element),
        this.element = null) : this.updateOverlay())
    }
    updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r;
        if (n) {
            let i = e.nodeBefore
              , o = e.nodeAfter;
            if (i || o) {
                let u = this.editorView.nodeDOM(this.cursorPos - (i ? i.nodeSize : 0));
                if (u) {
                    let d = u.getBoundingClientRect()
                      , f = i ? d.bottom : d.top;
                    i && o && (f = (f + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2),
                    r = {
                        left: d.left,
                        right: d.right,
                        top: f - this.width / 2,
                        bottom: f + this.width / 2
                    }
                }
            }
        }
        if (!r) {
            let i = this.editorView.coordsAtPos(this.cursorPos);
            r = {
                left: i.left - this.width / 2,
                right: i.left + this.width / 2,
                top: i.top,
                bottom: i.bottom
            }
        }
        let a = this.editorView.dom.offsetParent;
        this.element || (this.element = a.appendChild(document.createElement("div")),
        this.class && (this.element.className = this.class),
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;",
        this.color && (this.element.style.backgroundColor = this.color)),
        this.element.classList.toggle("prosemirror-dropcursor-block", n),
        this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let s, l;
        if (!a || a == document.body && getComputedStyle(a).position == "static")
            s = -pageXOffset,
            l = -pageYOffset;
        else {
            let i = a.getBoundingClientRect();
            s = i.left - a.scrollLeft,
            l = i.top - a.scrollTop
        }
        this.element.style.left = r.left - s + "px",
        this.element.style.top = r.top - l + "px",
        this.element.style.width = r.right - r.left + "px",
        this.element.style.height = r.bottom - r.top + "px"
    }
    scheduleRemoval(e) {
        clearTimeout(this.timeout),
        this.timeout = setTimeout( () => this.setCursor(null), e)
    }
    dragover(e) {
        if (!this.editorView.editable)
            return;
        let n = this.editorView.posAtCoords({
            left: e.clientX,
            top: e.clientY
        })
          , r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside)
          , a = r && r.type.spec.disableDropCursor
          , s = typeof a == "function" ? a(this.editorView, n, e) : a;
        if (n && !s) {
            let l = n.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                let i = Vw(this.editorView.state.doc, l, this.editorView.dragging.slice);
                i != null && (l = i)
            }
            this.setCursor(l),
            this.scheduleRemoval(5e3)
        }
    }
    dragend() {
        this.scheduleRemoval(20)
    }
    drop() {
        this.scheduleRemoval(20)
    }
    dragleave(e) {
        (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null)
    }
}
const sz = ir.create({
    name: "dropCursor",
    addOptions() {
        return {
            color: "currentColor",
            width: 1,
            class: void 0
        }
    },
    addProseMirrorPlugins() {
        return [rz(this.options)]
    }
});
class Xt extends lt {
    constructor(e) {
        super(e, e)
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        return Xt.valid(r) ? new Xt(r) : lt.near(r)
    }
    content() {
        return Ie.empty
    }
    eq(e) {
        return e instanceof Xt && e.head == this.head
    }
    toJSON() {
        return {
            type: "gapcursor",
            pos: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new Xt(e.resolve(n.pos))
    }
    getBookmark() {
        return new ev(this.anchor)
    }
    static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !lz(e) || !iz(e))
            return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
            return r;
        let a = n.contentMatchAt(e.index()).defaultType;
        return a && a.isTextblock
    }
    static findGapCursorFrom(e, n, r=!1) {
        e: for (; ; ) {
            if (!r && Xt.valid(e))
                return e;
            let a = e.pos
              , s = null;
            for (let l = e.depth; ; l--) {
                let i = e.node(l);
                if (n > 0 ? e.indexAfter(l) < i.childCount : e.index(l) > 0) {
                    s = i.child(n > 0 ? e.indexAfter(l) : e.index(l) - 1);
                    break
                } else if (l == 0)
                    return null;
                a += n;
                let o = e.doc.resolve(a);
                if (Xt.valid(o))
                    return o
            }
            for (; ; ) {
                let l = n > 0 ? s.firstChild : s.lastChild;
                if (!l) {
                    if (s.isAtom && !s.isText && !Ze.isSelectable(s)) {
                        e = e.doc.resolve(a + s.nodeSize * n),
                        r = !1;
                        continue e
                    }
                    break
                }
                s = l,
                a += n;
                let i = e.doc.resolve(a);
                if (Xt.valid(i))
                    return i
            }
            return null
        }
    }
}
Xt.prototype.visible = !1;
Xt.findFrom = Xt.findGapCursorFrom;
lt.jsonID("gapcursor", Xt);
class ev {
    constructor(e) {
        this.pos = e
    }
    map(e) {
        return new ev(e.map(this.pos))
    }
    resolve(e) {
        let n = e.resolve(this.pos);
        return Xt.valid(n) ? new Xt(n) : lt.near(n)
    }
}
function lz(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.index(e)
          , r = t.node(e);
        if (n == 0) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let a = r.child(n - 1); ; a = a.lastChild) {
            if (a.childCount == 0 && !a.inlineContent || a.isAtom || a.type.spec.isolating)
                return !0;
            if (a.inlineContent)
                return !1
        }
    }
    return !0
}
function iz(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.indexAfter(e)
          , r = t.node(e);
        if (n == r.childCount) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let a = r.child(n); ; a = a.firstChild) {
            if (a.childCount == 0 && !a.inlineContent || a.isAtom || a.type.spec.isolating)
                return !0;
            if (a.inlineContent)
                return !1
        }
    }
    return !0
}
function oz() {
    return new $r({
        props: {
            decorations: fz,
            createSelectionBetween(t, e, n) {
                return e.pos == n.pos && Xt.valid(n) ? new Xt(n) : null
            },
            handleClick: dz,
            handleKeyDown: uz,
            handleDOMEvents: {
                beforeinput: cz
            }
        }
    })
}
const uz = xx({
    ArrowLeft: xu("horiz", -1),
    ArrowRight: xu("horiz", 1),
    ArrowUp: xu("vert", -1),
    ArrowDown: xu("vert", 1)
});
function xu(t, e) {
    const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
    return function(r, a, s) {
        let l = r.selection
          , i = e > 0 ? l.$to : l.$from
          , o = l.empty;
        if (l instanceof nt) {
            if (!s.endOfTextblock(n) || i.depth == 0)
                return !1;
            o = !1,
            i = r.doc.resolve(e > 0 ? i.after() : i.before())
        }
        let u = Xt.findGapCursorFrom(i, e, o);
        return u ? (a && a(r.tr.setSelection(new Xt(u))),
        !0) : !1
    }
}
function dz(t, e, n) {
    if (!t || !t.editable)
        return !1;
    let r = t.state.doc.resolve(e);
    if (!Xt.valid(r))
        return !1;
    let a = t.posAtCoords({
        left: n.clientX,
        top: n.clientY
    });
    return a && a.inside > -1 && Ze.isSelectable(t.state.doc.nodeAt(a.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new Xt(r))),
    !0)
}
function cz(t, e) {
    if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof Xt))
        return !1;
    let {$from: n} = t.state.selection
      , r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
    if (!r)
        return !1;
    let a = Ae.empty;
    for (let l = r.length - 1; l >= 0; l--)
        a = Ae.from(r[l].createAndFill(null, a));
    let s = t.state.tr.replace(n.pos, n.pos, new Ie(a,0,0));
    return s.setSelection(nt.near(s.doc.resolve(n.pos + 1))),
    t.dispatch(s),
    !1
}
function fz(t) {
    if (!(t.selection instanceof Xt))
        return null;
    let e = document.createElement("div");
    return e.className = "ProseMirror-gapcursor",
    cn.create(t.doc, [vr.widget(t.selection.head, e, {
        key: "gapcursor"
    })])
}
const pz = ir.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
        return [oz()]
    },
    extendNodeSchema(t) {
        var e;
        const n = {
            name: t.name,
            options: t.options,
            storage: t.storage
        };
        return {
            allowGapCursor: (e = at(He(t, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
        }
    }
})
  , hz = dr.create({
    name: "hardBreak",
    addOptions() {
        return {
            keepMarks: !0,
            HTMLAttributes: {}
        }
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    parseHTML() {
        return [{
            tag: "br"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["br", pn(this.options.HTMLAttributes, t)]
    },
    renderText() {
        return `
`
    },
    addCommands() {
        return {
            setHardBreak: () => ({commands: t, chain: e, state: n, editor: r}) => t.first([ () => t.exitCode(), () => t.command( () => {
                const {selection: a, storedMarks: s} = n;
                if (a.$from.parent.type.spec.isolating)
                    return !1;
                const {keepMarks: l} = this.options
                  , {splittableMarks: i} = r.extensionManager
                  , o = s || a.$to.parentOffset && a.$from.marks();
                return e().insertContent({
                    type: this.name
                }).command( ({tr: u, dispatch: d}) => {
                    if (d && o && l) {
                        const f = o.filter(p => i.includes(p.type.name));
                        u.ensureMarks(f)
                    }
                    return !0
                }
                ).run()
            }
            )])
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Enter": () => this.editor.commands.setHardBreak(),
            "Shift-Enter": () => this.editor.commands.setHardBreak()
        }
    }
})
  , mz = dr.create({
    name: "heading",
    addOptions() {
        return {
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {}
        }
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
        return {
            level: {
                default: 1,
                rendered: !1
            }
        }
    },
    parseHTML() {
        return this.options.levels.map(t => ({
            tag: `h${t}`,
            attrs: {
                level: t
            }
        }))
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, pn(this.options.HTMLAttributes, e), 0]
    },
    addCommands() {
        return {
            setHeading: t => ({commands: e}) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
            toggleHeading: t => ({commands: e}) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
        }
    },
    addKeyboardShortcuts() {
        return this.options.levels.reduce( (t, e) => ({
            ...t,
            [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({
                level: e
            })
        }), {})
    },
    addInputRules() {
        return this.options.levels.map(t => ch({
            find: new RegExp(`^(#{1,${t}})\\s$`),
            type: this.type,
            getAttributes: {
                level: t
            }
        }))
    }
});
var yd = 200
  , yn = function() {};
yn.prototype.append = function(e) {
    return e.length ? (e = yn.from(e),
    !this.length && e || e.length < yd && this.leafAppend(e) || this.length < yd && e.leafPrepend(this) || this.appendInner(e)) : this
}
;
yn.prototype.prepend = function(e) {
    return e.length ? yn.from(e).append(this) : this
}
;
yn.prototype.appendInner = function(e) {
    return new vz(this,e)
}
;
yn.prototype.slice = function(e, n) {
    return e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n ? yn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
}
;
yn.prototype.get = function(e) {
    if (!(e < 0 || e >= this.length))
        return this.getInner(e)
}
;
yn.prototype.forEach = function(e, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0)
}
;
yn.prototype.map = function(e, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length);
    var a = [];
    return this.forEach(function(s, l) {
        return a.push(e(s, l))
    }, n, r),
    a
}
;
yn.from = function(e) {
    return e instanceof yn ? e : e && e.length ? new jx(e) : yn.empty
}
;
var jx = function(t) {
    function e(r) {
        t.call(this),
        this.values = r
    }
    t && (e.__proto__ = t),
    e.prototype = Object.create(t && t.prototype),
    e.prototype.constructor = e;
    var n = {
        length: {
            configurable: !0
        },
        depth: {
            configurable: !0
        }
    };
    return e.prototype.flatten = function() {
        return this.values
    }
    ,
    e.prototype.sliceInner = function(a, s) {
        return a == 0 && s == this.length ? this : new e(this.values.slice(a, s))
    }
    ,
    e.prototype.getInner = function(a) {
        return this.values[a]
    }
    ,
    e.prototype.forEachInner = function(a, s, l, i) {
        for (var o = s; o < l; o++)
            if (a(this.values[o], i + o) === !1)
                return !1
    }
    ,
    e.prototype.forEachInvertedInner = function(a, s, l, i) {
        for (var o = s - 1; o >= l; o--)
            if (a(this.values[o], i + o) === !1)
                return !1
    }
    ,
    e.prototype.leafAppend = function(a) {
        if (this.length + a.length <= yd)
            return new e(this.values.concat(a.flatten()))
    }
    ,
    e.prototype.leafPrepend = function(a) {
        if (this.length + a.length <= yd)
            return new e(a.flatten().concat(this.values))
    }
    ,
    n.length.get = function() {
        return this.values.length
    }
    ,
    n.depth.get = function() {
        return 0
    }
    ,
    Object.defineProperties(e.prototype, n),
    e
}(yn);
yn.empty = new jx([]);
var vz = function(t) {
    function e(n, r) {
        t.call(this),
        this.left = n,
        this.right = r,
        this.length = n.length + r.length,
        this.depth = Math.max(n.depth, r.depth) + 1
    }
    return t && (e.__proto__ = t),
    e.prototype = Object.create(t && t.prototype),
    e.prototype.constructor = e,
    e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten())
    }
    ,
    e.prototype.getInner = function(r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    }
    ,
    e.prototype.forEachInner = function(r, a, s, l) {
        var i = this.left.length;
        if (a < i && this.left.forEachInner(r, a, Math.min(s, i), l) === !1 || s > i && this.right.forEachInner(r, Math.max(a - i, 0), Math.min(this.length, s) - i, l + i) === !1)
            return !1
    }
    ,
    e.prototype.forEachInvertedInner = function(r, a, s, l) {
        var i = this.left.length;
        if (a > i && this.right.forEachInvertedInner(r, a - i, Math.max(s, i) - i, l + i) === !1 || s < i && this.left.forEachInvertedInner(r, Math.min(a, i), s, l) === !1)
            return !1
    }
    ,
    e.prototype.sliceInner = function(r, a) {
        if (r == 0 && a == this.length)
            return this;
        var s = this.left.length;
        return a <= s ? this.left.slice(r, a) : r >= s ? this.right.slice(r - s, a - s) : this.left.slice(r, s).append(this.right.slice(0, a - s))
    }
    ,
    e.prototype.leafAppend = function(r) {
        var a = this.right.leafAppend(r);
        if (a)
            return new e(this.left,a)
    }
    ,
    e.prototype.leafPrepend = function(r) {
        var a = this.left.leafPrepend(r);
        if (a)
            return new e(a,this.right)
    }
    ,
    e.prototype.appendInner = function(r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left,new e(this.right,r)) : new e(this,r)
    }
    ,
    e
}(yn);
const gz = 500;
class Ar {
    constructor(e, n) {
        this.items = e,
        this.eventCount = n
    }
    popEvent(e, n) {
        if (this.eventCount == 0)
            return null;
        let r = this.items.length;
        for (; ; r--)
            if (this.items.get(r - 1).selection) {
                --r;
                break
            }
        let a, s;
        n && (a = this.remapping(r, this.items.length),
        s = a.maps.length);
        let l = e.tr, i, o, u = [], d = [];
        return this.items.forEach( (f, p) => {
            if (!f.step) {
                a || (a = this.remapping(r, p + 1),
                s = a.maps.length),
                s--,
                d.push(f);
                return
            }
            if (a) {
                d.push(new qr(f.map));
                let h = f.step.map(a.slice(s)), v;
                h && l.maybeStep(h).doc && (v = l.mapping.maps[l.mapping.maps.length - 1],
                u.push(new qr(v,void 0,void 0,u.length + d.length))),
                s--,
                v && a.appendMap(v, s)
            } else
                l.maybeStep(f.step);
            if (f.selection)
                return i = a ? f.selection.map(a.slice(s)) : f.selection,
                o = new Ar(this.items.slice(0, r).append(d.reverse().concat(u)),this.eventCount - 1),
                !1
        }
        , this.items.length, 0),
        {
            remaining: o,
            transform: l,
            selection: i
        }
    }
    addTransform(e, n, r, a) {
        let s = []
          , l = this.eventCount
          , i = this.items
          , o = !a && i.length ? i.get(i.length - 1) : null;
        for (let d = 0; d < e.steps.length; d++) {
            let f = e.steps[d].invert(e.docs[d]), p = new qr(e.mapping.maps[d],f,n), h;
            (h = o && o.merge(p)) && (p = h,
            d ? s.pop() : i = i.slice(0, i.length - 1)),
            s.push(p),
            n && (l++,
            n = void 0),
            a || (o = p)
        }
        let u = l - r.depth;
        return u > yz && (i = bz(i, u),
        l -= u),
        new Ar(i.append(s),l)
    }
    remapping(e, n) {
        let r = new Xl;
        return this.items.forEach( (a, s) => {
            let l = a.mirrorOffset != null && s - a.mirrorOffset >= e ? r.maps.length - a.mirrorOffset : void 0;
            r.appendMap(a.map, l)
        }
        , e, n),
        r
    }
    addMaps(e) {
        return this.eventCount == 0 ? this : new Ar(this.items.append(e.map(n => new qr(n))),this.eventCount)
    }
    rebased(e, n) {
        if (!this.eventCount)
            return this;
        let r = []
          , a = Math.max(0, this.items.length - n)
          , s = e.mapping
          , l = e.steps.length
          , i = this.eventCount;
        this.items.forEach(p => {
            p.selection && i--
        }
        , a);
        let o = n;
        this.items.forEach(p => {
            let h = s.getMirror(--o);
            if (h == null)
                return;
            l = Math.min(l, h);
            let v = s.maps[h];
            if (p.step) {
                let y = e.steps[h].invert(e.docs[h])
                  , k = p.selection && p.selection.map(s.slice(o + 1, h));
                k && i++,
                r.push(new qr(v,y,k))
            } else
                r.push(new qr(v))
        }
        , a);
        let u = [];
        for (let p = n; p < l; p++)
            u.push(new qr(s.maps[p]));
        let d = this.items.slice(0, a).append(u).append(r)
          , f = new Ar(d,i);
        return f.emptyItemCount() > gz && (f = f.compress(this.items.length - r.length)),
        f
    }
    emptyItemCount() {
        let e = 0;
        return this.items.forEach(n => {
            n.step || e++
        }
        ),
        e
    }
    compress(e=this.items.length) {
        let n = this.remapping(0, e)
          , r = n.maps.length
          , a = []
          , s = 0;
        return this.items.forEach( (l, i) => {
            if (i >= e)
                a.push(l),
                l.selection && s++;
            else if (l.step) {
                let o = l.step.map(n.slice(r))
                  , u = o && o.getMap();
                if (r--,
                u && n.appendMap(u, r),
                o) {
                    let d = l.selection && l.selection.map(n.slice(r));
                    d && s++;
                    let f = new qr(u.invert(),o,d), p, h = a.length - 1;
                    (p = a.length && a[h].merge(f)) ? a[h] = p : a.push(f)
                }
            } else
                l.map && r--
        }
        , this.items.length, 0),
        new Ar(yn.from(a.reverse()),s)
    }
}
Ar.empty = new Ar(yn.empty,0);
function bz(t, e) {
    let n;
    return t.forEach( (r, a) => {
        if (r.selection && e-- == 0)
            return n = a,
            !1
    }
    ),
    t.slice(n)
}
class qr {
    constructor(e, n, r, a) {
        this.map = e,
        this.step = n,
        this.selection = r,
        this.mirrorOffset = a
    }
    merge(e) {
        if (this.step && e.step && !e.selection) {
            let n = e.step.merge(this.step);
            if (n)
                return new qr(n.getMap().invert(),n,this.selection)
        }
    }
}
class Qa {
    constructor(e, n, r, a, s) {
        this.done = e,
        this.undone = n,
        this.prevRanges = r,
        this.prevTime = a,
        this.prevComposition = s
    }
}
const yz = 20;
function kz(t, e, n, r) {
    let a = n.getMeta(el), s;
    if (a)
        return a.historyState;
    n.getMeta(xz) && (t = new Qa(t.done,t.undone,null,0,-1));
    let l = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
        return t;
    if (l && l.getMeta(el))
        return l.getMeta(el).redo ? new Qa(t.done.addTransform(n, void 0, r, Iu(e)),t.undone,ny(n.mapping.maps[n.steps.length - 1]),t.prevTime,t.prevComposition) : new Qa(t.done,t.undone.addTransform(n, void 0, r, Iu(e)),null,t.prevTime,t.prevComposition);
    if (n.getMeta("addToHistory") !== !1 && !(l && l.getMeta("addToHistory") === !1)) {
        let i = n.getMeta("composition")
          , o = t.prevTime == 0 || !l && t.prevComposition != i && (t.prevTime < (n.time || 0) - r.newGroupDelay || !_z(n, t.prevRanges))
          , u = l ? If(t.prevRanges, n.mapping) : ny(n.mapping.maps[n.steps.length - 1]);
        return new Qa(t.done.addTransform(n, o ? e.selection.getBookmark() : void 0, r, Iu(e)),Ar.empty,u,n.time,i ?? t.prevComposition)
    } else
        return (s = n.getMeta("rebased")) ? new Qa(t.done.rebased(n, s),t.undone.rebased(n, s),If(t.prevRanges, n.mapping),t.prevTime,t.prevComposition) : new Qa(t.done.addMaps(n.mapping.maps),t.undone.addMaps(n.mapping.maps),If(t.prevRanges, n.mapping),t.prevTime,t.prevComposition)
}
function _z(t, e) {
    if (!e)
        return !1;
    if (!t.docChanged)
        return !0;
    let n = !1;
    return t.mapping.maps[0].forEach( (r, a) => {
        for (let s = 0; s < e.length; s += 2)
            r <= e[s + 1] && a >= e[s] && (n = !0)
    }
    ),
    n
}
function ny(t) {
    let e = [];
    return t.forEach( (n, r, a, s) => e.push(a, s)),
    e
}
function If(t, e) {
    if (!t)
        return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
        let a = e.map(t[r], 1)
          , s = e.map(t[r + 1], -1);
        a <= s && n.push(a, s)
    }
    return n
}
function wz(t, e, n) {
    let r = Iu(e)
      , a = el.get(e).spec.config
      , s = (n ? t.undone : t.done).popEvent(e, r);
    if (!s)
        return null;
    let l = s.selection.resolve(s.transform.doc)
      , i = (n ? t.done : t.undone).addTransform(s.transform, e.selection.getBookmark(), a, r)
      , o = new Qa(n ? i : s.remaining,n ? s.remaining : i,null,0,-1);
    return s.transform.setSelection(l).setMeta(el, {
        redo: n,
        historyState: o
    })
}
let Rf = !1
  , ry = null;
function Iu(t) {
    let e = t.plugins;
    if (ry != e) {
        Rf = !1,
        ry = e;
        for (let n = 0; n < e.length; n++)
            if (e[n].spec.historyPreserveItems) {
                Rf = !0;
                break
            }
    }
    return Rf
}
const el = new Cs("history")
  , xz = new Cs("closeHistory");
function Sz(t={}) {
    return t = {
        depth: t.depth || 100,
        newGroupDelay: t.newGroupDelay || 500
    },
    new $r({
        key: el,
        state: {
            init() {
                return new Qa(Ar.empty,Ar.empty,null,0,-1)
            },
            apply(e, n, r) {
                return kz(n, r, e, t)
            }
        },
        config: t,
        props: {
            handleDOMEvents: {
                beforeinput(e, n) {
                    let r = n.inputType
                      , a = r == "historyUndo" ? Hx : r == "historyRedo" ? Kx : null;
                    return a ? (n.preventDefault(),
                    a(e.state, e.dispatch)) : !1
                }
            }
        }
    })
}
function Ux(t, e) {
    return (n, r) => {
        let a = el.getState(n);
        if (!a || (t ? a.undone : a.done).eventCount == 0)
            return !1;
        if (r) {
            let s = wz(a, n, t);
            s && r(e ? s.scrollIntoView() : s)
        }
        return !0
    }
}
const Hx = Ux(!1, !0)
  , Kx = Ux(!0, !0)
  , $z = ir.create({
    name: "history",
    addOptions() {
        return {
            depth: 100,
            newGroupDelay: 500
        }
    },
    addCommands() {
        return {
            undo: () => ({state: t, dispatch: e}) => Hx(t, e),
            redo: () => ({state: t, dispatch: e}) => Kx(t, e)
        }
    },
    addProseMirrorPlugins() {
        return [Sz(this.options)]
    },
    addKeyboardShortcuts() {
        return {
            "Mod-z": () => this.editor.commands.undo(),
            "Shift-Mod-z": () => this.editor.commands.redo(),
            "Mod-y": () => this.editor.commands.redo(),
            "Mod-я": () => this.editor.commands.undo(),
            "Shift-Mod-я": () => this.editor.commands.redo()
        }
    }
})
  , Tz = dr.create({
    name: "horizontalRule",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    group: "block",
    parseHTML() {
        return [{
            tag: "hr"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["hr", pn(this.options.HTMLAttributes, t)]
    },
    addCommands() {
        return {
            setHorizontalRule: () => ({chain: t, state: e}) => {
                const {$to: n} = e.selection
                  , r = t();
                return n.parentOffset === 0 ? r.insertContentAt(Math.max(n.pos - 2, 0), {
                    type: this.name
                }) : r.insertContent({
                    type: this.name
                }),
                r.command( ({tr: a, dispatch: s}) => {
                    var l;
                    if (s) {
                        const {$to: i} = a.selection
                          , o = i.end();
                        if (i.nodeAfter)
                            i.nodeAfter.isTextblock ? a.setSelection(nt.create(a.doc, i.pos + 1)) : i.nodeAfter.isBlock ? a.setSelection(Ze.create(a.doc, i.pos)) : a.setSelection(nt.create(a.doc, i.pos));
                        else {
                            const u = (l = i.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
                            u && (a.insert(o, u),
                            a.setSelection(nt.create(a.doc, o + 1)))
                        }
                        a.scrollIntoView()
                    }
                    return !0
                }
                ).run()
            }
        }
    },
    addInputRules() {
        return [LK({
            find: /^(?:---|—-|___\s|\*\*\*\s)$/,
            type: this.type
        })]
    }
})
  , Cz = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/
  , Ez = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g
  , Az = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/
  , Mz = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g
  , Oz = da.create({
    name: "italic",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "em"
        }, {
            tag: "i",
            getAttrs: t => t.style.fontStyle !== "normal" && null
        }, {
            style: "font-style=italic"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["em", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setItalic: () => ({commands: t}) => t.setMark(this.name),
            toggleItalic: () => ({commands: t}) => t.toggleMark(this.name),
            unsetItalic: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-i": () => this.editor.commands.toggleItalic(),
            "Mod-I": () => this.editor.commands.toggleItalic()
        }
    },
    addInputRules() {
        return [mi({
            find: Cz,
            type: this.type
        }), mi({
            find: Az,
            type: this.type
        })]
    },
    addPasteRules() {
        return [vi({
            find: Ez,
            type: this.type
        }), vi({
            find: Mz,
            type: this.type
        })]
    }
})
  , Nz = dr.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
            tag: "li"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["li", pn(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
})
  , Dz = dr.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
            tag: "li"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["li", pn(this.options.HTMLAttributes, t), 0]
    },
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
})
  , ay = da.create({
    name: "textStyle",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "span",
            getAttrs: t => t.hasAttribute("style") ? {} : !1
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["span", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            removeEmptyTextStyle: () => ({state: t, commands: e}) => {
                const n = $c(t, this.type);
                return Object.entries(n).some( ([,a]) => !!a) ? !0 : e.unsetMark(this.name)
            }
        }
    }
})
  , sy = /^(\d+)\.\s$/
  , Pz = dr.create({
    name: "orderedList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    addAttributes() {
        return {
            start: {
                default: 1,
                parseHTML: t => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
            }
        }
    },
    parseHTML() {
        return [{
            tag: "ol"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        const {start: e, ...n} = t;
        return e === 1 ? ["ol", pn(this.options.HTMLAttributes, n), 0] : ["ol", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            toggleOrderedList: () => ({commands: t, chain: e}) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(Dz.name, this.editor.getAttributes(ay.name)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        }
    },
    addInputRules() {
        let t = Fo({
            find: sy,
            type: this.type,
            getAttributes: e => ({
                start: +e[1]
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t = Fo({
            find: sy,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: e => ({
                start: +e[1],
                ...this.editor.getAttributes(ay.name)
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            editor: this.editor
        })),
        [t]
    }
})
  , Fz = dr.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    group: "block",
    content: "inline*",
    parseHTML() {
        return [{
            tag: "p"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["p", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setParagraph: () => ({commands: t}) => t.setNode(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-0": () => this.editor.commands.setParagraph()
        }
    }
})
  , Bz = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/
  , Vz = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g
  , Iz = da.create({
    name: "strike",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "s"
        }, {
            tag: "del"
        }, {
            tag: "strike"
        }, {
            style: "text-decoration",
            consuming: !1,
            getAttrs: t => t.includes("line-through") ? {} : !1
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["s", pn(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setStrike: () => ({commands: t}) => t.setMark(this.name),
            toggleStrike: () => ({commands: t}) => t.toggleMark(this.name),
            unsetStrike: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        const t = {};
        return Qm() ? t["Mod-Shift-s"] = () => this.editor.commands.toggleStrike() : t["Ctrl-Shift-s"] = () => this.editor.commands.toggleStrike(),
        t
    },
    addInputRules() {
        return [mi({
            find: Bz,
            type: this.type
        })]
    },
    addPasteRules() {
        return [vi({
            find: Vz,
            type: this.type
        })]
    }
})
  , Rz = dr.create({
    name: "text",
    group: "inline"
})
  , zx = ir.create({
    name: "starterKit",
    addExtensions() {
        var t, e, n, r, a, s, l, i, o, u, d, f, p, h, v, y, k, w;
        const $ = [];
        return this.options.blockquote !== !1 && $.push(UK.configure((t = this.options) === null || t === void 0 ? void 0 : t.blockquote)),
        this.options.bold !== !1 && $.push(WK.configure((e = this.options) === null || e === void 0 ? void 0 : e.bold)),
        this.options.bulletList !== !1 && $.push(YK.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)),
        this.options.code !== !1 && $.push(QK.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)),
        this.options.codeBlock !== !1 && $.push(tz.configure((a = this.options) === null || a === void 0 ? void 0 : a.codeBlock)),
        this.options.document !== !1 && $.push(nz.configure((s = this.options) === null || s === void 0 ? void 0 : s.document)),
        this.options.dropcursor !== !1 && $.push(sz.configure((l = this.options) === null || l === void 0 ? void 0 : l.dropcursor)),
        this.options.gapcursor !== !1 && $.push(pz.configure((i = this.options) === null || i === void 0 ? void 0 : i.gapcursor)),
        this.options.hardBreak !== !1 && $.push(hz.configure((o = this.options) === null || o === void 0 ? void 0 : o.hardBreak)),
        this.options.heading !== !1 && $.push(mz.configure((u = this.options) === null || u === void 0 ? void 0 : u.heading)),
        this.options.history !== !1 && $.push($z.configure((d = this.options) === null || d === void 0 ? void 0 : d.history)),
        this.options.horizontalRule !== !1 && $.push(Tz.configure((f = this.options) === null || f === void 0 ? void 0 : f.horizontalRule)),
        this.options.italic !== !1 && $.push(Oz.configure((p = this.options) === null || p === void 0 ? void 0 : p.italic)),
        this.options.listItem !== !1 && $.push(Nz.configure((h = this.options) === null || h === void 0 ? void 0 : h.listItem)),
        this.options.orderedList !== !1 && $.push(Pz.configure((v = this.options) === null || v === void 0 ? void 0 : v.orderedList)),
        this.options.paragraph !== !1 && $.push(Fz.configure((y = this.options) === null || y === void 0 ? void 0 : y.paragraph)),
        this.options.strike !== !1 && $.push(Iz.configure((k = this.options) === null || k === void 0 ? void 0 : k.strike)),
        this.options.text !== !1 && $.push(Rz.configure((w = this.options) === null || w === void 0 ? void 0 : w.text)),
        $
    }
})
  , Lz = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , jz = c("path", {
    fill: "currentColor",
    d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4"
}, null, -1)
  , Uz = [jz];
function Hz(t, e) {
    return g(),
    _("svg", Lz, [...Uz])
}
const qx = {
    name: "bi-plus",
    render: Hz
}
  , Kz = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , zz = c("path", {
    fill: "currentColor",
    d: "M8.21 13c2.106 0 3.412-1.087 3.412-2.823c0-1.306-.984-2.283-2.324-2.386v-.055a2.176 2.176 0 0 0 1.852-2.14c0-1.51-1.162-2.46-3.014-2.46H3.843V13zM5.908 4.674h1.696c.963 0 1.517.451 1.517 1.244c0 .834-.629 1.32-1.73 1.32H5.908V4.673zm0 6.788V8.598h1.73c1.217 0 1.88.492 1.88 1.415c0 .943-.643 1.449-1.832 1.449H5.907z"
}, null, -1)
  , qz = [zz];
function Wz(t, e) {
    return g(),
    _("svg", Kz, [...qz])
}
const Wx = {
    name: "bi-type-bold",
    render: Wz
}
  , Gz = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Yz = c("path", {
    fill: "currentColor",
    "fill-rule": "evenodd",
    d: "M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m-3 1a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2"
}, null, -1)
  , Jz = [Yz];
function Xz(t, e) {
    return g(),
    _("svg", Gz, [...Jz])
}
const Gx = {
    name: "bi-list-ul",
    render: Xz
}
  , Qz = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Zz = c("g", {
    fill: "currentColor"
}, [c("path", {
    "fill-rule": "evenodd",
    d: "M5 11.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5"
}), c("path", {
    d: "M1.713 11.865v-.474H2c.217 0 .363-.137.363-.317c0-.185-.158-.31-.361-.31c-.223 0-.367.152-.373.31h-.59c.016-.467.373-.787.986-.787c.588-.002.954.291.957.703a.595.595 0 0 1-.492.594v.033a.615.615 0 0 1 .569.631c.003.533-.502.8-1.051.8c-.656 0-1-.37-1.008-.794h.582c.008.178.186.306.422.309c.254 0 .424-.145.422-.35c-.002-.195-.155-.348-.414-.348h-.3zm-.004-4.699h-.604v-.035c0-.408.295-.844.958-.844c.583 0 .96.326.96.756c0 .389-.257.617-.476.848l-.537.572v.03h1.054V9H1.143v-.395l.957-.99c.138-.142.293-.304.293-.508c0-.18-.147-.32-.342-.32a.33.33 0 0 0-.342.338zM2.564 5h-.635V2.924h-.031l-.598.42v-.567l.629-.443h.635z"
})], -1)
  , e9 = [Zz];
function t9(t, e) {
    return g(),
    _("svg", Qz, [...e9])
}
const Yx = {
    name: "bi-list-ol",
    render: t9
};
function xr(t) {
    "@babel/helpers - typeof";
    return xr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    xr(t)
}
function Qe(t) {
    if (t === null || t === !0 || t === !1)
        return NaN;
    var e = Number(t);
    return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e)
}
function Ue(t, e) {
    if (e.length < t)
        throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present")
}
function We(t) {
    Ue(1, arguments);
    var e = Object.prototype.toString.call(t);
    return t instanceof Date || xr(t) === "object" && e === "[object Date]" ? new Date(t.getTime()) : typeof t == "number" || e === "[object Number]" ? new Date(t) : ((typeof t == "string" || e === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),
    console.warn(new Error().stack)),
    new Date(NaN))
}
function xa(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return isNaN(r) ? new Date(NaN) : (r && n.setDate(n.getDate() + r),
    n)
}
function Pr(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    if (isNaN(r))
        return new Date(NaN);
    if (!r)
        return n;
    var a = n.getDate()
      , s = new Date(n.getTime());
    s.setMonth(n.getMonth() + r + 1, 0);
    var l = s.getDate();
    return a >= l ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), a),
    n)
}
function Jx(t, e) {
    if (Ue(2, arguments),
    !e || xr(e) !== "object")
        return new Date(NaN);
    var n = e.years ? Qe(e.years) : 0
      , r = e.months ? Qe(e.months) : 0
      , a = e.weeks ? Qe(e.weeks) : 0
      , s = e.days ? Qe(e.days) : 0
      , l = e.hours ? Qe(e.hours) : 0
      , i = e.minutes ? Qe(e.minutes) : 0
      , o = e.seconds ? Qe(e.seconds) : 0
      , u = We(t)
      , d = r || n ? Pr(u, r + n * 12) : u
      , f = s || a ? xa(d, s + a * 7) : d
      , p = i + l * 60
      , h = o + p * 60
      , v = h * 1e3
      , y = new Date(f.getTime() + v);
    return y
}
function n9(t, e) {
    Ue(2, arguments);
    var n = We(t).getTime()
      , r = Qe(e);
    return new Date(n + r)
}
var r9 = {};
function ma() {
    return r9
}
function ul(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = ma()
      , f = Qe((n = (r = (a = (s = e == null ? void 0 : e.weekStartsOn) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.weekStartsOn) !== null && a !== void 0 ? a : d.weekStartsOn) !== null && r !== void 0 ? r : (o = d.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(f >= 0 && f <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var p = We(t)
      , h = p.getDay()
      , v = (h < f ? 7 : 0) + h - f;
    return p.setDate(p.getDate() - v),
    p.setHours(0, 0, 0, 0),
    p
}
function kd(t) {
    return Ue(1, arguments),
    ul(t, {
        weekStartsOn: 1
    })
}
function a9(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getFullYear()
      , r = new Date(0);
    r.setFullYear(n + 1, 0, 4),
    r.setHours(0, 0, 0, 0);
    var a = kd(r)
      , s = new Date(0);
    s.setFullYear(n, 0, 4),
    s.setHours(0, 0, 0, 0);
    var l = kd(s);
    return e.getTime() >= a.getTime() ? n + 1 : e.getTime() >= l.getTime() ? n : n - 1
}
function s9(t) {
    Ue(1, arguments);
    var e = a9(t)
      , n = new Date(0);
    n.setFullYear(e, 0, 4),
    n.setHours(0, 0, 0, 0);
    var r = kd(n);
    return r
}
function _d(t) {
    var e = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return e.setUTCFullYear(t.getFullYear()),
    t.getTime() - e.getTime()
}
function ly(t) {
    Ue(1, arguments);
    var e = We(t);
    return e.setHours(0, 0, 0, 0),
    e
}
var l9 = 864e5;
function i9(t, e) {
    Ue(2, arguments);
    var n = ly(t)
      , r = ly(e)
      , a = n.getTime() - _d(n)
      , s = r.getTime() - _d(r);
    return Math.round((a - s) / l9)
}
function o9(t, e) {
    Ue(2, arguments);
    var n = Qe(e)
      , r = n * 3;
    return Pr(t, r)
}
function tv(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    return Pr(t, n * 12)
}
var nv = 6e4
  , rv = 36e5
  , u9 = 1e3;
function Xx(t) {
    return Ue(1, arguments),
    t instanceof Date || xr(t) === "object" && Object.prototype.toString.call(t) === "[object Date]"
}
function mo(t) {
    if (Ue(1, arguments),
    !Xx(t) && typeof t != "number")
        return !1;
    var e = We(t);
    return !isNaN(Number(e))
}
function iy(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = Math.floor(e.getMonth() / 3) + 1;
    return n
}
function Qx(t, e) {
    var n;
    Ue(1, arguments);
    var r = t || {}
      , a = We(r.start)
      , s = We(r.end)
      , l = s.getTime();
    if (!(a.getTime() <= l))
        throw new RangeError("Invalid interval");
    var i = []
      , o = a;
    o.setHours(0, 0, 0, 0);
    var u = Number((n = e == null ? void 0 : e.step) !== null && n !== void 0 ? n : 1);
    if (u < 1 || isNaN(u))
        throw new RangeError("`options.step` must be a number greater than 1");
    for (; o.getTime() <= l; )
        i.push(We(o)),
        o.setDate(o.getDate() + u),
        o.setHours(0, 0, 0, 0);
    return i
}
function Bo(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getMonth()
      , r = n - n % 3;
    return e.setMonth(r, 1),
    e.setHours(0, 0, 0, 0),
    e
}
function d9(t) {
    Ue(1, arguments);
    var e = t || {}
      , n = We(e.start)
      , r = We(e.end)
      , a = r.getTime();
    if (!(n.getTime() <= a))
        throw new RangeError("Invalid interval");
    var s = Bo(n)
      , l = Bo(r);
    a = l.getTime();
    for (var i = [], o = s; o.getTime() <= a; )
        i.push(We(o)),
        o = o9(o, 1);
    return i
}
function c9(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getFullYear();
    return e.setFullYear(n + 1, 0, 0),
    e.setHours(23, 59, 59, 999),
    e
}
function f9(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = new Date(0);
    return n.setFullYear(e.getFullYear(), 0, 1),
    n.setHours(0, 0, 0, 0),
    n
}
function p9(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = ma()
      , f = Qe((n = (r = (a = (s = e == null ? void 0 : e.weekStartsOn) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.weekStartsOn) !== null && a !== void 0 ? a : d.weekStartsOn) !== null && r !== void 0 ? r : (o = d.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(f >= 0 && f <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var p = We(t)
      , h = p.getDay()
      , v = (h < f ? -7 : 0) + 6 - (h - f);
    return p.setDate(p.getDate() + v),
    p.setHours(23, 59, 59, 999),
    p
}
function oy(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getMonth()
      , r = n - n % 3 + 3;
    return e.setMonth(r, 0),
    e.setHours(23, 59, 59, 999),
    e
}
function Zx(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    return n9(t, -n)
}
var h9 = 864e5;
function m9(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getTime();
    e.setUTCMonth(0, 1),
    e.setUTCHours(0, 0, 0, 0);
    var r = e.getTime()
      , a = n - r;
    return Math.floor(a / h9) + 1
}
function gi(t) {
    Ue(1, arguments);
    var e = 1
      , n = We(t)
      , r = n.getUTCDay()
      , a = (r < e ? 7 : 0) + r - e;
    return n.setUTCDate(n.getUTCDate() - a),
    n.setUTCHours(0, 0, 0, 0),
    n
}
function eS(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getUTCFullYear()
      , r = new Date(0);
    r.setUTCFullYear(n + 1, 0, 4),
    r.setUTCHours(0, 0, 0, 0);
    var a = gi(r)
      , s = new Date(0);
    s.setUTCFullYear(n, 0, 4),
    s.setUTCHours(0, 0, 0, 0);
    var l = gi(s);
    return e.getTime() >= a.getTime() ? n + 1 : e.getTime() >= l.getTime() ? n : n - 1
}
function v9(t) {
    Ue(1, arguments);
    var e = eS(t)
      , n = new Date(0);
    n.setUTCFullYear(e, 0, 4),
    n.setUTCHours(0, 0, 0, 0);
    var r = gi(n);
    return r
}
var g9 = 6048e5;
function tS(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = gi(e).getTime() - v9(e).getTime();
    return Math.round(n / g9) + 1
}
function dl(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = ma()
      , f = Qe((n = (r = (a = (s = e == null ? void 0 : e.weekStartsOn) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.weekStartsOn) !== null && a !== void 0 ? a : d.weekStartsOn) !== null && r !== void 0 ? r : (o = d.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(f >= 0 && f <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var p = We(t)
      , h = p.getUTCDay()
      , v = (h < f ? 7 : 0) + h - f;
    return p.setUTCDate(p.getUTCDate() - v),
    p.setUTCHours(0, 0, 0, 0),
    p
}
function av(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = We(t)
      , f = d.getUTCFullYear()
      , p = ma()
      , h = Qe((n = (r = (a = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : p.firstWeekContainsDate) !== null && r !== void 0 ? r : (o = p.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
    if (!(h >= 1 && h <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var v = new Date(0);
    v.setUTCFullYear(f + 1, 0, h),
    v.setUTCHours(0, 0, 0, 0);
    var y = dl(v, e)
      , k = new Date(0);
    k.setUTCFullYear(f, 0, h),
    k.setUTCHours(0, 0, 0, 0);
    var w = dl(k, e);
    return d.getTime() >= y.getTime() ? f + 1 : d.getTime() >= w.getTime() ? f : f - 1
}
function b9(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = ma()
      , f = Qe((n = (r = (a = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : d.firstWeekContainsDate) !== null && r !== void 0 ? r : (o = d.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && n !== void 0 ? n : 1)
      , p = av(t, e)
      , h = new Date(0);
    h.setUTCFullYear(p, 0, f),
    h.setUTCHours(0, 0, 0, 0);
    var v = dl(h, e);
    return v
}
var y9 = 6048e5;
function nS(t, e) {
    Ue(1, arguments);
    var n = We(t)
      , r = dl(n, e).getTime() - b9(n, e).getTime();
    return Math.round(r / y9) + 1
}
function Nt(t, e) {
    for (var n = t < 0 ? "-" : "", r = Math.abs(t).toString(); r.length < e; )
        r = "0" + r;
    return n + r
}
var k9 = {
    y: function(e, n) {
        var r = e.getUTCFullYear()
          , a = r > 0 ? r : 1 - r;
        return Nt(n === "yy" ? a % 100 : a, n.length)
    },
    M: function(e, n) {
        var r = e.getUTCMonth();
        return n === "M" ? String(r + 1) : Nt(r + 1, 2)
    },
    d: function(e, n) {
        return Nt(e.getUTCDate(), n.length)
    },
    a: function(e, n) {
        var r = e.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (n) {
        case "a":
        case "aa":
            return r.toUpperCase();
        case "aaa":
            return r;
        case "aaaaa":
            return r[0];
        case "aaaa":
        default:
            return r === "am" ? "a.m." : "p.m."
        }
    },
    h: function(e, n) {
        return Nt(e.getUTCHours() % 12 || 12, n.length)
    },
    H: function(e, n) {
        return Nt(e.getUTCHours(), n.length)
    },
    m: function(e, n) {
        return Nt(e.getUTCMinutes(), n.length)
    },
    s: function(e, n) {
        return Nt(e.getUTCSeconds(), n.length)
    },
    S: function(e, n) {
        var r = n.length
          , a = e.getUTCMilliseconds()
          , s = Math.floor(a * Math.pow(10, r - 3));
        return Nt(s, n.length)
    }
};
const La = k9;
var Dl = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
}
  , _9 = {
    G: function(e, n, r) {
        var a = e.getUTCFullYear() > 0 ? 1 : 0;
        switch (n) {
        case "G":
        case "GG":
        case "GGG":
            return r.era(a, {
                width: "abbreviated"
            });
        case "GGGGG":
            return r.era(a, {
                width: "narrow"
            });
        case "GGGG":
        default:
            return r.era(a, {
                width: "wide"
            })
        }
    },
    y: function(e, n, r) {
        if (n === "yo") {
            var a = e.getUTCFullYear()
              , s = a > 0 ? a : 1 - a;
            return r.ordinalNumber(s, {
                unit: "year"
            })
        }
        return La.y(e, n)
    },
    Y: function(e, n, r, a) {
        var s = av(e, a)
          , l = s > 0 ? s : 1 - s;
        if (n === "YY") {
            var i = l % 100;
            return Nt(i, 2)
        }
        return n === "Yo" ? r.ordinalNumber(l, {
            unit: "year"
        }) : Nt(l, n.length)
    },
    R: function(e, n) {
        var r = eS(e);
        return Nt(r, n.length)
    },
    u: function(e, n) {
        var r = e.getUTCFullYear();
        return Nt(r, n.length)
    },
    Q: function(e, n, r) {
        var a = Math.ceil((e.getUTCMonth() + 1) / 3);
        switch (n) {
        case "Q":
            return String(a);
        case "QQ":
            return Nt(a, 2);
        case "Qo":
            return r.ordinalNumber(a, {
                unit: "quarter"
            });
        case "QQQ":
            return r.quarter(a, {
                width: "abbreviated",
                context: "formatting"
            });
        case "QQQQQ":
            return r.quarter(a, {
                width: "narrow",
                context: "formatting"
            });
        case "QQQQ":
        default:
            return r.quarter(a, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    q: function(e, n, r) {
        var a = Math.ceil((e.getUTCMonth() + 1) / 3);
        switch (n) {
        case "q":
            return String(a);
        case "qq":
            return Nt(a, 2);
        case "qo":
            return r.ordinalNumber(a, {
                unit: "quarter"
            });
        case "qqq":
            return r.quarter(a, {
                width: "abbreviated",
                context: "standalone"
            });
        case "qqqqq":
            return r.quarter(a, {
                width: "narrow",
                context: "standalone"
            });
        case "qqqq":
        default:
            return r.quarter(a, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    M: function(e, n, r) {
        var a = e.getUTCMonth();
        switch (n) {
        case "M":
        case "MM":
            return La.M(e, n);
        case "Mo":
            return r.ordinalNumber(a + 1, {
                unit: "month"
            });
        case "MMM":
            return r.month(a, {
                width: "abbreviated",
                context: "formatting"
            });
        case "MMMMM":
            return r.month(a, {
                width: "narrow",
                context: "formatting"
            });
        case "MMMM":
        default:
            return r.month(a, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    L: function(e, n, r) {
        var a = e.getUTCMonth();
        switch (n) {
        case "L":
            return String(a + 1);
        case "LL":
            return Nt(a + 1, 2);
        case "Lo":
            return r.ordinalNumber(a + 1, {
                unit: "month"
            });
        case "LLL":
            return r.month(a, {
                width: "abbreviated",
                context: "standalone"
            });
        case "LLLLL":
            return r.month(a, {
                width: "narrow",
                context: "standalone"
            });
        case "LLLL":
        default:
            return r.month(a, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    w: function(e, n, r, a) {
        var s = nS(e, a);
        return n === "wo" ? r.ordinalNumber(s, {
            unit: "week"
        }) : Nt(s, n.length)
    },
    I: function(e, n, r) {
        var a = tS(e);
        return n === "Io" ? r.ordinalNumber(a, {
            unit: "week"
        }) : Nt(a, n.length)
    },
    d: function(e, n, r) {
        return n === "do" ? r.ordinalNumber(e.getUTCDate(), {
            unit: "date"
        }) : La.d(e, n)
    },
    D: function(e, n, r) {
        var a = m9(e);
        return n === "Do" ? r.ordinalNumber(a, {
            unit: "dayOfYear"
        }) : Nt(a, n.length)
    },
    E: function(e, n, r) {
        var a = e.getUTCDay();
        switch (n) {
        case "E":
        case "EE":
        case "EEE":
            return r.day(a, {
                width: "abbreviated",
                context: "formatting"
            });
        case "EEEEE":
            return r.day(a, {
                width: "narrow",
                context: "formatting"
            });
        case "EEEEEE":
            return r.day(a, {
                width: "short",
                context: "formatting"
            });
        case "EEEE":
        default:
            return r.day(a, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    e: function(e, n, r, a) {
        var s = e.getUTCDay()
          , l = (s - a.weekStartsOn + 8) % 7 || 7;
        switch (n) {
        case "e":
            return String(l);
        case "ee":
            return Nt(l, 2);
        case "eo":
            return r.ordinalNumber(l, {
                unit: "day"
            });
        case "eee":
            return r.day(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "eeeee":
            return r.day(s, {
                width: "narrow",
                context: "formatting"
            });
        case "eeeeee":
            return r.day(s, {
                width: "short",
                context: "formatting"
            });
        case "eeee":
        default:
            return r.day(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    c: function(e, n, r, a) {
        var s = e.getUTCDay()
          , l = (s - a.weekStartsOn + 8) % 7 || 7;
        switch (n) {
        case "c":
            return String(l);
        case "cc":
            return Nt(l, n.length);
        case "co":
            return r.ordinalNumber(l, {
                unit: "day"
            });
        case "ccc":
            return r.day(s, {
                width: "abbreviated",
                context: "standalone"
            });
        case "ccccc":
            return r.day(s, {
                width: "narrow",
                context: "standalone"
            });
        case "cccccc":
            return r.day(s, {
                width: "short",
                context: "standalone"
            });
        case "cccc":
        default:
            return r.day(s, {
                width: "wide",
                context: "standalone"
            })
        }
    },
    i: function(e, n, r) {
        var a = e.getUTCDay()
          , s = a === 0 ? 7 : a;
        switch (n) {
        case "i":
            return String(s);
        case "ii":
            return Nt(s, n.length);
        case "io":
            return r.ordinalNumber(s, {
                unit: "day"
            });
        case "iii":
            return r.day(a, {
                width: "abbreviated",
                context: "formatting"
            });
        case "iiiii":
            return r.day(a, {
                width: "narrow",
                context: "formatting"
            });
        case "iiiiii":
            return r.day(a, {
                width: "short",
                context: "formatting"
            });
        case "iiii":
        default:
            return r.day(a, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    a: function(e, n, r) {
        var a = e.getUTCHours()
          , s = a / 12 >= 1 ? "pm" : "am";
        switch (n) {
        case "a":
        case "aa":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "aaa":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "aaaaa":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "aaaa":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    b: function(e, n, r) {
        var a = e.getUTCHours(), s;
        switch (a === 12 ? s = Dl.noon : a === 0 ? s = Dl.midnight : s = a / 12 >= 1 ? "pm" : "am",
        n) {
        case "b":
        case "bb":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "bbb":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            }).toLowerCase();
        case "bbbbb":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "bbbb":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    B: function(e, n, r) {
        var a = e.getUTCHours(), s;
        switch (a >= 17 ? s = Dl.evening : a >= 12 ? s = Dl.afternoon : a >= 4 ? s = Dl.morning : s = Dl.night,
        n) {
        case "B":
        case "BB":
        case "BBB":
            return r.dayPeriod(s, {
                width: "abbreviated",
                context: "formatting"
            });
        case "BBBBB":
            return r.dayPeriod(s, {
                width: "narrow",
                context: "formatting"
            });
        case "BBBB":
        default:
            return r.dayPeriod(s, {
                width: "wide",
                context: "formatting"
            })
        }
    },
    h: function(e, n, r) {
        if (n === "ho") {
            var a = e.getUTCHours() % 12;
            return a === 0 && (a = 12),
            r.ordinalNumber(a, {
                unit: "hour"
            })
        }
        return La.h(e, n)
    },
    H: function(e, n, r) {
        return n === "Ho" ? r.ordinalNumber(e.getUTCHours(), {
            unit: "hour"
        }) : La.H(e, n)
    },
    K: function(e, n, r) {
        var a = e.getUTCHours() % 12;
        return n === "Ko" ? r.ordinalNumber(a, {
            unit: "hour"
        }) : Nt(a, n.length)
    },
    k: function(e, n, r) {
        var a = e.getUTCHours();
        return a === 0 && (a = 24),
        n === "ko" ? r.ordinalNumber(a, {
            unit: "hour"
        }) : Nt(a, n.length)
    },
    m: function(e, n, r) {
        return n === "mo" ? r.ordinalNumber(e.getUTCMinutes(), {
            unit: "minute"
        }) : La.m(e, n)
    },
    s: function(e, n, r) {
        return n === "so" ? r.ordinalNumber(e.getUTCSeconds(), {
            unit: "second"
        }) : La.s(e, n)
    },
    S: function(e, n) {
        return La.S(e, n)
    },
    X: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = s.getTimezoneOffset();
        if (l === 0)
            return "Z";
        switch (n) {
        case "X":
            return dy(l);
        case "XXXX":
        case "XX":
            return Ps(l);
        case "XXXXX":
        case "XXX":
        default:
            return Ps(l, ":")
        }
    },
    x: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = s.getTimezoneOffset();
        switch (n) {
        case "x":
            return dy(l);
        case "xxxx":
        case "xx":
            return Ps(l);
        case "xxxxx":
        case "xxx":
        default:
            return Ps(l, ":")
        }
    },
    O: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = s.getTimezoneOffset();
        switch (n) {
        case "O":
        case "OO":
        case "OOO":
            return "GMT" + uy(l, ":");
        case "OOOO":
        default:
            return "GMT" + Ps(l, ":")
        }
    },
    z: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = s.getTimezoneOffset();
        switch (n) {
        case "z":
        case "zz":
        case "zzz":
            return "GMT" + uy(l, ":");
        case "zzzz":
        default:
            return "GMT" + Ps(l, ":")
        }
    },
    t: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = Math.floor(s.getTime() / 1e3);
        return Nt(l, n.length)
    },
    T: function(e, n, r, a) {
        var s = a._originalDate || e
          , l = s.getTime();
        return Nt(l, n.length)
    }
};
function uy(t, e) {
    var n = t > 0 ? "-" : "+"
      , r = Math.abs(t)
      , a = Math.floor(r / 60)
      , s = r % 60;
    if (s === 0)
        return n + String(a);
    var l = e || "";
    return n + String(a) + l + Nt(s, 2)
}
function dy(t, e) {
    if (t % 60 === 0) {
        var n = t > 0 ? "-" : "+";
        return n + Nt(Math.abs(t) / 60, 2)
    }
    return Ps(t, e)
}
function Ps(t, e) {
    var n = e || ""
      , r = t > 0 ? "-" : "+"
      , a = Math.abs(t)
      , s = Nt(Math.floor(a / 60), 2)
      , l = Nt(a % 60, 2);
    return r + s + n + l
}
const w9 = _9;
var cy = function(e, n) {
    switch (e) {
    case "P":
        return n.date({
            width: "short"
        });
    case "PP":
        return n.date({
            width: "medium"
        });
    case "PPP":
        return n.date({
            width: "long"
        });
    case "PPPP":
    default:
        return n.date({
            width: "full"
        })
    }
}
  , rS = function(e, n) {
    switch (e) {
    case "p":
        return n.time({
            width: "short"
        });
    case "pp":
        return n.time({
            width: "medium"
        });
    case "ppp":
        return n.time({
            width: "long"
        });
    case "pppp":
    default:
        return n.time({
            width: "full"
        })
    }
}
  , x9 = function(e, n) {
    var r = e.match(/(P+)(p+)?/) || []
      , a = r[1]
      , s = r[2];
    if (!s)
        return cy(e, n);
    var l;
    switch (a) {
    case "P":
        l = n.dateTime({
            width: "short"
        });
        break;
    case "PP":
        l = n.dateTime({
            width: "medium"
        });
        break;
    case "PPP":
        l = n.dateTime({
            width: "long"
        });
        break;
    case "PPPP":
    default:
        l = n.dateTime({
            width: "full"
        });
        break
    }
    return l.replace("{{date}}", cy(a, n)).replace("{{time}}", rS(s, n))
}
  , S9 = {
    p: rS,
    P: x9
};
const ph = S9;
var $9 = ["D", "DD"]
  , T9 = ["YY", "YYYY"];
function aS(t) {
    return $9.indexOf(t) !== -1
}
function sS(t) {
    return T9.indexOf(t) !== -1
}
function wd(t, e, n) {
    if (t === "YYYY")
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(e, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "YY")
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(e, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "D")
        throw new RangeError("Use `d` instead of `D` (in `".concat(e, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (t === "DD")
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(e, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}
var C9 = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
}
  , E9 = function(e, n, r) {
    var a, s = C9[e];
    return typeof s == "string" ? a = s : n === 1 ? a = s.one : a = s.other.replace("{{count}}", n.toString()),
    r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + a : a + " ago" : a
};
const A9 = E9;
function Lf(t) {
    return function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , n = e.width ? String(e.width) : t.defaultWidth
          , r = t.formats[n] || t.formats[t.defaultWidth];
        return r
    }
}
var M9 = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
}
  , O9 = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
}
  , N9 = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
}
  , D9 = {
    date: Lf({
        formats: M9,
        defaultWidth: "full"
    }),
    time: Lf({
        formats: O9,
        defaultWidth: "full"
    }),
    dateTime: Lf({
        formats: N9,
        defaultWidth: "full"
    })
};
const P9 = D9;
var F9 = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
}
  , B9 = function(e, n, r, a) {
    return F9[e]
};
const V9 = B9;
function Li(t) {
    return function(e, n) {
        var r = n != null && n.context ? String(n.context) : "standalone", a;
        if (r === "formatting" && t.formattingValues) {
            var s = t.defaultFormattingWidth || t.defaultWidth
              , l = n != null && n.width ? String(n.width) : s;
            a = t.formattingValues[l] || t.formattingValues[s]
        } else {
            var i = t.defaultWidth
              , o = n != null && n.width ? String(n.width) : t.defaultWidth;
            a = t.values[o] || t.values[i]
        }
        var u = t.argumentCallback ? t.argumentCallback(e) : e;
        return a[u]
    }
}
var I9 = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
}
  , R9 = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}
  , L9 = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}
  , j9 = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}
  , U9 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
}
  , H9 = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
}
  , K9 = function(e, n) {
    var r = Number(e)
      , a = r % 100;
    if (a > 20 || a < 10)
        switch (a % 10) {
        case 1:
            return r + "st";
        case 2:
            return r + "nd";
        case 3:
            return r + "rd"
        }
    return r + "th"
}
  , z9 = {
    ordinalNumber: K9,
    era: Li({
        values: I9,
        defaultWidth: "wide"
    }),
    quarter: Li({
        values: R9,
        defaultWidth: "wide",
        argumentCallback: function(e) {
            return e - 1
        }
    }),
    month: Li({
        values: L9,
        defaultWidth: "wide"
    }),
    day: Li({
        values: j9,
        defaultWidth: "wide"
    }),
    dayPeriod: Li({
        values: U9,
        defaultWidth: "wide",
        formattingValues: H9,
        defaultFormattingWidth: "wide"
    })
};
const q9 = z9;
function ji(t) {
    return function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , r = n.width
          , a = r && t.matchPatterns[r] || t.matchPatterns[t.defaultMatchWidth]
          , s = e.match(a);
        if (!s)
            return null;
        var l = s[0], i = r && t.parsePatterns[r] || t.parsePatterns[t.defaultParseWidth], o = Array.isArray(i) ? G9(i, function(f) {
            return f.test(l)
        }) : W9(i, function(f) {
            return f.test(l)
        }), u;
        u = t.valueCallback ? t.valueCallback(o) : o,
        u = n.valueCallback ? n.valueCallback(u) : u;
        var d = e.slice(l.length);
        return {
            value: u,
            rest: d
        }
    }
}
function W9(t, e) {
    for (var n in t)
        if (t.hasOwnProperty(n) && e(t[n]))
            return n
}
function G9(t, e) {
    for (var n = 0; n < t.length; n++)
        if (e(t[n]))
            return n
}
function Y9(t) {
    return function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , r = e.match(t.matchPattern);
        if (!r)
            return null;
        var a = r[0]
          , s = e.match(t.parsePattern);
        if (!s)
            return null;
        var l = t.valueCallback ? t.valueCallback(s[0]) : s[0];
        l = n.valueCallback ? n.valueCallback(l) : l;
        var i = e.slice(a.length);
        return {
            value: l,
            rest: i
        }
    }
}
var J9 = /^(\d+)(th|st|nd|rd)?/i
  , X9 = /\d+/i
  , Q9 = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
}
  , Z9 = {
    any: [/^b/i, /^(a|c)/i]
}
  , eq = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
}
  , tq = {
    any: [/1/i, /2/i, /3/i, /4/i]
}
  , nq = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}
  , rq = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}
  , aq = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}
  , sq = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}
  , lq = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}
  , iq = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
}
  , oq = {
    ordinalNumber: Y9({
        matchPattern: J9,
        parsePattern: X9,
        valueCallback: function(e) {
            return parseInt(e, 10)
        }
    }),
    era: ji({
        matchPatterns: Q9,
        defaultMatchWidth: "wide",
        parsePatterns: Z9,
        defaultParseWidth: "any"
    }),
    quarter: ji({
        matchPatterns: eq,
        defaultMatchWidth: "wide",
        parsePatterns: tq,
        defaultParseWidth: "any",
        valueCallback: function(e) {
            return e + 1
        }
    }),
    month: ji({
        matchPatterns: nq,
        defaultMatchWidth: "wide",
        parsePatterns: rq,
        defaultParseWidth: "any"
    }),
    day: ji({
        matchPatterns: aq,
        defaultMatchWidth: "wide",
        parsePatterns: sq,
        defaultParseWidth: "any"
    }),
    dayPeriod: ji({
        matchPatterns: lq,
        defaultMatchWidth: "any",
        parsePatterns: iq,
        defaultParseWidth: "any"
    })
};
const uq = oq;
var dq = {
    code: "en-US",
    formatDistance: A9,
    formatLong: P9,
    formatRelative: V9,
    localize: q9,
    match: uq,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const lS = dq;
var cq = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , fq = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , pq = /^'([^]*?)'?$/
  , hq = /''/g
  , mq = /[a-zA-Z]/;
function fs(t, e, n) {
    var r, a, s, l, i, o, u, d, f, p, h, v, y, k, w, $, M, S;
    Ue(2, arguments);
    var T = String(e)
      , E = ma()
      , O = (r = (a = n == null ? void 0 : n.locale) !== null && a !== void 0 ? a : E.locale) !== null && r !== void 0 ? r : lS
      , U = Qe((s = (l = (i = (o = n == null ? void 0 : n.firstWeekContainsDate) !== null && o !== void 0 ? o : n == null || (u = n.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && i !== void 0 ? i : E.firstWeekContainsDate) !== null && l !== void 0 ? l : (f = E.locale) === null || f === void 0 || (p = f.options) === null || p === void 0 ? void 0 : p.firstWeekContainsDate) !== null && s !== void 0 ? s : 1);
    if (!(U >= 1 && U <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var L = Qe((h = (v = (y = (k = n == null ? void 0 : n.weekStartsOn) !== null && k !== void 0 ? k : n == null || (w = n.locale) === null || w === void 0 || ($ = w.options) === null || $ === void 0 ? void 0 : $.weekStartsOn) !== null && y !== void 0 ? y : E.weekStartsOn) !== null && v !== void 0 ? v : (M = E.locale) === null || M === void 0 || (S = M.options) === null || S === void 0 ? void 0 : S.weekStartsOn) !== null && h !== void 0 ? h : 0);
    if (!(L >= 0 && L <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!O.localize)
        throw new RangeError("locale must contain localize property");
    if (!O.formatLong)
        throw new RangeError("locale must contain formatLong property");
    var C = We(t);
    if (!mo(C))
        throw new RangeError("Invalid time value");
    var W = _d(C)
      , R = Zx(C, W)
      , G = {
        firstWeekContainsDate: U,
        weekStartsOn: L,
        locale: O,
        _originalDate: C
    }
      , te = T.match(fq).map(function(J) {
        var ae = J[0];
        if (ae === "p" || ae === "P") {
            var oe = ph[ae];
            return oe(J, O.formatLong)
        }
        return J
    }).join("").match(cq).map(function(J) {
        if (J === "''")
            return "'";
        var ae = J[0];
        if (ae === "'")
            return vq(J);
        var oe = w9[ae];
        if (oe)
            return !(n != null && n.useAdditionalWeekYearTokens) && sS(J) && wd(J, e, String(t)),
            !(n != null && n.useAdditionalDayOfYearTokens) && aS(J) && wd(J, e, String(t)),
            oe(R, J, O.localize, G);
        if (ae.match(mq))
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + ae + "`");
        return J
    }).join("");
    return te
}
function vq(t) {
    var e = t.match(pq);
    return e ? e[1].replace(hq, "'") : t
}
function gq(t, e) {
    if (t == null)
        throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var n in e)
        Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t
}
function bq(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getDay();
    return n
}
function yq(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getFullYear()
      , r = e.getMonth()
      , a = new Date(0);
    return a.setFullYear(n, r + 1, 0),
    a.setHours(0, 0, 0, 0),
    a.getDate()
}
function Fr(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getHours();
    return n
}
var kq = 6048e5;
function _q(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = kd(e).getTime() - s9(e).getTime();
    return Math.round(n / kq) + 1
}
function sa(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getMinutes();
    return n
}
function gt(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getMonth();
    return n
}
function bi(t) {
    Ue(1, arguments);
    var e = We(t)
      , n = e.getSeconds();
    return n
}
function wq(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = We(t)
      , f = d.getFullYear()
      , p = ma()
      , h = Qe((n = (r = (a = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : p.firstWeekContainsDate) !== null && r !== void 0 ? r : (o = p.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
    if (!(h >= 1 && h <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var v = new Date(0);
    v.setFullYear(f + 1, 0, h),
    v.setHours(0, 0, 0, 0);
    var y = ul(v, e)
      , k = new Date(0);
    k.setFullYear(f, 0, h),
    k.setHours(0, 0, 0, 0);
    var w = ul(k, e);
    return d.getTime() >= y.getTime() ? f + 1 : d.getTime() >= w.getTime() ? f : f - 1
}
function xq(t, e) {
    var n, r, a, s, l, i, o, u;
    Ue(1, arguments);
    var d = ma()
      , f = Qe((n = (r = (a = (s = e == null ? void 0 : e.firstWeekContainsDate) !== null && s !== void 0 ? s : e == null || (l = e.locale) === null || l === void 0 || (i = l.options) === null || i === void 0 ? void 0 : i.firstWeekContainsDate) !== null && a !== void 0 ? a : d.firstWeekContainsDate) !== null && r !== void 0 ? r : (o = d.locale) === null || o === void 0 || (u = o.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && n !== void 0 ? n : 1)
      , p = wq(t, e)
      , h = new Date(0);
    h.setFullYear(p, 0, f),
    h.setHours(0, 0, 0, 0);
    var v = ul(h, e);
    return v
}
var Sq = 6048e5;
function $q(t, e) {
    Ue(1, arguments);
    var n = We(t)
      , r = ul(n, e).getTime() - xq(n, e).getTime();
    return Math.round(r / Sq) + 1
}
function ct(t) {
    return Ue(1, arguments),
    We(t).getFullYear()
}
function Vo(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = We(e);
    return n.getTime() > r.getTime()
}
function Io(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = We(e);
    return n.getTime() < r.getTime()
}
function Kl(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = We(e);
    return n.getTime() === r.getTime()
}
function fy(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++)
        r[n] = t[n];
    return r
}
function Tq(t, e) {
    if (t) {
        if (typeof t == "string")
            return fy(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name),
        n === "Map" || n === "Set")
            return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return fy(t, e)
    }
}
function py(t, e) {
    var n = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (!n) {
        if (Array.isArray(t) || (n = Tq(t)) || e && t && typeof t.length == "number") {
            n && (t = n);
            var r = 0
              , a = function() {};
            return {
                s: a,
                n: function() {
                    return r >= t.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: t[r++]
                    }
                },
                e: function(u) {
                    throw u
                },
                f: a
            }
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    var s = !0, l = !1, i;
    return {
        s: function() {
            n = n.call(t)
        },
        n: function() {
            var u = n.next();
            return s = u.done,
            u
        },
        e: function(u) {
            l = !0,
            i = u
        },
        f: function() {
            try {
                !s && n.return != null && n.return()
            } finally {
                if (l)
                    throw i
            }
        }
    }
}
function je(t) {
    if (t === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}
function hh(t, e) {
    return hh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, a) {
        return r.__proto__ = a,
        r
    }
    ,
    hh(t, e)
}
function yt(t, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(t, "prototype", {
        writable: !1
    }),
    e && hh(t, e)
}
function xd(t) {
    return xd = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }
    ,
    xd(t)
}
function iS() {
    try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (iS = function() {
        return !!t
    }
    )()
}
function Cq(t, e) {
    if (e && (xr(e) === "object" || typeof e == "function"))
        return e;
    if (e !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return je(t)
}
function kt(t) {
    var e = iS();
    return function() {
        var r = xd(t), a;
        if (e) {
            var s = xd(this).constructor;
            a = Reflect.construct(r, arguments, s)
        } else
            a = r.apply(this, arguments);
        return Cq(this, a)
    }
}
function pt(t, e) {
    if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function Eq(t, e) {
    if (xr(t) != "object" || !t)
        return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (xr(r) != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}
function oS(t) {
    var e = Eq(t, "string");
    return xr(e) == "symbol" ? e : e + ""
}
function hy(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(t, oS(r.key), r)
    }
}
function ht(t, e, n) {
    return e && hy(t.prototype, e),
    n && hy(t, n),
    Object.defineProperty(t, "prototype", {
        writable: !1
    }),
    t
}
function Re(t, e, n) {
    return e = oS(e),
    e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n,
    t
}
var Aq = 10
  , uS = function() {
    function t() {
        pt(this, t),
        Re(this, "priority", void 0),
        Re(this, "subPriority", 0)
    }
    return ht(t, [{
        key: "validate",
        value: function(n, r) {
            return !0
        }
    }]),
    t
}()
  , Mq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n(r, a, s, l, i) {
        var o;
        return pt(this, n),
        o = e.call(this),
        o.value = r,
        o.validateValue = a,
        o.setValue = s,
        o.priority = l,
        i && (o.subPriority = i),
        o
    }
    return ht(n, [{
        key: "validate",
        value: function(a, s) {
            return this.validateValue(a, this.value, s)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return this.setValue(a, s, this.value, l)
        }
    }]),
    n
}(uS)
  , Oq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", Aq),
        Re(je(r), "subPriority", -1),
        r
    }
    return ht(n, [{
        key: "set",
        value: function(a, s) {
            if (s.timestampIsSet)
                return a;
            var l = new Date(0);
            return l.setFullYear(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate()),
            l.setHours(a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()),
            l
        }
    }]),
    n
}(uS)
  , At = function() {
    function t() {
        pt(this, t),
        Re(this, "incompatibleTokens", void 0),
        Re(this, "priority", void 0),
        Re(this, "subPriority", void 0)
    }
    return ht(t, [{
        key: "run",
        value: function(n, r, a, s) {
            var l = this.parse(n, r, a, s);
            return l ? {
                setter: new Mq(l.value,this.validate,this.set,this.priority,this.subPriority),
                rest: l.rest
            } : null
        }
    }, {
        key: "validate",
        value: function(n, r, a) {
            return !0
        }
    }]),
    t
}()
  , Nq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 140),
        Re(je(r), "incompatibleTokens", ["R", "u", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "G":
            case "GG":
            case "GGG":
                return l.era(a, {
                    width: "abbreviated"
                }) || l.era(a, {
                    width: "narrow"
                });
            case "GGGGG":
                return l.era(a, {
                    width: "narrow"
                });
            case "GGGG":
            default:
                return l.era(a, {
                    width: "wide"
                }) || l.era(a, {
                    width: "abbreviated"
                }) || l.era(a, {
                    width: "narrow"
                })
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return s.era = l,
            a.setUTCFullYear(l, 0, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , tn = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
}
  , Qr = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function nn(t, e) {
    return t && {
        value: e(t.value),
        rest: t.rest
    }
}
function Wt(t, e) {
    var n = e.match(t);
    return n ? {
        value: parseInt(n[0], 10),
        rest: e.slice(n[0].length)
    } : null
}
function Zr(t, e) {
    var n = e.match(t);
    if (!n)
        return null;
    if (n[0] === "Z")
        return {
            value: 0,
            rest: e.slice(1)
        };
    var r = n[1] === "+" ? 1 : -1
      , a = n[2] ? parseInt(n[2], 10) : 0
      , s = n[3] ? parseInt(n[3], 10) : 0
      , l = n[5] ? parseInt(n[5], 10) : 0;
    return {
        value: r * (a * rv + s * nv + l * u9),
        rest: e.slice(n[0].length)
    }
}
function dS(t) {
    return Wt(tn.anyDigitsSigned, t)
}
function Qt(t, e) {
    switch (t) {
    case 1:
        return Wt(tn.singleDigit, e);
    case 2:
        return Wt(tn.twoDigits, e);
    case 3:
        return Wt(tn.threeDigits, e);
    case 4:
        return Wt(tn.fourDigits, e);
    default:
        return Wt(new RegExp("^\\d{1," + t + "}"), e)
    }
}
function Sd(t, e) {
    switch (t) {
    case 1:
        return Wt(tn.singleDigitSigned, e);
    case 2:
        return Wt(tn.twoDigitsSigned, e);
    case 3:
        return Wt(tn.threeDigitsSigned, e);
    case 4:
        return Wt(tn.fourDigitsSigned, e);
    default:
        return Wt(new RegExp("^-?\\d{1," + t + "}"), e)
    }
}
function sv(t) {
    switch (t) {
    case "morning":
        return 4;
    case "evening":
        return 17;
    case "pm":
    case "noon":
    case "afternoon":
        return 12;
    case "am":
    case "midnight":
    case "night":
    default:
        return 0
    }
}
function cS(t, e) {
    var n = e > 0, r = n ? e : 1 - e, a;
    if (r <= 50)
        a = t || 100;
    else {
        var s = r + 50
          , l = Math.floor(s / 100) * 100
          , i = t >= s % 100;
        a = t + l - (i ? 100 : 0)
    }
    return n ? a : 1 - a
}
function fS(t) {
    return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0
}
var Dq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 130),
        Re(je(r), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            var i = function(u) {
                return {
                    year: u,
                    isTwoDigitYear: s === "yy"
                }
            };
            switch (s) {
            case "y":
                return nn(Qt(4, a), i);
            case "yo":
                return nn(l.ordinalNumber(a, {
                    unit: "year"
                }), i);
            default:
                return nn(Qt(s.length, a), i)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s.isTwoDigitYear || s.year > 0
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            var i = a.getUTCFullYear();
            if (l.isTwoDigitYear) {
                var o = cS(l.year, i);
                return a.setUTCFullYear(o, 0, 1),
                a.setUTCHours(0, 0, 0, 0),
                a
            }
            var u = !("era"in s) || s.era === 1 ? l.year : 1 - l.year;
            return a.setUTCFullYear(u, 0, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Pq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 130),
        Re(je(r), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            var i = function(u) {
                return {
                    year: u,
                    isTwoDigitYear: s === "YY"
                }
            };
            switch (s) {
            case "Y":
                return nn(Qt(4, a), i);
            case "Yo":
                return nn(l.ordinalNumber(a, {
                    unit: "year"
                }), i);
            default:
                return nn(Qt(s.length, a), i)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s.isTwoDigitYear || s.year > 0
        }
    }, {
        key: "set",
        value: function(a, s, l, i) {
            var o = av(a, i);
            if (l.isTwoDigitYear) {
                var u = cS(l.year, o);
                return a.setUTCFullYear(u, 0, i.firstWeekContainsDate),
                a.setUTCHours(0, 0, 0, 0),
                dl(a, i)
            }
            var d = !("era"in s) || s.era === 1 ? l.year : 1 - l.year;
            return a.setUTCFullYear(d, 0, i.firstWeekContainsDate),
            a.setUTCHours(0, 0, 0, 0),
            dl(a, i)
        }
    }]),
    n
}(At)
  , Fq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 130),
        Re(je(r), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s) {
            return Sd(s === "R" ? 4 : s.length, a)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            var i = new Date(0);
            return i.setUTCFullYear(l, 0, 4),
            i.setUTCHours(0, 0, 0, 0),
            gi(i)
        }
    }]),
    n
}(At)
  , Bq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 130),
        Re(je(r), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s) {
            return Sd(s === "u" ? 4 : s.length, a)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCFullYear(l, 0, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Vq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 120),
        Re(je(r), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "Q":
            case "QQ":
                return Qt(s.length, a);
            case "Qo":
                return l.ordinalNumber(a, {
                    unit: "quarter"
                });
            case "QQQ":
                return l.quarter(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.quarter(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "QQQQQ":
                return l.quarter(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "QQQQ":
            default:
                return l.quarter(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.quarter(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.quarter(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 4
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMonth((l - 1) * 3, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Iq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 120),
        Re(je(r), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "q":
            case "qq":
                return Qt(s.length, a);
            case "qo":
                return l.ordinalNumber(a, {
                    unit: "quarter"
                });
            case "qqq":
                return l.quarter(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.quarter(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "qqqqq":
                return l.quarter(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "qqqq":
            default:
                return l.quarter(a, {
                    width: "wide",
                    context: "standalone"
                }) || l.quarter(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.quarter(a, {
                    width: "narrow",
                    context: "standalone"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 4
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMonth((l - 1) * 3, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Rq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]),
        Re(je(r), "priority", 110),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            var i = function(u) {
                return u - 1
            };
            switch (s) {
            case "M":
                return nn(Wt(tn.month, a), i);
            case "MM":
                return nn(Qt(2, a), i);
            case "Mo":
                return nn(l.ordinalNumber(a, {
                    unit: "month"
                }), i);
            case "MMM":
                return l.month(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.month(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "MMMMM":
                return l.month(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "MMMM":
            default:
                return l.month(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.month(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.month(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 11
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMonth(l, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Lq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 110),
        Re(je(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            var i = function(u) {
                return u - 1
            };
            switch (s) {
            case "L":
                return nn(Wt(tn.month, a), i);
            case "LL":
                return nn(Qt(2, a), i);
            case "Lo":
                return nn(l.ordinalNumber(a, {
                    unit: "month"
                }), i);
            case "LLL":
                return l.month(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.month(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "LLLLL":
                return l.month(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "LLLL":
            default:
                return l.month(a, {
                    width: "wide",
                    context: "standalone"
                }) || l.month(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.month(a, {
                    width: "narrow",
                    context: "standalone"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 11
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMonth(l, 1),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At);
function jq(t, e, n) {
    Ue(2, arguments);
    var r = We(t)
      , a = Qe(e)
      , s = nS(r, n) - a;
    return r.setUTCDate(r.getUTCDate() - s * 7),
    r
}
var Uq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 100),
        Re(je(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "w":
                return Wt(tn.week, a);
            case "wo":
                return l.ordinalNumber(a, {
                    unit: "week"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 53
        }
    }, {
        key: "set",
        value: function(a, s, l, i) {
            return dl(jq(a, l, i), i)
        }
    }]),
    n
}(At);
function Hq(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e)
      , a = tS(n) - r;
    return n.setUTCDate(n.getUTCDate() - a * 7),
    n
}
var Kq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 100),
        Re(je(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "I":
                return Wt(tn.week, a);
            case "Io":
                return l.ordinalNumber(a, {
                    unit: "week"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 53
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return gi(Hq(a, l))
        }
    }]),
    n
}(At)
  , zq = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  , qq = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  , Wq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "subPriority", 1),
        Re(je(r), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "d":
                return Wt(tn.date, a);
            case "do":
                return l.ordinalNumber(a, {
                    unit: "date"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            var l = a.getUTCFullYear()
              , i = fS(l)
              , o = a.getUTCMonth();
            return i ? s >= 1 && s <= qq[o] : s >= 1 && s <= zq[o]
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCDate(l),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Gq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "subpriority", 1),
        Re(je(r), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "D":
            case "DD":
                return Wt(tn.dayOfYear, a);
            case "Do":
                return l.ordinalNumber(a, {
                    unit: "date"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            var l = a.getUTCFullYear()
              , i = fS(l);
            return i ? s >= 1 && s <= 366 : s >= 1 && s <= 365
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMonth(0, l),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At);
function lv(t, e, n) {
    var r, a, s, l, i, o, u, d;
    Ue(2, arguments);
    var f = ma()
      , p = Qe((r = (a = (s = (l = n == null ? void 0 : n.weekStartsOn) !== null && l !== void 0 ? l : n == null || (i = n.locale) === null || i === void 0 || (o = i.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && s !== void 0 ? s : f.weekStartsOn) !== null && a !== void 0 ? a : (u = f.locale) === null || u === void 0 || (d = u.options) === null || d === void 0 ? void 0 : d.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(p >= 0 && p <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var h = We(t)
      , v = Qe(e)
      , y = h.getUTCDay()
      , k = v % 7
      , w = (k + 7) % 7
      , $ = (w < p ? 7 : 0) + v - y;
    return h.setUTCDate(h.getUTCDate() + $),
    h
}
var Yq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "E":
            case "EE":
            case "EEE":
                return l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "EEEEE":
                return l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "EEEEEE":
                return l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "EEEE":
            default:
                return l.day(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 6
        }
    }, {
        key: "set",
        value: function(a, s, l, i) {
            return a = lv(a, l, i),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Jq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l, i) {
            var o = function(d) {
                var f = Math.floor((d - 1) / 7) * 7;
                return (d + i.weekStartsOn + 6) % 7 + f
            };
            switch (s) {
            case "e":
            case "ee":
                return nn(Qt(s.length, a), o);
            case "eo":
                return nn(l.ordinalNumber(a, {
                    unit: "day"
                }), o);
            case "eee":
                return l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "eeeee":
                return l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "eeeeee":
                return l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "eeee":
            default:
                return l.day(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 6
        }
    }, {
        key: "set",
        value: function(a, s, l, i) {
            return a = lv(a, l, i),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , Xq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l, i) {
            var o = function(d) {
                var f = Math.floor((d - 1) / 7) * 7;
                return (d + i.weekStartsOn + 6) % 7 + f
            };
            switch (s) {
            case "c":
            case "cc":
                return nn(Qt(s.length, a), o);
            case "co":
                return nn(l.ordinalNumber(a, {
                    unit: "day"
                }), o);
            case "ccc":
                return l.day(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.day(a, {
                    width: "short",
                    context: "standalone"
                }) || l.day(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "ccccc":
                return l.day(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "cccccc":
                return l.day(a, {
                    width: "short",
                    context: "standalone"
                }) || l.day(a, {
                    width: "narrow",
                    context: "standalone"
                });
            case "cccc":
            default:
                return l.day(a, {
                    width: "wide",
                    context: "standalone"
                }) || l.day(a, {
                    width: "abbreviated",
                    context: "standalone"
                }) || l.day(a, {
                    width: "short",
                    context: "standalone"
                }) || l.day(a, {
                    width: "narrow",
                    context: "standalone"
                })
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 6
        }
    }, {
        key: "set",
        value: function(a, s, l, i) {
            return a = lv(a, l, i),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At);
function Qq(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    n % 7 === 0 && (n = n - 7);
    var r = 1
      , a = We(t)
      , s = a.getUTCDay()
      , l = n % 7
      , i = (l + 7) % 7
      , o = (i < r ? 7 : 0) + n - s;
    return a.setUTCDate(a.getUTCDate() + o),
    a
}
var Zq = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 90),
        Re(je(r), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            var i = function(u) {
                return u === 0 ? 7 : u
            };
            switch (s) {
            case "i":
            case "ii":
                return Qt(s.length, a);
            case "io":
                return l.ordinalNumber(a, {
                    unit: "day"
                });
            case "iii":
                return nn(l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                }), i);
            case "iiiii":
                return nn(l.day(a, {
                    width: "narrow",
                    context: "formatting"
                }), i);
            case "iiiiii":
                return nn(l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                }), i);
            case "iiii":
            default:
                return nn(l.day(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.day(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.day(a, {
                    width: "short",
                    context: "formatting"
                }) || l.day(a, {
                    width: "narrow",
                    context: "formatting"
                }), i)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 7
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a = Qq(a, l),
            a.setUTCHours(0, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , eW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 80),
        Re(je(r), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "a":
            case "aa":
            case "aaa":
                return l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaaa":
                return l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return l.dayPeriod(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCHours(sv(l), 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , tW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 80),
        Re(je(r), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "b":
            case "bb":
            case "bbb":
                return l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbbb":
                return l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return l.dayPeriod(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCHours(sv(l), 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , nW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 80),
        Re(je(r), "incompatibleTokens", ["a", "b", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "B":
            case "BB":
            case "BBB":
                return l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBBB":
                return l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return l.dayPeriod(a, {
                    width: "wide",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "abbreviated",
                    context: "formatting"
                }) || l.dayPeriod(a, {
                    width: "narrow",
                    context: "formatting"
                })
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCHours(sv(l), 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , rW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 70),
        Re(je(r), "incompatibleTokens", ["H", "K", "k", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "h":
                return Wt(tn.hour12h, a);
            case "ho":
                return l.ordinalNumber(a, {
                    unit: "hour"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 12
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            var i = a.getUTCHours() >= 12;
            return i && l < 12 ? a.setUTCHours(l + 12, 0, 0, 0) : !i && l === 12 ? a.setUTCHours(0, 0, 0, 0) : a.setUTCHours(l, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , aW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 70),
        Re(je(r), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "H":
                return Wt(tn.hour23h, a);
            case "Ho":
                return l.ordinalNumber(a, {
                    unit: "hour"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 23
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCHours(l, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , sW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 70),
        Re(je(r), "incompatibleTokens", ["h", "H", "k", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "K":
                return Wt(tn.hour11h, a);
            case "Ko":
                return l.ordinalNumber(a, {
                    unit: "hour"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 11
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            var i = a.getUTCHours() >= 12;
            return i && l < 12 ? a.setUTCHours(l + 12, 0, 0, 0) : a.setUTCHours(l, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , lW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 70),
        Re(je(r), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "k":
                return Wt(tn.hour24h, a);
            case "ko":
                return l.ordinalNumber(a, {
                    unit: "hour"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 1 && s <= 24
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            var i = l <= 24 ? l % 24 : l;
            return a.setUTCHours(i, 0, 0, 0),
            a
        }
    }]),
    n
}(At)
  , iW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 60),
        Re(je(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "m":
                return Wt(tn.minute, a);
            case "mo":
                return l.ordinalNumber(a, {
                    unit: "minute"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 59
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMinutes(l, 0, 0),
            a
        }
    }]),
    n
}(At)
  , oW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 50),
        Re(je(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s, l) {
            switch (s) {
            case "s":
                return Wt(tn.second, a);
            case "so":
                return l.ordinalNumber(a, {
                    unit: "second"
                });
            default:
                return Qt(s.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, s) {
            return s >= 0 && s <= 59
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCSeconds(l, 0),
            a
        }
    }]),
    n
}(At)
  , uW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 30),
        Re(je(r), "incompatibleTokens", ["t", "T"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s) {
            var l = function(o) {
                return Math.floor(o * Math.pow(10, -s.length + 3))
            };
            return nn(Qt(s.length, a), l)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return a.setUTCMilliseconds(l),
            a
        }
    }]),
    n
}(At)
  , dW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 10),
        Re(je(r), "incompatibleTokens", ["t", "T", "x"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s) {
            switch (s) {
            case "X":
                return Zr(Qr.basicOptionalMinutes, a);
            case "XX":
                return Zr(Qr.basic, a);
            case "XXXX":
                return Zr(Qr.basicOptionalSeconds, a);
            case "XXXXX":
                return Zr(Qr.extendedOptionalSeconds, a);
            case "XXX":
            default:
                return Zr(Qr.extended, a)
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return s.timestampIsSet ? a : new Date(a.getTime() - l)
        }
    }]),
    n
}(At)
  , cW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 10),
        Re(je(r), "incompatibleTokens", ["t", "T", "X"]),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a, s) {
            switch (s) {
            case "x":
                return Zr(Qr.basicOptionalMinutes, a);
            case "xx":
                return Zr(Qr.basic, a);
            case "xxxx":
                return Zr(Qr.basicOptionalSeconds, a);
            case "xxxxx":
                return Zr(Qr.extendedOptionalSeconds, a);
            case "xxx":
            default:
                return Zr(Qr.extended, a)
            }
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return s.timestampIsSet ? a : new Date(a.getTime() - l)
        }
    }]),
    n
}(At)
  , fW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 40),
        Re(je(r), "incompatibleTokens", "*"),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a) {
            return dS(a)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return [new Date(l * 1e3), {
                timestampIsSet: !0
            }]
        }
    }]),
    n
}(At)
  , pW = function(t) {
    yt(n, t);
    var e = kt(n);
    function n() {
        var r;
        pt(this, n);
        for (var a = arguments.length, s = new Array(a), l = 0; l < a; l++)
            s[l] = arguments[l];
        return r = e.call.apply(e, [this].concat(s)),
        Re(je(r), "priority", 20),
        Re(je(r), "incompatibleTokens", "*"),
        r
    }
    return ht(n, [{
        key: "parse",
        value: function(a) {
            return dS(a)
        }
    }, {
        key: "set",
        value: function(a, s, l) {
            return [new Date(l), {
                timestampIsSet: !0
            }]
        }
    }]),
    n
}(At)
  , hW = {
    G: new Nq,
    y: new Dq,
    Y: new Pq,
    R: new Fq,
    u: new Bq,
    Q: new Vq,
    q: new Iq,
    M: new Rq,
    L: new Lq,
    w: new Uq,
    I: new Kq,
    d: new Wq,
    D: new Gq,
    E: new Yq,
    e: new Jq,
    c: new Xq,
    i: new Zq,
    a: new eW,
    b: new tW,
    B: new nW,
    h: new rW,
    H: new aW,
    K: new sW,
    k: new lW,
    m: new iW,
    s: new oW,
    S: new uW,
    X: new dW,
    x: new cW,
    t: new fW,
    T: new pW
}
  , mW = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g
  , vW = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g
  , gW = /^'([^]*?)'?$/
  , bW = /''/g
  , yW = /\S/
  , kW = /[a-zA-Z]/;
function mh(t, e, n, r) {
    var a, s, l, i, o, u, d, f, p, h, v, y, k, w, $, M, S, T;
    Ue(3, arguments);
    var E = String(t)
      , O = String(e)
      , U = ma()
      , L = (a = (s = r == null ? void 0 : r.locale) !== null && s !== void 0 ? s : U.locale) !== null && a !== void 0 ? a : lS;
    if (!L.match)
        throw new RangeError("locale must contain match property");
    var C = Qe((l = (i = (o = (u = r == null ? void 0 : r.firstWeekContainsDate) !== null && u !== void 0 ? u : r == null || (d = r.locale) === null || d === void 0 || (f = d.options) === null || f === void 0 ? void 0 : f.firstWeekContainsDate) !== null && o !== void 0 ? o : U.firstWeekContainsDate) !== null && i !== void 0 ? i : (p = U.locale) === null || p === void 0 || (h = p.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && l !== void 0 ? l : 1);
    if (!(C >= 1 && C <= 7))
        throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var W = Qe((v = (y = (k = (w = r == null ? void 0 : r.weekStartsOn) !== null && w !== void 0 ? w : r == null || ($ = r.locale) === null || $ === void 0 || (M = $.options) === null || M === void 0 ? void 0 : M.weekStartsOn) !== null && k !== void 0 ? k : U.weekStartsOn) !== null && y !== void 0 ? y : (S = U.locale) === null || S === void 0 || (T = S.options) === null || T === void 0 ? void 0 : T.weekStartsOn) !== null && v !== void 0 ? v : 0);
    if (!(W >= 0 && W <= 6))
        throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (O === "")
        return E === "" ? We(n) : new Date(NaN);
    var R = {
        firstWeekContainsDate: C,
        weekStartsOn: W,
        locale: L
    }, G = [new Oq], te = O.match(vW).map(function(B) {
        var se = B[0];
        if (se in ph) {
            var pe = ph[se];
            return pe(B, L.formatLong)
        }
        return B
    }).join("").match(mW), J = [], ae = py(te), oe;
    try {
        var ne = function() {
            var se = oe.value;
            !(r != null && r.useAdditionalWeekYearTokens) && sS(se) && wd(se, O, t),
            !(r != null && r.useAdditionalDayOfYearTokens) && aS(se) && wd(se, O, t);
            var pe = se[0]
              , ie = hW[pe];
            if (ie) {
                var fe = ie.incompatibleTokens;
                if (Array.isArray(fe)) {
                    var F = J.find(function(ge) {
                        return fe.includes(ge.token) || ge.token === pe
                    });
                    if (F)
                        throw new RangeError("The format string mustn't contain `".concat(F.fullToken, "` and `").concat(se, "` at the same time"))
                } else if (ie.incompatibleTokens === "*" && J.length > 0)
                    throw new RangeError("The format string mustn't contain `".concat(se, "` and any other token at the same time"));
                J.push({
                    token: pe,
                    fullToken: se
                });
                var z = ie.run(E, se, L.match, R);
                if (!z)
                    return {
                        v: new Date(NaN)
                    };
                G.push(z.setter),
                E = z.rest
            } else {
                if (pe.match(kW))
                    throw new RangeError("Format string contains an unescaped latin alphabet character `" + pe + "`");
                if (se === "''" ? se = "'" : pe === "'" && (se = _W(se)),
                E.indexOf(se) === 0)
                    E = E.slice(se.length);
                else
                    return {
                        v: new Date(NaN)
                    }
            }
        };
        for (ae.s(); !(oe = ae.n()).done; ) {
            var I = ne();
            if (xr(I) === "object")
                return I.v
        }
    } catch (B) {
        ae.e(B)
    } finally {
        ae.f()
    }
    if (E.length > 0 && yW.test(E))
        return new Date(NaN);
    var j = G.map(function(B) {
        return B.priority
    }).sort(function(B, se) {
        return se - B
    }).filter(function(B, se, pe) {
        return pe.indexOf(B) === se
    }).map(function(B) {
        return G.filter(function(se) {
            return se.priority === B
        }).sort(function(se, pe) {
            return pe.subPriority - se.subPriority
        })
    }).map(function(B) {
        return B[0]
    })
      , re = We(n);
    if (isNaN(re.getTime()))
        return new Date(NaN);
    var le = Zx(re, _d(re)), ce = {}, xe = py(j), X;
    try {
        for (xe.s(); !(X = xe.n()).done; ) {
            var be = X.value;
            if (!be.validate(le, R))
                return new Date(NaN);
            var ee = be.set(le, ce, R);
            Array.isArray(ee) ? (le = ee[0],
            gq(ce, ee[1])) : le = ee
        }
    } catch (B) {
        xe.e(B)
    } finally {
        xe.f()
    }
    return le
}
function _W(t) {
    return t.match(gW)[1].replace(bW, "'")
}
function my(t, e) {
    Ue(2, arguments);
    var n = Bo(t)
      , r = Bo(e);
    return n.getTime() === r.getTime()
}
function wW(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    return xa(t, -n)
}
function xW(t, e) {
    var n;
    Ue(1, arguments);
    var r = Qe((n = e == null ? void 0 : e.additionalDigits) !== null && n !== void 0 ? n : 2);
    if (r !== 2 && r !== 1 && r !== 0)
        throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (!(typeof t == "string" || Object.prototype.toString.call(t) === "[object String]"))
        return new Date(NaN);
    var a = CW(t), s;
    if (a.date) {
        var l = EW(a.date, r);
        s = AW(l.restDateString, l.year)
    }
    if (!s || isNaN(s.getTime()))
        return new Date(NaN);
    var i = s.getTime(), o = 0, u;
    if (a.time && (o = MW(a.time),
    isNaN(o)))
        return new Date(NaN);
    if (a.timezone) {
        if (u = OW(a.timezone),
        isNaN(u))
            return new Date(NaN)
    } else {
        var d = new Date(i + o)
          , f = new Date(0);
        return f.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()),
        f.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds()),
        f
    }
    return new Date(i + o + u)
}
var Su = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
}
  , SW = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/
  , $W = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/
  , TW = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function CW(t) {
    var e = {}, n = t.split(Su.dateTimeDelimiter), r;
    if (n.length > 2)
        return e;
    if (/:/.test(n[0]) ? r = n[0] : (e.date = n[0],
    r = n[1],
    Su.timeZoneDelimiter.test(e.date) && (e.date = t.split(Su.timeZoneDelimiter)[0],
    r = t.substr(e.date.length, t.length))),
    r) {
        var a = Su.timezone.exec(r);
        a ? (e.time = r.replace(a[1], ""),
        e.timezone = a[1]) : e.time = r
    }
    return e
}
function EW(t, e) {
    var n = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)")
      , r = t.match(n);
    if (!r)
        return {
            year: NaN,
            restDateString: ""
        };
    var a = r[1] ? parseInt(r[1]) : null
      , s = r[2] ? parseInt(r[2]) : null;
    return {
        year: s === null ? a : s * 100,
        restDateString: t.slice((r[1] || r[2]).length)
    }
}
function AW(t, e) {
    if (e === null)
        return new Date(NaN);
    var n = t.match(SW);
    if (!n)
        return new Date(NaN);
    var r = !!n[4]
      , a = Ui(n[1])
      , s = Ui(n[2]) - 1
      , l = Ui(n[3])
      , i = Ui(n[4])
      , o = Ui(n[5]) - 1;
    if (r)
        return BW(e, i, o) ? NW(e, i, o) : new Date(NaN);
    var u = new Date(0);
    return !PW(e, s, l) || !FW(e, a) ? new Date(NaN) : (u.setUTCFullYear(e, s, Math.max(a, l)),
    u)
}
function Ui(t) {
    return t ? parseInt(t) : 1
}
function MW(t) {
    var e = t.match($W);
    if (!e)
        return NaN;
    var n = jf(e[1])
      , r = jf(e[2])
      , a = jf(e[3]);
    return VW(n, r, a) ? n * rv + r * nv + a * 1e3 : NaN
}
function jf(t) {
    return t && parseFloat(t.replace(",", ".")) || 0
}
function OW(t) {
    if (t === "Z")
        return 0;
    var e = t.match(TW);
    if (!e)
        return 0;
    var n = e[1] === "+" ? -1 : 1
      , r = parseInt(e[2])
      , a = e[3] && parseInt(e[3]) || 0;
    return IW(r, a) ? n * (r * rv + a * nv) : NaN
}
function NW(t, e, n) {
    var r = new Date(0);
    r.setUTCFullYear(t, 0, 4);
    var a = r.getUTCDay() || 7
      , s = (e - 1) * 7 + n + 1 - a;
    return r.setUTCDate(r.getUTCDate() + s),
    r
}
var DW = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function pS(t) {
    return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0
}
function PW(t, e, n) {
    return e >= 0 && e <= 11 && n >= 1 && n <= (DW[e] || (pS(t) ? 29 : 28))
}
function FW(t, e) {
    return e >= 1 && e <= (pS(t) ? 366 : 365)
}
function BW(t, e, n) {
    return e >= 1 && e <= 53 && n >= 0 && n <= 6
}
function VW(t, e, n) {
    return t === 24 ? e === 0 && n === 0 : n >= 0 && n < 60 && e >= 0 && e < 60 && t >= 0 && t < 25
}
function IW(t, e) {
    return e >= 0 && e <= 59
}
function hS(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e)
      , a = n.getFullYear()
      , s = n.getDate()
      , l = new Date(0);
    l.setFullYear(a, r, 15),
    l.setHours(0, 0, 0, 0);
    var i = yq(l);
    return n.setMonth(r, Math.min(s, i)),
    n
}
function Ut(t, e) {
    if (Ue(2, arguments),
    xr(e) !== "object" || e === null)
        throw new RangeError("values parameter must be an object");
    var n = We(t);
    return isNaN(n.getTime()) ? new Date(NaN) : (e.year != null && n.setFullYear(e.year),
    e.month != null && (n = hS(n, e.month)),
    e.date != null && n.setDate(Qe(e.date)),
    e.hours != null && n.setHours(Qe(e.hours)),
    e.minutes != null && n.setMinutes(Qe(e.minutes)),
    e.seconds != null && n.setSeconds(Qe(e.seconds)),
    e.milliseconds != null && n.setMilliseconds(Qe(e.milliseconds)),
    n)
}
function mS(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return n.setHours(r),
    n
}
function iv(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return n.setMilliseconds(r),
    n
}
function vS(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return n.setMinutes(r),
    n
}
function ov(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return n.setSeconds(r),
    n
}
function tl(t, e) {
    Ue(2, arguments);
    var n = We(t)
      , r = Qe(e);
    return isNaN(n.getTime()) ? new Date(NaN) : (n.setFullYear(r),
    n)
}
function yi(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    return Pr(t, -n)
}
function RW(t, e) {
    if (Ue(2, arguments),
    !e || xr(e) !== "object")
        return new Date(NaN);
    var n = e.years ? Qe(e.years) : 0
      , r = e.months ? Qe(e.months) : 0
      , a = e.weeks ? Qe(e.weeks) : 0
      , s = e.days ? Qe(e.days) : 0
      , l = e.hours ? Qe(e.hours) : 0
      , i = e.minutes ? Qe(e.minutes) : 0
      , o = e.seconds ? Qe(e.seconds) : 0
      , u = yi(t, r + n * 12)
      , d = wW(u, s + a * 7)
      , f = i + l * 60
      , p = o + f * 60
      , h = p * 1e3
      , v = new Date(d.getTime() - h);
    return v
}
function gS(t, e) {
    Ue(2, arguments);
    var n = Qe(e);
    return tv(t, -n)
}
function eu() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
    }), c("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
    }), c("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
    }), c("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
    })])
}
eu.compatConfig = {
    MODE: 3
};
function bS() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
    }), c("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
    })])
}
bS.compatConfig = {
    MODE: 3
};
function uv() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
    })])
}
uv.compatConfig = {
    MODE: 3
};
function dv() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
    })])
}
dv.compatConfig = {
    MODE: 3
};
function cv() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
    }), c("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
    })])
}
cv.compatConfig = {
    MODE: 3
};
function fv() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
    })])
}
fv.compatConfig = {
    MODE: 3
};
function pv() {
    return g(),
    _("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 32 32",
        fill: "currentColor",
        "aria-hidden": "true",
        class: "dp__icon"
    }, [c("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
    })])
}
pv.compatConfig = {
    MODE: 3
};
function hv(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var yS = {
    exports: {}
};
(function(t) {
    function e(n) {
        return n && n.__esModule ? n : {
            default: n
        }
    }
    t.exports = e,
    t.exports.__esModule = !0,
    t.exports.default = t.exports
}
)(yS);
var LW = yS.exports
  , vh = {
    exports: {}
};
(function(t, e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.default = n;
    function n(r) {
        if (r === null || r === !0 || r === !1)
            return NaN;
        var a = Number(r);
        return isNaN(a) ? a : a < 0 ? Math.ceil(a) : Math.floor(a)
    }
    t.exports = e.default
}
)(vh, vh.exports);
var jW = vh.exports;
const UW = hv(jW);
var gh = {
    exports: {}
};
(function(t, e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.default = n;
    function n(r) {
        var a = new Date(Date.UTC(r.getFullYear(), r.getMonth(), r.getDate(), r.getHours(), r.getMinutes(), r.getSeconds(), r.getMilliseconds()));
        return a.setUTCFullYear(r.getFullYear()),
        r.getTime() - a.getTime()
    }
    t.exports = e.default
}
)(gh, gh.exports);
var HW = gh.exports;
const vy = hv(HW);
function KW(t, e) {
    var n = GW(e);
    return n.formatToParts ? qW(n, t) : WW(n, t)
}
var zW = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
};
function qW(t, e) {
    try {
        for (var n = t.formatToParts(e), r = [], a = 0; a < n.length; a++) {
            var s = zW[n[a].type];
            s >= 0 && (r[s] = parseInt(n[a].value, 10))
        }
        return r
    } catch (l) {
        if (l instanceof RangeError)
            return [NaN];
        throw l
    }
}
function WW(t, e) {
    var n = t.format(e).replace(/\u200E/g, "")
      , r = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(n);
    return [r[3], r[1], r[2], r[4], r[5], r[6]]
}
var Uf = {};
function GW(t) {
    if (!Uf[t]) {
        var e = new Intl.DateTimeFormat("en-US",{
            hour12: !1,
            timeZone: "America/New_York",
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }).format(new Date("2014-06-25T04:00:00.123Z"))
          , n = e === "06/25/2014, 00:00:00" || e === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
        Uf[t] = n ? new Intl.DateTimeFormat("en-US",{
            hour12: !1,
            timeZone: t,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        }) : new Intl.DateTimeFormat("en-US",{
            hourCycle: "h23",
            timeZone: t,
            year: "numeric",
            month: "numeric",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
        })
    }
    return Uf[t]
}
function mv(t, e, n, r, a, s, l) {
    var i = new Date(0);
    return i.setUTCFullYear(t, e, n),
    i.setUTCHours(r, a, s, l),
    i
}
var gy = 36e5
  , YW = 6e4
  , Hf = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function vv(t, e, n) {
    var r, a;
    if (!t || (r = Hf.timezoneZ.exec(t),
    r))
        return 0;
    var s;
    if (r = Hf.timezoneHH.exec(t),
    r)
        return s = parseInt(r[1], 10),
        by(s) ? -(s * gy) : NaN;
    if (r = Hf.timezoneHHMM.exec(t),
    r) {
        s = parseInt(r[1], 10);
        var l = parseInt(r[2], 10);
        return by(s, l) ? (a = Math.abs(s) * gy + l * YW,
        s > 0 ? -a : a) : NaN
    }
    if (QW(t)) {
        e = new Date(e || Date.now());
        var i = n ? e : JW(e)
          , o = bh(i, t)
          , u = n ? o : XW(e, o, t);
        return -u
    }
    return NaN
}
function JW(t) {
    return mv(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())
}
function bh(t, e) {
    var n = KW(t, e)
      , r = mv(n[0], n[1] - 1, n[2], n[3] % 24, n[4], n[5], 0).getTime()
      , a = t.getTime()
      , s = a % 1e3;
    return a -= s >= 0 ? s : 1e3 + s,
    r - a
}
function XW(t, e, n) {
    var r = t.getTime()
      , a = r - e
      , s = bh(new Date(a), n);
    if (e === s)
        return e;
    a -= s - e;
    var l = bh(new Date(a), n);
    return s === l ? s : Math.max(s, l)
}
function by(t, e) {
    return -23 <= t && t <= 23 && (e == null || 0 <= e && e <= 59)
}
var yy = {};
function QW(t) {
    if (yy[t])
        return !0;
    try {
        return new Intl.DateTimeFormat(void 0,{
            timeZone: t
        }),
        yy[t] = !0,
        !0
    } catch {
        return !1
    }
}
var kS = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/
  , Kf = 36e5
  , ky = 6e4
  , ZW = 2
  , Un = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    YY: /^(\d{2})$/,
    YYY: [/^([+-]\d{2})$/, /^([+-]\d{3})$/, /^([+-]\d{4})$/],
    YYYY: /^(\d{4})/,
    YYYYY: [/^([+-]\d{4})/, /^([+-]\d{5})/, /^([+-]\d{6})/],
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    timeZone: kS
};
function yh(t, e) {
    if (arguments.length < 1)
        throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (t === null)
        return new Date(NaN);
    var n = e || {}
      , r = n.additionalDigits == null ? ZW : UW(n.additionalDigits);
    if (r !== 2 && r !== 1 && r !== 0)
        throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]")
        return new Date(t.getTime());
    if (typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]")
        return new Date(t);
    if (!(typeof t == "string" || Object.prototype.toString.call(t) === "[object String]"))
        return new Date(NaN);
    var a = eG(t)
      , s = tG(a.date, r)
      , l = s.year
      , i = s.restDateString
      , o = nG(i, l);
    if (isNaN(o))
        return new Date(NaN);
    if (o) {
        var u = o.getTime(), d = 0, f;
        if (a.time && (d = rG(a.time),
        isNaN(d)))
            return new Date(NaN);
        if (a.timeZone || n.timeZone) {
            if (f = vv(a.timeZone || n.timeZone, new Date(u + d)),
            isNaN(f))
                return new Date(NaN)
        } else
            f = vy(new Date(u + d)),
            f = vy(new Date(u + d + f));
        return new Date(u + d + f)
    } else
        return new Date(NaN)
}
function eG(t) {
    var e = {}, n = Un.dateTimePattern.exec(t), r;
    if (n ? (e.date = n[1],
    r = n[3]) : (n = Un.datePattern.exec(t),
    n ? (e.date = n[1],
    r = n[2]) : (e.date = null,
    r = t)),
    r) {
        var a = Un.timeZone.exec(r);
        a ? (e.time = r.replace(a[1], ""),
        e.timeZone = a[1].trim()) : e.time = r
    }
    return e
}
function tG(t, e) {
    var n = Un.YYY[e], r = Un.YYYYY[e], a;
    if (a = Un.YYYY.exec(t) || r.exec(t),
    a) {
        var s = a[1];
        return {
            year: parseInt(s, 10),
            restDateString: t.slice(s.length)
        }
    }
    if (a = Un.YY.exec(t) || n.exec(t),
    a) {
        var l = a[1];
        return {
            year: parseInt(l, 10) * 100,
            restDateString: t.slice(l.length)
        }
    }
    return {
        year: null
    }
}
function nG(t, e) {
    if (e === null)
        return null;
    var n, r, a, s;
    if (t.length === 0)
        return r = new Date(0),
        r.setUTCFullYear(e),
        r;
    if (n = Un.MM.exec(t),
    n)
        return r = new Date(0),
        a = parseInt(n[1], 10) - 1,
        wy(e, a) ? (r.setUTCFullYear(e, a),
        r) : new Date(NaN);
    if (n = Un.DDD.exec(t),
    n) {
        r = new Date(0);
        var l = parseInt(n[1], 10);
        return lG(e, l) ? (r.setUTCFullYear(e, 0, l),
        r) : new Date(NaN)
    }
    if (n = Un.MMDD.exec(t),
    n) {
        r = new Date(0),
        a = parseInt(n[1], 10) - 1;
        var i = parseInt(n[2], 10);
        return wy(e, a, i) ? (r.setUTCFullYear(e, a, i),
        r) : new Date(NaN)
    }
    if (n = Un.Www.exec(t),
    n)
        return s = parseInt(n[1], 10) - 1,
        xy(e, s) ? _y(e, s) : new Date(NaN);
    if (n = Un.WwwD.exec(t),
    n) {
        s = parseInt(n[1], 10) - 1;
        var o = parseInt(n[2], 10) - 1;
        return xy(e, s, o) ? _y(e, s, o) : new Date(NaN)
    }
    return null
}
function rG(t) {
    var e, n, r;
    if (e = Un.HH.exec(t),
    e)
        return n = parseFloat(e[1].replace(",", ".")),
        zf(n) ? n % 24 * Kf : NaN;
    if (e = Un.HHMM.exec(t),
    e)
        return n = parseInt(e[1], 10),
        r = parseFloat(e[2].replace(",", ".")),
        zf(n, r) ? n % 24 * Kf + r * ky : NaN;
    if (e = Un.HHMMSS.exec(t),
    e) {
        n = parseInt(e[1], 10),
        r = parseInt(e[2], 10);
        var a = parseFloat(e[3].replace(",", "."));
        return zf(n, r, a) ? n % 24 * Kf + r * ky + a * 1e3 : NaN
    }
    return null
}
function _y(t, e, n) {
    e = e || 0,
    n = n || 0;
    var r = new Date(0);
    r.setUTCFullYear(t, 0, 4);
    var a = r.getUTCDay() || 7
      , s = e * 7 + n + 1 - a;
    return r.setUTCDate(r.getUTCDate() + s),
    r
}
var aG = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  , sG = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function _S(t) {
    return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0
}
function wy(t, e, n) {
    if (e < 0 || e > 11)
        return !1;
    if (n != null) {
        if (n < 1)
            return !1;
        var r = _S(t);
        if (r && n > sG[e] || !r && n > aG[e])
            return !1
    }
    return !0
}
function lG(t, e) {
    if (e < 1)
        return !1;
    var n = _S(t);
    return !(n && e > 366 || !n && e > 365)
}
function xy(t, e, n) {
    return !(e < 0 || e > 52 || n != null && (n < 0 || n > 6))
}
function zf(t, e, n) {
    return !(t != null && (t < 0 || t >= 25) || e != null && (e < 0 || e >= 60) || n != null && (n < 0 || n >= 60))
}
var kh = {
    exports: {}
}
  , _h = {
    exports: {}
};
(function(t, e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.default = n;
    function n(r, a) {
        if (r == null)
            throw new TypeError("assign requires that input parameter not be null or undefined");
        for (var s in a)
            Object.prototype.hasOwnProperty.call(a, s) && (r[s] = a[s]);
        return r
    }
    t.exports = e.default
}
)(_h, _h.exports);
var iG = _h.exports;
(function(t, e) {
    var n = LW.default;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.default = a;
    var r = n(iG);
    function a(s) {
        return (0,
        r.default)({}, s)
    }
    t.exports = e.default
}
)(kh, kh.exports);
var oG = kh.exports;
const uG = hv(oG);
function dG(t, e, n) {
    var r = yh(t, n)
      , a = vv(e, r, !0)
      , s = new Date(r.getTime() - a)
      , l = new Date(0);
    return l.setFullYear(s.getUTCFullYear(), s.getUTCMonth(), s.getUTCDate()),
    l.setHours(s.getUTCHours(), s.getUTCMinutes(), s.getUTCSeconds(), s.getUTCMilliseconds()),
    l
}
function cG(t, e, n) {
    if (typeof t == "string" && !t.match(kS)) {
        var r = uG(n);
        return r.timeZone = e,
        yh(t, r)
    }
    var a = yh(t, n)
      , s = mv(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds()).getTime()
      , l = vv(e, new Date(s));
    return new Date(s + l)
}
function Sy(t) {
    return e => new Intl.DateTimeFormat(t,{
        weekday: "short",
        timeZone: "UTC"
    }).format(new Date(`2017-01-0${e}T00:00:00+00:00`)).slice(0, 2)
}
function fG(t) {
    return e => fs(new Date(`2017-01-0${e}T00:00:00+00:00`), "EEEEEE", {
        locale: t
    })
}
const pG = (t, e, n) => {
    const r = [1, 2, 3, 4, 5, 6, 7];
    let a;
    if (t !== null)
        try {
            a = r.map(fG(t))
        } catch {
            a = r.map(Sy(e))
        }
    else
        a = r.map(Sy(e));
    const s = a.slice(0, n)
      , l = a.slice(n + 1, a.length);
    return [a[n]].concat(...l).concat(...s)
}
  , gv = (t, e) => {
    const n = [];
    for (let r = +t[0]; r <= +t[1]; r++)
        n.push({
            value: +r,
            text: `${r}`
        });
    return e ? n.reverse() : n
}
  , wS = (t, e, n) => {
    const r = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(s => {
        const l = s < 10 ? `0${s}` : s;
        return new Date(`2017-${l}-01T00:00:00+00:00`)
    }
    );
    if (t !== null)
        try {
            const s = n === "long" ? "MMMM" : "MMM";
            return r.map( (l, i) => {
                const o = fs(l, s, {
                    locale: t
                });
                return {
                    text: o.charAt(0).toUpperCase() + o.substring(1),
                    value: i
                }
            }
            )
        } catch {}
    const a = new Intl.DateTimeFormat(e,{
        month: n,
        timeZone: "UTC"
    });
    return r.map( (s, l) => {
        const i = a.format(s);
        return {
            text: i.charAt(0).toUpperCase() + i.substring(1),
            value: l
        }
    }
    )
}
  , hG = t => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][t]
  , fn = t => {
    const e = A(t);
    return e != null && e.$el ? e == null ? void 0 : e.$el : e
}
  , mG = t => Object.assign({
    type: "dot"
}, t)
  , xS = t => Array.isArray(t) ? !!t[0] && !!t[1] : !1
  , $d = {
    prop: t => `"${t}" prop must be enabled!`,
    dateArr: t => `You need to use array as "model-value" binding in order to support "${t}"`
}
  , hn = t => t
  , $y = t => t === 0 ? t : !t || isNaN(+t) ? null : +t
  , Ty = t => t === null
  , vG = t => {
    if (t)
        return [...t.querySelectorAll("input, button, select, textarea, a[href]")][0]
}
  , gG = t => {
    const e = []
      , n = r => r.filter(a => a);
    for (let r = 0; r < t.length; r += 3) {
        const a = [t[r], t[r + 1], t[r + 2]];
        e.push(n(a))
    }
    return e
}
  , Ro = (t, e, n) => {
    const r = n ?? n === 0
      , a = e ?? e === 0;
    if (!r && !a)
        return !1;
    const s = +n
      , l = +e;
    return r && a ? +t > s || +t < l : r ? +t > s : a ? +t < l : !1
}
  , ki = (t, e) => gG(t).map(n => n.map(r => {
    const {active: a, disabled: s, isBetween: l, highlighted: i} = e(r);
    return {
        ...r,
        active: a,
        disabled: s,
        className: {
            dp__overlay_cell_active: a,
            dp__overlay_cell: !a,
            dp__overlay_cell_disabled: s,
            dp__overlay_cell_pad: !0,
            dp__overlay_cell_active_disabled: s && a,
            dp__cell_in_between: l,
            "dp--highlighted": i
        }
    }
}
))
  , ps = (t, e, n=!1) => {
    t && e.allowStopPropagation && (n && t.stopImmediatePropagation(),
    t.stopPropagation())
}
  , Cy = (t, e, n, r, a) => {
    const s = mh(t, e.slice(0, t.length), new Date);
    return mo(s) && Xx(s) ? r || a ? s : Ut(s, {
        hours: +n.hours,
        minutes: +(n == null ? void 0 : n.minutes),
        seconds: +(n == null ? void 0 : n.seconds),
        milliseconds: 0
    }) : null
}
  , bG = (t, e, n, r, a) => {
    const s = Array.isArray(n) ? n[0] : n;
    if (typeof e == "string")
        return Cy(t, e, s, r, a);
    if (Array.isArray(e)) {
        let l = null;
        for (const i of e)
            if (l = Cy(t, i, s, r, a),
            l)
                break;
        return l
    }
    return typeof e == "function" ? e(t) : null
}
  , Me = t => t ? new Date(t) : new Date
  , yG = (t, e, n) => {
    if (e) {
        const a = (t.getMonth() + 1).toString().padStart(2, "0")
          , s = t.getDate().toString().padStart(2, "0")
          , l = t.getHours().toString().padStart(2, "0")
          , i = t.getMinutes().toString().padStart(2, "0")
          , o = n ? t.getSeconds().toString().padStart(2, "0") : "00";
        return `${t.getFullYear()}-${a}-${s}T${l}:${i}:${o}.000Z`
    }
    const r = Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds());
    return new Date(r).toISOString()
}
  , Sr = t => {
    let e = Me(JSON.parse(JSON.stringify(t)));
    return e = mS(e, 0),
    e = vS(e, 0),
    e = ov(e, 0),
    e = iv(e, 0),
    e
}
  , hs = (t, e, n, r) => {
    let a = t ? Me(t) : Me();
    return (e || e === 0) && (a = mS(a, +e)),
    (n || n === 0) && (a = vS(a, +n)),
    (r || r === 0) && (a = ov(a, +r)),
    iv(a, 0)
}
  , An = (t, e) => !t || !e ? !1 : Io(Sr(t), Sr(e))
  , xt = (t, e) => !t || !e ? !1 : Kl(Sr(t), Sr(e))
  , Pn = (t, e) => !t || !e ? !1 : Vo(Sr(t), Sr(e))
  , Tc = (t, e, n) => t != null && t[0] && t != null && t[1] ? Pn(n, t[0]) && An(n, t[1]) : t != null && t[0] && e ? Pn(n, t[0]) && An(n, e) || An(n, t[0]) && Pn(n, e) : !1
  , Mr = t => {
    const e = Ut(new Date(t), {
        date: 1
    });
    return Sr(e)
}
  , qf = (t, e, n) => e && (n || n === 0) ? Object.fromEntries(["hours", "minutes", "seconds"].map(r => r === e ? [r, n] : [r, isNaN(+t[r]) ? void 0 : +t[r]])) : {
    hours: isNaN(+t.hours) ? void 0 : +t.hours,
    minutes: isNaN(+t.minutes) ? void 0 : +t.minutes,
    seconds: isNaN(+t.seconds) ? void 0 : +t.seconds
}
  , nl = t => ({
    hours: Fr(t),
    minutes: sa(t),
    seconds: bi(t)
})
  , SS = (t, e) => {
    if (e) {
        const n = ct(Me(e));
        if (n > t)
            return 12;
        if (n === t)
            return gt(Me(e))
    }
}
  , $S = (t, e) => {
    if (e) {
        const n = ct(Me(e));
        return n < t ? -1 : n === t ? gt(Me(e)) : void 0
    }
}
  , _i = t => {
    if (t)
        return ct(Me(t))
}
  , gr = (t, e) => e ? dG(t, e) : t
  , TS = (t, e) => e ? cG(t, e) : t
  , Ey = t => t instanceof Date ? t : xW(t)
  , CS = (t, e) => {
    const n = Pn(t, e) ? e : t
      , r = Pn(e, t) ? e : t;
    return Qx({
        start: n,
        end: r
    })
}
  , kG = t => {
    const e = Pr(t, 1);
    return {
        month: gt(e),
        year: ct(e)
    }
}
  , Ru = (t, e, n) => {
    const r = ul(gr(t, e), {
        weekStartsOn: +n
    })
      , a = p9(gr(t, e), {
        weekStartsOn: +n
    });
    return [r, a]
}
  , ES = (t, e) => {
    const n = {
        hours: Fr(Me()),
        minutes: sa(Me()),
        seconds: e ? bi(Me()) : 0
    };
    return Object.assign(n, t)
}
  , as = (t, e, n) => [Ut(Me(t), {
    date: 1
}), Ut(Me(), {
    month: e,
    year: n,
    date: 1
})]
  , Sa = (t, e, n) => {
    let r = t ? Me(t) : Me();
    return (e || e === 0) && (r = hS(r, e)),
    n && (r = tl(r, n)),
    r
}
  , AS = (t, e, n, r, a) => {
    if (!r || a && !e || !a && !n)
        return !1;
    const s = a ? Pr(t, 1) : yi(t, 1)
      , l = [gt(s), ct(s)];
    return a ? !wG(...l, e) : !_G(...l, n)
}
  , _G = (t, e, n) => An(...as(n, t, e)) || xt(...as(n, t, e))
  , wG = (t, e, n) => Pn(...as(n, t, e)) || xt(...as(n, t, e))
  , MS = (t, e, n, r, a, s, l) => {
    if (typeof e == "function" && !l)
        return e(t);
    const i = n ? {
        locale: n
    } : void 0;
    return Array.isArray(t) ? `${fs(t[0], s, i)}${a && !t[1] ? "" : r}${t[1] ? fs(t[1], s, i) : ""}` : fs(t, s, i)
}
  , Pl = t => {
    if (t)
        return null;
    throw new Error($d.prop("partial-range"))
}
  , $u = (t, e) => {
    if (e)
        return t();
    throw new Error($d.prop("range"))
}
  , wh = t => Array.isArray(t) ? mo(t[0]) && (t[1] ? mo(t[1]) : !0) : t ? mo(t) : !1
  , xG = t => Ut(Me(), {
    hours: +t.hours || 0,
    minutes: +t.minutes || 0,
    seconds: +t.seconds || 0
})
  , Wf = (t, e, n, r) => {
    if (!t)
        return !0;
    if (r) {
        const a = n === "max" ? Io(t, e) : Vo(t, e)
          , s = {
            seconds: 0,
            milliseconds: 0
        };
        return a || Kl(Ut(t, s), Ut(e, s))
    }
    return n === "max" ? t.getTime() <= e.getTime() : t.getTime() >= e.getTime()
}
  , Ay = (t, e, n, r, a) => {
    const s = t ? xG(t) : Me(e);
    return Array.isArray(r) ? Wf(r[0], s, n, !!e) && Wf(r[1], s, n, !!e) && a : Wf(r, s, n, !!e) && a
}
  , Gf = t => Ut(Me(), nl(t))
  , SG = (t, e) => Array.isArray(t) ? t.map(n => Me(n)).filter(n => ct(Me(n)) === e).map(n => gt(n)) : []
  , OS = (t, e, n) => typeof t == "function" ? t({
    month: e,
    year: n
}) : !!t.months.find(r => r.month === e && r.year === n)
  , bv = (t, e) => typeof t == "function" ? t(e) : t.years.includes(e)
  , Hi = Fn({
    menuFocused: !1,
    shiftKeyInMenu: !1
})
  , NS = () => {
    const t = n => {
        Hi.menuFocused = n
    }
      , e = n => {
        Hi.shiftKeyInMenu !== n && (Hi.shiftKeyInMenu = n)
    }
    ;
    return {
        control: K( () => ({
            shiftKeyInMenu: Hi.shiftKeyInMenu,
            menuFocused: Hi.menuFocused
        })),
        setMenuFocused: t,
        setShiftKey: e
    }
}
  , Lt = Fn({
    monthYear: [],
    calendar: [],
    time: [],
    actionRow: [],
    selectionGrid: [],
    timePicker: {
        0: [],
        1: []
    },
    monthPicker: []
})
  , Yf = me(null)
  , Tu = me(!1)
  , Jf = me(!1)
  , Xf = me(!1)
  , Qf = me(!1)
  , Rn = me(0)
  , wn = me(0)
  , Ms = () => {
    const t = K( () => Tu.value ? [...Lt.selectionGrid, Lt.actionRow].filter(f => f.length) : Jf.value ? [...Lt.timePicker[0], ...Lt.timePicker[1], Qf.value ? [] : [Yf.value], Lt.actionRow].filter(f => f.length) : Xf.value ? [...Lt.monthPicker, Lt.actionRow] : [Lt.monthYear, ...Lt.calendar, Lt.time, Lt.actionRow].filter(f => f.length))
      , e = f => {
        Rn.value = f ? Rn.value + 1 : Rn.value - 1;
        let p = null;
        t.value[wn.value] && (p = t.value[wn.value][Rn.value]),
        p || (Rn.value = f ? Rn.value - 1 : Rn.value + 1)
    }
      , n = f => {
        wn.value === 0 && !f || wn.value === t.value.length && f || (wn.value = f ? wn.value + 1 : wn.value - 1,
        t.value[wn.value] ? t.value[wn.value] && !t.value[wn.value][Rn.value] && Rn.value !== 0 && (Rn.value = t.value[wn.value].length - 1) : wn.value = f ? wn.value - 1 : wn.value + 1)
    }
      , r = f => {
        let p = null;
        t.value[wn.value] && (p = t.value[wn.value][Rn.value]),
        p ? p.focus({
            preventScroll: !Tu.value
        }) : Rn.value = f ? Rn.value - 1 : Rn.value + 1
    }
      , a = () => {
        e(!0),
        r(!0)
    }
      , s = () => {
        e(!1),
        r(!1)
    }
      , l = () => {
        n(!1),
        r(!0)
    }
      , i = () => {
        n(!0),
        r(!0)
    }
      , o = (f, p) => {
        Lt[p] = f
    }
      , u = (f, p) => {
        Lt[p] = f
    }
      , d = () => {
        Rn.value = 0,
        wn.value = 0
    }
    ;
    return {
        buildMatrix: o,
        buildMultiLevelMatrix: u,
        setTimePickerBackRef: f => {
            Yf.value = f
        }
        ,
        setSelectionGrid: f => {
            Tu.value = f,
            d(),
            f || (Lt.selectionGrid = [])
        }
        ,
        setTimePicker: (f, p=!1) => {
            Jf.value = f,
            Qf.value = p,
            d(),
            f || (Lt.timePicker[0] = [],
            Lt.timePicker[1] = [])
        }
        ,
        setTimePickerElements: (f, p=0) => {
            Lt.timePicker[p] = f
        }
        ,
        arrowRight: a,
        arrowLeft: s,
        arrowUp: l,
        arrowDown: i,
        clearArrowNav: () => {
            Lt.monthYear = [],
            Lt.calendar = [],
            Lt.time = [],
            Lt.actionRow = [],
            Lt.selectionGrid = [],
            Lt.timePicker[0] = [],
            Lt.timePicker[1] = [],
            Tu.value = !1,
            Jf.value = !1,
            Qf.value = !1,
            Xf.value = !1,
            d(),
            Yf.value = null
        }
        ,
        setMonthPicker: f => {
            Xf.value = f,
            d()
        }
        ,
        refSets: Lt
    }
}
  , My = t => ({
    menuAppearTop: "dp-menu-appear-top",
    menuAppearBottom: "dp-menu-appear-bottom",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down",
    ...t ?? {}
})
  , $G = t => ({
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: e => `Increment ${e}`,
    decrementValue: e => `Decrement ${e}`,
    openTpOverlay: e => `Open ${e} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    nextYear: "Next year",
    prevYear: "Previous year",
    day: () => "",
    ...t ?? {}
})
  , Oy = t => t ? typeof t == "boolean" ? t ? 2 : 0 : +t >= 2 ? +t : 2 : 0
  , TG = t => {
    const e = typeof t == "object" && t
      , n = {
        static: !0,
        solo: !1
    };
    if (!t)
        return {
            ...n,
            count: Oy(!1)
        };
    const r = e ? t : {}
      , a = e ? r.count ?? !0 : t
      , s = Oy(a);
    return Object.assign(n, r, {
        count: s
    })
}
  , CG = (t, e, n) => t || (typeof n == "string" ? n : e)
  , EG = t => typeof t == "boolean" ? t ? My({}) : !1 : My(t)
  , AG = t => {
    const e = {
        enterSubmit: !0,
        tabSubmit: !0,
        openMenu: !0,
        selectOnFocus: !1,
        rangeSeparator: " - "
    };
    return typeof t == "object" ? {
        ...e,
        ...t ?? {},
        enabled: !0
    } : {
        ...e,
        enabled: t
    }
}
  , MG = t => ({
    months: [],
    years: [],
    times: {
        hours: [],
        minutes: [],
        seconds: []
    },
    ...t ?? {}
})
  , OG = t => ({
    showSelect: !0,
    showCancel: !0,
    showNow: !1,
    showPreview: !0,
    ...t ?? {}
})
  , NG = t => {
    const e = {
        input: !1
    };
    return typeof t == "object" ? {
        ...e,
        ...t ?? {},
        enabled: !0
    } : {
        enabled: t,
        ...e
    }
}
  , DG = t => ({
    allowStopPropagation: !0,
    closeOnScroll: !1,
    modeHeight: 255,
    allowPreventDefault: !1,
    closeOnClearValue: !0,
    closeOnAutoApply: !0,
    noSwipe: !1,
    keepActionRow: !1,
    onClickOutside: void 0,
    ...t ?? {}
})
  , PG = (t, e, n) => {
    const r = {
        dates: Array.isArray(t) ? t.map(a => Me(a)) : [],
        years: [],
        months: [],
        quarters: [],
        weeks: [],
        weekdays: e,
        options: {
            highlightDisabled: n
        }
    };
    return typeof t == "function" ? t : {
        ...r,
        ...t ?? {}
    }
}
  , sn = t => {
    const e = () => {
        const k = t.enableSeconds ? ":ss" : "";
        return t.is24 ? `HH:mm${k}` : `hh:mm${k} aa`
    }
      , n = () => t.format ? t.format : t.monthPicker ? "MM/yyyy" : t.timePicker ? e() : t.weekPicker ? "MM/dd/yyyy" : t.yearPicker ? "yyyy" : t.quarterPicker ? "QQQ/yyyy" : t.enableTimePicker ? `MM/dd/yyyy, ${e()}` : "MM/dd/yyyy"
      , r = k => ES(k, t.enableSeconds)
      , a = () => t.range ? t.startTime && Array.isArray(t.startTime) ? [r(t.startTime[0]), r(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? r(t.startTime) : null
      , s = K( () => TG(t.multiCalendars))
      , l = K( () => a())
      , i = K( () => $G(t.ariaLabels))
      , o = K( () => MG(t.filters))
      , u = K( () => EG(t.transitions))
      , d = K( () => OG(t.actionRow))
      , f = K( () => CG(t.previewFormat, t.format, n()))
      , p = K( () => AG(t.textInput))
      , h = K( () => NG(t.inline))
      , v = K( () => DG(t.config))
      , y = K( () => PG(t.highlight, t.highlightWeekDays, t.highlightDisabledDays));
    return {
        defaultedTransitions: u,
        defaultedMultiCalendars: s,
        defaultedStartTime: l,
        defaultedAriaLabels: i,
        defaultedFilters: o,
        defaultedActionRow: d,
        defaultedPreviewFormat: f,
        defaultedTextInput: p,
        defaultedInline: h,
        defaultedConfig: v,
        defaultedHighlight: y,
        getDefaultPattern: n,
        getDefaultStartTime: a
    }
}
  , FG = (t, e, n) => {
    const r = me()
      , {defaultedTextInput: a, getDefaultPattern: s} = sn(e)
      , l = me("")
      , i = _e(e, "format");
    Ke(r, () => {
        t("internal-model-change", r.value)
    }
    ),
    Ke(i, () => {
        te()
    }
    );
    const o = j => TS(j, e.timezone)
      , u = j => gr(j, e.timezone)
      , d = (j, re, le=!1) => MS(j, e.format, e.formatLocale, a.value.rangeSeparator, e.modelAuto, re ?? s(), le)
      , f = j => j ? e.modelType ? ae(j) : {
        hours: Fr(j),
        minutes: sa(j),
        seconds: e.enableSeconds ? bi(j) : 0
    } : null
      , p = j => e.modelType ? ae(j) : {
        month: gt(j),
        year: ct(j)
    }
      , h = j => Array.isArray(j) ? $u( () => [tl(Me(), j[0]), j[1] ? tl(Me(), j[1]) : Pl(e.partialRange)], e.range) : tl(Me(), +j)
      , v = (j, re) => (typeof j == "string" || typeof j == "number") && e.modelType ? J(j) : re
      , y = j => Array.isArray(j) ? [v(j[0], hs(null, +j[0].hours, +j[0].minutes, j[0].seconds)), v(j[1], hs(null, +j[1].hours, +j[1].minutes, j[1].seconds))] : v(j, hs(null, j.hours, j.minutes, j.seconds))
      , k = j => Array.isArray(j) ? e.multiDates ? j.map(re => v(re, Sa(null, +re.month, +re.year))) : $u( () => [v(j[0], Sa(null, +j[0].month, +j[0].year)), v(j[1], j[1] ? Sa(null, +j[1].month, +j[1].year) : Pl(e.partialRange))], e.range) : v(j, Sa(null, +j.month, +j.year))
      , w = j => {
        if (Array.isArray(j))
            return j.map(re => J(re));
        throw new Error($d.dateArr("multi-dates"))
    }
      , $ = j => {
        if (Array.isArray(j))
            return [Me(j[0]), Me(j[1])];
        throw new Error($d.dateArr("week-picker"))
    }
      , M = j => e.modelAuto ? Array.isArray(j) ? [J(j[0]), J(j[1])] : e.autoApply ? [J(j)] : [J(j), null] : Array.isArray(j) ? $u( () => [J(j[0]), j[1] ? J(j[1]) : Pl(e.partialRange)], e.range) : J(j)
      , S = () => {
        Array.isArray(r.value) && e.range && r.value.length === 1 && r.value.push(Pl(e.partialRange))
    }
      , T = () => {
        const j = r.value;
        return [ae(j[0]), j[1] ? ae(j[1]) : Pl(e.partialRange)]
    }
      , E = () => r.value[1] ? T() : ae(hn(r.value[0]))
      , O = () => (r.value || []).map(j => ae(j))
      , U = () => (S(),
    e.modelAuto ? E() : e.multiDates ? O() : Array.isArray(r.value) ? $u( () => T(), e.range) : ae(hn(r.value)))
      , L = j => !j || Array.isArray(j) && !j.length ? null : e.timePicker ? y(hn(j)) : e.monthPicker ? k(hn(j)) : e.yearPicker ? h(hn(j)) : e.multiDates ? w(hn(j)) : e.weekPicker ? $(hn(j)) : M(hn(j))
      , C = j => {
        const re = L(j);
        wh(hn(re)) ? (r.value = hn(re),
        te()) : (r.value = null,
        l.value = "")
    }
      , W = () => {
        const j = re => fs(re, a.value.format);
        return `${j(r.value[0])} ${a.value.rangeSeparator} ${r.value[1] ? j(r.value[1]) : ""}`
    }
      , R = () => n.value && r.value ? Array.isArray(r.value) ? W() : fs(r.value, a.value.format) : d(r.value)
      , G = () => r.value ? e.multiDates ? r.value.map(j => d(j)).join("; ") : a.value.enabled && typeof a.value.format == "string" ? R() : d(r.value) : ""
      , te = () => {
        !e.format || typeof e.format == "string" || a.value.enabled && typeof a.value.format == "string" ? l.value = G() : l.value = e.format(r.value)
    }
      , J = j => {
        if (e.utc) {
            const re = new Date(j);
            return e.utc === "preserve" ? new Date(re.getTime() + re.getTimezoneOffset() * 6e4) : re
        }
        return e.modelType ? e.modelType === "date" || e.modelType === "timestamp" ? u(new Date(j)) : e.modelType === "format" && (typeof e.format == "string" || !e.format) ? mh(j, s(), new Date) : u(mh(j, e.modelType, new Date)) : u(new Date(j))
    }
      , ae = j => j ? e.utc ? yG(j, e.utc === "preserve", e.enableSeconds) : e.modelType ? e.modelType === "timestamp" ? +o(j) : e.modelType === "format" && (typeof e.format == "string" || !e.format) ? d(o(j)) : d(o(j), e.modelType, !0) : o(j) : ""
      , oe = (j, re=!1) => {
        if (t("update:model-value", j),
        e.emitTimezone && re) {
            const le = Array.isArray(j) ? j.map(ce => gr(hn(ce)), e.emitTimezone) : gr(hn(j), e.emitTimezone);
            t("update:model-timezone-value", le)
        }
    }
      , ne = j => Array.isArray(r.value) ? e.multiDates ? r.value.map(re => j(re)) : [j(r.value[0]), r.value[1] ? j(r.value[1]) : Pl(e.partialRange)] : j(hn(r.value))
      , I = j => oe(hn(ne(j)));
    return {
        inputValue: l,
        internalModelValue: r,
        checkBeforeEmit: () => r.value ? e.range ? e.partialRange ? r.value.length >= 1 : r.value.length === 2 : !!r.value : !1,
        parseExternalModelValue: C,
        formatInputValue: te,
        emitModelValue: () => (te(),
        e.monthPicker ? I(p) : e.timePicker ? I(f) : e.yearPicker ? I(ct) : e.weekPicker ? oe(r.value.map(j => ae(j)), !0) : oe(U(), !0))
    }
}
  , BG = (t, e) => {
    const {defaultedFilters: n} = sn(t)
      , {validateMonthYearInRange: r} = Ni(t)
      , a = (u, d) => {
        let f = u;
        return n.value.months.includes(gt(f)) ? (f = d ? Pr(u, 1) : yi(u, 1),
        a(f, d)) : f
    }
      , s = (u, d) => {
        let f = u;
        return n.value.years.includes(ct(f)) ? (f = d ? tv(u, 1) : gS(u, 1),
        s(f, d)) : f
    }
      , l = (u, d=!1) => {
        const f = Ut(new Date, {
            month: t.month,
            year: t.year
        });
        let p = u ? Pr(f, 1) : yi(f, 1);
        t.disableYearSelect && (p = tl(p, t.year));
        let h = gt(p)
          , v = ct(p);
        n.value.months.includes(h) && (p = a(p, u),
        h = gt(p),
        v = ct(p)),
        n.value.years.includes(v) && (p = s(p, u),
        v = ct(p)),
        r(h, v, u, t.preventMinMaxNavigation) && i(h, v, d)
    }
      , i = (u, d, f) => {
        e("update-month-year", {
            month: u,
            year: d,
            fromNav: f
        })
    }
      , o = K( () => u => AS(Ut(new Date, {
        month: t.month,
        year: t.year
    }), t.maxDate, t.minDate, t.preventMinMaxNavigation, u));
    return {
        handleMonthYearChange: l,
        isDisabled: o,
        updateMonthYear: i
    }
}
;
var Rl = (t => (t.center = "center",
t.left = "left",
t.right = "right",
t))(Rl || {})
  , Tr = (t => (t.month = "month",
t.year = "year",
t))(Tr || {})
  , Fs = (t => (t.top = "top",
t.bottom = "bottom",
t))(Fs || {})
  , rl = (t => (t.header = "header",
t.calendar = "calendar",
t.timePicker = "timePicker",
t))(rl || {})
  , Wr = (t => (t.month = "month",
t.year = "year",
t.calendar = "calendar",
t.time = "time",
t.minutes = "minutes",
t.hours = "hours",
t.seconds = "seconds",
t))(Wr || {});
const VG = ({menuRef: t, menuRefInner: e, inputRef: n, pickerWrapperRef: r, inline: a, emit: s, props: l, slots: i}) => {
    const o = me({})
      , u = me(!1)
      , d = me({
        top: "0",
        left: "0"
    })
      , f = me(!1)
      , p = _e(l, "teleportCenter");
    Ke(p, () => {
        d.value = JSON.parse(JSON.stringify({})),
        S()
    }
    );
    const h = J => {
        if (l.teleport) {
            const ae = J.getBoundingClientRect();
            return {
                left: ae.left + window.scrollX,
                top: ae.top + window.scrollY
            }
        }
        return {
            top: 0,
            left: 0
        }
    }
      , v = (J, ae) => {
        d.value.left = `${J + ae - o.value.width}px`
    }
      , y = J => {
        d.value.left = `${J}px`
    }
      , k = (J, ae) => {
        l.position === Rl.left && y(J),
        l.position === Rl.right && v(J, ae),
        l.position === Rl.center && (d.value.left = `${J + ae / 2 - o.value.width / 2}px`)
    }
      , w = J => {
        const {width: ae, height: oe} = J.getBoundingClientRect()
          , {top: ne, left: I} = l.altPosition ? l.altPosition(J) : h(J);
        return {
            top: +ne,
            left: +I,
            width: ae,
            height: oe
        }
    }
      , $ = () => {
        d.value.left = "50%",
        d.value.top = "50%",
        d.value.transform = "translate(-50%, -50%)",
        d.value.position = "fixed",
        delete d.value.opacity
    }
      , M = () => {
        const J = fn(n)
          , {top: ae, left: oe, transform: ne} = l.altPosition(J);
        d.value = {
            top: `${ae}px`,
            left: `${oe}px`,
            transform: ne ?? ""
        }
    }
      , S = (J=!0) => {
        var ae;
        if (!a.value.enabled) {
            if (p.value)
                return $();
            if (l.altPosition !== null)
                return M();
            if (J) {
                const oe = l.teleport ? (ae = e.value) == null ? void 0 : ae.$el : t.value;
                oe && (o.value = oe.getBoundingClientRect()),
                s("recalculate-position")
            }
            return W()
        }
    }
      , T = ({inputEl: J, left: ae, width: oe}) => {
        window.screen.width > 768 && !u.value && k(ae, oe),
        U(J)
    }
      , E = J => {
        const {top: ae, left: oe, height: ne, width: I} = w(J);
        d.value.top = `${ne + ae + +l.offset}px`,
        f.value = !1,
        u.value || (d.value.left = `${oe + I / 2 - o.value.width / 2}px`),
        T({
            inputEl: J,
            left: oe,
            width: I
        })
    }
      , O = J => {
        const {top: ae, left: oe, width: ne} = w(J);
        d.value.top = `${ae - +l.offset - o.value.height}px`,
        f.value = !0,
        T({
            inputEl: J,
            left: oe,
            width: ne
        })
    }
      , U = J => {
        if (l.autoPosition) {
            const {left: ae, width: oe} = w(J)
              , {left: ne, right: I} = o.value;
            if (!u.value) {
                if (Math.abs(ne) !== Math.abs(I)) {
                    if (ne <= 0)
                        return u.value = !0,
                        y(ae);
                    if (I >= document.documentElement.clientWidth)
                        return u.value = !0,
                        v(ae, oe)
                }
                return k(ae, oe)
            }
        }
    }
      , L = () => {
        const J = fn(n);
        if (J) {
            const {height: ae} = o.value
              , {top: oe, height: ne} = J.getBoundingClientRect()
              , I = window.innerHeight - oe - ne
              , j = oe;
            return ae <= I ? Fs.bottom : ae > I && ae <= j ? Fs.top : I >= j ? Fs.bottom : Fs.top
        }
        return Fs.bottom
    }
      , C = J => L() === Fs.bottom ? E(J) : O(J)
      , W = () => {
        const J = fn(n);
        if (J)
            return l.autoPosition ? C(J) : E(J)
    }
      , R = function(J) {
        if (J) {
            const ae = J.scrollHeight > J.clientHeight
              , oe = window.getComputedStyle(J).overflowY.indexOf("hidden") !== -1;
            return ae && !oe
        }
        return !0
    }
      , G = function(J) {
        return !J || J === document.body || J.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : R(J) ? J : G(J.parentNode)
    }
      , te = J => {
        if (J)
            switch (l.position) {
            case Rl.left:
                return {
                    left: 0,
                    transform: "translateX(0)"
                };
            case Rl.right:
                return {
                    left: `${J.width}px`,
                    transform: "translateX(-100%)"
                };
            default:
                return {
                    left: `${J.width / 2}px`,
                    transform: "translateX(-50%)"
                }
            }
        return {}
    }
    ;
    return {
        openOnTop: f,
        menuStyle: d,
        xCorrect: u,
        setMenuPosition: S,
        getScrollableParent: G,
        shadowRender: (J, ae) => {
            var oe, ne, I;
            const j = document.createElement("div")
              , re = (oe = fn(n)) == null ? void 0 : oe.getBoundingClientRect();
            j.setAttribute("id", "dp--temp-container");
            const le = (ne = r.value) != null && ne.clientWidth ? r.value : document.body;
            le.append(j);
            const ce = document.getElementById("dp--temp-container")
              , xe = te(re)
              , X = st(J, {
                ...ae,
                shadow: !0,
                style: {
                    opacity: 0,
                    position: "absolute",
                    ...xe
                }
            }, Object.fromEntries(Object.keys(i).filter(be => ["right-sidebar", "left-sidebar"].includes(be)).map(be => [be, i[be]])));
            mg(X, ce),
            o.value = (I = X.el) == null ? void 0 : I.getBoundingClientRect(),
            mg(null, ce),
            le.removeChild(ce)
        }
    }
}
  , ja = [{
    name: "clock-icon",
    use: ["time", "calendar", "shared"]
}, {
    name: "arrow-left",
    use: ["month-year", "calendar", "shared", "year-mode"]
}, {
    name: "arrow-right",
    use: ["month-year", "calendar", "shared", "year-mode"]
}, {
    name: "arrow-up",
    use: ["time", "calendar", "month-year", "shared"]
}, {
    name: "arrow-down",
    use: ["time", "calendar", "month-year", "shared"]
}, {
    name: "calendar-icon",
    use: ["month-year", "time", "calendar", "shared", "year-mode"]
}, {
    name: "day",
    use: ["calendar", "shared"]
}, {
    name: "month-overlay-value",
    use: ["calendar", "month-year", "shared"]
}, {
    name: "year-overlay-value",
    use: ["calendar", "month-year", "shared", "year-mode"]
}, {
    name: "year-overlay",
    use: ["month-year", "shared"]
}, {
    name: "month-overlay",
    use: ["month-year", "shared"]
}, {
    name: "month-overlay-header",
    use: ["month-year", "shared"]
}, {
    name: "year-overlay-header",
    use: ["month-year", "shared"]
}, {
    name: "hours-overlay-value",
    use: ["calendar", "time", "shared"]
}, {
    name: "minutes-overlay-value",
    use: ["calendar", "time", "shared"]
}, {
    name: "seconds-overlay-value",
    use: ["calendar", "time", "shared"]
}, {
    name: "hours",
    use: ["calendar", "time", "shared"]
}, {
    name: "minutes",
    use: ["calendar", "time", "shared"]
}, {
    name: "month",
    use: ["calendar", "month-year", "shared"]
}, {
    name: "year",
    use: ["calendar", "month-year", "shared", "year-mode"]
}, {
    name: "action-buttons",
    use: ["action"]
}, {
    name: "action-preview",
    use: ["action"]
}, {
    name: "calendar-header",
    use: ["calendar", "shared"]
}, {
    name: "marker-tooltip",
    use: ["calendar", "shared"]
}, {
    name: "action-extra",
    use: ["menu"]
}, {
    name: "time-picker-overlay",
    use: ["calendar", "time", "shared"]
}, {
    name: "am-pm-button",
    use: ["calendar", "time", "shared"]
}, {
    name: "left-sidebar",
    use: ["menu"]
}, {
    name: "right-sidebar",
    use: ["menu"]
}, {
    name: "month-year",
    use: ["month-year", "shared"]
}, {
    name: "time-picker",
    use: ["menu", "shared"]
}, {
    name: "action-row",
    use: ["action"]
}, {
    name: "marker",
    use: ["calendar", "shared"]
}, {
    name: "quarter",
    use: ["shared"]
}]
  , IG = [{
    name: "trigger"
}, {
    name: "input-icon"
}, {
    name: "clear-icon"
}, {
    name: "dp-input"
}]
  , RG = {
    all: () => ja,
    monthYear: () => ja.filter(t => t.use.includes("month-year")),
    input: () => IG,
    timePicker: () => ja.filter(t => t.use.includes("time")),
    action: () => ja.filter(t => t.use.includes("action")),
    calendar: () => ja.filter(t => t.use.includes("calendar")),
    menu: () => ja.filter(t => t.use.includes("menu")),
    shared: () => ja.filter(t => t.use.includes("shared")),
    yearMode: () => ja.filter(t => t.use.includes("year-mode"))
}
  , sr = (t, e, n) => {
    const r = [];
    return RG[e]().forEach(a => {
        t[a.name] && r.push(a.name)
    }
    ),
    n != null && n.length && n.forEach(a => {
        a.slot && r.push(a.slot)
    }
    ),
    r
}
  , tu = t => {
    const e = K( () => r => t.value ? r ? t.value.open : t.value.close : "")
      , n = K( () => r => t.value ? r ? t.value.menuAppearTop : t.value.menuAppearBottom : "");
    return {
        transitionName: e,
        showTransition: !!t.value,
        menuTransition: n
    }
}
  , nu = (t, e) => {
    const n = Me(gr(new Date, t.timezone))
      , r = me([{
        month: gt(n),
        year: ct(n)
    }])
      , a = Fn({
        hours: t.range ? [Fr(n), Fr(n)] : Fr(n),
        minutes: t.range ? [sa(n), sa(n)] : sa(n),
        seconds: t.range ? [0, 0] : 0
    })
      , s = K({
        get: () => t.internalModelValue,
        set: o => {
            !t.readonly && !t.disabled && e("update:internal-model-value", o)
        }
    })
      , l = K( () => o => r.value[o] ? r.value[o].month : 0)
      , i = K( () => o => r.value[o] ? r.value[o].year : 0);
    return {
        calendars: r,
        time: a,
        modelValue: s,
        month: l,
        year: i
    }
}
  , LG = (t, e) => {
    const {defaultedMultiCalendars: n, defaultedHighlight: r} = sn(e)
      , {isDisabled: a, matchDate: s} = Ni(e)
      , l = me(null)
      , i = me(Me(gr(new Date, e.timezone)))
      , o = I => {
        !I.current && e.hideOffsetDates || (l.value = I.value)
    }
      , u = () => {
        l.value = null
    }
      , d = I => Array.isArray(t.value) && e.range && t.value[0] && l.value ? I ? Pn(l.value, t.value[0]) : An(l.value, t.value[0]) : !0
      , f = (I, j) => {
        const re = () => t.value ? j ? t.value[0] || null : t.value[1] : null
          , le = t.value && Array.isArray(t.value) ? re() : null;
        return xt(Me(I.value), le)
    }
      , p = I => {
        const j = Array.isArray(t.value) ? t.value[0] : null;
        return I ? !An(l.value ?? null, j) : !0
    }
      , h = (I, j=!0) => (e.range || e.weekPicker) && Array.isArray(t.value) && t.value.length === 2 ? e.hideOffsetDates && !I.current ? !1 : xt(Me(I.value), t.value[j ? 0 : 1]) : e.range ? f(I, j) && p(j) || xt(I.value, Array.isArray(t.value) ? t.value[0] : null) && d(j) : !1
      , v = (I, j, re) => Array.isArray(t.value) && t.value[0] && t.value.length === 1 ? I ? !1 : re ? Pn(t.value[0], j.value) : An(t.value[0], j.value) : !1
      , y = I => !t.value || e.hideOffsetDates && !I.current ? !1 : e.range ? e.modelAuto && Array.isArray(t.value) ? xt(I.value, t.value[0] ? t.value[0] : i.value) : !1 : e.multiDates && Array.isArray(t.value) ? t.value.some(j => xt(j, I.value)) : xt(I.value, t.value ? t.value : i.value)
      , k = I => {
        if (e.autoRange || e.weekPicker) {
            if (l.value) {
                if (e.hideOffsetDates && !I.current)
                    return !1;
                const j = xa(l.value, +e.autoRange)
                  , re = Ru(Me(l.value), e.timezone, e.weekStart);
                return e.weekPicker ? xt(re[1], Me(I.value)) : xt(j, Me(I.value))
            }
            return !1
        }
        return !1
    }
      , w = I => {
        if (e.autoRange || e.weekPicker) {
            if (l.value) {
                const j = xa(l.value, +e.autoRange);
                if (e.hideOffsetDates && !I.current)
                    return !1;
                const re = Ru(Me(l.value), e.timezone, e.weekStart);
                return e.weekPicker ? Pn(I.value, re[0]) && An(I.value, re[1]) : Pn(I.value, l.value) && An(I.value, j)
            }
            return !1
        }
        return !1
    }
      , $ = I => {
        if (e.autoRange || e.weekPicker) {
            if (l.value) {
                if (e.hideOffsetDates && !I.current)
                    return !1;
                const j = Ru(Me(l.value), e.timezone, e.weekStart);
                return e.weekPicker ? xt(j[0], I.value) : xt(l.value, I.value)
            }
            return !1
        }
        return !1
    }
      , M = I => Tc(t.value, l.value, I.value)
      , S = () => e.modelAuto && Array.isArray(e.internalModelValue) ? !!e.internalModelValue[0] : !1
      , T = () => e.modelAuto ? xS(e.internalModelValue) : !0
      , E = I => {
        if (Array.isArray(t.value) && t.value.length || e.weekPicker)
            return !1;
        const j = e.range ? !h(I) && !h(I, !1) : !0;
        return !a(I.value) && !y(I) && !(!I.current && e.hideOffsetDates) && j
    }
      , O = I => e.range ? e.modelAuto ? S() && y(I) : !1 : y(I)
      , U = I => {
        var j;
        return r.value ? typeof r.value == "function" ? r.value(I.value) : s(I.value, (j = e.arrMapValues) != null && j.highlightedDates ? e.arrMapValues.highlightedDates : r.value.dates) : !1
    }
      , L = I => {
        const j = a(I.value);
        return j && (typeof r.value == "function" ? !r.value(I.value, j) : !r.value.options.highlightDisabled)
    }
      , C = I => {
        var j;
        return typeof r.value == "function" ? r.value(I.value) : (j = r.value.weekdays) == null ? void 0 : j.includes(I.value.getDay())
    }
      , W = I => (e.range || e.weekPicker) && (!(n.value.count > 0) || I.current) && T() && !(!I.current && e.hideOffsetDates) && !y(I) ? M(I) : !1
      , R = I => {
        const {isRangeStart: j, isRangeEnd: re} = J(I)
          , le = e.range ? j || re : !1;
        return {
            dp__cell_offset: !I.current,
            dp__pointer: !e.disabled && !(!I.current && e.hideOffsetDates) && !a(I.value),
            dp__cell_disabled: a(I.value),
            dp__cell_highlight: !L(I) && (U(I) || C(I)) && !O(I) && !le,
            dp__cell_highlight_active: !L(I) && (U(I) || C(I)) && O(I),
            dp__today: !e.noToday && xt(I.value, i.value) && I.current
        }
    }
      , G = I => ({
        dp__active_date: O(I),
        dp__date_hover: E(I)
    })
      , te = I => ({
        ...ae(I),
        ...oe(I),
        dp__range_between_week: W(I) && e.weekPicker
    })
      , J = I => {
        const j = n.value.count > 0 ? I.current && h(I) && T() : h(I) && T()
          , re = n.value.count > 0 ? I.current && h(I, !1) && T() : h(I, !1) && T();
        return {
            isRangeStart: j,
            isRangeEnd: re
        }
    }
      , ae = I => {
        const {isRangeStart: j, isRangeEnd: re} = J(I);
        return {
            dp__range_start: j,
            dp__range_end: re,
            dp__range_between: W(I) && !e.weekPicker,
            dp__date_hover_start: v(E(I), I, !0),
            dp__date_hover_end: v(E(I), I, !1)
        }
    }
      , oe = I => ({
        ...ae(I),
        dp__cell_auto_range: w(I),
        dp__cell_auto_range_start: $(I),
        dp__cell_auto_range_end: k(I)
    })
      , ne = I => e.range ? e.autoRange ? oe(I) : e.modelAuto ? {
        ...G(I),
        ...ae(I)
    } : ae(I) : e.weekPicker ? te(I) : G(I);
    return {
        setHoverDate: o,
        clearHoverDate: u,
        getDayClassData: I => e.hideOffsetDates && !I.current ? {} : {
            ...R(I),
            ...ne(I),
            [e.dayClass ? e.dayClass(I.value) : ""]: !0,
            [e.calendarCellClassName]: !!e.calendarCellClassName
        }
    }
}
  , Ni = t => {
    const {defaultedFilters: e, defaultedHighlight: n} = sn(t)
      , r = () => {
        if (t.timezone)
            return t.timezone;
        if (t.utc)
            return "UTC"
    }
      , a = C => {
        const W = Sr(s(Me(C))).toISOString()
          , [R] = W.split("T");
        return R
    }
      , s = C => t.utc === "preserve" ? TS(C, r()) : gr(C, r())
      , l = C => {
        var W;
        const R = t.maxDate ? Pn(s(C), s(Me(t.maxDate))) : !1
          , G = t.minDate ? An(s(C), s(Me(t.minDate))) : !1
          , te = d(s(C), (W = t.arrMapValues) != null && W.disabledDates ? t.arrMapValues.disabledDates : t.disabledDates)
          , J = e.value.months.map(j => +j).includes(gt(C))
          , ae = t.disabledWeekDays.length ? t.disabledWeekDays.some(j => +j === bq(C)) : !1
          , oe = p(C)
          , ne = ct(C)
          , I = ne < +t.yearRange[0] || ne > +t.yearRange[1];
        return !(R || G || te || J || I || ae || oe)
    }
      , i = (C, W) => An(...as(t.minDate, C, W)) || xt(...as(t.minDate, C, W))
      , o = (C, W) => Pn(...as(t.maxDate, C, W)) || xt(...as(t.maxDate, C, W))
      , u = (C, W, R) => {
        let G = !1;
        return t.maxDate && R && o(C, W) && (G = !0),
        t.minDate && !R && i(C, W) && (G = !0),
        G
    }
      , d = (C, W) => C ? W instanceof Map ? !!W.get(a(C)) : Array.isArray(W) ? W.some(R => xt(s(Me(R)), s(C))) : W ? W(Me(JSON.parse(JSON.stringify(C)))) : !1 : !0
      , f = (C, W, R, G) => {
        let te = !1;
        return G ? t.minDate && t.maxDate ? te = u(C, W, R) : (t.minDate && i(C, W) || t.maxDate && o(C, W)) && (te = !0) : te = !0,
        te
    }
      , p = C => {
        var W, R, G, te, J;
        return Array.isArray(t.allowedDates) && !((W = t.allowedDates) != null && W.length) ? !0 : (R = t.arrMapValues) != null && R.allowedDates ? !d(C, (G = t.arrMapValues) == null ? void 0 : G.allowedDates) : (te = t.allowedDates) != null && te.length ? !((J = t.allowedDates) != null && J.some(ae => xt(s(Me(ae)), s(C)))) : !1
    }
      , h = C => !l(C)
      , v = C => t.noDisabledRange ? !Qx({
        start: C[0],
        end: C[1]
    }).some(W => h(W)) : !0
      , y = (C, W, R=0) => {
        if (Array.isArray(W) && W[R]) {
            const G = i9(C, W[R])
              , te = CS(W[R], C)
              , J = te.length === 1 ? 0 : te.filter(oe => h(oe)).length
              , ae = Math.abs(G) - J;
            if (t.minRange && t.maxRange)
                return ae >= +t.minRange && ae <= +t.maxRange;
            if (t.minRange)
                return ae >= +t.minRange;
            if (t.maxRange)
                return ae <= +t.maxRange
        }
        return !0
    }
      , k = C => new Map(C.map(W => [a(W), !0]))
      , w = C => Array.isArray(C) && C.length > 0
      , $ = () => {
        const C = {
            disabledDates: null,
            allowedDates: null,
            highlightedDates: null
        };
        return w(t.allowedDates) && (C.allowedDates = k(t.allowedDates)),
        typeof n.value != "function" && w(n.value.dates) && (C.highlightedDates = k(n.value.dates)),
        w(t.disabledDates) && (C.disabledDates = k(t.disabledDates)),
        C
    }
      , M = () => !t.enableTimePicker || t.monthPicker || t.yearPicker || t.ignoreTimeValidation
      , S = C => Array.isArray(C) ? [C[0] ? Gf(C[0]) : null, C[1] ? Gf(C[1]) : null] : Gf(C)
      , T = (C, W, R) => C.find(G => +G.hours === Fr(W) && G.minutes === "*" ? !0 : +G.minutes === sa(W) && +G.hours === Fr(W)) && R
      , E = (C, W, R) => {
        const [G,te] = C
          , [J,ae] = W;
        return !T(G, J, R) && !T(te, ae, R) && R
    }
      , O = (C, W) => {
        const R = Array.isArray(W) ? W : [W];
        return Array.isArray(t.disabledTimes) ? Array.isArray(t.disabledTimes[0]) ? E(t.disabledTimes, R, C) : !R.some(G => T(t.disabledTimes, G, C)) : C
    }
      , U = (C, W) => {
        const R = Array.isArray(W) ? [nl(W[0]), W[1] ? nl(W[1]) : void 0] : nl(W)
          , G = !t.disabledTimes(R);
        return C && G
    }
      , L = (C, W) => t.disabledTimes ? Array.isArray(t.disabledTimes) ? O(W, C) : U(W, C) : W;
    return {
        isDisabled: h,
        validateDate: l,
        validateMonthYearInRange: f,
        isDateRangeAllowed: v,
        checkMinMaxRange: y,
        matchDate: d,
        mapDatesArrToMap: $,
        isValidTime: C => {
            let W = !0;
            if (!C || M())
                return !0;
            const R = !t.minDate && !t.maxDate ? S(C) : C;
            return (t.maxTime || t.maxDate) && (W = Ay(t.maxTime, t.maxDate, "max", hn(R), W)),
            (t.minTime || t.minDate) && (W = Ay(t.minTime, t.minDate, "min", hn(R), W)),
            L(C, W)
        }
    }
}
  , Cc = () => {
    const t = K( () => (r, a) => r == null ? void 0 : r.includes(a))
      , e = K( () => (r, a) => r.count ? r.solo ? !0 : a === 0 : !0)
      , n = K( () => (r, a) => r.count ? r.solo ? !0 : a === r.count - 1 : !0);
    return {
        hideNavigationButtons: t,
        showLeftIcon: e,
        showRightIcon: n
    }
}
  , jG = (t, e, n) => {
    const r = me(0)
      , a = Fn({
        [rl.timePicker]: !t.enableTimePicker || t.timePicker || t.monthPicker,
        [rl.calendar]: !1,
        [rl.header]: !1
    })
      , s = (...d) => {
        var f;
        (f = t.flow) != null && f.length && (a[d] = !0,
        Object.keys(a).filter(p => !a[p]).length || u())
    }
      , l = () => {
        var d;
        (d = t.flow) != null && d.length && r.value !== -1 && (r.value += 1,
        e("flow-step", r.value),
        u())
    }
      , i = () => {
        r.value = -1
    }
      , o = (d, f, ...p) => {
        t.flow[r.value] === d && n.value && n.value[f](...p)
    }
      , u = () => {
        o(Wr.month, "toggleMonthPicker", !0),
        o(Wr.year, "toggleYearPicker", !0),
        o(Wr.calendar, "toggleTimePicker", !1, !0),
        o(Wr.time, "toggleTimePicker", !0, !0);
        const d = t.flow[r.value];
        (d === Wr.hours || d === Wr.minutes || d === Wr.seconds) && o(d, "toggleTimePicker", !0, !0, d)
    }
    ;
    return {
        childMount: s,
        updateFlowStep: l,
        resetFlow: i,
        flowStep: r
    }
}
  , Ec = {
    multiCalendars: {
        type: [Boolean, Number, String, Object],
        default: void 0
    },
    modelValue: {
        type: [String, Date, Array, Object, Number],
        default: null
    },
    modelType: {
        type: String,
        default: null
    },
    position: {
        type: String,
        default: "center"
    },
    dark: {
        type: Boolean,
        default: !1
    },
    format: {
        type: [String, Function],
        default: () => null
    },
    autoPosition: {
        type: Boolean,
        default: !0
    },
    altPosition: {
        type: Function,
        default: null
    },
    transitions: {
        type: [Boolean, Object],
        default: !0
    },
    formatLocale: {
        type: Object,
        default: null
    },
    utc: {
        type: [Boolean, String],
        default: !1
    },
    ariaLabels: {
        type: Object,
        default: () => ({})
    },
    offset: {
        type: [Number, String],
        default: 10
    },
    hideNavigation: {
        type: Array,
        default: () => []
    },
    timezone: {
        type: String,
        default: null
    },
    emitTimezone: {
        type: String,
        default: null
    },
    vertical: {
        type: Boolean,
        default: !1
    },
    disableMonthYearSelect: {
        type: Boolean,
        default: !1
    },
    disableYearSelect: {
        type: Boolean,
        default: !1
    },
    menuClassName: {
        type: String,
        default: null
    },
    dayClass: {
        type: Function,
        default: null
    },
    yearRange: {
        type: Array,
        default: () => [1900, 2100]
    },
    calendarCellClassName: {
        type: String,
        default: null
    },
    enableTimePicker: {
        type: Boolean,
        default: !0
    },
    autoApply: {
        type: Boolean,
        default: !1
    },
    disabledDates: {
        type: [Array, Function],
        default: () => []
    },
    monthNameFormat: {
        type: String,
        default: "short"
    },
    startDate: {
        type: [Date, String],
        default: null
    },
    startTime: {
        type: [Object, Array],
        default: null
    },
    hideOffsetDates: {
        type: Boolean,
        default: !1
    },
    autoRange: {
        type: [Number, String],
        default: null
    },
    noToday: {
        type: Boolean,
        default: !1
    },
    disabledWeekDays: {
        type: Array,
        default: () => []
    },
    allowedDates: {
        type: Array,
        default: null
    },
    nowButtonLabel: {
        type: String,
        default: "Now"
    },
    markers: {
        type: Array,
        default: () => []
    },
    escClose: {
        type: Boolean,
        default: !0
    },
    spaceConfirm: {
        type: Boolean,
        default: !0
    },
    monthChangeOnArrows: {
        type: Boolean,
        default: !0
    },
    presetDates: {
        type: Array,
        default: () => []
    },
    flow: {
        type: Array,
        default: () => []
    },
    partialFlow: {
        type: Boolean,
        default: !1
    },
    preventMinMaxNavigation: {
        type: Boolean,
        default: !1
    },
    minRange: {
        type: [Number, String],
        default: null
    },
    maxRange: {
        type: [Number, String],
        default: null
    },
    multiDatesLimit: {
        type: [Number, String],
        default: null
    },
    reverseYears: {
        type: Boolean,
        default: !1
    },
    weekPicker: {
        type: Boolean,
        default: !1
    },
    filters: {
        type: Object,
        default: () => ({})
    },
    arrowNavigation: {
        type: Boolean,
        default: !1
    },
    disableTimeRangeValidation: {
        type: Boolean,
        default: !1
    },
    highlight: {
        type: [Array, Function, Object],
        default: null
    },
    highlightWeekDays: {
        type: Array,
        default: null
    },
    highlightDisabledDays: {
        type: Boolean,
        default: !1
    },
    teleport: {
        type: [String, Boolean],
        default: null
    },
    teleportCenter: {
        type: Boolean,
        default: !1
    },
    locale: {
        type: String,
        default: "en-Us"
    },
    weekNumName: {
        type: String,
        default: "W"
    },
    weekStart: {
        type: [Number, String],
        default: 1
    },
    weekNumbers: {
        type: [String, Function],
        default: null
    },
    calendarClassName: {
        type: String,
        default: null
    },
    monthChangeOnScroll: {
        type: [Boolean, String],
        default: !0
    },
    dayNames: {
        type: [Function, Array],
        default: null
    },
    monthPicker: {
        type: Boolean,
        default: !1
    },
    customProps: {
        type: Object,
        default: null
    },
    yearPicker: {
        type: Boolean,
        default: !1
    },
    modelAuto: {
        type: Boolean,
        default: !1
    },
    selectText: {
        type: String,
        default: "Select"
    },
    cancelText: {
        type: String,
        default: "Cancel"
    },
    previewFormat: {
        type: [String, Function],
        default: () => ""
    },
    multiDates: {
        type: Boolean,
        default: !1
    },
    partialRange: {
        type: Boolean,
        default: !0
    },
    ignoreTimeValidation: {
        type: Boolean,
        default: !1
    },
    minDate: {
        type: [Date, String],
        default: null
    },
    maxDate: {
        type: [Date, String],
        default: null
    },
    minTime: {
        type: Object,
        default: null
    },
    maxTime: {
        type: Object,
        default: null
    },
    name: {
        type: String,
        default: null
    },
    placeholder: {
        type: String,
        default: ""
    },
    hideInputIcon: {
        type: Boolean,
        default: !1
    },
    clearable: {
        type: Boolean,
        default: !0
    },
    state: {
        type: Boolean,
        default: null
    },
    required: {
        type: Boolean,
        default: !1
    },
    autocomplete: {
        type: String,
        default: "off"
    },
    inputClassName: {
        type: String,
        default: null
    },
    fixedStart: {
        type: Boolean,
        default: !1
    },
    fixedEnd: {
        type: Boolean,
        default: !1
    },
    timePicker: {
        type: Boolean,
        default: !1
    },
    enableSeconds: {
        type: Boolean,
        default: !1
    },
    is24: {
        type: Boolean,
        default: !0
    },
    noHoursOverlay: {
        type: Boolean,
        default: !1
    },
    noMinutesOverlay: {
        type: Boolean,
        default: !1
    },
    noSecondsOverlay: {
        type: Boolean,
        default: !1
    },
    hoursGridIncrement: {
        type: [String, Number],
        default: 1
    },
    minutesGridIncrement: {
        type: [String, Number],
        default: 5
    },
    secondsGridIncrement: {
        type: [String, Number],
        default: 5
    },
    hoursIncrement: {
        type: [Number, String],
        default: 1
    },
    minutesIncrement: {
        type: [Number, String],
        default: 1
    },
    secondsIncrement: {
        type: [Number, String],
        default: 1
    },
    range: {
        type: Boolean,
        default: !1
    },
    uid: {
        type: String,
        default: null
    },
    disabled: {
        type: Boolean,
        default: !1
    },
    readonly: {
        type: Boolean,
        default: !1
    },
    inline: {
        type: [Boolean, Object],
        default: !1
    },
    textInput: {
        type: [Boolean, Object],
        default: !1
    },
    noDisabledRange: {
        type: Boolean,
        default: !1
    },
    sixWeeks: {
        type: [Boolean, String],
        default: !1
    },
    actionRow: {
        type: Object,
        default: () => ({})
    },
    focusStartDate: {
        type: Boolean,
        default: !1
    },
    disabledTimes: {
        type: [Function, Array],
        default: void 0
    },
    showLastInRange: {
        type: Boolean,
        default: !0
    },
    timePickerInline: {
        type: Boolean,
        default: !1
    },
    calendar: {
        type: Function,
        default: null
    },
    config: {
        type: Object,
        default: void 0
    },
    quarterPicker: {
        type: Boolean,
        default: !1
    },
    yearFirst: {
        type: Boolean,
        default: !1
    }
}
  , jr = {
    ...Ec,
    shadow: {
        type: Boolean,
        default: !1
    },
    flowStep: {
        type: Number,
        default: 0
    },
    internalModelValue: {
        type: [Date, Array],
        default: null
    },
    arrMapValues: {
        type: Object,
        default: () => ({})
    },
    noOverlayFocus: {
        type: Boolean,
        default: !1
    }
}
  , UG = {
    key: 1,
    class: "dp__input_wrap"
}
  , HG = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid", "onKeydown"]
  , KG = {
    key: 2,
    class: "dp__clear_icon"
}
  , zG = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "DatepickerInput",
    props: {
        isMenuOpen: {
            type: Boolean,
            default: !1
        },
        inputValue: {
            type: String,
            default: ""
        },
        ...Ec
    },
    emits: ["clear", "open", "update:input-value", "set-input-date", "close", "select-date", "set-empty-date", "toggle", "focus-prev", "focus", "blur", "real-blur"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {defaultedTextInput: a, defaultedAriaLabels: s, defaultedInline: l, defaultedConfig: i, getDefaultPattern: o, getDefaultStartTime: u} = sn(r)
          , d = me()
          , f = me(null)
          , p = me(!1)
          , h = me(!1)
          , v = K( () => ({
            dp__pointer: !r.disabled && !r.readonly && !a.value.enabled,
            dp__disabled: r.disabled,
            dp__input_readonly: !a.value.enabled,
            dp__input: !0,
            dp__input_icon_pad: !r.hideInputIcon,
            dp__input_valid: !!r.state,
            dp__input_invalid: r.state === !1,
            dp__input_focus: p.value || r.isMenuOpen,
            dp__input_reg: !a.value.enabled,
            [r.inputClassName]: !!r.inputClassName
        }))
          , y = () => {
            n("set-input-date", null),
            r.autoApply && (n("set-empty-date"),
            d.value = null)
        }
          , k = R => {
            const G = u();
            return bG(R, a.value.format ?? o(), G ?? ES({}, r.enableSeconds), r.inputValue, h.value)
        }
          , w = R => {
            const {rangeSeparator: G} = a.value
              , [te,J] = R.split(`${G}`);
            if (te) {
                const ae = k(te.trim())
                  , oe = J ? k(J.trim()) : null
                  , ne = ae && oe ? [ae, oe] : [ae];
                d.value = ae ? ne : null
            }
        }
          , $ = () => {
            h.value = !0
        }
          , M = R => {
            if (r.range)
                w(R);
            else if (r.multiDates) {
                const G = R.split(";");
                d.value = G.map(te => k(te.trim())).filter(te => te)
            } else
                d.value = k(R)
        }
          , S = R => {
            var G;
            const te = typeof R == "string" ? R : (G = R.target) == null ? void 0 : G.value;
            te !== "" ? (a.value.openMenu && !r.isMenuOpen && n("open"),
            M(te),
            n("set-input-date", d.value)) : y(),
            h.value = !1,
            n("update:input-value", te)
        }
          , T = R => {
            a.value.enabled ? (M(R.target.value),
            a.value.enterSubmit && wh(d.value) && r.inputValue !== "" ? (n("set-input-date", d.value, !0),
            d.value = null) : a.value.enterSubmit && r.inputValue === "" && (d.value = null,
            n("clear"))) : U(R)
        }
          , E = R => {
            a.value.enabled && a.value.tabSubmit && M(R.target.value),
            a.value.tabSubmit && wh(d.value) && r.inputValue !== "" ? (n("set-input-date", d.value, !0),
            d.value = null) : a.value.tabSubmit && r.inputValue === "" && (d.value = null,
            n("clear"))
        }
          , O = () => {
            var R;
            p.value = !0,
            n("focus"),
            a.value.enabled && a.value.selectOnFocus && ((R = f.value) == null || R.select())
        }
          , U = R => {
            R.preventDefault(),
            ps(R, i.value, !0),
            a.value.enabled && a.value.openMenu && !l.value.input && !r.isMenuOpen ? n("open") : a.value.enabled || n("toggle")
        }
          , L = () => {
            n("real-blur"),
            p.value = !1,
            (!r.isMenuOpen || l.value.enabled && l.value.input) && n("blur"),
            r.autoApply && a.value.enabled && d.value && !r.isMenuOpen && (n("set-input-date", d.value),
            n("select-date"),
            d.value = null)
        }
          , C = R => {
            ps(R, i.value, !0),
            n("clear")
        }
          , W = R => {
            if (!a.value.enabled) {
                if (R.code === "Tab")
                    return;
                R.preventDefault()
            }
        }
        ;
        return e({
            focusInput: () => {
                var R;
                (R = f.value) == null || R.focus({
                    preventScroll: !0
                })
            }
            ,
            setParsedDate: R => {
                d.value = R
            }
        }),
        (R, G) => {
            var te;
            return g(),
            _("div", {
                onClick: U
            }, [R.$slots.trigger && !R.$slots["dp-input"] && !A(l).enabled ? Z(R.$slots, "trigger", {
                key: 0
            }) : q("", !0), !R.$slots.trigger && (!A(l).enabled || A(l).input) ? (g(),
            _("div", UG, [R.$slots["dp-input"] && !R.$slots.trigger && !A(l).enabled ? Z(R.$slots, "dp-input", {
                key: 0,
                value: t.inputValue,
                isMenuOpen: t.isMenuOpen,
                onInput: S,
                onEnter: T,
                onTab: E,
                onClear: C,
                onBlur: L,
                onKeypress: W,
                onPaste: $
            }) : q("", !0), R.$slots["dp-input"] ? q("", !0) : (g(),
            _("input", {
                key: 1,
                ref_key: "inputRef",
                ref: f,
                id: R.uid ? `dp-input-${R.uid}` : void 0,
                name: R.name,
                class: ye(v.value),
                inputmode: A(a).enabled ? "text" : "none",
                placeholder: R.placeholder,
                disabled: R.disabled,
                readonly: R.readonly,
                required: R.required,
                value: t.inputValue,
                autocomplete: R.autocomplete,
                "aria-label": (te = A(s)) == null ? void 0 : te.input,
                "aria-disabled": R.disabled || void 0,
                "aria-invalid": R.state === !1 ? !0 : void 0,
                onInput: S,
                onKeydown: [Xe(T, ["enter"]), Xe(E, ["tab"]), W],
                onBlur: L,
                onFocus: O,
                onKeypress: W,
                onPaste: $
            }, null, 42, HG)), c("div", {
                onClick: G[2] || (G[2] = J => n("toggle"))
            }, [R.$slots["input-icon"] && !R.hideInputIcon ? (g(),
            _("span", {
                key: 0,
                class: "dp__input_icon",
                onClick: G[0] || (G[0] = J => n("toggle"))
            }, [Z(R.$slots, "input-icon")])) : q("", !0), !R.$slots["input-icon"] && !R.hideInputIcon && !R.$slots["dp-input"] ? (g(),
            de(A(eu), {
                key: 1,
                onClick: G[1] || (G[1] = J => n("toggle")),
                class: "dp__input_icon dp__input_icons"
            })) : q("", !0)]), R.$slots["clear-icon"] && t.inputValue && R.clearable && !R.disabled && !R.readonly ? (g(),
            _("span", KG, [Z(R.$slots, "clear-icon", {
                clear: C
            })])) : q("", !0), R.clearable && !R.$slots["clear-icon"] && t.inputValue && !R.disabled && !R.readonly ? (g(),
            de(A(bS), {
                key: 3,
                class: "dp__clear_icon dp__input_icons",
                onClick: G[3] || (G[3] = _t(J => C(J), ["prevent"]))
            })) : q("", !0)])) : q("", !0)])
        }
    }
})
  , qG = ["title"]
  , WG = {
    class: "dp__action_buttons"
}
  , GG = ["onKeydown", "disabled"]
  , YG = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "ActionRow",
    props: {
        menuMount: {
            type: Boolean,
            default: !1
        },
        calendarWidth: {
            type: Number,
            default: 0
        },
        ...jr
    },
    emits: ["close-picker", "select-date", "select-now", "invalid-select"],
    setup(t, {emit: e}) {
        const n = t
          , {defaultedActionRow: r, defaultedPreviewFormat: a, defaultedMultiCalendars: s, defaultedTextInput: l, defaultedInline: i, getDefaultPattern: o} = sn(n)
          , {isValidTime: u} = Ni(n)
          , {buildMatrix: d} = Ms()
          , f = me(null)
          , p = me(null);
        Zt( () => {
            n.arrowNavigation && d([fn(f), fn(p)], "actionRow")
        }
        );
        const h = K( () => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0)
          , v = K( () => !y.value || !k.value || !h.value)
          , y = K( () => !n.enableTimePicker || n.ignoreTimeValidation ? !0 : u(n.internalModelValue))
          , k = K( () => n.monthPicker ? n.range && Array.isArray(n.internalModelValue) ? !n.internalModelValue.filter(L => !O(L)).length : O(n.internalModelValue) : !0)
          , w = () => {
            const L = a.value;
            return n.timePicker || n.monthPicker,
            L(hn(n.internalModelValue))
        }
          , $ = () => {
            const L = n.internalModelValue;
            return s.value.count > 0 ? `${M(L[0])} - ${M(L[1])}` : [M(L[0]), M(L[1])]
        }
          , M = L => MS(L, a.value, n.formatLocale, l.value.rangeSeparator, n.modelAuto, o())
          , S = K( () => !n.internalModelValue || !n.menuMount ? "" : typeof a.value == "string" ? Array.isArray(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? $() : n.multiDates ? n.internalModelValue.map(L => `${M(L)}`) : n.modelAuto ? `${M(n.internalModelValue[0])}` : `${M(n.internalModelValue[0])} -` : M(n.internalModelValue) : w())
          , T = () => n.multiDates ? "; " : " - "
          , E = K( () => Array.isArray(S.value) ? S.value.join(T()) : S.value)
          , O = L => {
            if (!n.monthPicker)
                return !0;
            let C = !0;
            const W = Me(Mr(L));
            if (n.minDate && n.maxDate) {
                const R = Me(Mr(n.minDate))
                  , G = Me(Mr(n.maxDate));
                return Pn(W, R) && An(W, G) || xt(W, R) || xt(W, G)
            }
            if (n.minDate) {
                const R = Me(Mr(n.minDate));
                C = Pn(W, R) || xt(W, R)
            }
            if (n.maxDate) {
                const R = Me(Mr(n.maxDate));
                C = An(W, R) || xt(W, R)
            }
            return C
        }
          , U = () => {
            y.value && k.value && h.value ? e("select-date") : e("invalid-select")
        }
        ;
        return (L, C) => (g(),
        _("div", {
            class: "dp__action_row",
            style: Rt(t.calendarWidth ? {
                width: `${t.calendarWidth}px`
            } : {})
        }, [L.$slots["action-row"] ? Z(L.$slots, "action-row", ut(Ve({
            key: 0
        }, {
            internalModelValue: L.internalModelValue,
            disabled: v.value,
            selectDate: () => L.$emit("select-date"),
            closePicker: () => L.$emit("close-picker")
        }))) : (g(),
        _(we, {
            key: 1
        }, [A(r).showPreview ? (g(),
        _("div", {
            key: 0,
            class: "dp__selection_preview",
            title: E.value
        }, [L.$slots["action-preview"] ? Z(L.$slots, "action-preview", {
            key: 0,
            value: L.internalModelValue
        }) : q("", !0), L.$slots["action-preview"] ? q("", !0) : (g(),
        _(we, {
            key: 1
        }, [ve(Q(E.value), 1)], 64))], 8, qG)) : q("", !0), c("div", WG, [L.$slots["action-buttons"] ? Z(L.$slots, "action-buttons", {
            key: 0,
            value: L.internalModelValue
        }) : q("", !0), L.$slots["action-buttons"] ? q("", !0) : (g(),
        _(we, {
            key: 1
        }, [!A(i).enabled && A(r).showCancel ? (g(),
        _("button", {
            key: 0,
            type: "button",
            ref_key: "cancelButtonRef",
            ref: f,
            class: "dp__action_button dp__action_cancel",
            onClick: C[0] || (C[0] = W => L.$emit("close-picker")),
            onKeydown: [C[1] || (C[1] = Xe(W => L.$emit("close-picker"), ["enter"])), C[2] || (C[2] = Xe(W => L.$emit("close-picker"), ["space"]))]
        }, Q(L.cancelText), 545)) : q("", !0), A(r).showNow ? (g(),
        _("button", {
            key: 1,
            type: "button",
            ref_key: "cancelButtonRef",
            ref: f,
            class: "dp__action_button dp__action_cancel",
            onClick: C[3] || (C[3] = W => L.$emit("select-now")),
            onKeydown: [C[4] || (C[4] = Xe(W => L.$emit("select-now"), ["enter"])), C[5] || (C[5] = Xe(W => L.$emit("select-now"), ["space"]))]
        }, Q(L.nowButtonLabel), 545)) : q("", !0), A(r).showSelect ? (g(),
        _("button", {
            key: 2,
            type: "button",
            class: "dp__action_button dp__action_select",
            onKeydown: [Xe(U, ["enter"]), Xe(U, ["space"])],
            onClick: U,
            disabled: v.value,
            ref_key: "selectButtonRef",
            ref: p
        }, Q(L.selectText), 41, GG)) : q("", !0)], 64))])], 64))], 4))
    }
})
  , JG = ["onKeydown"]
  , XG = {
    class: "dp__selection_grid_header"
}
  , QG = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"]
  , ZG = ["aria-label", "onKeydown"]
  , ru = Se({
    __name: "SelectionOverlay",
    props: {
        items: {},
        type: {},
        isLast: {
            type: Boolean
        },
        arrowNavigation: {
            type: Boolean
        },
        skipButtonRef: {
            type: Boolean
        },
        headerRefs: {},
        hideNavigation: {},
        escClose: {
            type: Boolean
        },
        useRelative: {
            type: Boolean
        },
        height: {},
        textInput: {
            type: [Boolean, Object]
        },
        config: {},
        noOverlayFocus: {
            type: Boolean
        }
    },
    emits: ["selected", "toggle", "reset-flow", "hover-value"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {setSelectionGrid: a, buildMultiLevelMatrix: s, setMonthPicker: l} = Ms()
          , {defaultedAriaLabels: i, defaultedTextInput: o, defaultedConfig: u} = sn(r)
          , {hideNavigationButtons: d} = Cc()
          , f = me(!1)
          , p = me(null)
          , h = me(null)
          , v = me([])
          , y = me()
          , k = me(null)
          , w = me(0)
          , $ = me(null);
        k1( () => {
            p.value = null
        }
        ),
        Zt( () => {
            Ot().then( () => C()),
            r.noOverlayFocus || S(),
            M(!0)
        }
        ),
        Ko( () => M(!1));
        const M = ne => {
            var I;
            r.arrowNavigation && ((I = r.headerRefs) != null && I.length ? l(ne) : a(ne))
        }
          , S = () => {
            var ne;
            const I = fn(h);
            I && (o.value.enabled || (p.value ? (ne = p.value) == null || ne.focus({
                preventScroll: !0
            }) : I.focus({
                preventScroll: !0
            })),
            f.value = I.clientHeight < I.scrollHeight)
        }
          , T = K( () => ({
            dp__overlay: !0,
            "dp--overlay-absolute": !r.useRelative,
            "dp--overlay-relative": r.useRelative
        }))
          , E = K( () => r.useRelative ? {
            height: `${r.height}px`,
            width: "260px"
        } : void 0)
          , O = K( () => ({
            dp__overlay_col: !0
        }))
          , U = K( () => ({
            dp__btn: !0,
            dp__button: !0,
            dp__overlay_action: !0,
            dp__over_action_scroll: f.value,
            dp__button_bottom: r.isLast
        }))
          , L = K( () => {
            var ne, I;
            return {
                dp__overlay_container: !0,
                dp__container_flex: ((ne = r.items) == null ? void 0 : ne.length) <= 6,
                dp__container_block: ((I = r.items) == null ? void 0 : I.length) > 6
            }
        }
        );
        Ke( () => r.items, () => C(), {
            deep: !0
        });
        const C = () => {
            Ot().then( () => {
                const ne = fn(p)
                  , I = fn(h)
                  , j = fn(k)
                  , re = fn($)
                  , le = j ? j.getBoundingClientRect().height : 0;
                I && (I.getBoundingClientRect().height ? w.value = I.getBoundingClientRect().height - le : w.value = u.value.modeHeight - le),
                ne && re && (re.scrollTop = ne.offsetTop - re.offsetTop - (w.value / 2 - ne.getBoundingClientRect().height) - le)
            }
            )
        }
          , W = ne => {
            ne.disabled || n("selected", ne.value)
        }
          , R = () => {
            n("toggle"),
            n("reset-flow")
        }
          , G = () => {
            r.escClose && R()
        }
          , te = (ne, I, j, re) => {
            ne && (I.active && (p.value = ne),
            r.arrowNavigation && (Array.isArray(v.value[j]) ? v.value[j][re] = ne : v.value[j] = [ne],
            J()))
        }
          , J = () => {
            var ne, I;
            const j = (ne = r.headerRefs) != null && ne.length ? [r.headerRefs].concat(v.value) : v.value.concat([r.skipButtonRef ? [] : [k.value]]);
            s(hn(j), (I = r.headerRefs) != null && I.length ? "monthPicker" : "selectionGrid")
        }
          , ae = ne => {
            r.arrowNavigation || ps(ne, u.value, !0)
        }
          , oe = ne => {
            y.value = ne,
            n("hover-value", ne)
        }
        ;
        return e({
            focusGrid: S
        }),
        (ne, I) => {
            var j;
            return g(),
            _("div", {
                ref_key: "gridWrapRef",
                ref: h,
                class: ye(T.value),
                style: Rt(E.value),
                role: "dialog",
                tabindex: "0",
                onKeydown: [Xe(_t(G, ["prevent"]), ["esc"]), I[0] || (I[0] = Xe(_t(re => ae(re), ["prevent"]), ["left"])), I[1] || (I[1] = Xe(_t(re => ae(re), ["prevent"]), ["up"])), I[2] || (I[2] = Xe(_t(re => ae(re), ["prevent"]), ["down"])), I[3] || (I[3] = Xe(_t(re => ae(re), ["prevent"]), ["right"]))]
            }, [c("div", {
                class: ye(L.value),
                ref_key: "containerRef",
                ref: $,
                role: "grid",
                style: Rt({
                    height: `${w.value}px`
                })
            }, [c("div", XG, [Z(ne.$slots, "header")]), ne.$slots.overlay ? Z(ne.$slots, "overlay", {
                key: 0
            }) : (g(!0),
            _(we, {
                key: 1
            }, Ne(ne.items, (re, le) => (g(),
            _("div", {
                class: ye(["dp__overlay_row", {
                    dp__flex_row: ne.items.length >= 3
                }]),
                key: le,
                role: "row"
            }, [(g(!0),
            _(we, null, Ne(re, (ce, xe) => (g(),
            _("div", {
                role: "gridcell",
                class: ye(O.value),
                key: ce.value,
                "aria-selected": ce.active,
                "aria-disabled": ce.disabled || void 0,
                ref_for: !0,
                ref: X => te(X, ce, le, xe),
                tabindex: "0",
                onClick: X => W(ce),
                onKeydown: [Xe(_t(X => W(ce), ["prevent"]), ["enter"]), Xe(_t(X => W(ce), ["prevent"]), ["space"])],
                onMouseover: X => oe(ce.value)
            }, [c("div", {
                class: ye(ce.className)
            }, [ne.$slots.item ? Z(ne.$slots, "item", {
                key: 0,
                item: ce
            }) : q("", !0), ne.$slots.item ? q("", !0) : (g(),
            _(we, {
                key: 1
            }, [ve(Q(ce.text), 1)], 64))], 2)], 42, QG))), 128))], 2))), 128))], 6), ne.$slots["button-icon"] ? ft((g(),
            _("button", {
                key: 0,
                type: "button",
                "aria-label": (j = A(i)) == null ? void 0 : j.toggleOverlay,
                class: ye(U.value),
                tabindex: "0",
                ref_key: "toggleButton",
                ref: k,
                onClick: R,
                onKeydown: [Xe(R, ["enter"]), Xe(R, ["tab"])]
            }, [Z(ne.$slots, "button-icon")], 42, ZG)), [[jn, !A(d)(ne.hideNavigation, ne.type)]]) : q("", !0)], 46, JG)
        }
    }
})
  , Ac = Se({
    __name: "InstanceWrap",
    props: {
        multiCalendars: {},
        stretch: {
            type: Boolean
        }
    },
    setup(t) {
        const e = t
          , n = K( () => e.multiCalendars > 0 ? [...Array(e.multiCalendars).keys()] : [0])
          , r = K( () => ({
            dp__instance_calendar: e.multiCalendars > 0
        }));
        return (a, s) => (g(),
        _("div", {
            class: ye({
                dp__menu_inner: !a.stretch,
                "dp--menu--inner-stretched": a.stretch,
                dp__flex_display: a.multiCalendars > 0
            })
        }, [(g(!0),
        _(we, null, Ne(n.value, (l, i) => (g(),
        _("div", {
            key: l,
            class: ye(r.value)
        }, [Z(a.$slots, "default", {
            instance: l,
            index: i
        })], 2))), 128))], 2))
    }
})
  , eY = ["aria-label", "aria-disabled"]
  , vo = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "ArrowBtn",
    props: {
        ariaLabel: {},
        disabled: {
            type: Boolean
        }
    },
    emits: ["activate", "set-ref"],
    setup(t, {emit: e}) {
        const n = me(null);
        return Zt( () => e("set-ref", n)),
        (r, a) => (g(),
        _("button", {
            type: "button",
            class: "dp__btn dp--arrow-btn-nav",
            onClick: a[0] || (a[0] = s => r.$emit("activate")),
            onKeydown: [a[1] || (a[1] = Xe(_t(s => r.$emit("activate"), ["prevent"]), ["enter"])), a[2] || (a[2] = Xe(_t(s => r.$emit("activate"), ["prevent"]), ["space"]))],
            tabindex: "0",
            "aria-label": r.ariaLabel,
            "aria-disabled": r.disabled || void 0,
            ref_key: "elRef",
            ref: n
        }, [c("span", {
            class: ye(["dp__inner_nav", {
                dp__inner_nav_disabled: r.disabled
            }])
        }, [Z(r.$slots, "default")], 2)], 40, eY))
    }
})
  , tY = {
    class: "dp--year-mode-picker"
}
  , nY = ["aria-label"]
  , DS = Se({
    __name: "YearModePicker",
    props: {
        ...jr,
        showYearPicker: {
            type: Boolean,
            default: !1
        },
        items: {
            type: Array,
            default: () => []
        },
        instance: {
            type: Number,
            default: 0
        },
        year: {
            type: Number,
            default: 0
        },
        isDisabled: {
            type: Function,
            default: () => !1
        }
    },
    emits: ["toggle-year-picker", "year-select", "handle-year"],
    setup(t, {emit: e}) {
        const n = t
          , {showRightIcon: r, showLeftIcon: a} = Cc()
          , {defaultedConfig: s, defaultedMultiCalendars: l, defaultedAriaLabels: i, defaultedTransitions: o} = sn(n)
          , {showTransition: u, transitionName: d} = tu(o)
          , f = (v=!1, y) => {
            e("toggle-year-picker", {
                flow: v,
                show: y
            })
        }
          , p = v => {
            e("year-select", v)
        }
          , h = (v=!1) => {
            e("handle-year", v)
        }
        ;
        return (v, y) => {
            var k, w, $;
            return g(),
            _("div", tY, [A(a)(A(l), t.instance) ? (g(),
            de(vo, {
                key: 0,
                ref: "mpPrevIconRef",
                "aria-label": (k = A(i)) == null ? void 0 : k.prevYear,
                disabled: t.isDisabled(!1),
                onActivate: y[0] || (y[0] = M => h(!1))
            }, {
                default: N( () => [v.$slots["arrow-left"] ? Z(v.$slots, "arrow-left", {
                    key: 0
                }) : q("", !0), v.$slots["arrow-left"] ? q("", !0) : (g(),
                de(A(uv), {
                    key: 1
                }))]),
                _: 3
            }, 8, ["aria-label", "disabled"])) : q("", !0), c("button", {
                class: "dp__btn dp--year-select",
                type: "button",
                ref: "mpYearButtonRef",
                "aria-label": (w = A(i)) == null ? void 0 : w.openYearsOverlay,
                onClick: y[1] || (y[1] = () => f(!1)),
                onKeydown: y[2] || (y[2] = Xe( () => f(!1), ["enter"]))
            }, [v.$slots.year ? Z(v.$slots, "year", {
                key: 0,
                year: t.year
            }) : q("", !0), v.$slots.year ? q("", !0) : (g(),
            _(we, {
                key: 1
            }, [ve(Q(t.year), 1)], 64))], 40, nY), A(r)(A(l), t.instance) ? (g(),
            de(vo, {
                key: 1,
                ref: "mpNextIconRef",
                "aria-label": ($ = A(i)) == null ? void 0 : $.nextYear,
                disabled: t.isDisabled(!0),
                onActivate: y[3] || (y[3] = M => h(!0))
            }, {
                default: N( () => [v.$slots["arrow-right"] ? Z(v.$slots, "arrow-right", {
                    key: 0
                }) : q("", !0), v.$slots["arrow-right"] ? q("", !0) : (g(),
                de(A(dv), {
                    key: 1
                }))]),
                _: 3
            }, 8, ["aria-label", "disabled"])) : q("", !0), x(fa, {
                name: A(d)(t.showYearPicker),
                css: A(u)
            }, {
                default: N( () => [t.showYearPicker ? (g(),
                de(ru, {
                    key: 0,
                    items: t.items,
                    "text-input": v.textInput,
                    "esc-close": v.escClose,
                    config: v.config,
                    onToggle: f,
                    onSelected: y[4] || (y[4] = M => p(M)),
                    "is-last": v.autoApply && !A(s).keepActionRow,
                    type: "year"
                }, gn({
                    "button-icon": N( () => [v.$slots["calendar-icon"] ? Z(v.$slots, "calendar-icon", {
                        key: 0
                    }) : q("", !0), v.$slots["calendar-icon"] ? q("", !0) : (g(),
                    de(A(eu), {
                        key: 1
                    }))]),
                    _: 2
                }, [v.$slots["year-overlay-value"] ? {
                    name: "item",
                    fn: N( ({item: M}) => [Z(v.$slots, "year-overlay-value", {
                        text: M.text,
                        value: M.value
                    })]),
                    key: "0"
                } : void 0]), 1032, ["items", "text-input", "esc-close", "config", "is-last"])) : q("", !0)]),
                _: 3
            }, 8, ["name", "css"])])
        }
    }
})
  , Mc = (t, e, n) => {
    if (e.value && Array.isArray(e.value))
        if (e.value.some(r => xt(t, r))) {
            const r = e.value.filter(a => !xt(a, t));
            e.value = r.length ? r : null
        } else
            (n && +n > e.value.length || !n) && e.value.push(t);
    else
        e.value = [t]
}
  , yv = (t, e, n) => {
    let r = t.value ? t.value.slice() : [];
    return r.length === 2 && r[1] !== null && (r = []),
    r.length ? An(e, r[0]) ? (r.unshift(e),
    n("range-start", r[0]),
    n("range-start", r[1])) : (r[1] = e,
    n("range-end", e)) : (r = [e],
    n("range-start", e)),
    t.value = r,
    r
}
  , Oc = (t, e, n, r) => {
    t[0] && t[1] && n && e("auto-apply"),
    t[0] && !t[1] && r && n && e("auto-apply")
}
  , PS = ({multiCalendars: t, highlight: e, calendars: n, modelValue: r, props: a, year: s, month: l, emit: i}) => {
    const o = K( () => gv(a.yearRange, a.reverseYears))
      , u = me([!1])
      , d = K( () => (S, T) => {
        const E = Ut(Mr(new Date), {
            month: l.value(S),
            year: s.value(S)
        });
        return AS(E, a.maxDate, a.minDate, a.preventMinMaxNavigation, T)
    }
    )
      , f = () => {
        for (let S = 0; S < t.value.count; S++)
            if (S === 0)
                n.value[S] = n.value[0];
            else {
                const T = Ut(Me(), n.value[S - 1]);
                n.value[S] = {
                    month: gt(T),
                    year: ct(tv(T, 1))
                }
            }
    }
      , p = S => {
        if (!S)
            return f();
        const T = Ut(Me(), n.value[S]);
        return n.value[0].year = ct(gS(T, t.value.count - 1)),
        f()
    }
      , h = S => a.focusStartDate ? S[0] : S[1] ? S[1] : S[0]
      , v = () => {
        if (r.value) {
            const S = Array.isArray(r.value) ? h(r.value) : r.value;
            n.value[0] = {
                month: gt(S),
                year: ct(S)
            }
        }
    }
    ;
    Zt( () => {
        v(),
        t.value.count && f()
    }
    );
    const y = (S, T) => {
        n.value[T].year = S,
        t.value.count && !t.value.solo && p(T)
    }
      , k = K( () => S => ki(o.value, T => {
        const E = s.value(S) === T.value
          , O = Ro(T.value, _i(a.minDate), _i(a.maxDate))
          , U = bv(e.value, T.value);
        return {
            active: E,
            disabled: O,
            highlighted: U
        }
    }
    ))
      , w = (S, T) => {
        y(S, T),
        M(T)
    }
      , $ = (S, T=!1) => {
        if (!d.value(S, T)) {
            const E = T ? s.value(S) + 1 : s.value(S) - 1;
            y(E, S)
        }
    }
      , M = (S, T=!1, E) => {
        T || i("reset-flow"),
        E !== void 0 ? u.value[S] = E : u.value[S] = !u.value[S],
        u.value || i("overlay-closed")
    }
    ;
    return {
        isDisabled: d,
        groupedYears: k,
        showYearPicker: u,
        selectYear: y,
        toggleYearPicker: M,
        handleYearSelect: w,
        handleYear: $
    }
}
  , rY = (t, e) => {
    const {defaultedMultiCalendars: n, defaultedAriaLabels: r, defaultedTransitions: a, defaultedConfig: s, defaultedHighlight: l} = sn(t)
      , {modelValue: i, year: o, month: u, calendars: d} = nu(t, e)
      , f = K( () => wS(t.formatLocale, t.locale, t.monthNameFormat))
      , p = me(null)
      , {selectYear: h, groupedYears: v, showYearPicker: y, toggleYearPicker: k, handleYearSelect: w, handleYear: $, isDisabled: M} = PS({
        modelValue: i,
        multiCalendars: n,
        highlight: l,
        calendars: d,
        year: o,
        month: u,
        props: t,
        emit: e
    })
      , S = oe => oe ? {
        month: gt(oe),
        year: ct(oe)
    } : {
        month: null,
        year: null
    }
      , T = () => i.value ? Array.isArray(i.value) ? i.value.map(oe => S(oe)) : S(i.value) : S()
      , E = (oe, ne) => {
        const I = d.value[oe]
          , j = T();
        return Array.isArray(j) ? j.some(re => re.year === (I == null ? void 0 : I.year) && re.month === ne) : (I == null ? void 0 : I.year) === j.year && ne === j.month
    }
      , O = (oe, ne, I) => {
        var j, re;
        const le = T();
        return Array.isArray(le) ? o.value(ne) === ((j = le[I]) == null ? void 0 : j.year) && oe === ((re = le[I]) == null ? void 0 : re.month) : !1
    }
      , U = (oe, ne) => {
        if (t.range) {
            const I = T();
            if (Array.isArray(i.value) && Array.isArray(I)) {
                const j = O(oe, ne, 0) || O(oe, ne, 1)
                  , re = Sa(Mr(Me()), oe, o.value(ne));
                return Tc(i.value, p.value, re) && !j
            }
            return !1
        }
        return !1
    }
      , L = K( () => oe => ki(f.value, ne => {
        const I = E(oe, ne.value)
          , j = Ro(ne.value, SS(o.value(oe), t.minDate), $S(o.value(oe), t.maxDate)) || SG(t.disabledDates, o.value(oe)).includes(ne.value)
          , re = U(ne.value, oe)
          , le = OS(l.value, ne.value, o.value(oe));
        return {
            active: I,
            disabled: j,
            isBetween: re,
            highlighted: le
        }
    }
    ))
      , C = (oe, ne) => Sa(Mr(Me()), oe, o.value(ne))
      , W = (oe, ne) => {
        const I = i.value ? i.value : Mr(new Date);
        i.value = Sa(I, oe, o.value(ne)),
        e("auto-apply")
    }
      , R = (oe, ne) => {
        const I = yv(i, C(oe, ne), e);
        Oc(I, e, t.autoApply, t.modelAuto)
    }
      , G = (oe, ne) => {
        Mc(C(oe, ne), i, t.multiDatesLimit),
        e("auto-apply", !0)
    }
      , te = (oe, ne) => (d.value[ne].month = oe,
    ae(ne, d.value[ne].year, oe),
    t.multiDates ? G(oe, ne) : t.range ? R(oe, ne) : W(oe, ne))
      , J = (oe, ne) => {
        h(oe, ne),
        ae(ne, oe, null)
    }
      , ae = (oe, ne, I) => {
        let j = I;
        if (!j) {
            const re = T();
            j = Array.isArray(re) ? re[oe].month : re.month
        }
        e("update-month-year", {
            instance: oe,
            year: ne,
            month: j
        })
    }
    ;
    return {
        groupedMonths: L,
        groupedYears: v,
        year: o,
        isDisabled: M,
        defaultedMultiCalendars: n,
        defaultedAriaLabels: r,
        defaultedTransitions: a,
        defaultedConfig: s,
        showYearPicker: y,
        modelValue: i,
        setHoverDate: (oe, ne) => {
            p.value = C(oe, ne)
        }
        ,
        selectMonth: te,
        selectYear: J,
        toggleYearPicker: k,
        handleYearSelect: w,
        handleYear: $,
        getModelMonthYear: T
    }
}
  , aY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "MonthPicker",
    props: {
        ...jr
    },
    emits: ["update:internal-model-value", "overlay-closed", "reset-flow", "range-start", "range-end", "auto-apply", "update-month-year"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = sr(a, "yearMode")
          , {groupedMonths: l, groupedYears: i, year: o, isDisabled: u, defaultedMultiCalendars: d, defaultedConfig: f, showYearPicker: p, modelValue: h, setHoverDate: v, selectMonth: y, selectYear: k, toggleYearPicker: w, handleYearSelect: $, handleYear: M, getModelMonthYear: S} = rY(r, n);
        return e({
            getSidebarProps: () => ({
                modelValue: h,
                year: o,
                getModelMonthYear: S,
                selectMonth: y,
                selectYear: k,
                handleYear: M
            })
        }),
        (T, E) => (g(),
        de(Ac, {
            "multi-calendars": A(d).count,
            stretch: ""
        }, {
            default: N( ({instance: O}) => [T.$slots["month-year"] ? Z(T.$slots, "month-year", ut(Ve({
                key: 0
            }, {
                year: A(o),
                months: A(l)(O),
                years: A(i)(O),
                selectMonth: A(y),
                selectYear: A(k),
                instance: O
            }))) : (g(),
            de(ru, {
                key: 1,
                items: A(l)(O),
                "arrow-navigation": T.arrowNavigation,
                "is-last": T.autoApply && !A(f).keepActionRow,
                "esc-close": T.escClose,
                height: A(f).modeHeight,
                config: T.config,
                "no-overlay-focus": T.noOverlayFocus,
                onSelected: U => A(y)(U, O),
                onHoverValue: U => A(v)(U, O),
                "use-relative": "",
                type: "month"
            }, {
                header: N( () => [x(DS, Ve(T.$props, {
                    items: A(i)(O),
                    instance: O,
                    "show-year-picker": A(p)[O],
                    year: A(o)(O),
                    "is-disabled": U => A(u)(O, U),
                    onHandleYear: U => A(M)(O, U),
                    onYearSelect: U => A($)(U, O),
                    onToggleYearPicker: U => A(w)(O, U == null ? void 0 : U.flow, U == null ? void 0 : U.show)
                }), gn({
                    _: 2
                }, [Ne(A(s), (U, L) => ({
                    name: U,
                    fn: N(C => [Z(T.$slots, U, ut(Vt(C)))])
                }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]),
                _: 2
            }, 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))]),
            _: 3
        }, 8, ["multi-calendars"]))
    }
})
  , sY = (t, e) => {
    const {modelValue: n} = nu(t, e)
      , r = me(null)
      , {defaultedHighlight: a} = sn(t)
      , s = u => Array.isArray(n.value) ? n.value.some(d => ct(d) === u) : n.value ? ct(n.value) === u : !1
      , l = u => t.range && Array.isArray(n.value) ? Tc(n.value, r.value, o(u)) : !1
      , i = K( () => ki(gv(t.yearRange, t.reverseYears), u => {
        const d = s(u.value)
          , f = Ro(u.value, _i(t.minDate), _i(t.maxDate))
          , p = l(u.value)
          , h = bv(a.value, u.value);
        return {
            active: d,
            disabled: f,
            isBetween: p,
            highlighted: h
        }
    }
    ))
      , o = u => tl(Mr(new Date), u);
    return {
        groupedYears: i,
        modelValue: n,
        setHoverValue: u => {
            r.value = tl(Mr(new Date), u)
        }
        ,
        selectYear: u => {
            if (t.multiDates)
                return Mc(o(u), n, t.multiDatesLimit),
                e("auto-apply", !0);
            if (t.range) {
                const d = yv(n, o(u), e);
                return Oc(d, e, t.autoApply, t.modelAuto)
            }
            n.value = o(u),
            e("auto-apply")
        }
    }
}
  , lY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "YearPicker",
    props: {
        ...jr
    },
    emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {groupedYears: a, modelValue: s, selectYear: l, setHoverValue: i} = sY(r, n)
          , {defaultedConfig: o} = sn(r);
        return e({
            getSidebarProps: () => ({
                modelValue: s,
                selectYear: l
            })
        }),
        (u, d) => (g(),
        _("div", null, [u.$slots["month-year"] ? Z(u.$slots, "month-year", ut(Ve({
            key: 0
        }, {
            years: A(a),
            selectYear: A(l)
        }))) : (g(),
        de(ru, {
            key: 1,
            items: A(a),
            "is-last": u.autoApply && !A(o).keepActionRow,
            height: A(o).modeHeight,
            config: u.config,
            "no-overlay-focus": u.noOverlayFocus,
            type: "year",
            "use-relative": "",
            onSelected: A(l),
            onHoverValue: A(i)
        }, gn({
            _: 2
        }, [u.$slots["year-overlay-value"] ? {
            name: "item",
            fn: N( ({item: f}) => [Z(u.$slots, "year-overlay-value", {
                text: f.text,
                value: f.value
            })]),
            key: "0"
        } : void 0]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))]))
    }
})
  , iY = {
    key: 0,
    class: "dp__time_input"
}
  , oY = ["aria-label", "onKeydown", "onClick"]
  , uY = c("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
}, null, -1)
  , dY = c("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
}, null, -1)
  , cY = ["aria-label", "disabled", "onKeydown", "onClick"]
  , fY = ["aria-label", "onKeydown", "onClick"]
  , pY = c("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
}, null, -1)
  , hY = c("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
}, null, -1)
  , mY = {
    key: 0
}
  , vY = ["aria-label", "onKeydown"]
  , gY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "TimeInput",
    props: {
        hours: {
            type: Number,
            default: 0
        },
        minutes: {
            type: Number,
            default: 0
        },
        seconds: {
            type: Number,
            default: 0
        },
        closeTimePickerBtn: {
            type: Object,
            default: null
        },
        order: {
            type: Number,
            default: 0
        },
        disabledTimesConfig: {
            type: Function,
            default: null
        },
        validateTime: {
            type: Function,
            default: () => !1
        },
        ...jr
    },
    emits: ["set-hours", "set-minutes", "update:hours", "update:minutes", "update:seconds", "reset-flow", "mounted", "overlay-closed", "am-pm-change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {setTimePickerElements: a, setTimePickerBackRef: s} = Ms()
          , {defaultedAriaLabels: l, defaultedTransitions: i, defaultedFilters: o, defaultedConfig: u} = sn(r)
          , {transitionName: d, showTransition: f} = tu(i)
          , p = Fn({
            hours: !1,
            minutes: !1,
            seconds: !1
        })
          , h = me("AM")
          , v = me(null)
          , y = me([]);
        Zt( () => {
            n("mounted")
        }
        );
        const k = X => Ut(new Date, {
            hours: X.hours,
            minutes: X.minutes,
            seconds: r.enableSeconds ? X.seconds : 0,
            milliseconds: 0
        })
          , w = K( () => X => G(X, r[X]) || M(X, r[X]))
          , $ = K( () => ({
            hours: r.hours,
            minutes: r.minutes,
            seconds: r.seconds
        }))
          , M = (X, be) => r.range && !r.disableTimeRangeValidation ? !r.validateTime(X, be) : !1
          , S = (X, be) => {
            if (r.range && !r.disableTimeRangeValidation) {
                const ee = be ? +r[`${X}Increment`] : -+r[`${X}Increment`]
                  , B = r[X] + ee;
                return !r.validateTime(X, B)
            }
            return !1
        }
          , T = K( () => X => !J(+r[X] + +r[`${X}Increment`], X) || S(X, !0))
          , E = K( () => X => !J(+r[X] - +r[`${X}Increment`], X) || S(X, !1))
          , O = (X, be) => Jx(Ut(Me(), X), be)
          , U = (X, be) => RW(Ut(Me(), X), be)
          , L = K( () => ({
            dp__time_col: !0,
            dp__time_col_block: !r.timePickerInline,
            dp__time_col_reg_block: !r.enableSeconds && r.is24 && !r.timePickerInline,
            dp__time_col_reg_inline: !r.enableSeconds && r.is24 && r.timePickerInline,
            dp__time_col_reg_with_button: !r.enableSeconds && !r.is24,
            dp__time_col_sec: r.enableSeconds && r.is24,
            dp__time_col_sec_with_button: r.enableSeconds && !r.is24
        }))
          , C = K( () => {
            const X = [{
                type: "hours"
            }, {
                type: "",
                separator: !0
            }, {
                type: "minutes"
            }];
            return r.enableSeconds ? X.concat([{
                type: "",
                separator: !0
            }, {
                type: "seconds"
            }]) : X
        }
        )
          , W = K( () => C.value.filter(X => !X.separator))
          , R = K( () => X => {
            if (X === "hours") {
                const be = j(+r.hours);
                return {
                    text: be < 10 ? `0${be}` : `${be}`,
                    value: be
                }
            }
            return {
                text: r[X] < 10 ? `0${r[X]}` : `${r[X]}`,
                value: r[X]
            }
        }
        )
          , G = (X, be) => {
            var ee;
            if (!r.disabledTimesConfig)
                return !1;
            const B = r.disabledTimesConfig(r.order, X === "hours" ? be : void 0);
            return B[X] ? !!((ee = B[X]) != null && ee.includes(be)) : !0
        }
          , te = X => {
            const be = r.is24 ? 24 : 12
              , ee = X === "hours" ? be : 60
              , B = +r[`${X}GridIncrement`]
              , se = X === "hours" && !r.is24 ? B : 0
              , pe = [];
            for (let ie = se; ie < ee; ie += B)
                pe.push({
                    value: ie,
                    text: ie < 10 ? `0${ie}` : `${ie}`
                });
            return X === "hours" && !r.is24 && pe.push({
                value: 0,
                text: "12"
            }),
            ki(pe, ie => ({
                active: !1,
                disabled: o.value.times[X].includes(ie.value) || !J(ie.value, X) || G(X, ie.value) || M(X, ie.value)
            }))
        }
          , J = (X, be) => {
            const ee = r.minTime ? k(qf(r.minTime)) : null
              , B = r.maxTime ? k(qf(r.maxTime)) : null
              , se = k(qf($.value, be, X));
            return ee && B ? (Io(se, B) || Kl(se, B)) && (Vo(se, ee) || Kl(se, ee)) : ee ? Vo(se, ee) || Kl(se, ee) : B ? Io(se, B) || Kl(se, B) : !0
        }
          , ae = X => r[`no${X[0].toUpperCase() + X.slice(1)}Overlay`]
          , oe = X => {
            ae(X) || (p[X] = !p[X],
            p[X] || n("overlay-closed"))
        }
          , ne = X => X === "hours" ? Fr : X === "minutes" ? sa : bi
          , I = (X, be=!0) => {
            const ee = be ? O : U
              , B = be ? +r[`${X}Increment`] : -+r[`${X}Increment`];
            J(+r[X] + B, X) && n(`update:${X}`, ne(X)(ee({
                [X]: +r[X]
            }, {
                [X]: +r[`${X}Increment`]
            })))
        }
          , j = X => r.is24 ? X : (X >= 12 ? h.value = "PM" : h.value = "AM",
        hG(X))
          , re = () => {
            h.value === "PM" ? (h.value = "AM",
            n("update:hours", r.hours - 12)) : (h.value = "PM",
            n("update:hours", r.hours + 12)),
            n("am-pm-change", h.value)
        }
          , le = X => {
            p[X] = !0
        }
          , ce = (X, be, ee) => {
            if (X && r.arrowNavigation) {
                Array.isArray(y.value[be]) ? y.value[be][ee] = X : y.value[be] = [X];
                const B = y.value.reduce( (se, pe) => pe.map( (ie, fe) => [...se[fe] || [], pe[fe]]), []);
                s(r.closeTimePickerBtn),
                v.value && (B[1] = B[1].concat(v.value)),
                a(B, r.order)
            }
        }
          , xe = (X, be) => (oe(X),
        X === "hours" && !r.is24 ? n(`update:${X}`, h.value === "PM" ? be + 12 : be) : n(`update:${X}`, be));
        return e({
            openChildCmp: le
        }),
        (X, be) => {
            var ee;
            return X.disabled ? q("", !0) : (g(),
            _("div", iY, [(g(!0),
            _(we, null, Ne(C.value, (B, se) => {
                var pe, ie, fe;
                return g(),
                _("div", {
                    key: se,
                    class: ye(L.value)
                }, [B.separator ? (g(),
                _(we, {
                    key: 0
                }, [ve(" : ")], 64)) : (g(),
                _(we, {
                    key: 1
                }, [c("button", {
                    type: "button",
                    class: ye({
                        dp__btn: !0,
                        dp__inc_dec_button: !X.timePickerInline,
                        dp__inc_dec_button_inline: X.timePickerInline,
                        dp__tp_inline_btn_top: X.timePickerInline,
                        dp__inc_dec_button_disabled: T.value(B.type)
                    }),
                    "aria-label": (pe = A(l)) == null ? void 0 : pe.incrementValue(B.type),
                    tabindex: "0",
                    onKeydown: [Xe(_t(F => I(B.type), ["prevent"]), ["enter"]), Xe(_t(F => I(B.type), ["prevent"]), ["space"])],
                    onClick: F => I(B.type),
                    ref_for: !0,
                    ref: F => ce(F, se, 0)
                }, [r.timePickerInline ? (g(),
                _(we, {
                    key: 1
                }, [uY, dY], 64)) : (g(),
                _(we, {
                    key: 0
                }, [X.$slots["arrow-up"] ? Z(X.$slots, "arrow-up", {
                    key: 0
                }) : q("", !0), X.$slots["arrow-up"] ? q("", !0) : (g(),
                de(A(fv), {
                    key: 1
                }))], 64))], 42, oY), c("button", {
                    type: "button",
                    "aria-label": (ie = A(l)) == null ? void 0 : ie.openTpOverlay(B.type),
                    class: ye({
                        dp__time_display: !0,
                        dp__time_display_block: !X.timePickerInline,
                        dp__time_display_inline: X.timePickerInline,
                        "dp--time-invalid": w.value(B.type),
                        "dp--time-overlay-btn": !w.value(B.type)
                    }),
                    disabled: ae(B.type),
                    tabindex: "0",
                    onKeydown: [Xe(_t(F => oe(B.type), ["prevent"]), ["enter"]), Xe(_t(F => oe(B.type), ["prevent"]), ["space"])],
                    onClick: F => oe(B.type),
                    ref_for: !0,
                    ref: F => ce(F, se, 1)
                }, [X.$slots[B.type] ? Z(X.$slots, B.type, {
                    key: 0,
                    text: R.value(B.type).text,
                    value: R.value(B.type).value
                }) : q("", !0), X.$slots[B.type] ? q("", !0) : (g(),
                _(we, {
                    key: 1
                }, [ve(Q(R.value(B.type).text), 1)], 64))], 42, cY), c("button", {
                    type: "button",
                    class: ye({
                        dp__btn: !0,
                        dp__inc_dec_button: !X.timePickerInline,
                        dp__inc_dec_button_inline: X.timePickerInline,
                        dp__tp_inline_btn_bottom: X.timePickerInline,
                        dp__inc_dec_button_disabled: E.value(B.type)
                    }),
                    "aria-label": (fe = A(l)) == null ? void 0 : fe.decrementValue(B.type),
                    tabindex: "0",
                    onKeydown: [Xe(_t(F => I(B.type, !1), ["prevent"]), ["enter"]), Xe(_t(F => I(B.type, !1), ["prevent"]), ["space"])],
                    onClick: F => I(B.type, !1),
                    ref_for: !0,
                    ref: F => ce(F, se, 2)
                }, [r.timePickerInline ? (g(),
                _(we, {
                    key: 1
                }, [pY, hY], 64)) : (g(),
                _(we, {
                    key: 0
                }, [X.$slots["arrow-down"] ? Z(X.$slots, "arrow-down", {
                    key: 0
                }) : q("", !0), X.$slots["arrow-down"] ? q("", !0) : (g(),
                de(A(pv), {
                    key: 1
                }))], 64))], 42, fY)], 64))], 2)
            }
            ), 128)), X.is24 ? q("", !0) : (g(),
            _("div", mY, [X.$slots["am-pm-button"] ? Z(X.$slots, "am-pm-button", {
                key: 0,
                toggle: re,
                value: h.value
            }) : q("", !0), X.$slots["am-pm-button"] ? q("", !0) : (g(),
            _("button", {
                key: 1,
                ref_key: "amPmButton",
                ref: v,
                type: "button",
                class: "dp__pm_am_button",
                role: "button",
                "aria-label": (ee = A(l)) == null ? void 0 : ee.amPmButton,
                tabindex: "0",
                onClick: re,
                onKeydown: [Xe(_t(re, ["prevent"]), ["enter"]), Xe(_t(re, ["prevent"]), ["space"])]
            }, Q(h.value), 41, vY))])), (g(!0),
            _(we, null, Ne(W.value, (B, se) => (g(),
            de(fa, {
                key: se,
                name: A(d)(p[B.type]),
                css: A(f)
            }, {
                default: N( () => [p[B.type] ? (g(),
                de(ru, {
                    key: 0,
                    items: te(B.type),
                    "is-last": X.autoApply && !A(u).keepActionRow,
                    "esc-close": X.escClose,
                    type: B.type,
                    "text-input": X.textInput,
                    config: X.config,
                    "arrow-navigation": X.arrowNavigation,
                    onSelected: pe => xe(B.type, pe),
                    onToggle: pe => oe(B.type),
                    onResetFlow: be[0] || (be[0] = pe => X.$emit("reset-flow"))
                }, gn({
                    "button-icon": N( () => [X.$slots["clock-icon"] ? Z(X.$slots, "clock-icon", {
                        key: 0
                    }) : q("", !0), X.$slots["clock-icon"] ? q("", !0) : (g(),
                    de(A(cv), {
                        key: 1
                    }))]),
                    _: 2
                }, [X.$slots[`${B.type}-overlay-value`] ? {
                    name: "item",
                    fn: N( ({item: pe}) => [Z(X.$slots, `${B.type}-overlay-value`, {
                        text: pe.text,
                        value: pe.value
                    })]),
                    key: "0"
                } : void 0]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "onSelected", "onToggle"])) : q("", !0)]),
                _: 2
            }, 1032, ["name", "css"]))), 128))]))
        }
    }
})
  , bY = {
    class: "dp--tp-wrap"
}
  , yY = ["aria-label", "tabindex"]
  , kY = ["tabindex"]
  , _Y = ["aria-label"]
  , FS = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "TimePicker",
    props: {
        hours: {
            type: [Number, Array],
            default: 0
        },
        minutes: {
            type: [Number, Array],
            default: 0
        },
        seconds: {
            type: [Number, Array],
            default: 0
        },
        disabledTimesConfig: {
            type: Function,
            default: null
        },
        validateTime: {
            type: Function,
            default: () => !1
        },
        ...jr
    },
    emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow", "overlay-opened", "overlay-closed", "am-pm-change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {buildMatrix: a, setTimePicker: s} = Ms()
          , l = en()
          , {defaultedTransitions: i, defaultedAriaLabels: o, defaultedTextInput: u, defaultedConfig: d} = sn(r)
          , {transitionName: f, showTransition: p} = tu(i)
          , {hideNavigationButtons: h} = Cc()
          , v = me(null)
          , y = me(null)
          , k = me([])
          , w = me(null);
        Zt( () => {
            n("mount"),
            !r.timePicker && r.arrowNavigation ? a([fn(v.value)], "time") : s(!0, r.timePicker)
        }
        );
        const $ = K( () => r.range && r.modelAuto ? xS(r.internalModelValue) : !0)
          , M = me(!1)
          , S = te => ({
            hours: Array.isArray(r.hours) ? r.hours[te] : r.hours,
            minutes: Array.isArray(r.minutes) ? r.minutes[te] : r.minutes,
            seconds: Array.isArray(r.seconds) ? r.seconds[te] : r.seconds
        })
          , T = K( () => {
            const te = [];
            if (r.range)
                for (let J = 0; J < 2; J++)
                    te.push(S(J));
            else
                te.push(S(0));
            return te
        }
        )
          , E = (te, J=!1, ae="") => {
            J || n("reset-flow"),
            M.value = te,
            n(te ? "overlay-opened" : "overlay-closed"),
            r.arrowNavigation && s(te),
            Ot( () => {
                ae !== "" && k.value[0] && k.value[0].openChildCmp(ae)
            }
            )
        }
          , O = K( () => ({
            dp__btn: !0,
            dp__button: !0,
            dp__button_bottom: r.autoApply && !d.value.keepActionRow
        }))
          , U = sr(l, "timePicker")
          , L = (te, J, ae) => r.range ? J === 0 ? [te, T.value[1][ae]] : [T.value[0][ae], te] : te
          , C = te => {
            n("update:hours", te)
        }
          , W = te => {
            n("update:minutes", te)
        }
          , R = te => {
            n("update:seconds", te)
        }
          , G = () => {
            if (w.value && !u.value.enabled && !r.noOverlayFocus) {
                const te = vG(w.value);
                te && te.focus({
                    preventScroll: !0
                })
            }
        }
        ;
        return e({
            toggleTimePicker: E
        }),
        (te, J) => {
            var ae;
            return g(),
            _("div", bY, [!te.timePicker && !te.timePickerInline ? ft((g(),
            _("button", {
                key: 0,
                type: "button",
                class: ye(O.value),
                "aria-label": (ae = A(o)) == null ? void 0 : ae.openTimePicker,
                tabindex: te.noOverlayFocus ? void 0 : 0,
                ref_key: "openTimePickerBtn",
                ref: v,
                onKeydown: [J[0] || (J[0] = Xe(oe => E(!0), ["enter"])), J[1] || (J[1] = Xe(oe => E(!0), ["space"]))],
                onClick: J[2] || (J[2] = oe => E(!0))
            }, [te.$slots["clock-icon"] ? Z(te.$slots, "clock-icon", {
                key: 0
            }) : q("", !0), te.$slots["clock-icon"] ? q("", !0) : (g(),
            de(A(cv), {
                key: 1
            }))], 42, yY)), [[jn, !A(h)(te.hideNavigation, "time")]]) : q("", !0), x(fa, {
                name: A(f)(M.value),
                css: A(p) && !te.timePickerInline
            }, {
                default: N( () => {
                    var oe;
                    return [M.value || te.timePicker || te.timePickerInline ? (g(),
                    _("div", {
                        key: 0,
                        class: ye({
                            dp__overlay: !te.timePickerInline,
                            "dp--overlay-absolute": !r.timePicker && !te.timePickerInline,
                            "dp--overlay-relative": r.timePicker
                        }),
                        style: Rt(te.timePicker ? {
                            height: `${A(d).modeHeight}px`
                        } : void 0),
                        ref_key: "overlayRef",
                        ref: w,
                        tabindex: te.timePickerInline ? void 0 : 0
                    }, [c("div", {
                        class: ye(te.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"),
                        style: {
                            display: "flex"
                        }
                    }, [te.$slots["time-picker-overlay"] ? Z(te.$slots, "time-picker-overlay", {
                        key: 0,
                        hours: t.hours,
                        minutes: t.minutes,
                        seconds: t.seconds,
                        setHours: C,
                        setMinutes: W,
                        setSeconds: R
                    }) : q("", !0), te.$slots["time-picker-overlay"] ? q("", !0) : (g(),
                    _("div", {
                        key: 1,
                        class: ye(te.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                    }, [(g(!0),
                    _(we, null, Ne(T.value, (ne, I) => ft((g(),
                    de(gY, Ve({
                        key: I
                    }, {
                        ...te.$props,
                        order: I,
                        hours: ne.hours,
                        minutes: ne.minutes,
                        seconds: ne.seconds,
                        closeTimePickerBtn: y.value,
                        disabledTimesConfig: t.disabledTimesConfig,
                        disabled: I === 0 ? te.fixedStart : te.fixedEnd
                    }, {
                        "validate-time": (j, re) => t.validateTime(j, L(re, I, j)),
                        ref_for: !0,
                        ref_key: "timeInputRefs",
                        ref: k,
                        "onUpdate:hours": j => C(L(j, I, "hours")),
                        "onUpdate:minutes": j => W(L(j, I, "minutes")),
                        "onUpdate:seconds": j => R(L(j, I, "seconds")),
                        onMounted: G,
                        onOverlayClosed: G,
                        onAmPmChange: J[3] || (J[3] = j => te.$emit("am-pm-change", j))
                    }), gn({
                        _: 2
                    }, [Ne(A(U), (j, re) => ({
                        name: j,
                        fn: N(le => [Z(te.$slots, j, ut(Vt(le)))])
                    }))]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [[jn, I === 0 ? !0 : $.value]])), 128))], 2)), !te.timePicker && !te.timePickerInline ? ft((g(),
                    _("button", {
                        key: 2,
                        type: "button",
                        ref_key: "closeTimePickerBtn",
                        ref: y,
                        class: ye(O.value),
                        "aria-label": (oe = A(o)) == null ? void 0 : oe.closeTimePicker,
                        tabindex: "0",
                        onKeydown: [J[4] || (J[4] = Xe(ne => E(!1), ["enter"])), J[5] || (J[5] = Xe(ne => E(!1), ["space"]))],
                        onClick: J[6] || (J[6] = ne => E(!1))
                    }, [te.$slots["calendar-icon"] ? Z(te.$slots, "calendar-icon", {
                        key: 0
                    }) : q("", !0), te.$slots["calendar-icon"] ? q("", !0) : (g(),
                    de(A(eu), {
                        key: 1
                    }))], 42, _Y)), [[jn, !A(h)(te.hideNavigation, "time")]]) : q("", !0)], 2)], 14, kY)) : q("", !0)]
                }
                ),
                _: 3
            }, 8, ["name", "css"])])
        }
    }
})
  , BS = (t, e, n, r) => {
    const a = (w, $) => Array.isArray(e[w]) ? e[w][$] : e[w]
      , s = w => t.enableSeconds ? Array.isArray(e.seconds) ? e.seconds[w] : e.seconds : 0
      , l = (w, $) => w ? $ !== void 0 ? hs(w, a("hours", $), a("minutes", $), s($)) : hs(w, e.hours, e.minutes, s()) : ov(Me(), s($))
      , i = (w, $) => {
        e[w] = $
    }
      , o = (w, $) => {
        const M = Object.fromEntries(Object.keys(e).map(S => S === w ? [S, $] : [S, e[S]].slice()));
        if (t.range && !t.disableTimeRangeValidation) {
            const S = E => n.value ? hs(n.value[E], M.hours[E], M.minutes[E], M.seconds[E]) : null
              , T = E => iv(n.value[E], 0);
            return !(xt(S(0), S(1)) && (Vo(S(0), T(1)) || Io(S(1), T(0))))
        }
        return !0
    }
      , u = (w, $) => {
        o(w, $) && (i(w, $),
        r && r())
    }
      , d = w => {
        u("hours", w)
    }
      , f = w => {
        u("minutes", w)
    }
      , p = w => {
        u("seconds", w)
    }
      , h = (w, $, M, S) => {
        $ && d(w),
        !$ && !M && f(w),
        M && p(w),
        n.value && S(n.value)
    }
      , v = w => {
        if (w) {
            const $ = Array.isArray(w)
              , M = $ ? [+w[0].hours, +w[1].hours] : +w.hours
              , S = $ ? [+w[0].minutes, +w[1].minutes] : +w.minutes
              , T = $ ? [+w[0].seconds, +w[1].seconds] : +w.seconds;
            i("hours", M),
            i("minutes", S),
            t.enableSeconds && i("seconds", T)
        }
    }
      , y = (w, $) => {
        const M = {
            hours: Array.isArray(e.hours) ? e.hours[w] : e.hours,
            disabledArr: []
        };
        return ($ || $ === 0) && (M.hours = $),
        Array.isArray(t.disabledTimes) && (M.disabledArr = t.range && Array.isArray(t.disabledTimes[w]) ? t.disabledTimes[w] : t.disabledTimes),
        M
    }
      , k = K( () => (w, $) => {
        var M;
        if (Array.isArray(t.disabledTimes)) {
            const {disabledArr: S, hours: T} = y(w, $)
              , E = S.filter(O => +O.hours === T);
            return ((M = E[0]) == null ? void 0 : M.minutes) === "*" ? {
                hours: [T],
                minutes: void 0,
                seconds: void 0
            } : {
                hours: [],
                minutes: (E == null ? void 0 : E.map(O => +O.minutes)) ?? [],
                seconds: (E == null ? void 0 : E.map(O => O.seconds ? +O.seconds : void 0)) ?? []
            }
        }
        return {
            hours: [],
            minutes: [],
            seconds: []
        }
    }
    );
    return {
        setTime: i,
        updateHours: d,
        updateMinutes: f,
        updateSeconds: p,
        getSetDateTime: l,
        updateTimeValues: h,
        getSecondsValue: s,
        assignStartTime: v,
        validateTime: o,
        disabledTimesConfig: k
    }
}
  , wY = (t, e) => {
    const {modelValue: n, time: r} = nu(t, e)
      , {defaultedStartTime: a} = sn(t)
      , {updateTimeValues: s, getSetDateTime: l, setTime: i, assignStartTime: o, disabledTimesConfig: u, validateTime: d} = BS(t, r, n)
      , f = $ => {
        const {hours: M, minutes: S, seconds: T} = $;
        return {
            hours: +M,
            minutes: +S,
            seconds: T ? +T : 0
        }
    }
      , p = () => {
        if (t.startTime) {
            if (Array.isArray(t.startTime)) {
                const M = f(t.startTime[0])
                  , S = f(t.startTime[1]);
                return [Ut(Me(), M), Ut(Me(), S)]
            }
            const $ = f(t.startTime);
            return Ut(Me(), $)
        }
        return t.range ? [null, null] : null
    }
      , h = () => {
        if (t.range) {
            const [$,M] = p();
            n.value = [l($, 0), l(M, 1)]
        } else
            n.value = l(p())
    }
      , v = $ => Array.isArray($) ? [nl(Me($[0])), nl(Me($[1]))] : [nl($ ?? Me())]
      , y = ($, M, S) => {
        i("hours", $),
        i("minutes", M),
        i("seconds", t.enableSeconds ? S : 0)
    }
      , k = () => {
        const [$,M] = v(n.value);
        return t.range ? y([$.hours, M.hours], [$.minutes, M.minutes], [$.seconds, M.minutes]) : y($.hours, $.minutes, $.seconds)
    }
    ;
    Zt( () => {
        if (!t.shadow)
            return o(a.value),
            n.value ? k() : h()
    }
    );
    const w = () => {
        Array.isArray(n.value) ? n.value = n.value.map( ($, M) => $ && l($, M)) : n.value = l(n.value),
        e("time-update")
    }
    ;
    return {
        modelValue: n,
        time: r,
        disabledTimesConfig: u,
        updateTime: ($, M=!0, S=!1) => {
            s($, M, S, w)
        }
        ,
        validateTime: d
    }
}
  , xY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "TimePickerSolo",
    props: {
        ...jr
    },
    emits: ["update:internal-model-value", "time-update", "am-pm-change"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = sr(a, "timePicker")
          , {time: l, modelValue: i, disabledTimesConfig: o, updateTime: u, validateTime: d} = wY(r, n);
        return e({
            getSidebarProps: () => ({
                modelValue: i,
                time: l,
                updateTime: u
            })
        }),
        (f, p) => (g(),
        de(Ac, {
            "multi-calendars": 0,
            stretch: ""
        }, {
            default: N( () => [x(FS, Ve(f.$props, {
                hours: A(l).hours,
                minutes: A(l).minutes,
                seconds: A(l).seconds,
                "internal-model-value": f.internalModelValue,
                "disabled-times-config": A(o),
                "validate-time": A(d),
                "onUpdate:hours": p[0] || (p[0] = h => A(u)(h)),
                "onUpdate:minutes": p[1] || (p[1] = h => A(u)(h, !1)),
                "onUpdate:seconds": p[2] || (p[2] = h => A(u)(h, !1, !0)),
                onAmPmChange: p[3] || (p[3] = h => f.$emit("am-pm-change", h))
            }), gn({
                _: 2
            }, [Ne(A(s), (h, v) => ({
                name: h,
                fn: N(y => [Z(f.$slots, h, ut(Vt(y)))])
            }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])]),
            _: 3
        }))
    }
})
  , SY = {
    class: "dp__month_year_row"
}
  , $Y = ["aria-label", "onClick", "onKeydown"]
  , TY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "DpHeader",
    props: {
        month: {
            type: Number,
            default: 0
        },
        year: {
            type: Number,
            default: 0
        },
        instance: {
            type: Number,
            default: 0
        },
        years: {
            type: Array,
            default: () => []
        },
        months: {
            type: Array,
            default: () => []
        },
        ...jr
    },
    emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {defaultedTransitions: a, defaultedAriaLabels: s, defaultedMultiCalendars: l, defaultedFilters: i, defaultedConfig: o, defaultedHighlight: u} = sn(r)
          , {transitionName: d, showTransition: f} = tu(a)
          , {buildMatrix: p} = Ms()
          , {handleMonthYearChange: h, isDisabled: v, updateMonthYear: y} = BG(r, n)
          , {showLeftIcon: k, showRightIcon: w} = Cc()
          , $ = me(!1)
          , M = me(!1)
          , S = me([null, null, null, null]);
        Zt( () => {
            n("mount")
        }
        );
        const T = I => ({
            get: () => r[I],
            set: j => {
                const re = I === Tr.month ? Tr.year : Tr.month;
                n("update-month-year", {
                    [I]: j,
                    [re]: r[re]
                }),
                I === Tr.month ? G(!0) : te(!0)
            }
        })
          , E = K(T(Tr.month))
          , O = K(T(Tr.year))
          , U = K( () => I => ({
            month: r.month,
            year: r.year,
            items: I === Tr.month ? r.months : r.years,
            instance: r.instance,
            updateMonthYear: y,
            toggle: I === Tr.month ? G : te
        }))
          , L = K( () => r.months.find(j => j.value === r.month) || {
            text: "",
            value: 0
        })
          , C = K( () => ki(r.months, I => {
            const j = r.month === I.value
              , re = Ro(I.value, SS(r.year, r.minDate), $S(r.year, r.maxDate)) || i.value.months.includes(I.value)
              , le = OS(u.value, I.value, r.year);
            return {
                active: j,
                disabled: re,
                highlighted: le
            }
        }
        ))
          , W = K( () => ki(r.years, I => {
            const j = r.year === I.value
              , re = Ro(I.value, _i(r.minDate), _i(r.maxDate)) || i.value.years.includes(I.value)
              , le = bv(u.value, I.value);
            return {
                active: j,
                disabled: re,
                highlighted: le
            }
        }
        ))
          , R = (I, j) => {
            j !== void 0 ? I.value = j : I.value = !I.value,
            I.value || n("overlay-closed")
        }
          , G = (I=!1, j) => {
            J(I),
            R($, j)
        }
          , te = (I=!1, j) => {
            J(I),
            R(M, j)
        }
          , J = I => {
            I || n("reset-flow")
        }
          , ae = (I, j) => {
            r.arrowNavigation && (S.value[j] = fn(I),
            p(S.value, "monthYear"))
        }
          , oe = K( () => {
            var I, j;
            return [{
                type: Tr.month,
                index: 1,
                toggle: G,
                modelValue: E.value,
                updateModelValue: re => E.value = re,
                text: L.value.text,
                showSelectionGrid: $.value,
                items: C.value,
                ariaLabel: (I = s.value) == null ? void 0 : I.openMonthsOverlay
            }, {
                type: Tr.year,
                index: 2,
                toggle: te,
                modelValue: O.value,
                updateModelValue: re => O.value = re,
                text: r.year,
                showSelectionGrid: M.value,
                items: W.value,
                ariaLabel: (j = s.value) == null ? void 0 : j.openYearsOverlay
            }]
        }
        )
          , ne = K( () => r.disableYearSelect ? [oe.value[0]] : r.yearFirst ? [...oe.value].reverse() : oe.value);
        return e({
            toggleMonthPicker: G,
            toggleYearPicker: te,
            handleMonthYearChange: h
        }),
        (I, j) => {
            var re, le, ce;
            return g(),
            _("div", SY, [I.$slots["month-year"] ? Z(I.$slots, "month-year", ut(Ve({
                key: 0
            }, {
                month: t.month,
                year: t.year,
                months: t.months,
                years: t.years,
                updateMonthYear: A(y),
                handleMonthYearChange: A(h),
                instance: t.instance
            }))) : (g(),
            _(we, {
                key: 1
            }, [A(k)(A(l), t.instance) && !I.vertical ? (g(),
            de(vo, {
                key: 0,
                "aria-label": (re = A(s)) == null ? void 0 : re.prevMonth,
                disabled: A(v)(!1),
                onActivate: j[0] || (j[0] = xe => A(h)(!1, !0)),
                onSetRef: j[1] || (j[1] = xe => ae(xe, 0))
            }, {
                default: N( () => [I.$slots["arrow-left"] ? Z(I.$slots, "arrow-left", {
                    key: 0
                }) : q("", !0), I.$slots["arrow-left"] ? q("", !0) : (g(),
                de(A(uv), {
                    key: 1
                }))]),
                _: 3
            }, 8, ["aria-label", "disabled"])) : q("", !0), c("div", {
                class: ye(["dp__month_year_wrap", {
                    dp__year_disable_select: I.disableYearSelect
                }])
            }, [(g(!0),
            _(we, null, Ne(ne.value, (xe, X) => (g(),
            _(we, {
                key: xe.type
            }, [c("button", {
                type: "button",
                class: "dp__btn dp__month_year_select",
                tabindex: "0",
                "aria-label": xe.ariaLabel,
                ref_for: !0,
                ref: be => ae(be, X + 1),
                onClick: xe.toggle,
                onKeydown: [Xe(_t(xe.toggle, ["prevent"]), ["enter"]), Xe(_t(xe.toggle, ["prevent"]), ["space"])]
            }, [I.$slots[xe.type] ? Z(I.$slots, xe.type, {
                key: 0,
                text: xe.text,
                value: r[xe.type]
            }) : q("", !0), I.$slots[xe.type] ? q("", !0) : (g(),
            _(we, {
                key: 1
            }, [ve(Q(xe.text), 1)], 64))], 40, $Y), x(fa, {
                name: A(d)(xe.showSelectionGrid),
                css: A(f)
            }, {
                default: N( () => [xe.showSelectionGrid ? (g(),
                de(ru, {
                    key: 0,
                    items: xe.items,
                    "arrow-navigation": I.arrowNavigation,
                    "hide-navigation": I.hideNavigation,
                    "is-last": I.autoApply && !A(o).keepActionRow,
                    "skip-button-ref": !1,
                    config: I.config,
                    type: xe.type,
                    "header-refs": [],
                    "esc-close": I.escClose,
                    "text-input": I.textInput,
                    onSelected: xe.updateModelValue,
                    onToggle: xe.toggle
                }, gn({
                    "button-icon": N( () => [I.$slots["calendar-icon"] ? Z(I.$slots, "calendar-icon", {
                        key: 0
                    }) : q("", !0), I.$slots["calendar-icon"] ? q("", !0) : (g(),
                    de(A(eu), {
                        key: 1
                    }))]),
                    _: 2
                }, [I.$slots[`${xe.type}-overlay-value`] ? {
                    name: "item",
                    fn: N( ({item: be}) => [Z(I.$slots, `${xe.type}-overlay-value`, {
                        text: be.text,
                        value: be.value
                    })]),
                    key: "0"
                } : void 0, I.$slots[`${xe.type}-overlay`] ? {
                    name: "overlay",
                    fn: N( () => [Z(I.$slots, `${xe.type}-overlay`, ut(Vt(U.value(xe.type))))]),
                    key: "1"
                } : void 0, I.$slots[`${xe.type}-overlay-header`] ? {
                    name: "header",
                    fn: N( () => [Z(I.$slots, `${xe.type}-overlay-header`, {
                        toggle: xe.toggle
                    })]),
                    key: "2"
                } : void 0]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "text-input", "onSelected", "onToggle"])) : q("", !0)]),
                _: 2
            }, 1032, ["name", "css"])], 64))), 128))], 2), A(k)(A(l), t.instance) && I.vertical ? (g(),
            de(vo, {
                key: 1,
                "aria-label": (le = A(s)) == null ? void 0 : le.prevMonth,
                disabled: A(v)(!1),
                onActivate: j[2] || (j[2] = xe => A(h)(!1, !0))
            }, {
                default: N( () => [I.$slots["arrow-up"] ? Z(I.$slots, "arrow-up", {
                    key: 0
                }) : q("", !0), I.$slots["arrow-up"] ? q("", !0) : (g(),
                de(A(fv), {
                    key: 1
                }))]),
                _: 3
            }, 8, ["aria-label", "disabled"])) : q("", !0), A(w)(A(l), t.instance) ? (g(),
            de(vo, {
                key: 2,
                ref: "rightIcon",
                disabled: A(v)(!0),
                "aria-label": (ce = A(s)) == null ? void 0 : ce.nextMonth,
                onActivate: j[3] || (j[3] = xe => A(h)(!0, !0)),
                onSetRef: j[4] || (j[4] = xe => ae(xe, I.disableYearSelect ? 2 : 3))
            }, {
                default: N( () => [I.$slots[I.vertical ? "arrow-down" : "arrow-right"] ? Z(I.$slots, I.vertical ? "arrow-down" : "arrow-right", {
                    key: 0
                }) : q("", !0), I.$slots[I.vertical ? "arrow-down" : "arrow-right"] ? q("", !0) : (g(),
                de(qe(I.vertical ? A(pv) : A(dv)), {
                    key: 1
                }))]),
                _: 3
            }, 8, ["disabled", "aria-label"])) : q("", !0)], 64))])
        }
    }
})
  , CY = ["aria-label"]
  , EY = {
    class: "dp__calendar_header",
    role: "row"
}
  , AY = {
    key: 0,
    class: "dp__calendar_header_item",
    role: "gridcell"
}
  , MY = c("div", {
    class: "dp__calendar_header_separator"
}, null, -1)
  , OY = ["aria-label"]
  , NY = {
    key: 0,
    role: "gridcell",
    class: "dp__calendar_item dp__week_num"
}
  , DY = {
    class: "dp__cell_inner"
}
  , PY = ["aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"]
  , FY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "DpCalendar",
    props: {
        mappedDates: {
            type: Array,
            default: () => []
        },
        instance: {
            type: Number,
            default: 0
        },
        month: {
            type: Number,
            default: 0
        },
        year: {
            type: Number,
            default: 0
        },
        ...jr
    },
    emits: ["select-date", "set-hover-date", "handle-scroll", "mount", "handle-swipe", "handle-space", "tooltip-open", "tooltip-close"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {buildMultiLevelMatrix: a} = Ms()
          , {defaultedTransitions: s, defaultedConfig: l, defaultedAriaLabels: i, defaultedMultiCalendars: o} = sn(r)
          , u = me(null)
          , d = me({
            bottom: "",
            left: "",
            transform: ""
        })
          , f = me([])
          , p = me(null)
          , h = me(!0)
          , v = me("")
          , y = me({
            startX: 0,
            endX: 0,
            startY: 0,
            endY: 0
        })
          , k = me([])
          , w = me({
            left: "50%"
        })
          , $ = K( () => r.calendar ? r.calendar(r.mappedDates) : r.mappedDates)
          , M = K( () => r.dayNames ? Array.isArray(r.dayNames) ? r.dayNames : r.dayNames(r.locale, +r.weekStart) : pG(r.formatLocale, r.locale, +r.weekStart));
        Zt( () => {
            n("mount", {
                cmp: "calendar",
                refs: f
            }),
            l.value.noSwipe || p.value && (p.value.addEventListener("touchstart", G, {
                passive: !1
            }),
            p.value.addEventListener("touchend", te, {
                passive: !1
            }),
            p.value.addEventListener("touchmove", J, {
                passive: !1
            })),
            r.monthChangeOnScroll && p.value && p.value.addEventListener("wheel", ne, {
                passive: !1
            })
        }
        );
        const S = le => le ? r.vertical ? "vNext" : "next" : r.vertical ? "vPrevious" : "previous"
          , T = (le, ce) => {
            if (r.transitions) {
                const xe = Sr(Sa(Me(), r.month, r.year));
                v.value = Pn(Sr(Sa(Me(), le, ce)), xe) ? s.value[S(!0)] : s.value[S(!1)],
                h.value = !1,
                Ot( () => {
                    h.value = !0
                }
                )
            }
        }
          , E = K( () => ({
            [r.calendarClassName]: !!r.calendarClassName
        }))
          , O = K( () => le => {
            const ce = mG(le);
            return {
                dp__marker_dot: ce.type === "dot",
                dp__marker_line: ce.type === "line"
            }
        }
        )
          , U = K( () => le => xt(le, u.value))
          , L = K( () => ({
            dp__calendar: !0,
            dp__calendar_next: o.value.count > 0 && r.instance !== 0
        }))
          , C = K( () => le => r.hideOffsetDates ? le.current : !0)
          , W = async (le, ce, xe) => {
            var X, be;
            if (n("set-hover-date", le),
            (be = (X = le.marker) == null ? void 0 : X.tooltip) != null && be.length) {
                const ee = fn(f.value[ce][xe]);
                if (ee) {
                    const {width: B, height: se} = ee.getBoundingClientRect();
                    u.value = le.value;
                    let pe = {
                        left: `${B / 2}px`
                    }
                      , ie = -50;
                    if (await Ot(),
                    k.value[0]) {
                        const {left: fe, width: F} = k.value[0].getBoundingClientRect();
                        fe < 0 && (pe = {
                            left: "0"
                        },
                        ie = 0,
                        w.value.left = `${B / 2}px`),
                        window.innerWidth < fe + F && (pe = {
                            right: "0"
                        },
                        ie = 0,
                        w.value.left = `${F - B / 2}px`)
                    }
                    d.value = {
                        bottom: `${se}px`,
                        ...pe,
                        transform: `translateX(${ie}%)`
                    },
                    n("tooltip-open", le.marker)
                }
            }
        }
          , R = le => {
            u.value && (u.value = null,
            d.value = JSON.parse(JSON.stringify({
                bottom: "",
                left: "",
                transform: ""
            })),
            n("tooltip-close", le.marker))
        }
          , G = le => {
            y.value.startX = le.changedTouches[0].screenX,
            y.value.startY = le.changedTouches[0].screenY
        }
          , te = le => {
            y.value.endX = le.changedTouches[0].screenX,
            y.value.endY = le.changedTouches[0].screenY,
            ae()
        }
          , J = le => {
            r.vertical && !r.inline && le.preventDefault()
        }
          , ae = () => {
            const le = r.vertical ? "Y" : "X";
            Math.abs(y.value[`start${le}`] - y.value[`end${le}`]) > 10 && n("handle-swipe", y.value[`start${le}`] > y.value[`end${le}`] ? "right" : "left")
        }
          , oe = (le, ce, xe) => {
            le && (Array.isArray(f.value[ce]) ? f.value[ce][xe] = le : f.value[ce] = [le]),
            r.arrowNavigation && a(f.value, "calendar")
        }
          , ne = le => {
            r.monthChangeOnScroll && (le.preventDefault(),
            n("handle-scroll", le))
        }
          , I = le => {
            const ce = le[0];
            return r.weekNumbers === "local" ? $q(ce.value, {
                weekStartsOn: +r.weekStart
            }) : r.weekNumbers === "iso" ? _q(ce.value) : typeof r.weekNumbers == "function" ? r.weekNumbers(ce.value) : ""
        }
          , j = (le, ce) => {
            ps(le, l.value),
            n("select-date", ce)
        }
          , re = le => {
            ps(le, l.value)
        }
        ;
        return e({
            triggerTransition: T
        }),
        (le, ce) => {
            var xe;
            return g(),
            _("div", {
                class: ye(L.value)
            }, [c("div", {
                ref_key: "calendarWrapRef",
                ref: p,
                role: "grid",
                class: ye(E.value),
                "aria-label": (xe = A(i)) == null ? void 0 : xe.calendarWrap
            }, [(g(),
            _(we, {
                key: 0
            }, [c("div", EY, [le.weekNumbers ? (g(),
            _("div", AY, Q(le.weekNumName), 1)) : q("", !0), (g(!0),
            _(we, null, Ne(M.value, (X, be) => (g(),
            _("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: be
            }, [le.$slots["calendar-header"] ? Z(le.$slots, "calendar-header", {
                key: 0,
                day: X,
                index: be
            }) : q("", !0), le.$slots["calendar-header"] ? q("", !0) : (g(),
            _(we, {
                key: 1
            }, [ve(Q(X), 1)], 64))]))), 128))]), MY, x(fa, {
                name: v.value,
                css: !!le.transitions
            }, {
                default: N( () => {
                    var X;
                    return [h.value ? (g(),
                    _("div", {
                        key: 0,
                        class: "dp__calendar",
                        role: "rowgroup",
                        "aria-label": ((X = A(i)) == null ? void 0 : X.calendarDays) || void 0
                    }, [(g(!0),
                    _(we, null, Ne($.value, (be, ee) => (g(),
                    _("div", {
                        class: "dp__calendar_row",
                        role: "row",
                        key: ee
                    }, [le.weekNumbers ? (g(),
                    _("div", NY, [c("div", DY, Q(I(be.days)), 1)])) : q("", !0), (g(!0),
                    _(we, null, Ne(be.days, (B, se) => {
                        var pe, ie, fe;
                        return g(),
                        _("div", {
                            role: "gridcell",
                            class: "dp__calendar_item",
                            ref_for: !0,
                            ref: F => oe(F, ee, se),
                            key: se + ee,
                            "aria-selected": B.classData.dp__active_date || B.classData.dp__range_start || B.classData.dp__range_start,
                            "aria-disabled": B.classData.dp__cell_disabled || void 0,
                            "aria-label": (ie = (pe = A(i)) == null ? void 0 : pe.day) == null ? void 0 : ie.call(pe, B),
                            tabindex: "0",
                            onClick: _t(F => j(F, B), ["prevent"]),
                            onKeydown: [Xe(F => le.$emit("select-date", B), ["enter"]), Xe(F => le.$emit("handle-space", B), ["space"])],
                            onMouseenter: F => W(B, ee, se),
                            onMouseleave: F => R(B)
                        }, [c("div", {
                            class: ye(["dp__cell_inner", B.classData])
                        }, [le.$slots.day && C.value(B) ? Z(le.$slots, "day", {
                            key: 0,
                            day: +B.text,
                            date: B.value
                        }) : q("", !0), le.$slots.day ? q("", !0) : (g(),
                        _(we, {
                            key: 1
                        }, [ve(Q(B.text), 1)], 64)), B.marker && C.value(B) ? (g(),
                        _(we, {
                            key: 2
                        }, [le.$slots.marker ? Z(le.$slots, "marker", {
                            key: 0,
                            marker: B.marker,
                            day: +B.text,
                            date: B.value
                        }) : (g(),
                        _("div", {
                            key: 1,
                            class: ye(O.value(B.marker)),
                            style: Rt(B.marker.color ? {
                                backgroundColor: B.marker.color
                            } : {})
                        }, null, 6))], 64)) : q("", !0), U.value(B.value) ? (g(),
                        _("div", {
                            key: 3,
                            class: "dp__marker_tooltip",
                            ref_for: !0,
                            ref_key: "activeTooltip",
                            ref: k,
                            style: Rt(d.value)
                        }, [(fe = B.marker) != null && fe.tooltip ? (g(),
                        _("div", {
                            key: 0,
                            class: "dp__tooltip_content",
                            onClick: re
                        }, [(g(!0),
                        _(we, null, Ne(B.marker.tooltip, (F, z) => (g(),
                        _("div", {
                            key: z,
                            class: "dp__tooltip_text"
                        }, [le.$slots["marker-tooltip"] ? Z(le.$slots, "marker-tooltip", {
                            key: 0,
                            tooltip: F,
                            day: B.value
                        }) : q("", !0), le.$slots["marker-tooltip"] ? q("", !0) : (g(),
                        _(we, {
                            key: 1
                        }, [c("div", {
                            class: "dp__tooltip_mark",
                            style: Rt(F.color ? {
                                backgroundColor: F.color
                            } : {})
                        }, null, 4), c("div", null, Q(F.text), 1)], 64))]))), 128)), c("div", {
                            class: "dp__arrow_bottom_tp",
                            style: Rt(w.value)
                        }, null, 4)])) : q("", !0)], 4)) : q("", !0)], 2)], 40, PY)
                    }
                    ), 128))]))), 128))], 8, OY)) : q("", !0)]
                }
                ),
                _: 3
            }, 8, ["name", "css"])], 64))], 10, CY)], 2)
        }
    }
})
  , Ny = t => Array.isArray(t)
  , BY = (t, e, n, r) => {
    const a = me([])
      , {modelValue: s, calendars: l, time: i} = nu(t, e)
      , {defaultedMultiCalendars: o, defaultedStartTime: u} = sn(t)
      , {validateMonthYearInRange: d, isDisabled: f, isDateRangeAllowed: p, checkMinMaxRange: h} = Ni(t)
      , {updateTimeValues: v, getSetDateTime: y, setTime: k, assignStartTime: w, validateTime: $, disabledTimesConfig: M} = BS(t, i, s, r)
      , S = K( () => m => l.value[m] ? l.value[m].month : 0)
      , T = K( () => m => l.value[m] ? l.value[m].year : 0)
      , E = (m, b, P) => {
        var Y, he;
        l.value[m] || (l.value[m] = {
            month: 0,
            year: 0
        }),
        l.value[m].month = Ty(b) ? (Y = l.value[m]) == null ? void 0 : Y.month : b,
        l.value[m].year = Ty(P) ? (he = l.value[m]) == null ? void 0 : he.year : P
    }
      , O = () => {
        t.autoApply && e("select-date")
    }
    ;
    Ke(s, (m, b) => {
        JSON.stringify(m) !== JSON.stringify(b) && C()
    }
    ),
    Zt( () => {
        t.shadow || (s.value || (j(),
        u.value && w(u.value)),
        C(!0),
        t.focusStartDate && t.startDate && j())
    }
    );
    const U = K( () => {
        var m;
        return (m = t.flow) != null && m.length && !t.partialFlow ? t.flowStep === t.flow.length : !0
    }
    )
      , L = () => {
        t.autoApply && U.value && e("auto-apply", t.partialFlow)
    }
      , C = (m=!1) => {
        if (s.value)
            return Array.isArray(s.value) ? (a.value = s.value,
            ae(m)) : R(s.value, m);
        if (o.value.count && m && !t.startDate)
            return W(Me(), m)
    }
      , W = (m, b=!1) => {
        if ((!o.value.count || !o.value.static || b) && E(0, gt(m), ct(m)),
        o.value.count)
            for (let P = 1; P < o.value.count; P++) {
                const Y = Ut(Me(), {
                    month: S.value(P - 1),
                    year: T.value(P - 1)
                })
                  , he = Jx(Y, {
                    months: 1
                });
                l.value[P] = {
                    month: gt(he),
                    year: ct(he)
                }
            }
    }
      , R = (m, b) => {
        W(m),
        k("hours", Fr(m)),
        k("minutes", sa(m)),
        k("seconds", bi(m)),
        o.value.count && b && I()
    }
      , G = m => {
        if (o.value.count) {
            if (o.value.solo)
                return 0;
            const b = gt(m[0])
              , P = gt(m[1]);
            return Math.abs(P - b) < o.value.count ? 0 : 1
        }
        return 1
    }
      , te = (m, b) => {
        m[1] && t.showLastInRange ? W(m[G(m)], b) : W(m[0], b);
        const P = (Y, he) => [Y(m[0]), m[1] ? Y(m[1]) : i[he][1]];
        k("hours", P(Fr, "hours")),
        k("minutes", P(sa, "minutes")),
        k("seconds", P(bi, "seconds"))
    }
      , J = (m, b) => {
        if ((t.range || t.weekPicker) && !t.multiDates)
            return te(m, b);
        if (t.multiDates && b) {
            const P = m[m.length - 1];
            return R(P, b)
        }
    }
      , ae = m => {
        const b = s.value;
        J(b, m),
        o.value.count && o.value.solo && I()
    }
      , oe = (m, b) => {
        const P = Ut(Me(), {
            month: S.value(b),
            year: T.value(b)
        })
          , Y = m < 0 ? Pr(P, 1) : yi(P, 1);
        d(gt(Y), ct(Y), m < 0, t.preventMinMaxNavigation) && (E(b, gt(Y), ct(Y)),
        e("update-month-year", {
            instance: b,
            month: gt(Y),
            year: ct(Y)
        }),
        o.value.count && !o.value.solo && ne(b),
        n())
    }
      , ne = m => {
        for (let b = m - 1; b >= 0; b--) {
            const P = yi(Ut(Me(), {
                month: S.value(b + 1),
                year: T.value(b + 1)
            }), 1);
            E(b, gt(P), ct(P))
        }
        for (let b = m + 1; b <= o.value.count - 1; b++) {
            const P = Pr(Ut(Me(), {
                month: S.value(b - 1),
                year: T.value(b - 1)
            }), 1);
            E(b, gt(P), ct(P))
        }
    }
      , I = () => {
        if (Array.isArray(s.value) && s.value.length === 2) {
            const m = Me(Me(s.value[1] ? s.value[1] : Pr(s.value[0], 1)))
              , [b,P] = [gt(s.value[0]), ct(s.value[0])]
              , [Y,he] = [gt(s.value[1]), ct(s.value[1])];
            (b !== Y || b === Y && P !== he) && o.value.solo && E(1, gt(m), ct(m))
        } else
            s.value && !Array.isArray(s.value) && (E(0, gt(s.value), ct(s.value)),
            W(Me()))
    }
      , j = () => {
        t.startDate && (E(0, gt(Me(t.startDate)), ct(Me(t.startDate))),
        o.value.count && ne(0))
    }
      , re = (m, b) => {
        t.monthChangeOnScroll && oe(t.monthChangeOnScroll !== "inverse" ? -m.deltaY : m.deltaY, b)
    }
      , le = (m, b, P=!1) => {
        t.monthChangeOnArrows && t.vertical === P && ce(m, b)
    }
      , ce = (m, b) => {
        oe(m === "right" ? -1 : 1, b)
    }
      , xe = m => t.markers.find(b => xt(Ey(m.value), Ey(b.date)))
      , X = (m, b) => {
        switch (t.sixWeeks === !0 ? "append" : t.sixWeeks) {
        case "prepend":
            return [!0, !1];
        case "center":
            return [m == 0, !0];
        case "fair":
            return [m == 0 || b > m, !0];
        case "append":
            return [!1, !1];
        default:
            return [!1, !1]
        }
    }
      , be = (m, b, P, Y) => {
        if (t.sixWeeks && m.length < 6) {
            const he = 6 - m.length
              , $e = (b.getDay() + 7 - Y) % 7
              , Je = 6 - (P.getDay() + 7 - Y) % 7
              , [wt,tt] = X($e, Je);
            for (let it = 1; it <= he; it++)
                if (tt ? !!(it % 2) == wt : wt) {
                    const ot = m[0].days[0]
                      , Fc = ee(xa(ot.value, -7), gt(b));
                    m.unshift({
                        days: Fc
                    })
                } else {
                    const ot = m[m.length - 1]
                      , Fc = ot.days[ot.days.length - 1]
                      , JS = ee(xa(Fc.value, 1), gt(b));
                    m.push({
                        days: JS
                    })
                }
        }
        return m
    }
      , ee = (m, b) => {
        const P = Me(m)
          , Y = [];
        for (let he = 0; he < 7; he++) {
            const $e = xa(P, he)
              , Je = gt($e) !== b;
            Y.push({
                text: t.hideOffsetDates && Je ? "" : $e.getDate(),
                value: $e,
                current: !Je,
                classData: {}
            })
        }
        return Y
    }
      , B = (m, b) => {
        const P = []
          , Y = Me(gr(new Date(b,m), t.timezone))
          , he = Me(gr(new Date(b,m + 1,0), t.timezone))
          , $e = t.weekStart
          , Je = ul(Y, {
            weekStartsOn: $e
        })
          , wt = tt => {
            const it = ee(tt, m);
            if (P.push({
                days: it
            }),
            !P[P.length - 1].days.some(ot => xt(Sr(ot.value), Sr(he)))) {
                const ot = xa(tt, 7);
                wt(ot)
            }
        }
        ;
        return wt(Je),
        be(P, Y, he, $e)
    }
      , se = m => (s.value = Ru(Me(m.value), t.timezone, t.weekStart),
    e("date-update", m.value),
    L())
      , pe = m => {
        const b = hs(Me(m.value), i.hours, i.minutes, Ee());
        e("date-update", b),
        t.multiDates ? Mc(b, s, t.multiDatesLimit) : s.value = b,
        r(),
        Ot().then( () => {
            L()
        }
        )
    }
      , ie = m => t.noDisabledRange ? CS(a.value[0], m).some(b => f(b)) : !1
      , fe = () => {
        a.value = s.value ? s.value.slice() : [],
        a.value.length === 2 && !(t.fixedStart || t.fixedEnd) && (a.value = [])
    }
      , F = (m, b) => {
        const P = [Me(m.value), xa(Me(m.value), +t.autoRange)];
        p(P) ? (b && z(m.value),
        a.value = P) : e("invalid-date", m.value)
    }
      , z = m => {
        const b = gt(Me(m))
          , P = ct(Me(m));
        if (E(0, b, P),
        o.value.count > 0)
            for (let Y = 1; Y < o.value.count; Y++) {
                const he = kG(Ut(Me(m), {
                    year: S.value(Y - 1),
                    month: T.value(Y - 1)
                }));
                E(Y, he.month, he.year)
            }
    }
      , ge = m => Array.isArray(s.value) && s.value.length === 2 ? t.fixedStart && (Pn(m, s.value[0]) || xt(m, s.value[0])) ? [s.value[0], m] : t.fixedEnd && (An(m, s.value[1]) || xt(m, s.value[1])) ? [m, s.value[1]] : (e("invalid-fixed-range", m),
    s.value) : []
      , Te = m => {
        if (ie(m.value) || !h(m.value, s.value, t.fixedStart ? 0 : 1))
            return e("invalid-date", m.value);
        a.value = ge(Me(m.value))
    }
      , ke = (m, b) => {
        if (fe(),
        t.autoRange)
            return F(m, b);
        if (t.fixedStart || t.fixedEnd)
            return Te(m);
        a.value[0] ? h(Me(m.value), s.value) && !ie(m.value) ? An(Me(m.value), Me(a.value[0])) ? (a.value.unshift(Me(m.value)),
        e("range-end", a.value[0])) : (a.value[1] = Me(m.value),
        e("range-end", a.value[1])) : (t.autoApply && e("auto-apply-invalid", m.value),
        e("invalid-date", m.value)) : (a.value[0] = Me(m.value),
        e("range-start", a.value[0]))
    }
      , Ee = (m=!0) => t.enableSeconds ? Array.isArray(i.seconds) ? m ? i.seconds[0] : i.seconds[1] : i.seconds : 0
      , Fe = m => {
        a.value[m] = hs(a.value[m], i.hours[m], i.minutes[m], Ee(m !== 1))
    }
      , Oe = () => {
        var m, b;
        a.value[0] && a.value[1] && +((m = a.value) == null ? void 0 : m[0]) > +((b = a.value) == null ? void 0 : b[1]) && (a.value.reverse(),
        e("range-start", a.value[0]),
        e("range-end", a.value[1]))
    }
      , De = () => {
        a.value.length && (a.value[0] && !a.value[1] ? Fe(0) : (Fe(0),
        Fe(1),
        r()),
        Oe(),
        s.value = a.value.slice(),
        Oc(a.value, e, t.autoApply, t.modelAuto))
    }
      , Ce = (m, b=!1) => {
        if (f(m.value) || !m.current && t.hideOffsetDates)
            return e("invalid-date", m.value);
        if (t.weekPicker)
            return se(m);
        if (!t.range)
            return pe(m);
        Ny(i.hours) && Ny(i.minutes) && !t.multiDates && (ke(m, b),
        De())
    }
      , Be = (m, b) => {
        var P;
        E(m, b.month, b.year),
        o.value.count && !o.value.solo && ne(m),
        e("update-month-year", {
            instance: m,
            month: b.month,
            year: b.year
        }),
        n(o.value.solo ? m : void 0);
        const Y = (P = t.flow) != null && P.length ? t.flow[t.flowStep] : void 0;
        !b.fromNav && (Y === Wr.month || Y === Wr.year) && r()
    }
      , ze = (m, b) => {
        Array.isArray(m) && m.length <= 2 && t.range ? s.value = m.map(P => gr(Me(P), b ? void 0 : t.timezone)) : Array.isArray(m) || (s.value = gr(Me(m), b ? void 0 : t.timezone)),
        O(),
        t.multiCalendars && Ot().then( () => C(!0))
    }
      , Le = () => {
        t.range ? s.value && Array.isArray(s.value) && s.value[0] ? s.value = An(Me(), s.value[0]) ? [Me(), s.value[0]] : [s.value[0], Me()] : s.value = [Me()] : s.value = Me(),
        O()
    }
      , Ye = () => {
        if (Array.isArray(s.value))
            if (t.multiDates) {
                const m = D();
                s.value[s.value.length - 1] = y(m)
            } else
                s.value = s.value.map( (m, b) => m && y(m, b));
        else
            s.value = y(s.value);
        e("time-update")
    }
      , D = () => Array.isArray(s.value) && s.value.length ? s.value[s.value.length - 1] : null;
    return {
        calendars: l,
        modelValue: s,
        month: S,
        year: T,
        time: i,
        disabledTimesConfig: M,
        validateTime: $,
        getCalendarDays: B,
        getMarker: xe,
        handleScroll: re,
        handleSwipe: ce,
        handleArrow: le,
        selectDate: Ce,
        updateMonthYear: Be,
        presetDate: ze,
        selectCurrentDate: Le,
        updateTime: (m, b=!0, P=!1) => {
            v(m, b, P, Ye)
        }
    }
}
  , VY = {
    key: 0
}
  , IY = Se({
    __name: "DatePicker",
    props: {
        ...jr
    },
    emits: ["tooltip-open", "tooltip-close", "mount", "update:internal-model-value", "update-flow-step", "reset-flow", "auto-apply", "focus-menu", "select-date", "range-start", "range-end", "invalid-fixed-range", "time-update", "am-pm-change", "time-picker-open", "time-picker-close", "recalculate-position", "update-month-year", "auto-apply-invalid", "date-update", "invalid-date"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {calendars: a, month: s, year: l, modelValue: i, time: o, disabledTimesConfig: u, validateTime: d, getCalendarDays: f, getMarker: p, handleArrow: h, handleScroll: v, handleSwipe: y, selectDate: k, updateMonthYear: w, presetDate: $, selectCurrentDate: M, updateTime: S} = BY(r, n, ne, I)
          , T = en()
          , {setHoverDate: E, getDayClassData: O, clearHoverDate: U} = LG(i, r)
          , {defaultedMultiCalendars: L} = sn(r)
          , C = me([])
          , W = me([])
          , R = me(null)
          , G = sr(T, "calendar")
          , te = sr(T, "monthYear")
          , J = sr(T, "timePicker")
          , ae = re => {
            r.shadow || n("mount", re)
        }
        ;
        Ke(a, () => {
            r.shadow || setTimeout( () => {
                n("recalculate-position")
            }
            , 0)
        }
        , {
            deep: !0
        });
        const oe = K( () => re => f(s.value(re), l.value(re)).map(le => ({
            ...le,
            days: le.days.map(ce => (ce.marker = p(ce),
            ce.classData = O(ce),
            ce))
        })));
        function ne(re) {
            var le;
            re || re === 0 ? (le = W.value[re]) == null || le.triggerTransition(s.value(re), l.value(re)) : W.value.forEach( (ce, xe) => ce.triggerTransition(s.value(xe), l.value(xe)))
        }
        function I() {
            n("update-flow-step")
        }
        const j = (re, le=!1) => {
            k(re, le),
            r.spaceConfirm && n("select-date")
        }
        ;
        return e({
            clearHoverDate: U,
            presetDate: $,
            selectCurrentDate: M,
            toggleMonthPicker: (re, le, ce=0) => {
                var xe;
                (xe = C.value[ce]) == null || xe.toggleMonthPicker(re, le)
            }
            ,
            toggleYearPicker: (re, le, ce=0) => {
                var xe;
                (xe = C.value[ce]) == null || xe.toggleYearPicker(re, le)
            }
            ,
            toggleTimePicker: (re, le, ce) => {
                var xe;
                (xe = R.value) == null || xe.toggleTimePicker(re, le, ce)
            }
            ,
            handleArrow: h,
            updateMonthYear: w,
            getSidebarProps: () => ({
                modelValue: i,
                month: s,
                year: l,
                time: o,
                updateTime: S,
                updateMonthYear: w,
                selectDate: k,
                presetDate: $
            })
        }),
        (re, le) => (g(),
        _(we, null, [x(Ac, {
            "multi-calendars": A(L).count
        }, {
            default: N( ({instance: ce, index: xe}) => [re.disableMonthYearSelect ? q("", !0) : (g(),
            de(TY, Ve({
                key: 0,
                ref: X => {
                    X && (C.value[xe] = X)
                }
                ,
                months: A(wS)(re.formatLocale, re.locale, re.monthNameFormat),
                years: A(gv)(re.yearRange, re.reverseYears),
                month: A(s)(ce),
                year: A(l)(ce),
                instance: ce
            }, re.$props, {
                onMount: le[0] || (le[0] = X => ae(A(rl).header)),
                onResetFlow: le[1] || (le[1] = X => re.$emit("reset-flow")),
                onUpdateMonthYear: X => A(w)(ce, X),
                onOverlayClosed: le[2] || (le[2] = X => re.$emit("focus-menu"))
            }), gn({
                _: 2
            }, [Ne(A(te), (X, be) => ({
                name: X,
                fn: N(ee => [Z(re.$slots, X, ut(Vt(ee)))])
            }))]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])), x(FY, Ve({
                ref: X => {
                    X && (W.value[xe] = X)
                }
                ,
                "mapped-dates": oe.value(ce),
                month: A(s)(ce),
                year: A(l)(ce),
                instance: ce
            }, re.$props, {
                onSelectDate: X => A(k)(X, ce !== 1),
                onHandleSpace: X => j(X, ce !== 1),
                onSetHoverDate: le[3] || (le[3] = X => A(E)(X)),
                onHandleScroll: X => A(v)(X, ce),
                onHandleSwipe: X => A(y)(X, ce),
                onMount: le[4] || (le[4] = X => ae(A(rl).calendar)),
                onResetFlow: le[5] || (le[5] = X => re.$emit("reset-flow")),
                onTooltipOpen: le[6] || (le[6] = X => re.$emit("tooltip-open", X)),
                onTooltipClose: le[7] || (le[7] = X => re.$emit("tooltip-close", X))
            }), gn({
                _: 2
            }, [Ne(A(G), (X, be) => ({
                name: X,
                fn: N(ee => [Z(re.$slots, X, ut(Vt({
                    ...ee
                })))])
            }))]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])]),
            _: 3
        }, 8, ["multi-calendars"]), re.enableTimePicker ? (g(),
        _("div", VY, [re.$slots["time-picker"] ? Z(re.$slots, "time-picker", ut(Ve({
            key: 0
        }, {
            time: A(o),
            updateTime: A(S)
        }))) : (g(),
        de(FS, Ve({
            key: 1,
            ref_key: "timePickerRef",
            ref: R
        }, re.$props, {
            hours: A(o).hours,
            minutes: A(o).minutes,
            seconds: A(o).seconds,
            "internal-model-value": re.internalModelValue,
            "disabled-times-config": A(u),
            "validate-time": A(d),
            onMount: le[8] || (le[8] = ce => ae(A(rl).timePicker)),
            "onUpdate:hours": le[9] || (le[9] = ce => A(S)(ce)),
            "onUpdate:minutes": le[10] || (le[10] = ce => A(S)(ce, !1)),
            "onUpdate:seconds": le[11] || (le[11] = ce => A(S)(ce, !1, !0)),
            onResetFlow: le[12] || (le[12] = ce => re.$emit("reset-flow")),
            onOverlayClosed: le[13] || (le[13] = ce => re.$emit("time-picker-close")),
            onOverlayOpened: le[14] || (le[14] = ce => re.$emit("time-picker-open", ce)),
            onAmPmChange: le[15] || (le[15] = ce => re.$emit("am-pm-change", ce))
        }), gn({
            _: 2
        }, [Ne(A(J), (ce, xe) => ({
            name: ce,
            fn: N(X => [Z(re.$slots, ce, ut(Vt(X)))])
        }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))])) : q("", !0)], 64))
    }
})
  , RY = (t, e) => {
    const n = me()
      , {defaultedMultiCalendars: r, defaultedConfig: a, defaultedHighlight: s} = sn(t)
      , {modelValue: l, year: i, month: o, calendars: u} = nu(t, e)
      , {isDisabled: d} = Ni(t)
      , {selectYear: f, groupedYears: p, showYearPicker: h, isDisabled: v, toggleYearPicker: y, handleYearSelect: k, handleYear: w} = PS({
        modelValue: l,
        multiCalendars: r,
        highlight: s,
        calendars: u,
        month: o,
        year: i,
        props: t,
        emit: e
    })
      , $ = (L, C) => [L, C].map(W => fs(W, "MMMM", {
        locale: t.formatLocale
    })).join("-")
      , M = K( () => L => l.value ? Array.isArray(l.value) ? l.value.some(C => my(L, C)) : my(l.value, L) : !1)
      , S = L => {
        if (t.range) {
            if (Array.isArray(l.value)) {
                const C = xt(L, l.value[0]) || xt(L, l.value[1]);
                return Tc(l.value, n.value, L) && !C
            }
            return !1
        }
        return !1
    }
      , T = K( () => L => {
        const C = Ut(new Date, {
            year: i.value(L)
        });
        return d9({
            start: f9(C),
            end: c9(C)
        }).map(W => {
            const R = Bo(W)
              , G = oy(W)
              , te = d(W)
              , J = S(R)
              , ae = typeof s.value == "function" ? s.value({
                quarter: iy(R),
                year: ct(R)
            }) : !!s.value.quarters.find(oe => oe.quarter === iy(R) && oe.year === ct(R));
            return {
                text: $(R, G),
                value: R,
                active: M.value(R),
                highlighted: ae,
                disabled: te,
                isBetween: J
            }
        }
        )
    }
    )
      , E = L => {
        Mc(L, l, t.multiDatesLimit),
        e("auto-apply", !0)
    }
      , O = L => {
        const C = yv(l, L, e);
        Oc(C, e, t.autoApply, t.modelAuto)
    }
      , U = L => {
        l.value = L,
        e("auto-apply")
    }
    ;
    return {
        defaultedConfig: a,
        defaultedMultiCalendars: r,
        groupedYears: p,
        year: i,
        isDisabled: v,
        quarters: T,
        showYearPicker: h,
        modelValue: l,
        setHoverDate: L => {
            n.value = L
        }
        ,
        selectYear: f,
        selectQuarter: (L, C, W) => {
            if (!W)
                return u.value[C].month = gt(oy(L)),
                t.multiDates ? E(L) : t.range ? O(L) : U(L)
        }
        ,
        toggleYearPicker: y,
        handleYearSelect: k,
        handleYear: w
    }
}
  , LY = {
    class: "dp--quarter-items"
}
  , jY = ["disabled", "onClick", "onMouseover"]
  , UY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "QuarterPicker",
    props: {
        ...jr
    },
    emits: ["update:internal-model-value", "reset-flow", "overlay-closed", "auto-apply", "range-start", "range-end"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = sr(a, "yearMode")
          , {defaultedMultiCalendars: l, defaultedConfig: i, groupedYears: o, year: u, isDisabled: d, quarters: f, modelValue: p, showYearPicker: h, setHoverDate: v, selectQuarter: y, toggleYearPicker: k, handleYearSelect: w, handleYear: $} = RY(r, n);
        return e({
            getSidebarProps: () => ({
                modelValue: p,
                year: u,
                selectQuarter: y,
                handleYearSelect: w,
                handleYear: $
            })
        }),
        (M, S) => (g(),
        de(Ac, {
            "multi-calendars": A(l).count,
            stretch: ""
        }, {
            default: N( ({instance: T}) => [c("div", {
                class: "dp-quarter-picker-wrap",
                style: Rt({
                    minHeight: `${A(i).modeHeight}px`
                })
            }, [c("div", null, [x(DS, Ve(M.$props, {
                items: A(o)(T),
                instance: T,
                "show-year-picker": A(h)[T],
                year: A(u)(T),
                "is-disabled": E => A(d)(T, E),
                onHandleYear: E => A($)(T, E),
                onYearSelect: E => A(w)(E, T),
                onToggleYearPicker: E => A(k)(T, E == null ? void 0 : E.flow, E == null ? void 0 : E.show)
            }), gn({
                _: 2
            }, [Ne(A(s), (E, O) => ({
                name: E,
                fn: N(U => [Z(M.$slots, E, ut(Vt(U)))])
            }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]), c("div", LY, [(g(!0),
            _(we, null, Ne(A(f)(T), (E, O) => (g(),
            _("div", {
                key: O
            }, [c("button", {
                type: "button",
                class: ye(["dp--qr-btn", {
                    "dp--qr-btn-active": E.active,
                    "dp--qr-btn-between": E.isBetween,
                    "dp--qr-btn-disabled": E.disabled,
                    "dp--highlighted": E.highlighted
                }]),
                disabled: E.disabled,
                onClick: U => A(y)(E.value, T, E.disabled),
                onMouseover: U => A(v)(E.value)
            }, [M.$slots.quarter ? Z(M.$slots, "quarter", {
                key: 0,
                value: E.value,
                text: E.text
            }) : (g(),
            _(we, {
                key: 1
            }, [ve(Q(E.text), 1)], 64))], 42, jY)]))), 128))])], 4)]),
            _: 3
        }, 8, ["multi-calendars"]))
    }
})
  , HY = ["id", "onKeydown"]
  , KY = {
    key: 0,
    class: "dp__sidebar_left"
}
  , zY = {
    key: 1,
    class: "dp--preset-dates"
}
  , qY = ["onClick", "onKeydown"]
  , WY = {
    key: 2,
    class: "dp__sidebar_right"
}
  , GY = {
    key: 3,
    class: "dp__action_extra"
}
  , Dy = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "DatepickerMenu",
    props: {
        ...Ec,
        shadow: {
            type: Boolean,
            default: !1
        },
        openOnTop: {
            type: Boolean,
            default: !1
        },
        internalModelValue: {
            type: [Date, Array],
            default: null
        },
        arrMapValues: {
            type: Object,
            default: () => ({})
        },
        noOverlayFocus: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["close-picker", "select-date", "auto-apply", "time-update", "flow-step", "update-month-year", "invalid-select", "update:internal-model-value", "recalculate-position", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "auto-apply-invalid", "date-update", "invalid-date"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = K( () => {
            const {openOnTop: ie, ...fe} = r;
            return {
                ...fe,
                flowStep: O.value,
                noOverlayFocus: r.noOverlayFocus
            }
        }
        )
          , {setMenuFocused: s, setShiftKey: l, control: i} = NS()
          , o = en()
          , {defaultedTextInput: u, defaultedInline: d, defaultedConfig: f} = sn(r)
          , p = me(null)
          , h = me(0)
          , v = me(null)
          , y = me(null)
          , k = me(!1)
          , w = me(null);
        Zt( () => {
            if (!r.shadow) {
                k.value = !0,
                $(),
                window.addEventListener("resize", $);
                const ie = fn(v);
                if (ie && !u.value.enabled && !d.value.enabled && (s(!0),
                R()),
                ie) {
                    const fe = F => {
                        f.value.allowPreventDefault && F.preventDefault(),
                        ps(F, f.value, !0)
                    }
                    ;
                    ie.addEventListener("pointerdown", fe),
                    ie.addEventListener("mousedown", fe)
                }
            }
        }
        ),
        Ko( () => {
            window.removeEventListener("resize", $)
        }
        );
        const $ = () => {
            const ie = fn(y);
            ie && (h.value = ie.getBoundingClientRect().width)
        }
          , {arrowRight: M, arrowLeft: S, arrowDown: T, arrowUp: E} = Ms()
          , {flowStep: O, updateFlowStep: U, childMount: L, resetFlow: C} = jG(r, n, w)
          , W = K( () => r.monthPicker ? aY : r.yearPicker ? lY : r.timePicker ? xY : r.quarterPicker ? UY : IY)
          , R = () => {
            const ie = fn(v);
            ie && ie.focus({
                preventScroll: !0
            })
        }
          , G = K( () => {
            var ie;
            return ((ie = w.value) == null ? void 0 : ie.getSidebarProps()) || {}
        }
        )
          , te = () => {
            r.openOnTop && n("recalculate-position")
        }
          , J = sr(o, "action")
          , ae = K( () => r.monthPicker || r.yearPicker ? sr(o, "monthYear") : r.timePicker ? sr(o, "timePicker") : sr(o, "shared"))
          , oe = K( () => r.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top")
          , ne = K( () => ({
            dp__menu_disabled: r.disabled,
            dp__menu_readonly: r.readonly
        }))
          , I = K( () => ({
            dp__menu: !0,
            dp__menu_index: !d.value.enabled,
            dp__relative: d.value.enabled,
            [r.menuClassName]: !!r.menuClassName
        }))
          , j = ie => {
            ps(ie, f.value, !0)
        }
          , re = () => {
            r.escClose && n("close-picker")
        }
          , le = ie => {
            if (r.arrowNavigation) {
                if (ie === "up")
                    return E();
                if (ie === "down")
                    return T();
                if (ie === "left")
                    return S();
                if (ie === "right")
                    return M()
            } else
                ie === "left" || ie === "up" ? ee("handleArrow", "left", 0, ie === "up") : ee("handleArrow", "right", 0, ie === "down")
        }
          , ce = ie => {
            l(ie.shiftKey),
            !r.disableMonthYearSelect && ie.code === "Tab" && ie.target.classList.contains("dp__menu") && i.value.shiftKeyInMenu && (ie.preventDefault(),
            ps(ie, f.value, !0),
            n("close-picker"))
        }
          , xe = () => {
            R(),
            n("time-picker-close")
        }
          , X = ie => {
            var fe, F, z;
            (fe = w.value) == null || fe.toggleTimePicker(!1, !1),
            (F = w.value) == null || F.toggleMonthPicker(!1, !1, ie),
            (z = w.value) == null || z.toggleYearPicker(!1, !1, ie)
        }
          , be = (ie, fe=0) => {
            var F, z, ge;
            return ie === "month" ? (F = w.value) == null ? void 0 : F.toggleMonthPicker(!1, !0, fe) : ie === "year" ? (z = w.value) == null ? void 0 : z.toggleYearPicker(!1, !0, fe) : ie === "time" ? (ge = w.value) == null ? void 0 : ge.toggleTimePicker(!0, !1) : X(fe)
        }
          , ee = (ie, ...fe) => {
            var F, z;
            (F = w.value) != null && F[ie] && ((z = w.value) == null || z[ie](...fe))
        }
          , B = () => {
            ee("selectCurrentDate")
        }
          , se = (ie, fe) => {
            ee("presetDate", ie, fe)
        }
          , pe = () => {
            ee("clearHoverDate")
        }
        ;
        return e({
            updateMonthYear: (ie, fe) => {
                ee("updateMonthYear", ie, fe)
            }
            ,
            switchView: be
        }),
        (ie, fe) => {
            var F;
            return g(),
            _("div", {
                id: ie.uid ? `dp-menu-${ie.uid}` : void 0,
                tabindex: "0",
                ref_key: "dpMenuRef",
                ref: v,
                role: "dialog",
                class: ye(I.value),
                onMouseleave: pe,
                onClick: j,
                onKeydown: [Xe(re, ["esc"]), fe[18] || (fe[18] = Xe(_t(z => le("left"), ["prevent"]), ["left"])), fe[19] || (fe[19] = Xe(_t(z => le("up"), ["prevent"]), ["up"])), fe[20] || (fe[20] = Xe(_t(z => le("down"), ["prevent"]), ["down"])), fe[21] || (fe[21] = Xe(_t(z => le("right"), ["prevent"]), ["right"])), ce]
            }, [(ie.disabled || ie.readonly) && A(d).enabled ? (g(),
            _("div", {
                key: 0,
                class: ye(ne.value)
            }, null, 2)) : q("", !0), !A(d).enabled && !ie.teleportCenter ? (g(),
            _("div", {
                key: 1,
                class: ye(oe.value)
            }, null, 2)) : q("", !0), c("div", {
                ref_key: "innerMenuRef",
                ref: y,
                class: ye({
                    dp__menu_content_wrapper: ((F = ie.presetDates) == null ? void 0 : F.length) || !!ie.$slots["left-sidebar"] || !!ie.$slots["right-sidebar"]
                }),
                style: Rt({
                    "--dp-menu-width": `${h.value}px`
                })
            }, [ie.$slots["left-sidebar"] ? (g(),
            _("div", KY, [Z(ie.$slots, "left-sidebar", ut(Vt(G.value)))])) : q("", !0), ie.presetDates.length ? (g(),
            _("div", zY, [(g(!0),
            _(we, null, Ne(ie.presetDates, (z, ge) => (g(),
            _(we, {
                key: ge
            }, [z.slot ? Z(ie.$slots, z.slot, {
                key: 0,
                presetDate: se,
                label: z.label,
                value: z.value
            }) : (g(),
            _("button", {
                key: 1,
                type: "button",
                style: Rt(z.style || {}),
                class: "dp__btn dp--preset-range",
                onClick: _t(Te => se(z.value, z.noTz), ["prevent"]),
                onKeydown: [Xe(_t(Te => se(z.value, z.noTz), ["prevent"]), ["enter"]), Xe(_t(Te => se(z.value, z.noTz), ["prevent"]), ["space"])]
            }, Q(z.label), 45, qY))], 64))), 128))])) : q("", !0), c("div", {
                class: "dp__instance_calendar",
                ref_key: "calendarWrapperRef",
                ref: p,
                role: "document"
            }, [(g(),
            de(qe(W.value), Ve({
                ref_key: "dynCmpRef",
                ref: w
            }, a.value, {
                "flow-step": A(O),
                onMount: A(L),
                onUpdateFlowStep: A(U),
                onResetFlow: A(C),
                onFocusMenu: R,
                onSelectDate: fe[0] || (fe[0] = z => ie.$emit("select-date")),
                onDateUpdate: fe[1] || (fe[1] = z => ie.$emit("date-update", z)),
                onTooltipOpen: fe[2] || (fe[2] = z => ie.$emit("tooltip-open", z)),
                onTooltipClose: fe[3] || (fe[3] = z => ie.$emit("tooltip-close", z)),
                onAutoApply: fe[4] || (fe[4] = z => ie.$emit("auto-apply", z)),
                onRangeStart: fe[5] || (fe[5] = z => ie.$emit("range-start", z)),
                onRangeEnd: fe[6] || (fe[6] = z => ie.$emit("range-end", z)),
                onInvalidFixedRange: fe[7] || (fe[7] = z => ie.$emit("invalid-fixed-range", z)),
                onTimeUpdate: fe[8] || (fe[8] = z => ie.$emit("time-update")),
                onAmPmChange: fe[9] || (fe[9] = z => ie.$emit("am-pm-change", z)),
                onTimePickerOpen: fe[10] || (fe[10] = z => ie.$emit("time-picker-open", z)),
                onTimePickerClose: xe,
                onRecalculatePosition: te,
                onUpdateMonthYear: fe[11] || (fe[11] = z => ie.$emit("update-month-year", z)),
                onAutoApplyInvalid: fe[12] || (fe[12] = z => ie.$emit("auto-apply-invalid", z)),
                onInvalidDate: fe[13] || (fe[13] = z => ie.$emit("invalid-date", z)),
                "onUpdate:internalModelValue": fe[14] || (fe[14] = z => ie.$emit("update:internal-model-value", z))
            }), gn({
                _: 2
            }, [Ne(ae.value, (z, ge) => ({
                name: z,
                fn: N(Te => [Z(ie.$slots, z, ut(Vt({
                    ...Te
                })))])
            }))]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))], 512), ie.$slots["right-sidebar"] ? (g(),
            _("div", WY, [Z(ie.$slots, "right-sidebar", ut(Vt(G.value)))])) : q("", !0), ie.$slots["action-extra"] ? (g(),
            _("div", GY, [ie.$slots["action-extra"] ? Z(ie.$slots, "action-extra", {
                key: 0,
                selectCurrentDate: B
            }) : q("", !0)])) : q("", !0)], 6), !ie.autoApply || A(f).keepActionRow ? (g(),
            de(YG, Ve({
                key: 2,
                "menu-mount": k.value
            }, a.value, {
                "calendar-width": h.value,
                onClosePicker: fe[15] || (fe[15] = z => ie.$emit("close-picker")),
                onSelectDate: fe[16] || (fe[16] = z => ie.$emit("select-date")),
                onInvalidSelect: fe[17] || (fe[17] = z => ie.$emit("invalid-select")),
                onSelectNow: B
            }), gn({
                _: 2
            }, [Ne(A(J), (z, ge) => ({
                name: z,
                fn: N(Te => [Z(ie.$slots, z, ut(Vt({
                    ...Te
                })))])
            }))]), 1040, ["menu-mount", "calendar-width"])) : q("", !0)], 42, HY)
        }
    }
})
  , YY = typeof window < "u" ? window : void 0
  , Zf = () => {}
  , JY = t => Ho() ? (Bd(t),
!0) : !1
  , XY = (t, e, n, r) => {
    if (!t)
        return Zf;
    let a = Zf;
    const s = Ke( () => A(t), i => {
        a(),
        i && (i.addEventListener(e, n, r),
        a = () => {
            i.removeEventListener(e, n, r),
            a = Zf
        }
        )
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , l = () => {
        s(),
        a()
    }
    ;
    return JY(l),
    l
}
  , QY = (t, e, n, r={}) => {
    const {window: a=YY, event: s="pointerdown"} = r;
    return a ? XY(a, s, l => {
        const i = fn(t)
          , o = fn(e);
        !i || !o || i === l.target || l.composedPath().includes(i) || l.composedPath().includes(o) || n(l)
    }
    , {
        passive: !0
    }) : void 0
}
  , ZY = Se({
    compatConfig: {
        MODE: 3
    },
    __name: "VueDatePicker",
    props: {
        ...Ec
    },
    emits: ["update:model-value", "update:model-timezone-value", "text-submit", "closed", "cleared", "open", "focus", "blur", "internal-model-change", "recalculate-position", "flow-step", "update-month-year", "invalid-select", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "date-update", "invalid-date"],
    setup(t, {expose: e, emit: n}) {
        const r = t
          , a = en()
          , s = me(!1)
          , l = _e(r, "modelValue")
          , i = _e(r, "timezone")
          , o = me(null)
          , u = me(null)
          , d = me(null)
          , f = me(!1)
          , p = me(null)
          , {setMenuFocused: h, setShiftKey: v} = NS()
          , {clearArrowNav: y} = Ms()
          , {mapDatesArrToMap: k, validateDate: w, isValidTime: $} = Ni(r)
          , {defaultedTransitions: M, defaultedTextInput: S, defaultedInline: T, defaultedConfig: E} = sn(r)
          , {menuTransition: O, showTransition: U} = tu(M);
        Zt( () => {
            j(r.modelValue),
            Ot().then( () => {
                T.value.enabled || (ae(p.value).addEventListener("scroll", B),
                window.addEventListener("resize", se))
            }
            ),
            T.value.enabled && (s.value = !0)
        }
        );
        const L = K( () => k());
        Ko( () => {
            if (!T.value.enabled) {
                const b = ae(p.value);
                b && b.removeEventListener("scroll", B),
                window.removeEventListener("resize", se)
            }
        }
        );
        const C = sr(a, "all", r.presetDates)
          , W = sr(a, "input");
        Ke([l, i], () => {
            j(l.value)
        }
        , {
            deep: !0
        });
        const {openOnTop: R, menuStyle: G, xCorrect: te, setMenuPosition: J, getScrollableParent: ae, shadowRender: oe} = VG({
            menuRef: o,
            menuRefInner: u,
            inputRef: d,
            pickerWrapperRef: p,
            inline: T,
            emit: n,
            props: r,
            slots: a
        })
          , {inputValue: ne, internalModelValue: I, parseExternalModelValue: j, emitModelValue: re, formatInputValue: le, checkBeforeEmit: ce} = FG(n, r, f)
          , xe = K( () => ({
            dp__main: !0,
            dp__theme_dark: r.dark,
            dp__theme_light: !r.dark,
            dp__flex_display: T.value.enabled,
            dp__flex_display_with_input: T.value.input
        }))
          , X = K( () => r.dark ? "dp__theme_dark" : "dp__theme_light")
          , be = K( () => r.teleport ? {
            to: typeof r.teleport == "boolean" ? "body" : r.teleport,
            disabled: T.value.enabled
        } : {
            class: "dp__outer_menu_wrap"
        })
          , ee = K( () => T.value.enabled && (r.timePicker || r.monthPicker || r.yearPicker || r.quarterPicker))
          , B = () => {
            s.value && (E.value.closeOnScroll ? Ee() : J())
        }
          , se = () => {
            s.value && J()
        }
          , pe = () => {
            !r.disabled && !r.readonly && (oe(Dy, r),
            J(!1),
            s.value = !0,
            s.value && n("open"),
            s.value || ke(),
            j(r.modelValue))
        }
          , ie = () => {
            var b;
            ne.value = "",
            ke(),
            (b = d.value) == null || b.setParsedDate(null),
            n("update:model-value", null),
            n("update:model-timezone-value", null),
            n("cleared"),
            E.value.closeOnClearValue && Ee()
        }
          , fe = () => {
            const b = I.value;
            return !b || !Array.isArray(b) && w(b) ? !0 : Array.isArray(b) ? b.length === 2 && w(b[0]) && w(b[1]) ? !0 : r.partialRange && !r.timePicker ? w(b[0]) : !1 : !1
        }
          , F = () => {
            ce() && fe() ? (re(),
            Ee()) : n("invalid-select", I.value)
        }
          , z = b => {
            ge(),
            re(),
            E.value.closeOnAutoApply && !b && Ee()
        }
          , ge = () => {
            d.value && S.value.enabled && d.value.setParsedDate(I.value)
        }
          , Te = (b=!1) => {
            r.autoApply && $(I.value) && fe() && (r.range && Array.isArray(I.value) ? (r.partialRange || I.value.length === 2) && z(b) : z(b))
        }
          , ke = () => {
            S.value.enabled || (I.value = null)
        }
          , Ee = () => {
            T.value.enabled || (s.value && (s.value = !1,
            te.value = !1,
            h(!1),
            v(!1),
            y(),
            n("closed"),
            ne.value && j(l.value)),
            ke(),
            n("blur"))
        }
          , Fe = (b, P) => {
            if (!b) {
                I.value = null;
                return
            }
            const Y = Array.isArray(b) ? !b.some($e => !w($e)) : w(b)
              , he = $(b);
            Y && he && (I.value = b,
            P && (F(),
            n("text-submit")))
        }
          , Oe = () => {
            r.autoApply && $(I.value) && re(),
            ge()
        }
          , De = () => s.value ? Ee() : pe()
          , Ce = b => {
            I.value = b
        }
          , Be = () => {
            S.value.enabled && (f.value = !0,
            le()),
            n("focus")
        }
          , ze = () => {
            S.value.enabled && (f.value = !1,
            j(r.modelValue)),
            n("blur")
        }
          , Le = b => {
            u.value && u.value.updateMonthYear(0, {
                month: $y(b.month),
                year: $y(b.year)
            })
        }
          , Ye = b => {
            j(b ?? r.modelValue)
        }
          , D = (b, P) => {
            var Y;
            (Y = u.value) == null || Y.switchView(b, P)
        }
          , m = b => E.value.onClickOutside ? E.value.onClickOutside(b) : Ee();
        return QY(o, d, () => m(fe)),
        e({
            closeMenu: Ee,
            selectDate: F,
            clearValue: ie,
            openMenu: pe,
            onScroll: B,
            formatInputValue: le,
            updateInternalModelValue: Ce,
            setMonthYear: Le,
            parseModel: Ye,
            switchView: D
        }),
        (b, P) => (g(),
        _("div", {
            class: ye(xe.value),
            ref_key: "pickerWrapperRef",
            ref: p
        }, [x(zG, Ve({
            ref_key: "inputRef",
            ref: d,
            "is-menu-open": s.value,
            "input-value": A(ne),
            "onUpdate:inputValue": P[0] || (P[0] = Y => Kt(ne) ? ne.value = Y : null)
        }, b.$props, {
            onClear: ie,
            onOpen: pe,
            onSetInputDate: Fe,
            onSetEmptyDate: A(re),
            onSelectDate: F,
            onToggle: De,
            onClose: Ee,
            onFocus: Be,
            onBlur: ze,
            onRealBlur: P[1] || (P[1] = Y => f.value = !1)
        }), gn({
            _: 2
        }, [Ne(A(W), (Y, he) => ({
            name: Y,
            fn: N($e => [Z(b.$slots, Y, ut(Vt($e)))])
        }))]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]), x(fa, {
            name: A(O)(A(R)),
            css: A(U) && !A(T).enabled
        }, {
            default: N( () => [s.value ? (g(),
            de(qe(b.teleport ? Ti : "div"), Ve({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: o
            }, be.value, {
                class: {
                    "dp--menu-wrapper": !A(T).enabled
                },
                style: A(T).enabled ? void 0 : A(G)
            }), {
                default: N( () => [x(Dy, Ve({
                    ref_key: "dpMenuRef",
                    ref: u,
                    class: {
                        [X.value]: !0,
                        "dp--menu-wrapper": b.teleport
                    },
                    style: b.teleport ? A(G) : void 0,
                    "open-on-top": A(R),
                    "arr-map-values": L.value,
                    "no-overlay-focus": ee.value
                }, b.$props, {
                    "internal-model-value": A(I),
                    "onUpdate:internalModelValue": P[2] || (P[2] = Y => Kt(I) ? I.value = Y : null),
                    onClosePicker: Ee,
                    onSelectDate: F,
                    onAutoApply: Te,
                    onTimeUpdate: Oe,
                    onFlowStep: P[3] || (P[3] = Y => b.$emit("flow-step", Y)),
                    onUpdateMonthYear: P[4] || (P[4] = Y => b.$emit("update-month-year", Y)),
                    onInvalidSelect: P[5] || (P[5] = Y => b.$emit("invalid-select", A(I))),
                    onAutoApplyInvalid: P[6] || (P[6] = Y => b.$emit("invalid-select", Y)),
                    onInvalidFixedRange: P[7] || (P[7] = Y => b.$emit("invalid-fixed-range", Y)),
                    onRecalculatePosition: A(J),
                    onTooltipOpen: P[8] || (P[8] = Y => b.$emit("tooltip-open", Y)),
                    onTooltipClose: P[9] || (P[9] = Y => b.$emit("tooltip-close", Y)),
                    onTimePickerOpen: P[10] || (P[10] = Y => b.$emit("time-picker-open", Y)),
                    onTimePickerClose: P[11] || (P[11] = Y => b.$emit("time-picker-close", Y)),
                    onAmPmChange: P[12] || (P[12] = Y => b.$emit("am-pm-change", Y)),
                    onRangeStart: P[13] || (P[13] = Y => b.$emit("range-start", Y)),
                    onRangeEnd: P[14] || (P[14] = Y => b.$emit("range-end", Y)),
                    onDateUpdate: P[15] || (P[15] = Y => b.$emit("date-update", Y)),
                    onInvalidDate: P[16] || (P[16] = Y => b.$emit("invalid-date", Y))
                }), gn({
                    _: 2
                }, [Ne(A(C), (Y, he) => ({
                    name: Y,
                    fn: N($e => [Z(b.$slots, Y, ut(Vt({
                        ...$e
                    })))])
                }))]), 1040, ["class", "style", "open-on-top", "arr-map-values", "no-overlay-focus", "internal-model-value", "onRecalculatePosition"])]),
                _: 3
            }, 16, ["class", "style"])) : q("", !0)]),
            _: 3
        }, 8, ["name", "css"])], 2))
    }
})
  , Ur = ( () => {
    const t = ZY;
    return t.install = e => {
        e.component("Vue3DatePicker", t)
    }
    ,
    t
}
)()
  , eJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Ur
}, Symbol.toStringTag, {
    value: "Module"
}));
Object.entries(eJ).forEach( ([t,e]) => {
    t !== "default" && (Ur[t] = e)
}
);
var tJ = Object.defineProperty
  , nJ = Object.getOwnPropertyDescriptor
  , au = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? nJ(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && tJ(e, n, a),
    a
}
;
let cl = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "kungorelse");
        V(this, "uppgiftslamnare");
        V(this, "kungorelsetyp");
        V(this, "underrubrik");
        V(this, "editor", null);
        V(this, "mappedKungorelse", {});
        V(this, "valdDatum", "");
        V(this, "valdLan", "");
        V(this, "fysJurPersNamn", []);
        V(this, "fysJurPersNr", []);
        V(this, "fysJurAntal", 1);
        V(this, "fysJurPers", []);
        V(this, "kungText", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "publiceringsdatum2", new Date);
        V(this, "altFakt", !1);
        V(this, "altGata", "");
        V(this, "altCo", "");
        V(this, "altPostnr", "");
        V(this, "altOrt", "");
        V(this, "altLand", "Sverige");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get lander() {
        return St().lander
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    tvattaKungtext() {
        this.editor.commands.setContent(qi(this.editor.getHTML()))
    }
    isJuridisktnamnOK(n) {
        return n != null && n != null && n.length > 0 && n.length < 101
    }
    objNamnformatter(n) {
        return n.length > 100 ? n.substring(0, 100) : n
    }
    objNamnCheck(n) {
        return this.inputChk ? this.kungorelsetyp.fysiskJuridiskPersonregel == "mojlig" ? this.fysJurPersNamn[n] == null || this.fysJurPersNamn[n] == null || this.fysJurPersNamn[n] == "" ? null : this.isJuridisktnamnOK(this.fysJurPersNamn[n]) : this.kungorelsetyp.fysiskJuridiskPersonregel == "obligatorisk" ? this.isJuridisktnamnOK(this.fysJurPersNamn[n]) : null : null
    }
    lanCheck() {
        return !this.inputChk || this.kungorelsetyp.lanRegel != "obligatorisk" ? null : this.valdLan.length != 0
    }
    textCheck() {
        return this.inputChk ? this.editor.getHTML() != "<p></p>" : !0
    }
    mapToKungorelse(n) {
        if (this.fysJurAntal == 1 && this.fysJurPersNamn[0] == null)
            this.fysJurPers = [];
        else {
            var r = 0
              , a = 0;
            for (r = 0; r < this.fysJurAntal; r++)
                this.fysJurPersNamn[r] && (this.fysJurPers[a++] = {
                    namn: this.fysJurPersNamn[r],
                    nummer: this.fysJurPersNr[r]
                })
        }
        return n.rubrikExternKod = this.kungorelsetyp.externKod,
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.valdDatum,
        n.fysiskaJuridiskaPersoner = this.fysJurPers,
        n.lan = this.valdLan,
        n.rubrik = this.kungorelsetyp.beskrivning,
        n.registreringsDatum = "",
        n.kontaktInfo = "",
        n.amnesomrade = "",
        n.kungorelseText = qi(this.editor.getHTML()),
        n.underrubrik = "",
        n.underrubrikExternKod = "",
        this.underrubrik != null && (n.underrubrik = this.underrubrik.beskrivning,
        n.underrubrikExternKod = this.underrubrik.externKod),
        n.altFakturering = this.altFakt,
        n.altFaktureringsCoAdress = "",
        n.altFaktureringsAdress = "",
        n.altFaktureringsPostNr = "",
        n.altFaktureringsPostOrt = "",
        n.altFaktureringsLand = "SE",
        this.altFakt && (n.altFaktureringsCoAdress = this.altCo,
        n.altFaktureringsAdress = this.altGata,
        n.altFaktureringsPostNr = this.altPostnr,
        n.altFaktureringsPostOrt = this.altOrt,
        n.altFaktureringsLand = this.altLand),
        n
    }
    mapFromKungorelse(n) {
        this.mappedKungorelse = n;
        var r = 0;
        for (this.fysJurAntal = n.fysiskaJuridiskaPersoner.length,
        r = 0; r < this.fysJurAntal; r++)
            this.fysJurPersNamn[r] = n.fysiskaJuridiskaPersoner[r].namn,
            this.fysJurPersNr[r] = n.fysiskaJuridiskaPersoner[r].nummer;
        this.editor.commands.setContent(n.kungorelseText),
        !n.kungorelseid || n.kungorelseid == "" ? this.publiceringsdatum = n.publiceringsDatum : this.publiceringsdatum = "",
        this.fakturareferens = n.fakturaReferens,
        this.kungText = n.kungorelseText,
        this.valdDatum = n.typDatum,
        this.valdLan = n.lan,
        this.altFakt = n.altFakturering,
        this.altFakt && (this.altGata = n.altFaktureringsAdress,
        this.altCo = n.altFaktureringsCoAdress,
        this.altPostnr = n.altFaktureringsPostNr,
        this.altOrt = n.altFaktureringsPostOrt,
        this.altLand = n.altFaktureringsLand,
        (!this.altLand || this.altLand == "") && (this.altLand = "SE"))
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        if (this.kungorelsetyp.intervall != "M" || n.getDate() == 1)
            return Mt(n);
        for (var r = 1; r < n.getDate(); r++) {
            var a = new Date;
            if (a.setTime(n.getTime()),
            a.setDate(r),
            !Mt(a))
                return !0
        }
        return Mt(n)
    }
    personOrgnummerGiltigt(n) {
        var r = this.fysJurPersNr[n];
        return r ? Ht(r) : null
    }
    isNummerGiltigt(n) {
        var r;
        return r = Ht(n),
        !(r == null || r == null || r == !1)
    }
    valideraFormular() {
        this.felMeddelande = "",
        this.inputChk = !0;
        var n = this.kungorelsetyp;
        if (n.fysiskJuridiskPersonregel == "obligatorisk" && (this.fysJurAntal < 1 && (this.felMeddelande += "• Fyll i vem kungörelsen avser.<br/>"),
        (!this.fysJurPersNamn[0] || this.fysJurPersNamn[0] == "") && (this.felMeddelande += "• Fyll i vem kungörelsen avser.<br/>")),
        n.fysiskJuridiskPersonregel == "mojlig" || n.fysiskJuridiskPersonregel == "obligatorisk") {
            var r = 0;
            for (r = 0; r < this.fysJurAntal; r++)
                this.fysJurPersNr[r] && !this.fysJurPersNamn[r] && (this.felMeddelande += "• Person nr " + (r + 1) + ", har inget namn.<br/>"),
                !(!this.fysJurPersNamn[r] || !this.fysJurPersNr[r]) && (this.fysJurPersNamn[r] == "" || this.fysJurPersNr[r] == "" || this.isNummerGiltigt(this.fysJurPersNr[r]) || (this.felMeddelande += "• Person nr " + (r + 1) + ", , har felaktigt personnummer.<br/>"))
        }
        return n.lanRegel == "obligatorisk" && this.valdLan == "" && (this.felMeddelande += "• Län måste fyllas i.<br/>"),
        this.editor.getHTML().replace(/<[^>]+>/g, "").trim() == "" && (this.felMeddelande += "• Kungörelsetext måste fyllas i.<br/>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.mappedKungorelse = {},
        this.valdDatum = "",
        this.valdLan = "",
        this.fysJurPersNamn = [],
        this.fysJurPersNr = [],
        this.fysJurAntal = 1,
        this.fysJurPers = [],
        this.kungText = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.publiceringsdatum2 = new Date,
        this.altFakt = !1,
        this.altGata = "",
        this.altCo = "",
        this.altPostnr = "",
        this.altOrt = "",
        this.altLand = "Sverige",
        this.editor.commands.setContent(""),
        this.felMeddelande = "",
        this.inputChk = !1
    }
    TaBortPerson(n) {
        this.fysJurPersNamn.splice(n, 1),
        this.fysJurPersNr.splice(n, 1),
        this.fysJurAntal--
    }
    created() {
        const n = St();
        n.getLan(),
        n.getLander()
    }
    mounted() {
        this.editor = new Rx({
            editorProps: {
                transformPasted(n) {
                    return sessionStorage.setItem("PoIT_Paste", "1"),
                    n
                }
            },
            parseOptions: {
                preserveWhitespace: "full"
            },
            content: "",
            extensions: [zx],
            onUpdate({editor: n}) {
                sessionStorage.getItem("PoIT_Paste") == "1" && (n.commands.setContent(qi(n.getHTML())),
                sessionStorage.setItem("PoIT_Paste", "0"))
            }
        }),
        this.kungorelse != null && (this.mapFromKungorelse(this.kungorelse),
        this.kungorelse.kungorelseText = qi(this.editor.getHTML()))
    }
    beforeUnmount() {
        this.editor.destroy()
    }
}
;
au([Bn()], cl.prototype, "kungorelse", 2);
au([Bn()], cl.prototype, "uppgiftslamnare", 2);
au([Bn()], cl.prototype, "kungorelsetyp", 2);
au([Bn()], cl.prototype, "underrubrik", 2);
cl = au([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        EditorContent: Lx,
        BFormCheckbox: $s,
        BFormSelect: yl,
        IBiPlus: qx,
        IBiTypeBold: Wx,
        IBiListUl: Gx,
        IBiListOl: Yx,
        IBiX: _l,
        BFormInput: H_,
        VueDatePicker: Ur
    }
})], cl);
const rJ = Et(cl);
const _n = t => ($t("data-v-54c2dba1"),
t = t(),
Tt(),
t)
  , aJ = {
    class: "col-12"
}
  , sJ = {
    key: 0,
    class: "mb-3 blv-fieldset mt-2"
}
  , lJ = _n( () => c("legend", {
    class: "legend"
}, "Kungörelsen avser", -1))
  , iJ = {
    class: "row hide-for-phones"
}
  , oJ = _n( () => c("div", {
    class: "col-sm-1 mb-2 mb-md-2"
}, [c("span", {
    class: "label label-sm visually-hidden"
}, "Nr")], -1))
  , uJ = {
    class: "col-sm-5 mb-2 mb-md-2"
}
  , dJ = {
    key: 0,
    class: "label label-sm"
}
  , cJ = {
    key: 1,
    class: "label label-sm"
}
  , fJ = _n( () => c("div", {
    class: "col-sm-5 mb-2 mb-md-2"
}, [c("span", {
    class: "label label-sm"
}, "Organisations- eller personnummer")], -1))
  , pJ = _n( () => c("div", {
    class: "col-sm-1 mb-2 mb-md-2"
}, [c("span", {
    class: "label label-sm"
})], -1))
  , hJ = {
    class: "row"
}
  , mJ = {
    class: "col-sm-1 mb-2 mb-md-2"
}
  , vJ = {
    class: "d-flex"
}
  , gJ = {
    class: "input-group-text",
    id: "basic-addon1"
}
  , bJ = {
    class: "col-sm-5 mb-2 mb-md-2"
}
  , yJ = {
    class: "col-sm-5 mb-2 mb-md-2"
}
  , kJ = {
    class: "col-sm-1 mb-2 mb-md-2"
}
  , _J = ["title", "onClick"]
  , wJ = {
    class: "visually-hidden"
}
  , xJ = {
    key: 1,
    class: "mb-3"
}
  , SJ = _n( () => c("label", {
    for: "lan"
}, "Län *", -1))
  , $J = ["value"]
  , TJ = {
    key: 2,
    class: "mb-3"
}
  , CJ = _n( () => c("label", {
    for: "lan"
}, "Län", -1))
  , EJ = ["value"]
  , AJ = {
    class: "card mb-3"
}
  , MJ = _n( () => c("div", {
    class: "card-header"
}, [c("label", {
    for: "editor"
}, "Kungörelsetext *")], -1))
  , OJ = {
    class: "kungtext p-4"
}
  , NJ = {
    key: 0
}
  , DJ = _n( () => c("span", {
    class: "visually-hidden"
}, "Fet Stil", -1))
  , PJ = _n( () => c("span", {
    class: "visually-hidden"
}, "Skapa punktlista", -1))
  , FJ = _n( () => c("span", {
    class: "visually-hidden"
}, "Skapa numrerad lista", -1))
  , BJ = {
    class: "mb-3 blv-fieldset mt-4"
}
  , VJ = _n( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , IJ = {
    key: 4,
    class: "row"
}
  , RJ = {
    class: "col-sm mb-2"
}
  , LJ = {
    key: 5
}
  , jJ = _n( () => c("h4", null, "Faktureringsadress", -1))
  , UJ = {
    class: "row"
}
  , HJ = {
    class: "col-sm mb-2"
}
  , KJ = {
    class: "list-group mb-2"
}
  , zJ = {
    class: "list-group-item"
}
  , qJ = {
    class: "row"
}
  , WJ = _n( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Namn")], -1))
  , GJ = {
    class: "col-md-9"
}
  , YJ = {
    class: "list-group-item"
}
  , JJ = {
    class: "row"
}
  , XJ = _n( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Adress")], -1))
  , QJ = {
    class: "col-md-9"
}
  , ZJ = {
    class: "list-group-item"
}
  , eX = {
    class: "row"
}
  , tX = _n( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Postnummer")], -1))
  , nX = {
    class: "col-md-9"
}
  , rX = {
    class: "list-group-item"
}
  , aX = {
    class: "row"
}
  , sX = _n( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Postort")], -1))
  , lX = {
    class: "col-md-9"
}
  , iX = {
    class: "list-group-item"
}
  , oX = {
    class: "row"
}
  , uX = _n( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Land")], -1))
  , dX = {
    class: "col-md-9"
}
  , cX = _n( () => c("h4", null, "Alternativ faktureringsadress", -1))
  , fX = ["value"];
function pX(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("i-bi-x")
      , u = ue("i-bi-plus")
      , d = ue("b-form-select")
      , f = ue("vue-date-picker")
      , p = ue("form-group")
      , h = ue("i-bi-type-bold")
      , v = ue("i-bi-list-ul")
      , y = ue("i-bi-list-ol")
      , k = ue("editor-content")
      , w = ue("b-form-checkbox")
      , $ = ue("meddelande");
    return g(),
    _("div", aJ, [t.kungorelsetyp.fysiskJuridiskPersonregel == "obligatorisk" || t.kungorelsetyp.fysiskJuridiskPersonregel == "mojlig" ? (g(),
    _("fieldset", sJ, [lJ, c("div", iJ, [oJ, c("div", uJ, [t.kungorelsetyp.fysiskJuridiskPersonregel == "obligatorisk" ? (g(),
    _("span", dJ, "Namn eller fastighetsbeteckning *")) : (g(),
    _("span", cJ, "Namn eller fastighetsbeteckning"))]), fJ, pJ]), (g(!0),
    _(we, null, Ne(t.fysJurAntal, (M, S) => (g(),
    _("div", {
        key: S
    }, [c("div", hJ, [c("div", mJ, [c("div", vJ, [c("span", gJ, Q(S + 1), 1)])]), c("div", bJ, [t.kungorelsetyp.fysiskJuridiskPersonregel == "obligatorisk" ? (g(),
    de(l, {
        key: 0,
        modelValue: t.fysJurPersNamn[S],
        "onUpdate:modelValue": T => t.fysJurPersNamn[S] = T,
        title: "Ange namn eller fastighetsbeteckning *",
        placeholder: "Ange namn eller fastighetsbeteckning *",
        formatter: t.objNamnformatter,
        state: t.objNamnCheck(S)
    }, null, 8, ["modelValue", "onUpdate:modelValue", "formatter", "state"])) : (g(),
    de(l, {
        key: 1,
        modelValue: t.fysJurPersNamn[S],
        "onUpdate:modelValue": T => t.fysJurPersNamn[S] = T,
        title: "Ange namn eller fastighetsbeteckning",
        placeholder: "Ange namn eller fastighetsbeteckning",
        formatter: t.objNamnformatter,
        state: t.objNamnCheck(S)
    }, null, 8, ["modelValue", "onUpdate:modelValue", "formatter", "state"])), x(i, {
        id: "input-live-feedback"
    }, {
        default: N( () => [ve("Namn måste fyllas i")]),
        _: 1
    })]), c("div", yJ, [x(l, {
        modelValue: t.fysJurPersNr[S],
        "onUpdate:modelValue": T => t.fysJurPersNr[S] = T,
        title: "Ange organisations- eller personnummer (valfritt)",
        placeholder: "Ange organisations- eller personnummer (valfritt)",
        state: t.personOrgnummerGiltigt(S)
    }, null, 8, ["modelValue", "onUpdate:modelValue", "state"]), x(i, {
        id: "input-live-feedback2"
    }, {
        default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
        _: 1
    })]), c("div", kJ, [t.fysJurAntal > 1 ? (g(),
    _("button", {
        key: 0,
        type: "button",
        title: "Ta bort rad " + (S + 1),
        class: "btn btn-danger blv-btn-icon blv-btn-danger",
        onClick: T => t.TaBortPerson(S)
    }, [x(o, {
        role: "img",
        class: "b-icon bi text-white",
        "aria-label": "x",
        focusable: "false"
    }), c("span", wJ, "Ta bort rad " + Q(S + 1), 1)], 8, _J)) : q("", !0)])])]))), 128)), c("button", {
        type: "button",
        class: "btn blv-color btn-primary",
        onClick: e[0] || (e[0] = M => t.fysJurAntal++)
    }, [x(u, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "plus",
        focusable: "false"
    }), ve(" Lägg till fler ")])])) : q("", !0), t.kungorelsetyp.lanRegel == "obligatorisk" ? (g(),
    _("div", xJ, [SJ, x(d, {
        modelValue: t.valdLan,
        "onUpdate:modelValue": e[1] || (e[1] = M => t.valdLan = M),
        class: "form-select",
        id: "lan",
        placeholder: "Välj Län",
        state: t.lanCheck()
    }, {
        default: N( () => [(g(!0),
        _(we, null, Ne(t.laner, M => (g(),
        _("option", {
            key: M.id,
            value: M.namn
        }, Q(M.namn), 9, $J))), 128))]),
        _: 1
    }, 8, ["modelValue", "state"])])) : q("", !0), t.kungorelsetyp.lanRegel == "mojlig" ? (g(),
    _("div", TJ, [CJ, ft(c("select", {
        "onUpdate:modelValue": e[2] || (e[2] = M => t.valdLan = M),
        class: "form-select",
        id: "lan",
        placeholder: "Välj Län"
    }, [(g(!0),
    _(we, null, Ne(t.laner, M => (g(),
    _("option", {
        key: M.id,
        value: M.namn
    }, Q(M.namn), 9, EJ))), 128))], 512), [[Xn, t.valdLan]])])) : q("", !0), t.kungorelsetyp.datumTyp != null ? (g(),
    de(p, {
        key: 3,
        label: t.kungorelsetyp.datumTyp,
        "label-for": "valdDatum"
    }, {
        default: N( () => [x(f, {
            modelValue: t.valdDatum,
            "onUpdate:modelValue": e[3] || (e[3] = M => t.valdDatum = M),
            id: "valdDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    }, 8, ["label"])) : q("", !0), c("div", AJ, [MJ, c("div", OJ, [t.editor ? (g(),
    _("div", NJ, [c("button", {
        type: "button",
        title: "Fet stil",
        onClick: e[4] || (e[4] = M => t.editor.chain().focus().toggleBold().run()),
        class: ye([{
            "is-active": t.editor.isActive("bold")
        }, "btn btn-primary blv-color btn-sm text-white me-3"])
    }, [x(h, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "type bold",
        focusable: "false"
    }), DJ], 2), c("button", {
        type: "button",
        title: "Skapa punktlista",
        onClick: e[5] || (e[5] = M => t.editor.chain().focus().toggleBulletList().run()),
        class: ye([{
            "is-active": t.editor.isActive("bulletList")
        }, "btn btn-primary blv-color btn-sm text-white me-3"])
    }, [x(v, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "list ul",
        focusable: "false"
    }), PJ], 2), c("button", {
        type: "button",
        title: "Skapa numrerad lista",
        onClick: e[6] || (e[6] = M => t.editor.chain().focus().toggleOrderedList().run()),
        class: ye([{
            "is-active": t.editor.isActive("orderedList")
        }, "btn btn-primary blv-color btn-sm text-white"])
    }, [x(y, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "list ol",
        focusable: "false"
    }), FJ], 2)])) : q("", !0), x(k, {
        editor: t.editor,
        id: "editor",
        class: ye(t.textCheck() ? "" : "hasError")
    }, null, 8, ["editor", "class"])])]), c("fieldset", BJ, [VJ, x(p, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(f, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[7] || (e[7] = M => t.publiceringsdatum = M),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    }), x(p, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[8] || (e[8] = M => t.fakturareferens = M),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), t.mappedKungorelse.kungorelseid != null && !t.uppgiftslamnare.harElektroniskFaktura && !t.uppgiftslamnare.harSamlingsfaktura ? (g(),
    _("div", IJ, [c("div", RJ, [x(w, {
        class: "mb-3",
        id: "altFaktId",
        modelValue: t.altFakt,
        "onUpdate:modelValue": e[9] || (e[9] = M => t.altFakt = M),
        name: "visafakturaadress"
    }, {
        default: N( () => [ve(" Jag vill ange en annan faktureringsadress.")]),
        _: 1
    }, 8, ["modelValue"])])])) : q("", !0), t.altFakt ? (g(),
    _("div", LJ, [jJ, c("div", UJ, [c("div", HJ, [c("ul", KJ, [c("li", zJ, [c("div", qJ, [WJ, c("div", GJ, [c("span", null, Q(t.uppgiftslamnare.namn), 1)])])]), c("li", YJ, [c("div", JJ, [XJ, c("div", QJ, [c("span", null, Q(t.uppgiftslamnare.faktureringGatuadress), 1)])])]), c("li", ZJ, [c("div", eX, [tX, c("div", nX, [c("span", null, Q(t.uppgiftslamnare.faktureringpostnummer), 1)])])]), c("li", rX, [c("div", aX, [sX, c("div", lX, [c("span", null, Q(t.uppgiftslamnare.faktureringPostort), 1)])])]), c("li", iX, [c("div", oX, [uX, c("div", dX, [c("span", null, Q(t.uppgiftslamnare.faktureringLand), 1)])])])])])]), cX, x(p, {
        label: "Co adress",
        "label-for": "altCo"
    }, {
        default: N( () => [x(l, {
            modelValue: t.altCo,
            "onUpdate:modelValue": e[10] || (e[10] = M => t.altCo = M),
            id: "altCo"
        }, null, 8, ["modelValue"])]),
        _: 1
    }), x(p, {
        label: "Gatuadress",
        "label-for": "altGata"
    }, {
        default: N( () => [x(l, {
            modelValue: t.altGata,
            "onUpdate:modelValue": e[11] || (e[11] = M => t.altGata = M),
            id: "altGata"
        }, null, 8, ["modelValue"])]),
        _: 1
    }), x(p, {
        label: "Postnummer",
        "label-for": "altPostnr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.altPostnr,
            "onUpdate:modelValue": e[12] || (e[12] = M => t.altPostnr = M),
            id: "altPostnr"
        }, null, 8, ["modelValue"])]),
        _: 1
    }), x(p, {
        label: "Postort",
        "label-for": "altOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.altOrt,
            "onUpdate:modelValue": e[13] || (e[13] = M => t.altOrt = M),
            id: "altOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    }), x(p, {
        label: "Land",
        "label-for": "altLand"
    }, {
        default: N( () => [ft(c("select", {
            "onUpdate:modelValue": e[14] || (e[14] = M => t.altLand = M),
            class: "form-select"
        }, [(g(!0),
        _(we, null, Ne(t.lander, M => (g(),
        _("option", {
            key: M.isoKod,
            value: M.isoKod
        }, Q(M.namn), 9, fX))), 128))], 512), [[Xn, t.altLand]])]),
        _: 1
    })])) : q("", !0), t.felMeddelande != "" ? (g(),
    de($, {
        key: 6,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const VS = rt(rJ, [["render", pX], ["__scopeId", "data-v-54c2dba1"]]);
var hX = Object.defineProperty
  , mX = Object.getOwnPropertyDescriptor
  , IS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? mX(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && hX(e, n, a),
    a
}
;
let Td = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "editor", null);
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objNamnF", "");
        V(this, "objCO", "");
        V(this, "objAdress", "");
        V(this, "objPostNr", "");
        V(this, "objOrt", "");
        V(this, "forvNamn", "");
        V(this, "forvCO", "");
        V(this, "forvAdress", "");
        V(this, "forvPostNr", "");
        V(this, "forvOrt", "");
        V(this, "forvTel", "");
        V(this, "edDatum", "");
        V(this, "edTid", "");
        V(this, "edPlats", "");
        V(this, "beslutsDatum", "");
        V(this, "annonsI", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objNamnF = this.clS(this.objNamnF),
        this.objCO = this.clS(this.objCO),
        this.objAdress = this.clS(this.objAdress),
        this.objPostNr = this.clS(this.objPostNr),
        this.objOrt = this.clS(this.objOrt),
        this.forvNamn = this.clS(this.forvNamn),
        this.forvCO = this.clS(this.forvCO),
        this.forvAdress = this.clS(this.forvAdress),
        this.forvPostNr = this.clS(this.forvPostNr),
        this.forvOrt = this.clS(this.forvOrt),
        this.forvTel = this.clS(this.forvTel),
        this.edPlats = this.clS(this.edPlats),
        this.annonsI = this.clS(this.annonsI),
        this.fakturareferens = this.clS(this.fakturareferens),
        this.edTid.length == 8 && (this.edTid = this.edTid.substr(0, 5));
        var r = "";
        return r += this.objNamn,
        this.objNr && (r += ", " + this.objNr),
        this.objNamnF && (r += ", med företagsnamn " + this.objNamnF),
        this.objCO != "" && (r += ", c/o " + this.objCO),
        this.objAdress && this.objAdress != "" && (r += ", " + this.objAdress),
        this.objPostNr != "" && (r += ", " + this.objPostNr),
        this.objOrt != "" && (r += ", " + this.objOrt),
        r += ", har",
        this.beslutsDatum && (r += " " + this.beslutsDatum),
        r += " försatts i konkurs vid " + this.uppgiftslamnare.namn + ". ",
        this.edDatum && this.edTid && this.edPlats && (r += "Edgångssammanträde hålls " + this.edDatum + " kl " + this.edTid + ", " + this.edPlats + ". ",
        r += "Borgenärerna kallas till sammanträdet genom denna kungörelse. "),
        this.forvNamn && (r += "Förvaltare är " + this.forvNamn,
        this.forvCO != "" && (r += ", c/o " + this.forvCO),
        this.forvAdress != "" && (r += ", " + this.forvAdress),
        this.forvPostNr != "" && (r += ", " + this.forvPostNr),
        this.forvOrt != "" && (r += ", " + this.forvOrt),
        this.forvTel != "" && (r += ", telefon: " + this.forvTel),
        r += ". "),
        this.annonsI && (r += "Fortsatta kungörelser i konkursen kommer att annonseras i " + this.annonsI + ". "),
        r += this.editor.getHTML(),
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.beslutsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        (this.edDatum != "" || this.edTid != "" || this.edPlats != "") && (this.edDatum == "" && (this.felMeddelande += "• Edgångssammanträdet saknar datum.<br>"),
        this.edTid == "" && (this.felMeddelande += "• Edgångssammanträdet saknar tid.<br>"),
        this.edPlats == "" && (this.felMeddelande += "• Edgångssammanträdet saknar plats.<br>")),
        this.felMeddelande == ""
    }
    mounted() {
        this.editor = new Rx({
            editorProps: {
                transformPasted(n) {
                    return sessionStorage.setItem("PoIT_Paste", "1"),
                    n
                }
            },
            content: "",
            extensions: [zx],
            onUpdate({editor: n}) {
                sessionStorage.getItem("PoIT_Paste") == "1" && (n.commands.setContent(qi(n.getHTML())),
                sessionStorage.setItem("PoIT_Paste", "0"))
            }
        })
    }
    beforeUnmount() {
        this.editor.destroy()
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objNamnF = "",
        this.objCO = "",
        this.objAdress = "",
        this.objPostNr = "",
        this.objOrt = "",
        this.forvNamn = "",
        this.forvCO = "",
        this.forvAdress = "",
        this.forvPostNr = "",
        this.forvOrt = "",
        this.forvTel = "",
        this.edDatum = "",
        this.edTid = "",
        this.edPlats = "",
        this.beslutsDatum = "",
        this.annonsI = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.editor.commands.setContent(""),
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
IS([Bn()], Td.prototype, "uppgiftslamnare", 2);
Td = IS([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        EditorContent: Lx,
        IBiTypeBold: Wx,
        IBiListUl: Gx,
        IBiListOl: Yx,
        VueDatePicker: Ur
    }
})], Td);
const vX = Et(Td);
const Ba = t => ($t("data-v-89a9bdab"),
t = t(),
Tt(),
t)
  , gX = {
    class: "col-12"
}
  , bX = {
    class: "mb-3 blv-fieldset"
}
  , yX = Ba( () => c("legend", {
    class: "legend"
}, "Konkursen avser", -1))
  , kX = {
    class: "row"
}
  , _X = {
    class: "col-sm-6"
}
  , wX = {
    class: "col-sm-6"
}
  , xX = {
    class: "row"
}
  , SX = {
    class: "col-sm-12"
}
  , $X = {
    class: "row"
}
  , TX = {
    class: "col-sm-6"
}
  , CX = {
    class: "col-sm-6"
}
  , EX = {
    class: "row"
}
  , AX = {
    class: "col-sm-6"
}
  , MX = {
    class: "col-sm-6"
}
  , OX = {
    class: "mb-3 blv-fieldset"
}
  , NX = Ba( () => c("legend", {
    class: "legend"
}, "Förvaltare", -1))
  , DX = {
    class: "row"
}
  , PX = {
    class: "col-sm-6"
}
  , FX = {
    class: "col-sm-6"
}
  , BX = {
    class: "row"
}
  , VX = {
    class: "col-sm-6"
}
  , IX = {
    class: "col-sm-6"
}
  , RX = {
    class: "row"
}
  , LX = {
    class: "col-sm-6"
}
  , jX = {
    class: "col-sm-6"
}
  , UX = {
    class: "mb-3 blv-fieldset mt-2"
}
  , HX = Ba( () => c("legend", {
    class: "legend"
}, "Edgångssammanträde", -1))
  , KX = {
    class: "row"
}
  , zX = {
    class: "col-sm-6"
}
  , qX = {
    class: "col-sm-6"
}
  , WX = {
    class: "row"
}
  , GX = {
    class: "col-sm-12"
}
  , YX = {
    class: "mb-3 blv-fieldset mt-2"
}
  , JX = Ba( () => c("legend", {
    class: "legend"
}, "Övriga uppgifter om konkursen", -1))
  , XX = {
    class: "row"
}
  , QX = {
    class: "col-sm-6"
}
  , ZX = {
    class: "col-sm-6"
}
  , eQ = {
    class: "card mb-3"
}
  , tQ = Ba( () => c("div", {
    class: "card-header"
}, [c("label", {
    for: "editor"
}, "Kompletterande Kungörelsetext")], -1))
  , nQ = {
    class: "list-group list-group-flush"
}
  , rQ = {
    class: "list-group-item"
}
  , aQ = {
    class: "kungtext"
}
  , sQ = {
    key: 0
}
  , lQ = Ba( () => c("span", {
    class: "visually-hidden"
}, "Fet Stil", -1))
  , iQ = Ba( () => c("span", {
    class: "visually-hidden"
}, "Skapa punktlista", -1))
  , oQ = Ba( () => c("span", {
    class: "visually-hidden"
}, "Skapa numrerad lista", -1))
  , uQ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , dQ = Ba( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , cQ = {
    class: "row"
}
  , fQ = {
    class: "col-sm-12"
};
function pQ(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("i-bi-type-bold")
      , f = ue("i-bi-list-ul")
      , p = ue("i-bi-list-ol")
      , h = ue("editor-content")
      , v = ue("meddelande");
    return g(),
    _("div", gX, [c("fieldset", bX, [yX, c("div", kX, [c("div", _X, [x(o, {
        label: "Företagsnamn eller personnamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = y => t.objNamn = y),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", wX, [x(o, {
        label: "Organisations- eller personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = y => t.objNr = y),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", xX, [c("div", SX, [x(o, {
        label: "Med företagsnamn (vid enskild näringsidkare)",
        "label-for": "objNamnF"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamnF,
            "onUpdate:modelValue": e[2] || (e[2] = y => t.objNamnF = y),
            id: "objNamnF"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", $X, [c("div", TX, [x(o, {
        label: "C/o",
        "label-for": "objCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objCO,
            "onUpdate:modelValue": e[3] || (e[3] = y => t.objCO = y),
            id: "objCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", CX, [x(o, {
        label: "Adress",
        "label-for": "objAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objAdress,
            "onUpdate:modelValue": e[4] || (e[4] = y => t.objAdress = y),
            id: "objAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", EX, [c("div", AX, [x(o, {
        label: "Postnummer",
        "label-for": "objPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objPostNr,
            "onUpdate:modelValue": e[5] || (e[5] = y => t.objPostNr = y),
            id: "objPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", MX, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[6] || (e[6] = y => t.objOrt = y),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("fieldset", OX, [NX, c("div", DX, [c("div", PX, [x(o, {
        label: "Företagsnamn eller personnamn",
        "label-for": "forvNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvNamn,
            "onUpdate:modelValue": e[7] || (e[7] = y => t.forvNamn = y),
            id: "forvNamn"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", FX, [x(o, {
        label: "Telefon",
        "label-for": "forvTel"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvTel,
            "onUpdate:modelValue": e[8] || (e[8] = y => t.forvTel = y),
            id: "forvTel"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", BX, [c("div", VX, [x(o, {
        label: "C/o",
        "label-for": "forvCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvCO,
            "onUpdate:modelValue": e[9] || (e[9] = y => t.forvCO = y),
            id: "forvCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", IX, [x(o, {
        label: "Adress",
        "label-for": "forvAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvAdress,
            "onUpdate:modelValue": e[10] || (e[10] = y => t.forvAdress = y),
            id: "forvAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", RX, [c("div", LX, [x(o, {
        label: "Postnummer",
        "label-for": "forvPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvPostNr,
            "onUpdate:modelValue": e[11] || (e[11] = y => t.forvPostNr = y),
            id: "forvPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", jX, [x(o, {
        label: "Postort",
        "label-for": "forvOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.forvOrt,
            "onUpdate:modelValue": e[12] || (e[12] = y => t.forvOrt = y),
            id: "forvOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("fieldset", UX, [HX, c("div", KX, [c("div", zX, [x(o, {
        label: "Datum",
        "label-for": "edDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.edDatum,
            "onUpdate:modelValue": e[13] || (e[13] = y => t.edDatum = y),
            id: "edDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", qX, [x(o, {
        label: "Tid",
        "label-for": "edTid"
    }, {
        default: N( () => [x(u, {
            modelValue: t.edTid,
            "onUpdate:modelValue": e[14] || (e[14] = y => t.edTid = y),
            id: "edTid",
            placeholder: "",
            "week-start": "1",
            "time-picker": "",
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            clearable: "",
            "input-class-name": "form-control",
            "model-type": "HH:mm"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", WX, [c("div", GX, [x(o, {
        label: "Plats",
        "label-for": "edPlats"
    }, {
        default: N( () => [x(l, {
            modelValue: t.edPlats,
            "onUpdate:modelValue": e[15] || (e[15] = y => t.edPlats = y),
            id: "edPlats"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("fieldset", YX, [JX, c("div", XX, [c("div", QX, [x(o, {
        label: "Datum för konkursbeslutet",
        "label-for": "beslutsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.beslutsDatum,
            "onUpdate:modelValue": e[16] || (e[16] = y => t.beslutsDatum = y),
            id: "beslutsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", ZX, [x(o, {
        label: "Fortsatta kungörelser annonseras i...",
        "label-for": "annonsI"
    }, {
        default: N( () => [x(l, {
            modelValue: t.annonsI,
            "onUpdate:modelValue": e[17] || (e[17] = y => t.annonsI = y),
            id: "annonsI"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("div", eQ, [tQ, c("ul", nQ, [c("li", rQ, [c("div", aQ, [t.editor ? (g(),
    _("div", sQ, [c("button", {
        type: "button",
        title: "Fet stil",
        onClick: e[18] || (e[18] = y => t.editor.chain().focus().toggleBold().run()),
        class: ye([{
            "is-active": t.editor.isActive("bold")
        }, "btn btn-primary blv-color btn-sm text-white me-3"])
    }, [x(d, {
        class: "b-icon bi",
        role: "img",
        "aria-label": "type bold",
        focusable: "false"
    }), lQ], 2), c("button", {
        type: "button",
        title: "Skapa punktlista",
        onClick: e[19] || (e[19] = y => t.editor.chain().focus().toggleBulletList().run()),
        class: ye([{
            "is-active": t.editor.isActive("bulletList")
        }, "btn btn-primary blv-color btn-sm text-white me-3"])
    }, [x(f, {
        class: "b-icon bi",
        role: "img",
        "aria-label": "list ul",
        focusable: "false"
    }), iQ], 2), c("button", {
        type: "button",
        title: "Skapa numrerad lista",
        onClick: e[20] || (e[20] = y => t.editor.chain().focus().toggleOrderedList().run()),
        class: ye([{
            "is-active": t.editor.isActive("orderedList")
        }, "btn btn-primary blv-color btn-sm text-white"])
    }, [x(p, {
        class: "b-icon bi",
        role: "img",
        "aria-label": "list ol",
        focusable: "false"
    }), oQ], 2)])) : q("", !0), x(h, {
        editor: t.editor,
        id: "editor"
    }, null, 8, ["editor"])])])])]), c("fieldset", uQ, [dQ, x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[21] || (e[21] = y => t.publiceringsdatum = y),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    }), c("div", cQ, [c("div", fQ, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[22] || (e[22] = y => t.fakturareferens = y),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(v, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const hQ = rt(vX, [["render", pQ], ["__scopeId", "data-v-89a9bdab"]]);
var mQ = Object.defineProperty
  , vQ = Object.getOwnPropertyDescriptor
  , RS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? vQ(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && mQ(e, n, a),
    a
}
;
let Cd = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objNamnF", "");
        V(this, "objOrt", "");
        V(this, "invändningsDatum", "");
        V(this, "klandringsDatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objNamnF = this.clS(this.objNamnF),
        this.objOrt = this.clS(this.objOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        return r += "I konkursen " + this.objNamn,
        this.objNr && (r += ", " + this.objNr),
        this.objNamnF && (r += ", med företagsnamn " + this.objNamnF),
        this.objOrt && (r += ", " + this.objOrt),
        r += ", har upprättats utdelningsförslag och förvaltningsredogörelse samt slutredovisning och tillsynsmyndighetens utlåtande däröver. ",
        r += "Handlingarna hålls tillgängliga hos rätten och tillsynsmyndigheten för den som vill ta del av dem. Invändning mot utdelningsförslaget kan göras",
        this.invändningsDatum && (r += " senast " + this.invändningsDatum),
        r += " hos ",
        r += this.uppgiftslamnare.namn + ",",
        this.uppgiftslamnare.gatuAdress && (r += " " + this.uppgiftslamnare.gatuAdress),
        this.uppgiftslamnare.coAdress && (r += " " + this.uppgiftslamnare.coAdress),
        this.uppgiftslamnare.postnummer && (r += " " + this.uppgiftslamnare.postnummer),
        this.uppgiftslamnare.postort && (r += " " + this.uppgiftslamnare.postort),
        r += ". ",
        r += "Slutredovisningen kan klandras genom att talan mot förvaltaren väcks vid samma tingsrätt",
        this.klandringsDatum && (r += " senast " + this.klandringsDatum + "."),
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.invändningsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objNamnF = "",
        this.objOrt = "",
        this.invändningsDatum = "",
        this.klandringsDatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
RS([Bn()], Cd.prototype, "uppgiftslamnare", 2);
Cd = RS([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], Cd);
const gQ = Et(Cd)
  , bQ = {
    class: "col-12"
}
  , yQ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , kQ = c("legend", {
    class: "legend"
}, "Utdelningsförslaget avser", -1)
  , _Q = {
    class: "row"
}
  , wQ = {
    class: "col-sm-6"
}
  , xQ = {
    class: "col-sm-6"
}
  , SQ = {
    class: "row"
}
  , $Q = {
    class: "col-sm-6"
}
  , TQ = {
    class: "col-sm-6"
}
  , CQ = {
    class: "row"
}
  , EQ = {
    class: "col-sm-6"
}
  , AQ = {
    class: "col-sm-6"
}
  , MQ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , OQ = c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1)
  , NQ = {
    class: "row"
}
  , DQ = {
    class: "col-sm-12"
};
function PQ(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", bQ, [c("fieldset", yQ, [kQ, c("div", _Q, [c("div", wQ, [x(o, {
        label: "Företagsnamn eller personnamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.objNamn = f),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", xQ, [x(o, {
        label: "Organisations- eller personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.objNr = f),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", SQ, [c("div", $Q, [x(o, {
        label: "Med företagsnamn (vid enskild näringsidkare)",
        "label-for": "objNamnF"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamnF,
            "onUpdate:modelValue": e[2] || (e[2] = f => t.objNamnF = f),
            id: "objNamnF"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", TQ, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.objOrt = f),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("div", CQ, [c("div", EQ, [x(o, {
        label: "Senaste invändningsdatum",
        "label-for": "invändningsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.invändningsDatum,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.invändningsDatum = f),
            id: "invändningsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", AQ, [x(o, {
        label: "Senaste klandringsdatum",
        "label-for": "klandringsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.klandringsDatum,
            "onUpdate:modelValue": e[5] || (e[5] = f => t.klandringsDatum = f),
            id: "klandringsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })])]), c("fieldset", MQ, [OQ, x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[6] || (e[6] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    }), c("div", NQ, [c("div", DQ, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[7] || (e[7] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const FQ = rt(gQ, [["render", PQ]]);
var BQ = Object.defineProperty
  , VQ = Object.getOwnPropertyDescriptor
  , Nc = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? VQ(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && BQ(e, n, a),
    a
}
;
let wi = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "kungorelsetyp");
        V(this, "underrubrik");
        V(this, "frnNr", "");
        V(this, "frnNamn", "");
        V(this, "frnCO", "");
        V(this, "frnAdress", "");
        V(this, "frnPostNr", "");
        V(this, "frnOrt", "");
        V(this, "tillNr", "");
        V(this, "tillNamn", "");
        V(this, "tillCO", "");
        V(this, "tillAdress", "");
        V(this, "tillPostNr", "");
        V(this, "tillOrt", "");
        V(this, "ingivningsdatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck1() {
        return !this.inputChk && this.frnNamn.length == 0 ? null : this.frnNamn.length != 0
    }
    objNamnCheck2() {
        return !this.inputChk && this.tillNamn.length == 0 ? null : this.tillNamn.length != 0
    }
    personOrgnummerGiltigt1() {
        return Ht(this.frnNr)
    }
    personOrgnummerGiltigt2() {
        return Ht(this.tillNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.frnNr = qn(this.clS(this.frnNr)),
        this.frnNamn = this.clS(this.frnNamn),
        this.frnCO = this.clS(this.frnCO),
        this.frnAdress = this.clS(this.frnAdress),
        this.frnPostNr = this.clS(this.frnPostNr),
        this.frnOrt = this.clS(this.frnOrt),
        this.tillNr = qn(this.clS(this.tillNr)),
        this.tillNamn = this.clS(this.tillNamn),
        this.tillCO = this.clS(this.tillCO),
        this.tillAdress = this.clS(this.tillAdress),
        this.tillPostNr = this.clS(this.tillPostNr),
        this.tillOrt = this.clS(this.tillOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        return this.underrubrik.externKod == "BODELANM" ? (r += this.frnNamn,
        (this.frnCO != this.tillCO || this.frnAdress != this.tillAdress || this.frnPostNr != this.tillPostNr || this.frnOrt != this.tillOrt) && (this.frnCO != "" && (r += ", c/o " + this.frnCO),
        this.frnAdress != "" && (r += ", " + this.frnAdress),
        this.frnPostNr != "" && (r += ", " + this.frnPostNr),
        this.frnOrt != "" && (r += ", " + this.frnOrt)),
        r.charAt(r.length - 1) != " " && (r += " "),
        r += "och ",
        r += this.tillNamn + ", ",
        this.tillCO != "" && (r += "c/o " + this.tillCO + ", "),
        this.tillAdress != "" && (r += this.tillAdress + ", "),
        this.tillPostNr != "" && (r += this.tillPostNr + ", "),
        this.tillOrt != "" && (r += this.tillOrt + ", "),
        r += "har ",
        this.ingivningsdatum && (r += this.ingivningsdatum + " "),
        r += "till " + this.uppgiftslamnare.namn + " anmält att de avser förrätta bodelning under äktenskapet.") : this.underrubrik.externKod == "BODELING" ? (r += "Bodelningshandlingar för ",
        r += this.frnNamn,
        (this.frnCO != this.tillCO || this.frnAdress != this.tillAdress || this.frnPostNr != this.tillPostNr || this.frnOrt != this.tillOrt) && (this.frnCO != "" && (r += ", c/o " + this.frnCO),
        this.frnAdress && this.frnAdress != "" && (r += ", " + this.frnAdress),
        this.frnPostNr != "" && (r += ", " + this.frnPostNr),
        this.frnOrt != "" && (r += ", " + this.frnOrt)),
        r.charAt(r.length - 1) != " " && (r += " "),
        r += "och ",
        r += this.tillNamn + ", ",
        this.tillCO != "" && (r += "c/o " + this.tillCO + ", "),
        this.tillAdress && this.tillAdress != "" && (r += this.tillAdress + ", "),
        this.tillPostNr != "" && (r += this.tillPostNr + ", "),
        this.tillOrt != "" && (r += this.tillOrt + ", "),
        r += "har ",
        this.ingivningsdatum && (r += this.ingivningsdatum + " "),
        r += "ingivits till " + this.uppgiftslamnare.namn + ".") : (r += "Gåva mellan makar har registrerats hos " + this.uppgiftslamnare.namn + " avseende gåva från ",
        r += this.frnNamn,
        (this.frnCO != this.tillCO || this.frnAdress != this.tillAdress || this.frnPostNr != this.tillPostNr || this.frnOrt != this.tillOrt) && (this.frnCO != "" && (r += ", c/o " + this.frnCO),
        this.frnAdress && this.frnAdress != "" && (r += ", " + this.frnAdress),
        this.frnPostNr != "" && (r += ", " + this.frnPostNr),
        this.frnOrt != "" && (r += ", " + this.frnOrt)),
        r.charAt(r.length - 1) != " " && (r += " "),
        r += "till ",
        r += this.tillNamn,
        this.tillCO != "" && (r += ", c/o " + this.tillCO),
        this.tillAdress && this.tillAdress != "" && (r += ", " + this.tillAdress),
        this.tillPostNr != "" && (r += ", " + this.tillPostNr),
        this.tillOrt != "" && (r += ", " + this.tillOrt),
        r += ". ",
        this.ingivningsdatum && (r += "Ingivningsdag " + this.ingivningsdatum + ". ")),
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.ingivningsdatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.frnNamn,
            nummer: this.frnNr
        }, {
            namn: this.tillNamn,
            nummer: this.tillNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.frnNamn == "" && (this.felMeddelande += "• Namn för första personen måste fyllas i.<br>"),
        this.tillNamn == "" && (this.felMeddelande += "• Namn för andra personen måste fyllas i.<br>"),
        this.frnNr != "" && !Ht(this.frnNr) && (this.felMeddelande += "• Felaktigt personnummer för första personen.<br>"),
        this.tillNr != "" && !Ht(this.tillNr) && (this.felMeddelande += "• Felaktigt personnummer för andra personen.<br>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.frnNr = "",
        this.frnNamn = "",
        this.frnCO = "",
        this.frnAdress = "",
        this.frnPostNr = "",
        this.frnOrt = "",
        this.tillNr = "",
        this.tillNamn = "",
        this.tillCO = "",
        this.tillAdress = "",
        this.tillPostNr = "",
        this.tillOrt = "",
        this.ingivningsdatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
Nc([Bn()], wi.prototype, "uppgiftslamnare", 2);
Nc([Bn()], wi.prototype, "kungorelsetyp", 2);
Nc([Bn()], wi.prototype, "underrubrik", 2);
wi = Nc([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], wi);
const IQ = Et(wi)
  , RQ = {
    class: "col-12"
}
  , LQ = {
    class: "row"
}
  , jQ = {
    class: "col-12 col-lg-6"
}
  , UQ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , HQ = {
    key: 0,
    class: "legend"
}
  , KQ = {
    key: 1,
    class: "legend"
}
  , zQ = {
    class: "row"
}
  , qQ = {
    class: "col-sm-12"
}
  , WQ = {
    class: "col-sm-12"
}
  , GQ = {
    class: "row"
}
  , YQ = {
    class: "col-sm-12"
}
  , JQ = {
    class: "col-sm-12"
}
  , XQ = {
    class: "row"
}
  , QQ = {
    class: "col-sm-12"
}
  , ZQ = {
    class: "col-sm-12"
}
  , eZ = {
    class: "col-12 col-lg-6"
}
  , tZ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , nZ = {
    key: 0,
    class: "legend"
}
  , rZ = {
    key: 1,
    class: "legend"
}
  , aZ = {
    class: "row"
}
  , sZ = {
    class: "col-sm-12"
}
  , lZ = {
    class: "col-sm-12"
}
  , iZ = {
    class: "row"
}
  , oZ = {
    class: "col-sm-12"
}
  , uZ = {
    class: "col-sm-12"
}
  , dZ = {
    class: "row"
}
  , cZ = {
    class: "col-sm-12"
}
  , fZ = {
    class: "col-sm-12"
}
  , pZ = {
    class: "row"
}
  , hZ = {
    class: "col-12"
}
  , mZ = {
    class: "mb-3 blv-fieldset mt-2"
}
  , vZ = c("legend", {
    class: "legend"
}, "Datum och referens", -1)
  , gZ = {
    class: "row"
}
  , bZ = {
    class: "col-12 col-md-6"
}
  , yZ = {
    class: "col-12 col-md-6"
}
  , kZ = {
    class: "row"
}
  , _Z = {
    class: "col-12"
}
  , wZ = {
    class: "row"
}
  , xZ = {
    class: "col-12"
};
function SZ(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", RQ, [c("div", LQ, [c("div", jQ, [c("fieldset", UQ, [t.underrubrik.externKod != "BODELANM" && t.underrubrik.externKod != "BODELING" ? (g(),
    _("legend", HQ, " Gåva från ")) : (g(),
    _("legend", KQ, "Personuppgifter")), c("div", zQ, [c("div", qQ, [x(o, {
        label: "Förnamn och efternamn *",
        "label-for": "frnNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.frnNamn = f),
            id: "frnNamn",
            state: t.objNamnCheck1()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", WQ, [x(o, {
        label: "Personnummer",
        "label-for": "frnNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.frnNr = f),
            id: "frnNr",
            state: t.personOrgnummerGiltigt1()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", GQ, [c("div", YQ, [x(o, {
        label: "C/o",
        "label-for": "frnCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnCO,
            "onUpdate:modelValue": e[2] || (e[2] = f => t.frnCO = f),
            id: "frnCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", JQ, [x(o, {
        label: "Adress",
        "label-for": "frnAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnAdress,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.frnAdress = f),
            id: "frnAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", XQ, [c("div", QQ, [x(o, {
        label: "Postnummer",
        "label-for": "frnPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnPostNr,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.frnPostNr = f),
            id: "frnPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", ZQ, [x(o, {
        label: "Postort",
        "label-for": "frnOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.frnOrt,
            "onUpdate:modelValue": e[5] || (e[5] = f => t.frnOrt = f),
            id: "frnOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])])]), c("div", eZ, [c("fieldset", tZ, [t.underrubrik.externKod != "BODELANM" && t.underrubrik.externKod != "BODELING" ? (g(),
    _("legend", nZ, " Gåva till ")) : (g(),
    _("legend", rZ, "Personuppgifter")), c("div", aZ, [c("div", sZ, [x(o, {
        label: "Förnamn och efternamn *",
        "label-for": "tillNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillNamn,
            "onUpdate:modelValue": e[6] || (e[6] = f => t.tillNamn = f),
            id: "tillNamn",
            state: t.objNamnCheck2()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback3"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", lZ, [x(o, {
        label: "Personnummer",
        "label-for": "tillNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillNr,
            "onUpdate:modelValue": e[7] || (e[7] = f => t.tillNr = f),
            id: "tillNr",
            state: t.personOrgnummerGiltigt2()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback4"
        }, {
            default: N( () => [ve("Ange person/orgnummer i format NNNNNN-NNNN")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", iZ, [c("div", oZ, [x(o, {
        label: "C/o",
        "label-for": "tillCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillCO,
            "onUpdate:modelValue": e[8] || (e[8] = f => t.tillCO = f),
            id: "tillCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", uZ, [x(o, {
        label: "Adress",
        "label-for": "tillAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillAdress,
            "onUpdate:modelValue": e[9] || (e[9] = f => t.tillAdress = f),
            id: "tillAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", dZ, [c("div", cZ, [x(o, {
        label: "Postnummer",
        "label-for": "tillPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillPostNr,
            "onUpdate:modelValue": e[10] || (e[10] = f => t.tillPostNr = f),
            id: "tillPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", fZ, [x(o, {
        label: "Postort",
        "label-for": "tillOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.tillOrt,
            "onUpdate:modelValue": e[11] || (e[11] = f => t.tillOrt = f),
            id: "tillOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])])])]), c("div", pZ, [c("div", hZ, [c("fieldset", mZ, [vZ, c("div", gZ, [c("div", bZ, [x(o, {
        label: "Ingivningsdatum",
        "label-for": "ingivningsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.ingivningsdatum,
            "onUpdate:modelValue": e[12] || (e[12] = f => t.ingivningsdatum = f),
            id: "ingivningsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", yZ, [x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[13] || (e[13] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    })])])])])]), c("div", kZ, [c("div", _Z, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[14] || (e[14] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", wZ, [c("div", xZ, [t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])])])
}
const $Z = rt(IQ, [["render", SZ]]);
var TZ = Object.defineProperty
  , CZ = Object.getOwnPropertyDescriptor
  , LS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? CZ(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && TZ(e, n, a),
    a
}
;
let Ed = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "bevakningsDatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        return r += "I konkursen " + this.objNamn + ", " + this.objNr + " ska bevakningsförfarande äga rum. ",
        r += "De som vill bevaka fordringar och eventuellt göra gällande förmånsrätt ska ",
        this.bevakningsDatum && (r += "senast " + this.bevakningsDatum + " "),
        r += "göra det skriftligen hos ",
        r += this.uppgiftslamnare.namn + ", ",
        this.uppgiftslamnare.gatuAdress && this.uppgiftslamnare.gatuAdress != "" && (r += this.uppgiftslamnare.gatuAdress + " "),
        r += this.uppgiftslamnare.postnummer + " ",
        r += this.uppgiftslamnare.postort + ".",
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.bevakningsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        this.felMeddelande != "" ? !1 : (this.felMeddelande = "",
        !0)
    }
    rensaFormular() {
        this.objNamn = "",
        this.objNr = "",
        this.bevakningsDatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
    created() {}
    mounted() {}
}
;
LS([Bn()], Ed.prototype, "uppgiftslamnare", 2);
Ed = LS([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], Ed);
const EZ = Et(Ed);
const Dc = t => ($t("data-v-d26fc0c8"),
t = t(),
Tt(),
t)
  , AZ = {
    class: "col-12"
}
  , MZ = Dc( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col-sm-12"
}, [c("legend", {
    class: "legend"
}, "Bevakningsförfarandet avser")])], -1))
  , OZ = {
    class: "row"
}
  , NZ = {
    class: "col-12 col-md-6"
}
  , DZ = {
    class: "col-12 col-md-6"
}
  , PZ = {
    class: "row"
}
  , FZ = {
    class: "col-12 col-md-6"
}
  , BZ = Dc( () => c("label", {
    for: "bevakningsDatum"
}, "Senaste bevakningsdatum", -1))
  , VZ = Dc( () => c("br", null, null, -1))
  , IZ = {
    class: "mb-3 blv-fieldset mt-4"
}
  , RZ = Dc( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , LZ = {
    class: "row"
}
  , jZ = {
    class: "col-12"
}
  , UZ = {
    class: "row"
}
  , HZ = {
    class: "col-12"
};
function KZ(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", AZ, [MZ, c("div", OZ, [c("div", NZ, [x(o, {
        label: "Företagsnamn eller personnamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.objNamn = f),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", DZ, [x(o, {
        label: "Organisations- eller personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.objNr = f),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", PZ, [c("div", FZ, [BZ, VZ, x(u, {
        modelValue: t.bevakningsDatum,
        "onUpdate:modelValue": e[2] || (e[2] = f => t.bevakningsDatum = f),
        id: "bevakningsDatum",
        placeholder: "",
        "week-start": "1",
        "enable-time-picker": !1,
        locale: "sv",
        "select-text": "Välj",
        "cancel-text": "Avbryt",
        format: t.formateraDatum,
        clearable: "",
        "auto-apply": "",
        "input-class-name": "form-control",
        "model-type": "yyyy-MM-dd"
    }, null, 8, ["modelValue", "format"])])]), c("fieldset", IZ, [RZ, c("div", LZ, [c("div", jZ, [x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    })])]), c("div", UZ, [c("div", HZ, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const zZ = rt(EZ, [["render", KZ], ["__scopeId", "data-v-d26fc0c8"]]);
var qZ = Object.defineProperty
  , WZ = Object.getOwnPropertyDescriptor
  , jS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? WZ(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && qZ(e, n, a),
    a
}
;
let Ad = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "editor", null);
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objNamnF", "");
        V(this, "objOrt", "");
        V(this, "invändningsDatum", "");
        V(this, "klandringsDatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get sokparametrar() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objNamnF = this.clS(this.objNamnF),
        this.objOrt = this.clS(this.objOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        return r += "I konkursen " + this.objNamn,
        this.objNr != "" && (r += ", " + this.objNr),
        this.objNamnF != "" && (r += ", med företagsnamn " + this.objNamnF),
        this.objOrt != "" && (r += ", " + this.objOrt),
        r += ", har upprättats efterutdelningsförslag och förvaltningsredogörelse samt slutredovisning och tillsynsmyndighetens utlåtande däröver. ",
        r += "Handlingarna hålls tillgängliga hos rätten och tillsynsmyndigheten för den som vill ta del av dem. Invändning mot efterutdelningsförslaget kan göras ",
        this.invändningsDatum && (r += "senast " + this.invändningsDatum + " "),
        r += "hos ",
        r += this.uppgiftslamnare.namn + ", ",
        this.uppgiftslamnare.gatuAdress && this.uppgiftslamnare.gatuAdress != "" && (r += this.uppgiftslamnare.gatuAdress + " "),
        r += this.uppgiftslamnare.postnummer + " ",
        r += this.uppgiftslamnare.postort + ". ",
        r += "Slutredovisningen kan klandras genom att talan mot förvaltaren väcks vid samma tingsrätt senast",
        this.klandringsDatum && (r += " " + this.klandringsDatum),
        r += ".",
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.invändningsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objNamnF = "",
        this.objOrt = "",
        this.invändningsDatum = "",
        this.klandringsDatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
jS([Bn()], Ad.prototype, "uppgiftslamnare", 2);
Ad = jS([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], Ad);
const GZ = Et(Ad);
const US = t => ($t("data-v-9aaaa8fa"),
t = t(),
Tt(),
t)
  , YZ = {
    class: "col-12"
}
  , JZ = US( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col-sm-12"
}, [c("legend", {
    class: "legend"
}, "Efterutdelningsförslaget avser")])], -1))
  , XZ = {
    class: "row"
}
  , QZ = {
    class: "col-sm-6"
}
  , ZZ = {
    class: "col-sm-6"
}
  , eee = {
    class: "row"
}
  , tee = {
    class: "col-sm-6"
}
  , nee = {
    class: "col-sm-6"
}
  , ree = {
    class: "row"
}
  , aee = {
    class: "col-sm-6"
}
  , see = {
    class: "col-sm-6"
}
  , lee = {
    class: "mb-3 blv-fieldset mt-2"
}
  , iee = US( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , oee = {
    class: "row"
}
  , uee = {
    class: "col-sm-12"
};
function dee(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", YZ, [JZ, c("div", XZ, [c("div", QZ, [x(o, {
        label: "Företagsnamn eller personnamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.objNamn = f),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", ZZ, [x(o, {
        label: "Organisations- eller personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.objNr = f),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", eee, [c("div", tee, [x(o, {
        label: "Med företagsnamn (vid enskild näringsidkare)",
        "label-for": "objNamnF"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamnF,
            "onUpdate:modelValue": e[2] || (e[2] = f => t.objNamnF = f),
            id: "objNamnF"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", nee, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.objOrt = f),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", ree, [c("div", aee, [x(o, {
        label: "Senaste invändningsdatum",
        "label-for": "invändningsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.invändningsDatum,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.invändningsDatum = f),
            id: "invändningsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", see, [x(o, {
        label: "Senaste klandringsdatum",
        "label-for": "klandringsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.klandringsDatum,
            "onUpdate:modelValue": e[5] || (e[5] = f => t.klandringsDatum = f),
            id: "klandringsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })])]), c("fieldset", lee, [iee, x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[6] || (e[6] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    }), c("div", oee, [c("div", uee, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[7] || (e[7] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const cee = rt(GZ, [["render", dee], ["__scopeId", "data-v-9aaaa8fa"]]);
var fee = Object.defineProperty
  , pee = Object.getOwnPropertyDescriptor
  , kv = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? pee(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && fee(e, n, a),
    a
}
;
let Lo = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "underrubrik");
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objCO", "");
        V(this, "objAdress", "");
        V(this, "objPostNr", "");
        V(this, "objOrt", "");
        V(this, "beslutsDatum", "");
        V(this, "interimistisktBeslut", !1);
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        var a, s;
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objCO = this.clS(this.objCO),
        this.objAdress = this.clS(this.objAdress),
        this.objPostNr = this.clS(this.objPostNr),
        this.objOrt = this.clS(this.objOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        switch (r += this.uppgiftslamnare.namn + " har " + this.beslutsDatum + " beslutat om ",
        (a = this.underrubrik) == null ? void 0 : a.externKod) {
        case "ANBEGRGOD":
            r += "anordnande av begränsat förvaltarskap ";
            break;
        case "ANFORV":
            r += "anordnande av förvaltarskap ";
            break;
        case "ANGODM":
            r += "anordnande av godmanskap ";
            break;
        case "ANUTFORV":
            r += "anordnande av utökat förvaltarskap ";
            break;
        case "JAMKFORV":
            r += "jämkning av förvaltarskap ";
            break;
        case "UPPFORV":
            r += "upphörande av förvaltarskap ";
            break
        }
        return r += "enligt föräldrabalken för " + this.objNamn,
        this.objNr != "" && (r += ", " + this.objNr),
        this.objCO != "" && (r += ", c/o " + this.objCO),
        this.objAdress && this.objAdress != "" && (r += ", " + this.objAdress),
        this.objPostNr != "" && (r += ", " + this.objPostNr),
        this.objOrt != "" && (r += ", " + this.objOrt),
        r.charAt(r.length - 1) == " " ? r = r.substring(0, r.length - 1) : r += ". ",
        ((s = this.underrubrik) == null ? void 0 : s.externKod) == "ANBEGRGOD" && (r += "Förvaltarskapet omfattar endast viss egendom eller vissa angelägenheter. "),
        this.interimistisktBeslut && (r += "Beslutet är interimistiskt. "),
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.beslutsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" ? (this.felMeddelande += "• Namn måste fyllas i.<br>",
        !1) : this.objNr != "" && !Ht(this.objNr) ? (this.felMeddelande += "• Felaktigt personnummer.<br>",
        !1) : !0
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objCO = "",
        this.objAdress = "",
        this.objPostNr = "",
        this.objOrt = "",
        this.beslutsDatum = "",
        this.interimistisktBeslut = !1,
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
kv([Bn()], Lo.prototype, "uppgiftslamnare", 2);
kv([Bn()], Lo.prototype, "underrubrik", 2);
Lo = kv([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        BFormCheckbox: $s,
        VueDatePicker: Ur
    }
})], Lo);
const hee = Et(Lo);
const HS = t => ($t("data-v-20063442"),
t = t(),
Tt(),
t)
  , mee = {
    class: "col-12"
}
  , vee = {
    class: "mb-3 blv-fieldset"
}
  , gee = HS( () => c("legend", {
    class: "legend"
}, "Beslutet om förvaltarskap avser", -1))
  , bee = {
    class: "row"
}
  , yee = {
    class: "col-sm-6"
}
  , kee = {
    class: "col-sm-6"
}
  , _ee = {
    class: "row"
}
  , wee = {
    class: "col-sm-6"
}
  , xee = {
    class: "col-sm-6"
}
  , See = {
    class: "row"
}
  , $ee = {
    class: "col-sm-6"
}
  , Tee = {
    class: "col-sm-6"
}
  , Cee = {
    class: "row align-items-end"
}
  , Eee = {
    class: "col-12 col-md-6"
}
  , Aee = {
    class: "col-sm-6"
}
  , Mee = {
    class: "mb-3 blv-fieldset mt-2"
}
  , Oee = HS( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , Nee = {
    class: "row"
}
  , Dee = {
    class: "col-12"
}
  , Pee = {
    class: "row"
}
  , Fee = {
    class: "col-sm-12"
};
function Bee(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("b-form-checkbox")
      , f = ue("meddelande");
    return g(),
    _("div", mee, [c("fieldset", vee, [gee, c("div", bee, [c("div", yee, [x(o, {
        label: "Förnamn och efternamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = p => t.objNamn = p),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", kee, [x(o, {
        label: "Personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = p => t.objNr = p),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", _ee, [c("div", wee, [x(o, {
        label: "C/o",
        "label-for": "objCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objCO,
            "onUpdate:modelValue": e[2] || (e[2] = p => t.objCO = p),
            id: "objCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", xee, [x(o, {
        label: "Adress",
        "label-for": "objAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objAdress,
            "onUpdate:modelValue": e[3] || (e[3] = p => t.objAdress = p),
            id: "objAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", See, [c("div", $ee, [x(o, {
        label: "Postnummer",
        "label-for": "objPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objPostNr,
            "onUpdate:modelValue": e[4] || (e[4] = p => t.objPostNr = p),
            id: "objPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", Tee, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[5] || (e[5] = p => t.objOrt = p),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", Cee, [c("div", Eee, [x(o, {
        label: "Beslutsdatum",
        "label-for": "beslutsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.beslutsDatum,
            "onUpdate:modelValue": e[6] || (e[6] = p => t.beslutsDatum = p),
            id: "beslutsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", Aee, [x(d, {
        class: "mb-3 pb-2",
        id: "interimistisktBeslut",
        modelValue: t.interimistisktBeslut,
        "onUpdate:modelValue": e[7] || (e[7] = p => t.interimistisktBeslut = p),
        name: "interimistisktBeslut"
    }, {
        default: N( () => [ve(" Interimistiskt beslut ")]),
        _: 1
    }, 8, ["modelValue"])])])]), c("fieldset", Mee, [Oee, c("div", Nee, [c("div", Dee, [x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[8] || (e[8] = p => t.publiceringsdatum = p),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    })])]), c("div", Pee, [c("div", Fee, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[9] || (e[9] = p => t.fakturareferens = p),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(f, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const Vee = rt(hee, [["render", Bee], ["__scopeId", "data-v-20063442"]]);
var Iee = Object.defineProperty
  , Ree = Object.getOwnPropertyDescriptor
  , _v = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Ree(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Iee(e, n, a),
    a
}
;
let jo = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "underrubrik");
        V(this, "editor", null);
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objCO", "");
        V(this, "objAdress", "");
        V(this, "objPostNr", "");
        V(this, "objOrt", "");
        V(this, "beslutsDatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objCO = this.clS(this.objCO),
        this.objAdress = this.clS(this.objAdress),
        this.objPostNr = this.clS(this.objPostNr),
        this.objOrt = this.clS(this.objOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "";
        switch (this.underrubrik.externKod) {
        case "SKULDSANINLPRI":
            r += "Kronofogdemyndigheten har ",
            this.beslutsDatum && (r += this.beslutsDatum + " "),
            r += "beslutat att inleda skuldsanering för " + this.objNamn,
            this.objNr && (r += ", " + this.objNr),
            this.objCO && (r += ", c/o " + this.objCO),
            this.objAdress && (r += ", " + this.objAdress),
            this.objPostNr && (r += ", " + this.objPostNr),
            this.objOrt && (r += ", " + this.objOrt),
            r += ". Var och en som har en fordran mot " + this.objNamn + " uppmanas att inom en månad från det att denna kungörelse införts skriftligen anmäla sin fordran. ",
            r += "Fordringsanmälan ska innehålla uppgifter om kapitalbelopp, räntesats, avgifter och upplupen ränta, uppkomstdatum, eventuell säkerhet och solidariskt betalningsansvar. ",
            r += "Uppge även uppgifter som ni anser kan ha betydelse för prövningen av ärendet. Uppge till vilket konto som betalning ska ske. Ni ska skicka anmälan till Kronofogdemyndigheten, Skuldsanering, 106 65 Stockholm. ",
            r += "Kronofogdemyndigheten upplyser om att betalningsansvaret för en fordran som inte anmäls kan falla bort från " + this.objNamn + ".";
            break;
        case "SKULDSANBESLPRI":
            r += this.uppgiftslamnare.namn + ", ",
            this.uppgiftslamnare.gatuAdress && (r += this.uppgiftslamnare.gatuAdress + ", "),
            this.uppgiftslamnare.coAdress && (r += this.uppgiftslamnare.coAdress + ", "),
            this.uppgiftslamnare.postnummer && (r += this.uppgiftslamnare.postnummer + ", "),
            this.uppgiftslamnare.postort && (r += this.uppgiftslamnare.postort + ", "),
            r += " har ",
            this.beslutsDatum && (r += this.beslutsDatum + ", "),
            r += " beslutat om skuldsanering för " + this.objNamn,
            this.objNr && (r += ", " + this.objNr),
            this.objCO && (r += ", c/o " + this.objCO),
            this.objAdress && (r += ", " + this.objAdress),
            this.objPostNr && (r += ", " + this.objPostNr),
            this.objOrt && (r += ", " + this.objOrt),
            r += ". ";
            break
        }
        return n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.typDatum = this.beslutsDatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objCO = "",
        this.objAdress = "",
        this.objPostNr = "",
        this.objOrt = "",
        this.beslutsDatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
_v([Bn()], jo.prototype, "uppgiftslamnare", 2);
_v([Bn()], jo.prototype, "underrubrik", 2);
jo = _v([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], jo);
const Lee = Et(jo);
const KS = t => ($t("data-v-a0b7d7ce"),
t = t(),
Tt(),
t)
  , jee = {
    class: "col-12"
}
  , Uee = {
    class: "mb-3 blv-fieldset"
}
  , Hee = KS( () => c("legend", {
    class: "legend"
}, "Skuldsaneringen avser", -1))
  , Kee = {
    class: "row"
}
  , zee = {
    class: "col-sm-6"
}
  , qee = {
    class: "col-sm-6"
}
  , Wee = {
    class: "row"
}
  , Gee = {
    class: "col-sm-6"
}
  , Yee = {
    class: "col-sm-6"
}
  , Jee = {
    class: "row"
}
  , Xee = {
    class: "col-sm-6"
}
  , Qee = {
    class: "col-sm-6"
}
  , Zee = {
    class: "mb-3 blv-fieldset mt-2"
}
  , ete = KS( () => c("legend", {
    class: "legend"
}, "Datum och referens", -1))
  , tte = {
    class: "row"
}
  , nte = {
    class: "col-12 col-md-6"
}
  , rte = {
    class: "col-12 col-md-6"
}
  , ate = {
    class: "row"
}
  , ste = {
    class: "col-sm-12"
};
function lte(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", jee, [c("fieldset", Uee, [Hee, c("div", Kee, [c("div", zee, [x(o, {
        label: "Förnamn och efternamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.objNamn = f),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", qee, [x(o, {
        label: "Personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.objNr = f),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", Wee, [c("div", Gee, [x(o, {
        label: "C/o",
        "label-for": "objCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objCO,
            "onUpdate:modelValue": e[2] || (e[2] = f => t.objCO = f),
            id: "objCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", Yee, [x(o, {
        label: "Adress",
        "label-for": "objAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objAdress,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.objAdress = f),
            id: "objAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", Jee, [c("div", Xee, [x(o, {
        label: "Postnummer",
        "label-for": "objPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objPostNr,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.objPostNr = f),
            id: "objPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", Qee, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[5] || (e[5] = f => t.objOrt = f),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("fieldset", Zee, [ete, c("div", tte, [c("div", nte, [x(o, {
        label: "Beslutsdatum",
        "label-for": "beslutsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.beslutsDatum,
            "onUpdate:modelValue": e[6] || (e[6] = f => t.beslutsDatum = f),
            id: "beslutsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })]), c("div", rte, [x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[7] || (e[7] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    })])]), c("div", ate, [c("div", ste, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[8] || (e[8] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const ite = rt(Lee, [["render", lte], ["__scopeId", "data-v-a0b7d7ce"]]);
var ote = Object.defineProperty
  , ute = Object.getOwnPropertyDescriptor
  , zS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? ute(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && ote(e, n, a),
    a
}
;
let Md = class extends Fa {
    constructor() {
        super(...arguments);
        V(this, "uppgiftslamnare");
        V(this, "objNr", "");
        V(this, "objNamn", "");
        V(this, "objCO", "");
        V(this, "objAdress", "");
        V(this, "objPostNr", "");
        V(this, "objOrt", "");
        V(this, "likvNamn", "");
        V(this, "likvCO", "");
        V(this, "likvAdress", "");
        V(this, "likvPostNr", "");
        V(this, "likvOrt", "");
        V(this, "anmalningsDatum", "");
        V(this, "fakturareferens", "");
        V(this, "publiceringsdatum", "");
        V(this, "felMeddelande", "");
        V(this, "inputChk", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    get getAktivKungorelsetyp() {
        return Pe().getAktivKungorelsetyp
    }
    formateraDatum(n) {
        return Da(n)
    }
    objNamnCheck() {
        return !this.inputChk && this.objNamn.length == 0 ? null : this.objNamn.length != 0
    }
    personOrgnummerGiltigt() {
        return Ht(this.objNr)
    }
    getMinDate() {
        var n = new Date;
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        for (n.setDate(n.getDate() + 1); Mt(n); )
            n.setDate(n.getDate() + 1);
        return n.toLocaleDateString("sv-SE")
    }
    isDayDisabled(n) {
        return Mt(n)
    }
    mapToKungorelse(n) {
        this.objNr = qn(this.clS(this.objNr)),
        this.objNamn = this.clS(this.objNamn),
        this.objCO = this.clS(this.objCO),
        this.objAdress = this.clS(this.objAdress),
        this.objPostNr = this.clS(this.objPostNr),
        this.objOrt = this.clS(this.objOrt),
        this.likvNamn = this.clS(this.likvNamn),
        this.likvCO = this.clS(this.likvCO),
        this.likvAdress = this.clS(this.likvAdress),
        this.likvPostNr = this.clS(this.likvPostNr),
        this.likvOrt = this.clS(this.likvOrt),
        this.fakturareferens = this.clS(this.fakturareferens);
        var r = "Okända borgenärer hos ";
        return r += this.objNamn,
        this.objNr && (r += ", " + this.objNr),
        this.objCO != "" && (r += ", c/o " + this.objCO),
        this.objAdress && this.objAdress != "" && (r += ", " + this.objAdress),
        this.objPostNr != "" && (r += ", " + this.objPostNr),
        this.objOrt != "" && (r += ", " + this.objOrt),
        this.likvNamn && (r += " med likvidator " + this.likvNamn,
        this.likvCO != "" && (r += ", c/o " + this.likvCO),
        this.likvAdress != "" && (r += ", " + this.likvAdress),
        this.likvPostNr != "" && (r += ", " + this.likvPostNr),
        this.likvOrt != "" && (r += " " + this.likvOrt)),
        r += ", kallas att",
        this.anmalningsDatum && (r += " senast " + this.anmalningsDatum),
        r += " skriftligen anmäla sina fordringar hos ",
        r += this.uppgiftslamnare.namn + ", ",
        this.uppgiftslamnare.gatuAdress && this.uppgiftslamnare.gatuAdress != "" && (r += this.uppgiftslamnare.gatuAdress + " "),
        r += this.uppgiftslamnare.postnummer + " ",
        r += this.uppgiftslamnare.postort + ".",
        n.kungorelseText = r,
        n.kontaktInfo = "",
        n.fakturaReferens = this.fakturareferens,
        n.publiceringsDatum = this.publiceringsdatum,
        n.fysiskaJuridiskaPersoner = [{
            namn: this.objNamn,
            nummer: this.objNr
        }],
        n
    }
    valideraFormular() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        this.objNamn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br>"),
        this.objNr != "" && !Ht(this.objNr) && (this.felMeddelande += "• Felaktigt personnummer.<br>"),
        this.felMeddelande == ""
    }
    rensaFormular() {
        this.objNr = "",
        this.objNamn = "",
        this.objCO = "",
        this.objAdress = "",
        this.objPostNr = "",
        this.objOrt = "",
        this.likvNamn = "",
        this.likvCO = "",
        this.likvAdress = "",
        this.likvPostNr = "",
        this.likvOrt = "",
        this.anmalningsDatum = "",
        this.fakturareferens = "",
        this.publiceringsdatum = "",
        this.felMeddelande = "",
        this.inputChk = !1
    }
}
;
zS([Bn()], Md.prototype, "uppgiftslamnare", 2);
Md = zS([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        VueDatePicker: Ur
    }
})], Md);
const dte = Et(Md);
const Pc = t => ($t("data-v-23acb481"),
t = t(),
Tt(),
t)
  , cte = {
    class: "col-12"
}
  , fte = Pc( () => c("br", null, null, -1))
  , pte = {
    class: "mb-3 blv-fieldset"
}
  , hte = Pc( () => c("legend", {
    class: "legend"
}, "Gäldenär", -1))
  , mte = {
    class: "row"
}
  , vte = {
    class: "col-sm-6"
}
  , gte = {
    class: "col-sm-6"
}
  , bte = {
    class: "row"
}
  , yte = {
    class: "col-sm-6"
}
  , kte = {
    class: "col-sm-6"
}
  , _te = {
    class: "row"
}
  , wte = {
    class: "col-sm-6"
}
  , xte = {
    class: "col-sm-6"
}
  , Ste = {
    class: "mb-3 blv-fieldset"
}
  , $te = Pc( () => c("legend", {
    class: "legend"
}, "Likvidator", -1))
  , Tte = {
    class: "row"
}
  , Cte = {
    class: "col-12"
}
  , Ete = {
    class: "row"
}
  , Ate = {
    class: "col-sm-6"
}
  , Mte = {
    class: "col-sm-6"
}
  , Ote = {
    class: "row"
}
  , Nte = {
    class: "col-sm-6"
}
  , Dte = {
    class: "col-sm-6"
}
  , Pte = {
    class: "row"
}
  , Fte = {
    class: "col-sm-6"
}
  , Bte = {
    class: "mb-3 blv-fieldset mt-4"
}
  , Vte = Pc( () => c("legend", {
    class: "legend"
}, "Publiceringsdatum och referens", -1))
  , Ite = {
    class: "row"
}
  , Rte = {
    class: "col-sm-12"
};
function Lte(t, e, n, r, a, s) {
    const l = ue("b-form-input")
      , i = ue("b-form-invalid-feedback")
      , o = ue("form-group")
      , u = ue("vue-date-picker")
      , d = ue("meddelande");
    return g(),
    _("div", cte, [fte, c("fieldset", pte, [hte, c("div", mte, [c("div", vte, [x(o, {
        label: "Företagsnamn eller personnamn *",
        "label-for": "objNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNamn,
            "onUpdate:modelValue": e[0] || (e[0] = f => t.objNamn = f),
            id: "objNamn",
            state: t.objNamnCheck()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback"
        }, {
            default: N( () => [ve("Namn måste fyllas i")]),
            _: 1
        })]),
        _: 1
    })]), c("div", gte, [x(o, {
        label: "Organisations- eller personnummer",
        "label-for": "objNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objNr,
            "onUpdate:modelValue": e[1] || (e[1] = f => t.objNr = f),
            id: "objNr",
            state: t.personOrgnummerGiltigt()
        }, null, 8, ["modelValue", "state"]), x(i, {
            id: "input-live-feedback2"
        }, {
            default: N( () => [ve("Ange personnummer i format ÅÅÅÅMMDD-XXXX")]),
            _: 1
        })]),
        _: 1
    })])]), c("div", bte, [c("div", yte, [x(o, {
        label: "C/o",
        "label-for": "objCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objCO,
            "onUpdate:modelValue": e[2] || (e[2] = f => t.objCO = f),
            id: "objCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", kte, [x(o, {
        label: "Adress",
        "label-for": "objAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objAdress,
            "onUpdate:modelValue": e[3] || (e[3] = f => t.objAdress = f),
            id: "objAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", _te, [c("div", wte, [x(o, {
        label: "Postnummer",
        "label-for": "objPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objPostNr,
            "onUpdate:modelValue": e[4] || (e[4] = f => t.objPostNr = f),
            id: "objPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", xte, [x(o, {
        label: "Postort",
        "label-for": "objOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.objOrt,
            "onUpdate:modelValue": e[5] || (e[5] = f => t.objOrt = f),
            id: "objOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("fieldset", Ste, [$te, c("div", Tte, [c("div", Cte, [x(o, {
        label: "Likvidators namn",
        "label-for": "likvNamn"
    }, {
        default: N( () => [x(l, {
            modelValue: t.likvNamn,
            "onUpdate:modelValue": e[6] || (e[6] = f => t.likvNamn = f),
            id: "likvNamn"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", Ete, [c("div", Ate, [x(o, {
        label: "C/o",
        "label-for": "likvCO"
    }, {
        default: N( () => [x(l, {
            modelValue: t.likvCO,
            "onUpdate:modelValue": e[7] || (e[7] = f => t.likvCO = f),
            id: "likvCO"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", Mte, [x(o, {
        label: "Adress",
        "label-for": "likvAdress"
    }, {
        default: N( () => [x(l, {
            modelValue: t.likvAdress,
            "onUpdate:modelValue": e[8] || (e[8] = f => t.likvAdress = f),
            id: "likvAdress"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])]), c("div", Ote, [c("div", Nte, [x(o, {
        label: "Postnummer",
        "label-for": "likvPostNr"
    }, {
        default: N( () => [x(l, {
            modelValue: t.likvPostNr,
            "onUpdate:modelValue": e[9] || (e[9] = f => t.likvPostNr = f),
            id: "likvPostNr"
        }, null, 8, ["modelValue"])]),
        _: 1
    })]), c("div", Dte, [x(o, {
        label: "Postort",
        "label-for": "likvOrt"
    }, {
        default: N( () => [x(l, {
            modelValue: t.likvOrt,
            "onUpdate:modelValue": e[10] || (e[10] = f => t.likvOrt = f),
            id: "likvOrt"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), c("div", Pte, [c("div", Fte, [x(o, {
        label: "Sista anmälningsdatum",
        "label-for": "anmalningsDatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.anmalningsDatum,
            "onUpdate:modelValue": e[11] || (e[11] = f => t.anmalningsDatum = f),
            id: "anmalningsDatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "format"])]),
        _: 1
    })])]), c("fieldset", Bte, [Vte, x(o, {
        label: "Önskat publiceringsdatum",
        "label-for": "publiceringsdatum"
    }, {
        default: N( () => [x(u, {
            modelValue: t.publiceringsdatum,
            "onUpdate:modelValue": e[12] || (e[12] = f => t.publiceringsdatum = f),
            "min-date": t.getMinDate(),
            "start-date": t.getMinDate(),
            "focus-start-date": "",
            "prevent-min-max-navigation": "",
            "disabled-dates": t.isDayDisabled,
            id: "publiceringsdatum",
            placeholder: "",
            "week-start": "1",
            "enable-time-picker": !1,
            locale: "sv",
            "select-text": "Välj",
            "cancel-text": "Avbryt",
            format: t.formateraDatum,
            clearable: "",
            "auto-apply": "",
            "input-class-name": "form-control",
            "model-type": "yyyy-MM-dd"
        }, null, 8, ["modelValue", "min-date", "start-date", "disabled-dates", "format"])]),
        _: 1
    }), c("div", Ite, [c("div", Rte, [x(o, {
        label: "Fakturareferens",
        "label-for": "fakturareferens"
    }, {
        default: N( () => [x(l, {
            modelValue: t.fakturareferens,
            "onUpdate:modelValue": e[13] || (e[13] = f => t.fakturareferens = f),
            id: "fakturareferens",
            maxlength: "25"
        }, null, 8, ["modelValue"])]),
        _: 1
    })])])]), t.felMeddelande != "" ? (g(),
    de(d, {
        key: 0,
        meddelande: t.felMeddelande,
        meddelandeTyp: "danger"
    }, null, 8, ["meddelande"])) : q("", !0)])
}
const jte = rt(dte, [["render", Lte], ["__scopeId", "data-v-23acb481"]])
  , Ute = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Hte = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456l-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"
}), c("path", {
    "fill-rule": "evenodd",
    d: "M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z"
})], -1)
  , Kte = [Hte];
function zte(t, e) {
    return g(),
    _("svg", Ute, [...Kte])
}
const qte = {
    name: "bi-pencil-square",
    render: zte
}
  , Wte = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Gte = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M11 6a3 3 0 1 1-6 0a3 3 0 0 1 6 0"
}), c("path", {
    d: "M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm12 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1v-1c0-1-1-4-6-4s-6 3-6 4v1a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1z"
})], -1)
  , Yte = [Gte];
function Jte(t, e) {
    return g(),
    _("svg", Wte, [...Yte])
}
const Xte = {
    name: "bi-person-square",
    render: Jte
}
  , Qte = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Zte = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M1.92.506a.5.5 0 0 1 .434.14L3 1.293l.646-.647a.5.5 0 0 1 .708 0L5 1.293l.646-.647a.5.5 0 0 1 .708 0L7 1.293l.646-.647a.5.5 0 0 1 .708 0L9 1.293l.646-.647a.5.5 0 0 1 .708 0l.646.647l.646-.647a.5.5 0 0 1 .708 0l.646.647l.646-.647a.5.5 0 0 1 .801.13l.5 1A.5.5 0 0 1 15 2v12a.5.5 0 0 1-.053.224l-.5 1a.5.5 0 0 1-.8.13L13 14.707l-.646.647a.5.5 0 0 1-.708 0L11 14.707l-.646.647a.5.5 0 0 1-.708 0L9 14.707l-.646.647a.5.5 0 0 1-.708 0L7 14.707l-.646.647a.5.5 0 0 1-.708 0L5 14.707l-.646.647a.5.5 0 0 1-.708 0L3 14.707l-.646.647a.5.5 0 0 1-.801-.13l-.5-1A.5.5 0 0 1 1 14V2a.5.5 0 0 1 .053-.224l.5-1a.5.5 0 0 1 .367-.27m.217 1.338L2 2.118v11.764l.137.274l.51-.51a.5.5 0 0 1 .707 0l.646.647l.646-.646a.5.5 0 0 1 .708 0l.646.646l.646-.646a.5.5 0 0 1 .708 0l.646.646l.646-.646a.5.5 0 0 1 .708 0l.646.646l.646-.646a.5.5 0 0 1 .708 0l.646.646l.646-.646a.5.5 0 0 1 .708 0l.509.509l.137-.274V2.118l-.137-.274l-.51.51a.5.5 0 0 1-.707 0L12 1.707l-.646.647a.5.5 0 0 1-.708 0L10 1.707l-.646.647a.5.5 0 0 1-.708 0L8 1.707l-.646.647a.5.5 0 0 1-.708 0L6 1.707l-.646.647a.5.5 0 0 1-.708 0L4 1.707l-.646.647a.5.5 0 0 1-.708 0z"
}), c("path", {
    d: "M3 4.5a.5.5 0 0 1 .5-.5h6a.5.5 0 1 1 0 1h-6a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h6a.5.5 0 1 1 0 1h-6a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h6a.5.5 0 1 1 0 1h-6a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5m8-6a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5m0 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 0 1h-1a.5.5 0 0 1-.5-.5"
})], -1)
  , ene = [Zte];
function tne(t, e) {
    return g(),
    _("svg", Qte, [...ene])
}
const qS = {
    name: "bi-receipt",
    render: tne
}
  , nne = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , rne = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M10.5 8a2.5 2.5 0 1 1-5 0a2.5 2.5 0 0 1 5 0"
}), c("path", {
    d: "M0 8s3-5.5 8-5.5S16 8 16 8s-3 5.5-8 5.5S0 8 0 8m8 3.5a3.5 3.5 0 1 0 0-7a3.5 3.5 0 0 0 0 7"
})], -1)
  , ane = [rne];
function sne(t, e) {
    return g(),
    _("svg", nne, [...ane])
}
const lne = {
    name: "bi-eye-fill",
    render: sne
};
var ine = Object.defineProperty
  , one = Object.getOwnPropertyDescriptor
  , une = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? one(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && ine(e, n, a),
    a
}
;
let xh = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "sida", 1);
        V(this, "aktivKungorelse", {});
        V(this, "valdUppgiftslamnare", {});
        V(this, "valdKungorelsetyp", {});
        V(this, "valdUnderrubrik", {});
        V(this, "kungorelsetyper", []);
        V(this, "underrubriker", [{
            beskrivning: "none",
            externKod: "none"
        }]);
        V(this, "kungorelser", []);
        V(this, "kvittoKungorelser", []);
        V(this, "kvittoTyp", {});
        V(this, "altFakt", !1);
        V(this, "altGata", "");
        V(this, "altCo", "");
        V(this, "altPostnr", "");
        V(this, "altOrt", "");
        V(this, "altLand", "Sverige");
        V(this, "skickar", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get lander() {
        return St().lander
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    formateraPersOrgNr(e) {
        return e && qn(e)
    }
    valjRubrik() {
        this.valdUnderrubrik = {},
        this.underrubriker = [{
            beskrivning: "none",
            externKod: "none"
        }],
        Pe().aktivKungorelsetyp = this.valdKungorelsetyp,
        this.aktivKungorelse.rubrikExternKod = this.valdKungorelsetyp.externKod,
        this.loadUnderrubriker()
    }
    taBort(e) {
        this.kungorelser.splice(e, 1)
    }
    forhandsGranska(e) {
        Pe().nyaKungorelser = this.kungorelser,
        Pe().aktivKungorelse = this.kungorelser[e],
        Pe().aktivUppgiftslamnare = this.valdUppgiftslamnare,
        this.$router.push({
            name: "granskakungorelse"
        })
    }
    getKungtextPreview(e) {
        var n = this.kungorelser[e].kungorelseText;
        return n = n.replaceAll("<br>", " "),
        n = n.replaceAll("<p>", " "),
        n = n.replaceAll("</p>", ""),
        n = n.replace(/<\/?[^>]+(>|$)/g, ""),
        n = n.replaceAll("&nbsp;", " "),
        n.substr(0, 22) + "..."
    }
    skicka() {
        if (!this.skickar) {
            this.skickar = !0,
            this.altFakt == !0 && (this.altGata == "" || this.altOrt == "") && (this.altFakt = !1);
            var e = 0
              , n = [];
            for (e = 0; e < this.kungorelser.length; e++) {
                var r = 0
                  , a = [];
                for (r = 0; r < this.kungorelser[e].fysiskaJuridiskaPersoner.length; r++) {
                    var s = {};
                    s.namn = this.kungorelser[e].fysiskaJuridiskaPersoner[r].namn.replaceAll("	", " ").trim(),
                    s.nummer = this.kungorelser[e].fysiskaJuridiskaPersoner[r].nummer != null ? this.kungorelser[e].fysiskaJuridiskaPersoner[r].nummer.replaceAll("-", "") : this.kungorelser[e].fysiskaJuridiskaPersoner[r].nummer,
                    a.push(s)
                }
                var l = {
                    kundAnvandareId: this.kungorelser[e].kundAnvandareId,
                    kundNummer: this.kungorelser[e].kundNummer,
                    rubrikExternKod: this.kungorelser[e].rubrikExternKod,
                    underrubrikExternKod: this.kungorelser[e].underrubrikExternKod,
                    kontaktInfo: this.kungorelser[e].kontaktInfo,
                    fakturaReferens: this.kungorelser[e].fakturaReferens,
                    kungorelseText: this.kungorelser[e].kungorelseText,
                    publiceringsDatum: this.kungorelser[e].publiceringsDatum,
                    typDatum: this.kungorelser[e].typDatum,
                    fysiskaJuridiskaPersoner: a,
                    lan: this.kungorelser[e].lan,
                    altFakturering: this.altFakt,
                    altFaktureringsAdress: this.altGata,
                    altFaktureringsCoAdress: this.altCo,
                    altFaktureringsPostNr: this.altPostnr,
                    altFaktureringsPostOrt: this.altOrt,
                    altFaktureringsLand: this.altLand
                };
                n.push(l)
            }
            Pe().registreraKungorelser(n).then(i => {
                Pe().nyaKungorelser = [],
                this.kungorelser = [],
                this.sida++,
                this.skickar = !1,
                this.altFakt = !1,
                this.kvittoKungorelser = JSON.parse(JSON.stringify(i))
            }
            )
        }
    }
    kvittoOK() {
        if (this.kvittoKungorelser.length == 0)
            return !1;
        for (var e = 0; e < this.kvittoKungorelser.length; e++)
            if (!this.kvittoKungorelser[e].kungorelseid || this.kvittoKungorelser[e].kungorelseid == "")
                return !1;
        return !0
    }
    print() {
        window.print()
    }
    loadRubriker() {
        this.valdKungorelsetyp = {},
        Pe().getKungorelsetyper(this.valdUppgiftslamnare.kundnummer).then( () => {
            this.kungorelsetyper = Pe().kungorelsetyper
        }
        )
    }
    loadUnderrubriker() {
        Pe().getUnderrubriker(this.valdKungorelsetyp.externKod).then( () => {
            this.underrubriker = Pe().underrubriker
        }
        )
    }
    foregaende() {
        this.$router.go(-1)
    }
    isKundSparrad() {
        return this.valdUppgiftslamnare.kundstatus == "Avslutad p.g.a. bolagsstatus" || this.valdUppgiftslamnare.kundstatus == "Avslutad"
    }
    skapaKungorelse() {
        var e = {};
        return e.kundAnvandareId = this.kundanvandare.id,
        e.kundNummer = this.valdUppgiftslamnare.kundnummer,
        e.uppgiftslamnare = this.valdUppgiftslamnare.namn,
        e.rubrikExternKod = this.valdKungorelsetyp.externKod,
        e.rubrik = this.valdKungorelsetyp.beskrivning,
        e.underrubrikExternKod = this.valdUnderrubrik.externKod,
        e.underrubrik = this.valdUnderrubrik.beskrivning,
        e.amnesomrade = "",
        e.kontaktInfo = "",
        e.fakturaReferens = "",
        e.kungorelseText = "",
        e.publiceringsDatum = "",
        e.typDatum = "",
        e.fysiskaJuridiskaPersoner = [],
        e.lan = "",
        e.registreringsDatum = "",
        e.kungorelseid = "",
        e
    }
    laggTillKungorelse() {
        var e = this.skapaKungorelse()
          , n = this.$refs.stdForm;
        n.valideraFormular() && (e = n.mapToKungorelse(e),
        this.kungorelser.push(e),
        n.rensaFormular())
    }
    get formKomp() {
        if (Object.keys(this.valdUnderrubrik).length)
            switch (this.valdUnderrubrik.externKod) {
            case "ANBEGRGOD":
            case "ANFORV":
            case "ANGODM":
            case "ANUTFORV":
            case "JAMKFORV":
            case "UPPFORV":
                return "Forvaltarskap";
            case "BODELANM":
            case "BODELING":
                return "GavaMellanMakar";
            case "SKULDSANINLPRI":
            case "SKULDSANBESLPRI":
                return "Skuldsanering";
            case "KALLBORGLI":
                return "Likvidation"
            }
        switch (this.valdKungorelsetyp.externKod) {
        case "KONKBESL":
            return "KonkursBeslut";
        case "UTDEL":
            return "UtdelningsForslag";
        case "GÅVA":
            return "GavaMellanMakar";
        case "BEVFORF":
            return "BevakningsForfarande";
        case "EFTERUTDEL":
            return "EfterutdelningsForslag"
        }
        return "Standard"
    }
    created() {
        St().getLander();
        const e = Pe();
        e.nyaKungorelser.length == 0 ? e.nyaKungorelser = [] : (this.kungorelser = e.nyaKungorelser,
        e.nyaKungorelser = []),
        e.getAktivUppgiftslamnare ? (this.valdUppgiftslamnare = e.getAktivUppgiftslamnare,
        e.getAktivKungorelsetyp && (this.valdKungorelsetyp = e.getAktivKungorelsetyp),
        this.loadRubriker()) : this.kundanvandare != null && this.kundanvandare.poitkunder != null && this.kundanvandare.poitkunder.length == 1 && (this.valdUppgiftslamnare = this.kundanvandare.poitkunder[0],
        this.loadRubriker())
    }
}
;
xh = une([Ct({
    components: {
        BFormCheckbox: $s,
        Selectlist: Vn,
        Meddelande: Ft,
        BSpinner: er,
        Standard: VS,
        KonkursBeslut: hQ,
        UtdelningsForslag: FQ,
        GavaMellanMakar: $Z,
        BevakningsForfarande: zZ,
        EfterutdelningsForslag: cee,
        Forvaltarskap: Vee,
        Skuldsanering: ite,
        Likvidation: jte,
        IBiPencilSquare: qte,
        IBiPersonSquare: Xte,
        IBiReceipt: qS,
        IBiEyeFill: lne,
        IBiX: _l,
        FormGroup: Na
    }
})], xh);
const dne = Et(xh);
const mt = t => ($t("data-v-b376c11d"),
t = t(),
Tt(),
t)
  , cne = {
    class: "page"
}
  , fne = mt( () => c("div", {
    class: "row justify-content-md-center"
}, [c("div", {
    class: "col-12 col-md-10"
}, [c("h1", {
    class: "py-3"
}, "Registrera kungörelse")])], -1))
  , pne = {
    class: "row justify-content-md-center"
}
  , hne = {
    class: "col-12 col-md-10 my-1 my-md-3"
}
  , mne = {
    class: "steps-form"
}
  , vne = {
    class: "row"
}
  , gne = {
    class: "col-4 steps-step text-start"
}
  , bne = mt( () => c("p", {
    class: "text-small"
}, "1. Registrera kungörelse", -1))
  , yne = {
    class: "col-4 steps-step text-center"
}
  , kne = mt( () => c("p", {
    class: "text-small"
}, "2. Fakturauppgifter", -1))
  , _ne = {
    class: "col-4 steps-step text-end"
}
  , wne = mt( () => c("p", {
    class: "text-small"
}, "3. Kvittens", -1))
  , xne = {
    key: 0,
    class: "row justify-content-md-center"
}
  , Sne = mt( () => c("div", {
    class: "col-12 col-md-10"
}, [c("p", {
    class: "alert blv-alert-info"
}, "Fält markerade med * måste du fylla i.")], -1))
  , $ne = [Sne]
  , Tne = {
    key: 1
}
  , Cne = {
    class: "row justify-content-md-center"
}
  , Ene = {
    key: 0,
    class: "col col-md-10"
}
  , Ane = {
    class: "mb-3"
}
  , Mne = mt( () => c("label", {
    for: "uppgiftsLamnare"
}, "Välj uppgiftslämnare", -1))
  , One = ["value"]
  , Nne = {
    key: 1,
    class: "col col-md-10"
}
  , Dne = {
    class: "mb-3"
}
  , Pne = {
    class: "list-group"
}
  , Fne = {
    class: "list-group-item"
}
  , Bne = {
    class: "row"
}
  , Vne = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label w100"
}, "Uppgiftslämnare")], -1))
  , Ine = {
    class: "col-md-9"
}
  , Rne = {
    key: 0,
    class: "row justify-content-md-center"
}
  , Lne = {
    key: 0,
    class: "col col-md-10"
}
  , jne = {
    key: 1,
    class: "col col-md-10"
}
  , Une = {
    class: "row"
}
  , Hne = {
    class: "col"
}
  , Kne = {
    class: "mb-3 blv-fieldset mt-2"
}
  , zne = mt( () => c("legend", {
    class: "legend"
}, "Vad vill du kungöra?", -1))
  , qne = {
    class: "row"
}
  , Wne = {
    class: "mb-3 col"
}
  , Gne = mt( () => c("label", {
    for: "valdKungorelsetyp"
}, "Typ av kungörelse", -1))
  , Yne = ["value"]
  , Jne = {
    key: 0,
    class: "row"
}
  , Xne = {
    class: "mb-3 col"
}
  , Qne = mt( () => c("label", {
    for: "valdUnderrubrik"
}, "Typ av ärende", -1))
  , Zne = ["value"]
  , ere = {
    key: 0,
    class: "row"
}
  , tre = {
    key: 1,
    class: "row"
}
  , nre = {
    class: "col-12"
}
  , rre = {
    class: "mb-3"
}
  , are = {
    key: 1,
    class: "row justify-content-md-center mt-2"
}
  , sre = {
    class: "col-12 col-md-10"
}
  , lre = {
    class: "table-responsive"
}
  , ire = {
    class: "table table-hover table-striped table-bv",
    id: "sokresultat"
}
  , ore = mt( () => c("caption", {
    class: "visually-hidden"
}, " Tabell med listade kungörelser ", -1))
  , ure = mt( () => c("thead", {
    class: "blv-thead"
}, [c("tr", null, [c("th", {
    class: "text-center"
}, "Nr"), c("th", null, "Kungörelse"), c("th", null, "Fakturareferens"), c("th", {
    class: "text-center"
}, "Funktioner")])], -1))
  , dre = {
    class: "align-middle text-center"
}
  , cre = {
    class: "align-middle"
}
  , fre = {
    class: "align-middle"
}
  , pre = {
    class: "align-middle text-center"
}
  , hre = mt( () => c("span", {
    class: "visually-hidden"
}, "Förhandsgranska", -1))
  , mre = mt( () => c("span", {
    class: "visually-hidden"
}, "Ta bort", -1))
  , vre = {
    key: 2,
    class: "row justify-content-md-center"
}
  , gre = {
    class: "col-10"
}
  , bre = {
    key: 2
}
  , yre = {
    class: "row justify-content-md-center"
}
  , kre = {
    key: 0,
    class: "col col-md-10"
}
  , _re = mt( () => c("h4", null, "e-Faktura", -1))
  , wre = {
    class: "list-group"
}
  , xre = {
    class: "list-group-item"
}
  , Sre = {
    class: "row"
}
  , $re = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "GLN-nummer")], -1))
  , Tre = {
    class: "col-md-9"
}
  , Cre = {
    class: "list-group-item"
}
  , Ere = {
    class: "row"
}
  , Are = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Referens e-faktura")], -1))
  , Mre = {
    class: "col-md-9"
}
  , Ore = {
    class: "row mt-3"
}
  , Nre = {
    class: "col"
}
  , Dre = mt( () => c("span", {
    class: "visually-hidden"
}, "Skickar ...", -1))
  , Pre = {
    key: 1,
    class: "col col-md-10"
}
  , Fre = mt( () => c("h4", null, "Faktureringsadress", -1))
  , Bre = {
    class: "row"
}
  , Vre = {
    class: "col-sm mb-2"
}
  , Ire = {
    class: "list-group mb-2"
}
  , Rre = {
    class: "list-group-item"
}
  , Lre = {
    class: "row"
}
  , jre = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Namn")], -1))
  , Ure = {
    class: "col-md-9"
}
  , Hre = {
    class: "list-group-item"
}
  , Kre = {
    class: "row"
}
  , zre = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Adress")], -1))
  , qre = {
    class: "col-md-9"
}
  , Wre = {
    class: "list-group-item"
}
  , Gre = {
    class: "row"
}
  , Yre = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Postnummer")], -1))
  , Jre = {
    class: "col-md-9"
}
  , Xre = {
    class: "list-group-item"
}
  , Qre = {
    class: "row"
}
  , Zre = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Postort")], -1))
  , eae = {
    class: "col-md-9"
}
  , tae = {
    class: "list-group-item"
}
  , nae = {
    class: "row"
}
  , rae = mt( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label"
}, "Land")], -1))
  , aae = {
    class: "col-md-9"
}
  , sae = {
    key: 0,
    class: "row"
}
  , lae = {
    class: "col-sm mb-2"
}
  , iae = {
    key: 1,
    class: "row"
}
  , oae = {
    class: "col-sm mb-2"
}
  , uae = mt( () => c("h4", null, "Alternativ faktureringsadress", -1))
  , dae = ["value"]
  , cae = {
    class: "row"
}
  , fae = {
    class: "col-sm mb-2"
}
  , pae = {
    class: "mb-3"
}
  , hae = mt( () => c("span", {
    class: "visually-hidden"
}, "Skickar ...", -1))
  , mae = {
    key: 3
}
  , vae = {
    class: "mb-3"
}
  , gae = {
    class: "row justify-content-md-center"
}
  , bae = {
    class: "col col-md-10 no-print"
}
  , yae = {
    key: 0
}
  , kae = {
    key: 1
}
  , _ae = {
    class: "col col-md-10 mt-3"
}
  , wae = ["value"]
  , xae = {
    class: "page-print"
}
  , Sae = mt( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col-12 col-md-12"
}, [c("h2", {
    class: "py-3"
}, "Kvittens")])], -1))
  , $ae = mt( () => c("div", {
    class: "row no-print"
}, [c("div", {
    class: "col"
}, [c("hr")])], -1))
  , Tae = {
    key: 0,
    class: "row"
}
  , Cae = {
    class: "col-md-12"
}
  , Eae = {
    class: "d-md-inline py-1 me-md-3"
}
  , Aae = {
    key: 0,
    class: "mt-3"
}
  , Mae = {
    class: "row"
}
  , Oae = {
    class: "col-12 col-lg-7 pt-4"
}
  , Nae = {
    key: 0,
    class: "row"
}
  , Dae = mt( () => c("div", {
    class: "col-md-6 col-print-6"
}, [c("p", {
    class: "label"
}, "Namn/fastighetsbeteckning")], -1))
  , Pae = {
    class: "col-md-6 col-print-6"
}
  , Fae = {
    class: "nowrap"
}
  , Bae = {
    key: 1
}
  , Vae = ["value"]
  , Iae = {
    key: 0,
    class: "row"
}
  , Rae = {
    class: "col-md-6 col-print-6"
}
  , Lae = {
    class: "label"
}
  , jae = {
    class: "col-md-6 col-print-6"
}
  , Uae = {
    id: "datum"
}
  , Hae = {
    key: 2,
    class: "row"
}
  , Kae = mt( () => c("div", {
    class: "col-md-6 col-print-6"
}, [c("p", {
    class: "label"
}, "Län")], -1))
  , zae = {
    class: "col-md-6 col-print-6"
}
  , qae = {
    id: "lan"
}
  , Wae = {
    key: 3,
    class: "row"
}
  , Gae = mt( () => c("div", {
    class: "col-md-6 col-print-6"
}, [c("p", {
    class: "label"
}, "Publiceringsdatum")], -1))
  , Yae = {
    class: "col-md-6 col-print-6"
}
  , Jae = {
    id: "publiceringsdatum"
}
  , Xae = {
    key: 4,
    class: "row"
}
  , Qae = mt( () => c("div", {
    class: "col-md-6 col-print-6"
}, [c("p", {
    class: "label"
}, "Kungörelse-id")], -1))
  , Zae = {
    class: "col-md-6 col-print-6"
}
  , ese = {
    id: "kungorelseid"
}
  , tse = {
    class: "row"
}
  , nse = mt( () => c("div", {
    class: "col-md-6 col-print-6"
}, [c("p", {
    class: "label"
}, "Uppgiftslämnare")], -1))
  , rse = {
    class: "col-md-6 col-print-6"
}
  , ase = {
    id: "kund"
}
  , sse = {
    class: "col-12"
}
  , lse = {
    class: "mt-3"
}
  , ise = {
    class: "infobox p-4 border blv-border-light bg-white"
}
  , ose = mt( () => c("h4", null, "Kungörelsetext", -1))
  , use = ["innerHTML"]
  , dse = mt( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col break-after"
}, [c("hr")])], -1))
  , cse = {
    class: "row justify-content-md-start"
}
  , fse = {
    class: "col-12"
};
function pse(t, e, n, r, a, s) {
    const l = ue("i-bi-pencil-square")
      , i = ue("i-bi-person-square")
      , o = ue("i-bi-receipt")
      , u = ue("meddelande")
      , d = ue("i-bi-eye-fill")
      , f = ue("b-button")
      , p = ue("i-bi-x")
      , h = ue("b-spinner")
      , v = ue("form-group")
      , y = ue("b-form-checkbox")
      , k = ue("b-form-input")
      , w = ue("b-form");
    return g(),
    _("div", cne, [fne, x(w, null, {
        default: N( () => [c("div", pne, [c("div", hne, [c("div", mne, [c("div", vne, [c("div", gne, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.sida == 1
            }])
        }, [x(l, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "pencil square",
            focusable: "false"
        })], 2), bne]), c("div", yne, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.sida == 2
            }])
        }, [x(i, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "person square",
            focusable: "false"
        })], 2), kne]), c("div", _ne, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.sida == 3
            }])
        }, [x(o, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "receipt",
            focusable: "false"
        })], 2), wne])])])])]), t.sida == 1 ? (g(),
        _("div", xne, $ne)) : q("", !0), t.sida == 1 ? (g(),
        _("div", Tne, [c("div", Cne, [t.kundanvandare.poitkunder.length > 1 && t.kungorelser.length == 0 ? (g(),
        _("div", Ene, [c("div", Ane, [Mne, ve(" * "), ft(c("select", {
            id: "uppgiftsLamnare",
            class: "form-select",
            "onUpdate:modelValue": e[0] || (e[0] = $ => t.valdUppgiftslamnare = $),
            onChange: e[1] || (e[1] = $ => t.loadRubriker())
        }, [(g(!0),
        _(we, null, Ne(t.kundanvandare.poitkunder, $ => (g(),
        _("option", {
            key: $.id,
            value: $
        }, Q($.namn), 9, One))), 128))], 544), [[Xn, t.valdUppgiftslamnare]])])])) : (g(),
        _("div", Nne, [c("div", Dne, [c("ul", Pne, [c("li", Fne, [c("div", Bne, [Vne, c("div", Ine, Q(t.valdUppgiftslamnare.namn), 1)])])])])]))]), Object.keys(t.valdUppgiftslamnare).length ? (g(),
        _("div", Rne, [t.isKundSparrad() ? (g(),
        _("div", Lne, [x(u, {
            meddelande: "Denna kund är avslutad.",
            meddelandeTyp: "info"
        })])) : (g(),
        _("div", jne, [c("div", Une, [c("div", Hne, [c("fieldset", Kne, [zne, c("div", qne, [c("div", Wne, [Gne, ve(" * "), ft(c("select", {
            id: "valdKungorelsetyp",
            class: "form-select",
            "onUpdate:modelValue": e[2] || (e[2] = $ => t.valdKungorelsetyp = $),
            placeholder: "Välj kungörelsetyp ...",
            onChange: e[3] || (e[3] = $ => t.valjRubrik())
        }, [(g(!0),
        _(we, null, Ne(t.kungorelsetyper, $ => (g(),
        _("option", {
            key: $.id,
            value: $
        }, Q($.kungorelseRubrik), 9, Yne))), 128))], 544), [[Xn, t.valdKungorelsetyp]])])]), t.underrubriker.length && t.underrubriker[0].externKod != "none" ? (g(),
        _("div", Jne, [c("div", Xne, [Qne, ve(" * "), ft(c("select", {
            id: "valdUnderrubrik",
            class: "form-select",
            "onUpdate:modelValue": e[4] || (e[4] = $ => t.valdUnderrubrik = $),
            placeholder: "Välj underrubrik ..."
        }, [(g(!0),
        _(we, null, Ne(t.underrubriker, ($, M) => (g(),
        _("option", {
            key: M,
            value: $
        }, Q($.beskrivning), 9, Zne))), 128))], 512), [[Xn, t.valdUnderrubrik]])])])) : q("", !0)])])]), Object.keys(t.valdKungorelsetyp).length && (Object.keys(t.valdUnderrubrik).length || t.underrubriker.length == 0) ? (g(),
        _("div", ere, [(g(),
        de(qe(t.formKomp), {
            ref: "stdForm",
            kungorelsetyp: t.valdKungorelsetyp,
            underrubrik: t.valdUnderrubrik,
            uppgiftslamnare: t.valdUppgiftslamnare
        }, null, 8, ["kungorelsetyp", "underrubrik", "uppgiftslamnare"]))])) : q("", !0), Object.keys(t.valdKungorelsetyp).length && (Object.keys(t.valdUnderrubrik).length || t.underrubriker.length == 0) ? (g(),
        _("div", tre, [c("div", nre, [c("div", rre, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary",
            onClick: e[5] || (e[5] = $ => t.laggTillKungorelse())
        }, " Lägg till kungörelse ")])])])) : q("", !0)]))])) : q("", !0), t.kungorelser.length != 0 ? (g(),
        _("div", are, [c("div", sre, [c("div", lre, [c("table", ire, [ore, ure, c("tbody", null, [(g(!0),
        _(we, null, Ne(t.kungorelser, ($, M) => (g(),
        _("tr", {
            key: M
        }, [c("td", dre, Q(M + 1), 1), c("td", cre, Q(t.getKungtextPreview(M)), 1), c("td", fre, Q(t.kungorelser[M].fakturaReferens), 1), c("td", pre, [x(f, {
            onClick: S => t.forhandsGranska(M),
            title: "Förhandsgranska kungörelse",
            class: "blv-color text-white me-3 border-0"
        }, {
            default: N( () => [x(d, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "eye fill",
                focusable: "false"
            }), hre]),
            _: 2
        }, 1032, ["onClick"]), x(f, {
            onClick: S => t.taBort(M),
            title: "Ta bort kungörelse",
            class: "blv-btn-danger border-0 text-white"
        }, {
            default: N( () => [x(p, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "x",
                focusable: "false"
            }), mre]),
            _: 2
        }, 1032, ["onClick"])])]))), 128))])])])])])) : q("", !0), t.kungorelser.length > 0 ? (g(),
        _("div", vre, [c("div", gre, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary",
            onClick: e[6] || (e[6] = $ => t.sida++)
        }, "Nästa »")])])) : q("", !0)])) : q("", !0), t.sida == 2 ? (g(),
        _("div", bre, [c("div", yre, [t.valdUppgiftslamnare.harElektroniskFaktura == !0 ? (g(),
        _("div", kre, [_re, c("ul", wre, [c("li", xre, [c("div", Sre, [$re, c("div", Tre, [c("span", null, Q(t.valdUppgiftslamnare.GLNNummer), 1)])])]), c("li", Cre, [c("div", Ere, [Are, c("div", Mre, [c("span", null, Q(t.valdUppgiftslamnare.eFakturaReferens), 1)])])])]), c("div", Ore, [c("div", Nre, [c("button", {
            type: "button",
            class: "btn blv-color btn-secondary me-2 d-inline",
            onClick: e[7] || (e[7] = $ => t.sida--)
        }, " « Föregående "), x(v, {
            class: "d-inline"
        }, {
            default: N( () => [c("button", {
                type: "button",
                class: "btn blv-color btn-primary",
                onClick: e[8] || (e[8] = $ => t.skicka())
            }, [ve(" Skicka och visa kvittens "), t.skickar ? (g(),
            de(h, {
                key: 0,
                small: ""
            })) : q("", !0), Dre])]),
            _: 1
        })])])])) : (g(),
        _("div", Pre, [Fre, c("div", Bre, [c("div", Vre, [c("ul", Ire, [c("li", Rre, [c("div", Lre, [jre, c("div", Ure, [c("span", null, Q(t.valdUppgiftslamnare.namn), 1)])])]), c("li", Hre, [c("div", Kre, [zre, c("div", qre, [c("span", null, Q(t.valdUppgiftslamnare.faktureringGatuadress), 1)])])]), c("li", Wre, [c("div", Gre, [Yre, c("div", Jre, [c("span", null, Q(t.valdUppgiftslamnare.faktureringpostnummer), 1)])])]), c("li", Xre, [c("div", Qre, [Zre, c("div", eae, [c("span", null, Q(t.valdUppgiftslamnare.faktureringPostort), 1)])])]), c("li", tae, [c("div", nae, [rae, c("div", aae, [c("span", null, Q(t.valdUppgiftslamnare.faktureringLand), 1)])])])])])]), t.valdUppgiftslamnare.harSamlingsfaktura ? q("", !0) : (g(),
        _("div", sae, [c("div", lae, [x(y, {
            class: "mb-3",
            id: "altFaktId",
            modelValue: t.altFakt,
            "onUpdate:modelValue": e[9] || (e[9] = $ => t.altFakt = $),
            name: "visafakturaadress"
        }, {
            default: N( () => [ve(" Jag vill ange en annan faktureringsadress.")]),
            _: 1
        }, 8, ["modelValue"])])])), t.altFakt != !1 ? (g(),
        _("div", iae, [c("div", oae, [uae, x(v, {
            label: "C/o",
            "label-for": "altCo"
        }, {
            default: N( () => [x(k, {
                modelValue: t.altCo,
                "onUpdate:modelValue": e[10] || (e[10] = $ => t.altCo = $),
                maxlength: "50",
                id: "altCo"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(v, {
            label: "Gatuadress",
            "label-for": "altGata"
        }, {
            default: N( () => [x(k, {
                modelValue: t.altGata,
                "onUpdate:modelValue": e[11] || (e[11] = $ => t.altGata = $),
                maxlength: "50",
                id: "altGata"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(v, {
            label: "Postnummer",
            "label-for": "altPostnr"
        }, {
            default: N( () => [x(k, {
                modelValue: t.altPostnr,
                "onUpdate:modelValue": e[12] || (e[12] = $ => t.altPostnr = $),
                maxlength: "6",
                id: "altPostnr"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(v, {
            label: "Postort",
            "label-for": "altOrt"
        }, {
            default: N( () => [x(k, {
                modelValue: t.altOrt,
                "onUpdate:modelValue": e[13] || (e[13] = $ => t.altOrt = $),
                maxlength: "50",
                id: "altOrt"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(v, {
            label: "Land",
            "label-for": "altLand"
        }, {
            default: N( () => [ft(c("select", {
                "onUpdate:modelValue": e[14] || (e[14] = $ => t.altLand = $),
                class: "form-select"
            }, [(g(!0),
            _(we, null, Ne(t.lander, $ => (g(),
            _("option", {
                key: $.isoKod,
                value: $.isoKod
            }, Q($.namn), 9, dae))), 128))], 512), [[Xn, t.altLand]])]),
            _: 1
        })])])) : q("", !0), c("div", cae, [c("div", fae, [c("div", pae, [c("button", {
            type: "button",
            class: "btn blv-color btn-secondary me-2",
            onClick: e[15] || (e[15] = $ => t.sida--)
        }, " « Föregående "), c("button", {
            type: "button",
            class: "btn blv-color btn-primary",
            onClick: e[16] || (e[16] = $ => t.skicka())
        }, [ve(" Skicka och visa kvittens "), t.skickar ? (g(),
        de(h, {
            key: 0,
            small: ""
        })) : q("", !0), hae])])])])]))])])) : q("", !0), t.sida == 3 ? (g(),
        _("div", mae, [c("div", vae, [c("div", gae, [c("div", bae, [t.kvittoOK() ? (g(),
        _("div", yae, [x(u, {
            meddelande: "Bolagsverket har tagit emot din kungörelse i Post- och Inrikes Tidningar.",
            meddelandeTyp: "success"
        })])) : (g(),
        _("div", kae, [x(u, {
            meddelande: "Tekniskt fel hos Bolagsverket. Försök igen senare.",
            meddelandeTyp: "danger"
        })]))]), c("div", _ae, [(g(!0),
        _(we, null, Ne(t.kvittoKungorelser, ($, M) => (g(),
        _("div", {
            key: M,
            value: $
        }, [c("div", xae, [Sae, $ae, $.rubrik != null && $.rubrik != "" ? (g(),
        _("div", Tae, [c("div", Cae, [c("h3", Eae, Q($.rubrik), 1), $.underrubrik != null && $.underrubrik != "" ? (g(),
        _("h4", Aae, Q($.underrubrik), 1)) : q("", !0)])])) : q("", !0), c("div", Mae, [c("div", Oae, [$.fysiskaJuridiskaPersoner != null && $.fysiskaJuridiskaPersoner.length > 0 ? (g(),
        _("div", Nae, [Dae, c("div", Pae, [(g(!0),
        _(we, null, Ne($.fysiskaJuridiskaPersoner, (S, T) => (g(),
        _("p", {
            id: "fysjur",
            key: T
        }, [ve(Q(S.namn) + ", ", 1), c("span", Fae, Q(t.formateraPersOrgNr(S.nummer)), 1)]))), 128))])])) : q("", !0), $.typDatum && $.typDatum != "" ? (g(),
        _("div", Bae, [(g(!0),
        _(we, null, Ne(t.kungorelsetyper, S => (g(),
        _("div", {
            key: S.id,
            value: S
        }, [S && S.externKod == $.rubrikExternKod ? (g(),
        _("div", Iae, [c("div", Rae, [c("p", Lae, Q(S.datumTyp), 1)]), c("div", jae, [c("p", Uae, Q($.typDatum), 1)])])) : q("", !0)], 8, Vae))), 128))])) : q("", !0), $.lan && t.aktivKungorelse.lan != "" ? (g(),
        _("div", Hae, [Kae, c("div", zae, [c("p", qae, Q($.lan), 1)])])) : q("", !0), $.publiceringsDatum != null && $.publiceringsDatum != "" ? (g(),
        _("div", Wae, [Gae, c("div", Yae, [c("p", Jae, Q($.publiceringsDatum), 1)])])) : q("", !0), $.kungorelseid != null && $.kungorelseid != "" ? (g(),
        _("div", Xae, [Qae, c("div", Zae, [c("p", ese, Q($.kungorelseid), 1)])])) : q("", !0), c("div", tse, [nse, c("div", rse, [c("p", ase, Q($.uppgiftslamnare), 1)])])]), c("div", sse, [c("div", lse, [c("div", ise, [ose, c("div", {
            innerHTML: $.kungorelseText
        }, null, 8, use)])])])]), dse, c("div", cse, [c("div", fse, [c("button", {
            type: "button",
            class: "btn blv-color btn-secondary me-2",
            onClick: e[17] || (e[17] = S => t.sida = 1)
        }, " Registrera ny kungörelse "), c("button", {
            type: "button",
            class: "btn blv-color btn-primary",
            onClick: e[18] || (e[18] = S => t.print())
        }, "Skriv ut")])])])], 8, wae))), 128))])])])])) : q("", !0)]),
        _: 1
    })])
}
const hse = rt(dne, [["render", pse], ["__scopeId", "data-v-b376c11d"]]);
var mse = Object.defineProperty
  , vse = Object.getOwnPropertyDescriptor
  , gse = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? vse(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && mse(e, n, a),
    a
}
;
let Sh = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "kungorelse", {});
        V(this, "uppgiftslamnare", {});
        V(this, "kungorelsetyp", {});
        V(this, "orgKungorelsetyp", {});
        V(this, "kungorelsetyper", []);
        V(this, "underrubrik", {});
        V(this, "orgUnderrubrik", {});
        V(this, "underrubriker", [{
            beskrivning: "none",
            externKod: "none"
        }])
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get laner() {
        return St().laner
    }
    get getAktivKungorelse() {
        return Pe().getAktivKungorelse
    }
    get getAktivUppgiftsLamnare() {
        return Pe().getAktivUppgiftslamnare
    }
    valjRubrik() {
        this.underrubrik = {},
        this.underrubriker = [{
            beskrivning: "none",
            externKod: "none"
        }],
        Pe().aktivKungorelsetyp = this.kungorelsetyp,
        this.kungorelse.rubrikExternKod = this.kungorelsetyp.externKod,
        this.loadUnderrubriker()
    }
    spara() {
        var n = this.$refs.stdForm;
        if (this.kungorelse.kungorelseid != null && this.kungorelse.kungorelseid != "") {
            var r = {
                ...this.kungorelse
            };
            if (r.fysiskaJuridiskaPersoner = JSON.parse(JSON.stringify(this.kungorelse.fysiskaJuridiskaPersoner)),
            this.kungorelse = n.mapToKungorelse(this.kungorelse),
            !this.isÄndrad(r, this.kungorelse)) {
                alert("Inga ändringar har registreras."),
                this.$router.back();
                return
            }
            this.kungorelse.kungorelseText = this.updateraKungorelseText(r, this.kungorelse);
            var a = {
                kungorelseid: this.kungorelse.kungorelseid,
                kundAnvandareId: this.kundanvandare.id,
                kundNummer: this.kungorelse.kundNummer,
                rubrikExternKod: this.kungorelse.rubrikExternKod,
                underrubrikExternKod: this.kungorelse.underrubrikExternKod,
                kontaktInfo: this.kungorelse.kontaktInfo,
                fakturaReferens: this.kungorelse.fakturaReferens,
                kungorelseText: this.kungorelse.kungorelseText,
                publiceringsDatum: "",
                typDatum: this.kungorelse.typDatum,
                fysiskaJuridiskaPersoner: this.kungorelse.fysiskaJuridiskaPersoner,
                lan: this.kungorelse.lan,
                altFakturering: this.kungorelse.altFakturering,
                altFaktureringsAdress: this.kungorelse.altFaktureringsAdress,
                altFaktureringsCoAdress: this.kungorelse.altFaktureringsCoAdress,
                altFaktureringsPostNr: this.kungorelse.altFaktureringsPostNr,
                altFaktureringsPostOrt: this.kungorelse.altFaktureringsPostOrt,
                altFaktureringsLand: this.kungorelse.altFaktureringsLand,
                email: this.kundanvandare.email,
                token: this.kundanvandare.token
            };
            Pe().updateraKungorelse(a).then( () => {
                this.$router.replace("/kvittoRattalse")
            }
            )
        } else
            this.kungorelse = n.mapToKungorelse(this.kungorelse),
            this.$router.back()
    }
    updateraKungorelseText(n, r) {
        var a = "<p><b>Rättelse:</b> Den kungörelse som publicerades " + n.publiceringsDatum + " var felaktig. Rättning gjord avseende:";
        return r.rubrikExternKod != n.rubrikExternKod && (a += " kungörelsetyp,"),
        r.underrubrikExternKod != n.underrubrikExternKod && (a += " underrubrik,"),
        r.lan != n.lan && (a += " län,"),
        r.typDatum != n.typDatum && (a += " datum,"),
        JSON.stringify(r.fysiskaJuridiskaPersoner) != JSON.stringify(n.fysiskaJuridiskaPersoner) && (a += " kungörelsen avser,"),
        this.isKungtextÄndrad(r.kungorelseText, n.kungorelseText.trim()) && (a += " kungörelsetext,"),
        a = a.substring(0, a.length - 1) + ".</p><p>&nbsp;</p>",
        a + r.kungorelseText
    }
    isÄndrad(n, r) {
        return !!(r.rubrikExternKod != n.rubrikExternKod || r.underrubrikExternKod != n.underrubrikExternKod || r.lan != n.lan || r.typDatum != n.typDatum || JSON.stringify(r.fysiskaJuridiskaPersoner) != JSON.stringify(n.fysiskaJuridiskaPersoner) || this.isKungtextÄndrad(r.kungorelseText, n.kungorelseText.trim()))
    }
    isKungtextÄndrad(n, r) {
        var a = n.replaceAll("<p>", "").replaceAll("</p>", "").trim()
          , s = r.replaceAll("<p>", "").replaceAll("</p>", "").trim();
        return a != s
    }
    foregaende() {
        this.$router.back()
    }
    getUppgiftslamnare(n) {
        var r = 0;
        for (r = 0; r < this.kundanvandare.poitkunder.length; r++)
            if (this.kundanvandare.poitkunder[r].kundnummer == n.kundNummer)
                return this.kundanvandare.poitkunder[r];
        return {}
    }
    loadRubriker() {
        this.kungorelsetyp = {},
        Pe().getKungorelsetyper(this.uppgiftslamnare.kundnummer).then( () => {
            this.kungorelsetyper = Pe().kungorelsetyper;
            var n = 0;
            for (n = 0; n < this.kungorelsetyper.length; n++)
                if (this.kungorelsetyper[n].externKod == this.kungorelse.rubrikExternKod) {
                    this.kungorelsetyp = this.kungorelsetyper[n],
                    this.valjRubrik();
                    break
                }
        }
        )
    }
    loadUnderrubriker() {
        Pe().getUnderrubriker(this.kungorelsetyp.externKod).then( () => {
            this.underrubriker = Pe().underrubriker;
            var n = 0;
            for (n = 0; n < this.underrubriker.length; n++)
                if (this.underrubriker[n].externKod == this.kungorelse.underrubrikExternKod) {
                    this.underrubrik = this.underrubriker[n];
                    break
                }
        }
        )
    }
    loadKungorelsetyp(n) {
        Pe().getKungorelsetyp(n).then( () => {
            this.orgKungorelsetyp = Pe().loadedKungorelsetyp,
            this.kungorelsetyp = this.orgKungorelsetyp
        }
        )
    }
    loadUnderrubrik(n) {
        Pe().getUnderrubrik(n).then( () => {
            this.orgUnderrubrik = Pe().loadedUnderrubrik,
            this.underrubrik = this.orgUnderrubrik
        }
        )
    }
    get formKomp() {
        return "Standard"
    }
    created() {
        this.kungorelse = Pe().getAktivKungorelse,
        this.uppgiftslamnare = this.getUppgiftslamnare(this.kungorelse),
        this.loadKungorelsetyp(this.kungorelse.rubrikExternKod),
        this.loadRubriker(),
        this.kungorelse.underrubrikExternKod && this.kungorelse.underrubrikExternKod != "" && this.loadUnderrubrik(this.kungorelse.underrubrikExternKod)
    }
}
;
Sh = gse([Ct({
    components: {
        Selectlist: Vn,
        Meddelande: Ft,
        Standard: VS,
        IBiX: _l
    }
})], Sh);
const bse = Et(Sh);
const xl = t => ($t("data-v-85becf1c"),
t = t(),
Tt(),
t)
  , yse = {
    key: 0,
    class: "page"
}
  , kse = {
    key: 0,
    class: "row justify-content-md-center"
}
  , _se = xl( () => c("div", {
    class: "col-12 col-md-8"
}, [c("h1", {
    class: "py-3"
}, "Rätta kungörelse"), c("p", {
    class: "my-3 alert blv-alert-info"
}, "När du rättar en kungörelse måste du betala avgiften för den igen.")], -1))
  , wse = [_se]
  , xse = {
    key: 1,
    class: "row justify-content-md-center"
}
  , Sse = xl( () => c("div", {
    class: "col-12 col-md-8"
}, [c("h1", {
    class: "py-3"
}, "Registrera kungörelse"), c("br")], -1))
  , $se = [Sse]
  , Tse = {
    class: "row justify-content-md-center"
}
  , Cse = {
    class: "col-12 col-md-8"
}
  , Ese = {
    class: "mb-3"
}
  , Ase = {
    class: "list-group"
}
  , Mse = {
    class: "list-group-item"
}
  , Ose = {
    class: "row"
}
  , Nse = xl( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label w100"
}, "Uppgiftslämnare")], -1))
  , Dse = {
    class: "col-md-9"
}
  , Pse = {
    class: "list-group-item"
}
  , Fse = {
    class: "row"
}
  , Bse = xl( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label w100"
}, "Typ av kungorelse")], -1))
  , Vse = {
    class: "col-md-9"
}
  , Ise = {
    key: 0,
    class: "list-group-item"
}
  , Rse = {
    class: "row"
}
  , Lse = xl( () => c("div", {
    class: "col-md-3"
}, [c("span", {
    class: "label w100"
}, "Underrubrik")], -1))
  , jse = {
    class: "col-md-9"
}
  , Use = {
    class: "row justify-content-md-center"
}
  , Hse = {
    class: "col-12 col-md-8"
}
  , Kse = {
    class: "row"
}
  , zse = {
    class: "mb-3 col"
}
  , qse = xl( () => c("label", {
    for: "kungorelsetyp"
}, "Ändra typ av kungörelse", -1))
  , Wse = ["value", "selected"]
  , Gse = {
    key: 0,
    class: "row justify-content-md-center"
}
  , Yse = {
    class: "col-12 col-md-8"
}
  , Jse = {
    class: "row"
}
  , Xse = {
    class: "mb-3 col"
}
  , Qse = xl( () => c("label", {
    for: "underrubrik"
}, "Ändra underrubrik", -1))
  , Zse = ["value"]
  , ele = {
    key: 1,
    class: "row justify-content-md-center"
}
  , tle = {
    class: "col-12 col-md-8"
}
  , nle = {
    class: "row"
}
  , rle = {
    class: "row justify-content-md-center"
}
  , ale = {
    class: "col-12 col-md-8"
}
  , sle = {
    key: 0
}
  , lle = {
    key: 1
};
function ile(t, e, n, r, a, s) {
    const l = ue("i-bi-x")
      , i = ue("b-form");
    return Object.keys(t.uppgiftslamnare).length && Object.keys(t.kungorelsetyp).length ? (g(),
    _("div", yse, [t.kungorelse.kungorelseid && t.kungorelse.kungorelseid != "" ? (g(),
    _("div", kse, wse)) : (g(),
    _("div", xse, $se)), x(i, null, {
        default: N( () => [c("div", Tse, [c("div", Cse, [c("div", Ese, [c("ul", Ase, [c("li", Mse, [c("div", Ose, [Nse, c("div", Dse, Q(t.uppgiftslamnare.namn), 1)])]), c("li", Pse, [c("div", Fse, [Bse, c("div", Vse, Q(t.orgKungorelsetyp.beskrivning), 1)])]), Object.keys(t.orgUnderrubrik).length ? (g(),
        _("li", Ise, [c("div", Rse, [Lse, c("div", jse, Q(t.orgUnderrubrik.beskrivning), 1)])])) : q("", !0)])])])]), c("div", Use, [c("div", Hse, [c("div", Kse, [c("div", zse, [qse, ft(c("select", {
            id: "kungorelsetypSelect",
            class: "form-select",
            "onUpdate:modelValue": e[0] || (e[0] = o => t.kungorelsetyp = o),
            placeholder: "Välj ny kungörelsetyp ...",
            onChange: e[1] || (e[1] = o => t.valjRubrik())
        }, [(g(!0),
        _(we, null, Ne(t.kungorelsetyper, o => (g(),
        _("option", {
            key: o.id,
            value: o,
            selected: o === t.orgKungorelsetyp
        }, Q(o.kungorelseRubrik), 9, Wse))), 128))], 544), [[Xn, t.kungorelsetyp]])])])])]), t.underrubriker.length && t.underrubriker[0].externKod != "none" ? (g(),
        _("div", Gse, [c("div", Yse, [c("div", Jse, [c("div", Xse, [Qse, ft(c("select", {
            id: "underrubrik",
            class: "form-select",
            "onUpdate:modelValue": e[2] || (e[2] = o => t.underrubrik = o),
            placeholder: "Välj underrubrik ..."
        }, [(g(!0),
        _(we, null, Ne(t.underrubriker, (o, u) => (g(),
        _("option", {
            key: u,
            value: o
        }, Q(o.beskrivning), 9, Zse))), 128))], 512), [[Xn, t.underrubrik]])])])])])) : q("", !0), Object.keys(t.kungorelsetyp).length && (Object.keys(t.underrubrik).length || t.underrubriker.length == 0) ? (g(),
        _("div", ele, [c("div", tle, [c("div", nle, [(g(),
        de(qe(t.formKomp), {
            ref: "stdForm",
            kungorelsetyp: t.kungorelsetyp,
            underrubrik: t.underrubrik,
            kungorelse: t.kungorelse,
            uppgiftslamnare: t.uppgiftslamnare
        }, null, 8, ["kungorelsetyp", "underrubrik", "kungorelse", "uppgiftslamnare"]))])])])) : q("", !0), c("div", rle, [c("div", ale, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary",
            onClick: e[3] || (e[3] = o => t.spara())
        }, [!t.kungorelse.kungorelseid || t.kungorelse.kungorelseid == "" ? (g(),
        _("span", sle, " Ändra ")) : (g(),
        _("span", lle, " Spara och skicka "))]), c("button", {
            type: "button",
            class: "btn blv-btn-abort ms-2",
            onClick: e[4] || (e[4] = o => t.foregaende())
        }, [x(l, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "x",
            focusable: "false"
        }), ve(" Avbryt ")])])])]),
        _: 1
    })])) : q("", !0)
}
const ole = rt(bse, [["render", ile], ["__scopeId", "data-v-85becf1c"]]);
var ule = Object.defineProperty
  , dle = Object.getOwnPropertyDescriptor
  , cle = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? dle(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && ule(e, n, a),
    a
}
;
let $h = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "inloggnamn", "");
        V(this, "losenord", "");
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info")
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    async sha256x2(e) {
        const n = new TextEncoder().encode(e)
          , r = await crypto.subtle.digest("SHA-256", n)
          , a = await crypto.subtle.digest("SHA-256", r);
        return Array.from(new Uint8Array(a)).map(i => i.toString(16).padStart(2, "0")).join("")
    }
    async skapaAuthentisering(e, n, r) {
        const a = await this.sha256x2(n + e)
          , s = await this.sha256x2(a + r + "3");
        var l = {
            email: e,
            losenordsHash: s
        };
        return l
    }
    bankId() {
        if (localStorage.getItem("PoIT_Redirect") == "true")
            return;
        localStorage.setItem("PoIT_Redirect", "true");
        const e = new URL(document.location.href)
          , n = "https://" + e.hostname + "/Shibboleth.sso/login?target=" + encodeURIComponent("https://" + e.hostname + "/poit-app/");
        console.log(n),
        document.location.href = n
    }
    loggain() {
        var e = {
            email: this.inloggnamn
        };
        dt().hamtaSalt(e).then(n => {
            this.skapaAuthentisering(this.inloggnamn, this.losenord, n).then(r => {
                dt().loggaIn(r).then(a => {
                    console.log("string " + a),
                    a == "FEL_LOSEN_ELLER_ANVANDARNAMN" ? (this.meddelande = "Fel användarnamn eller lösenord. Försök igen.",
                    this.visaMeddelande = !0,
                    this.meddelandeTyp = "danger") : a == "INAKTIVERAD" ? (this.meddelande = "Användare med denna e-postadress är inaktiverad hos kunden",
                    this.visaMeddelande = !0,
                    this.meddelandeTyp = "danger") : a == "LAST_TILL" ? (this.meddelande = "Denna användare är tillfälligt utlåst. Pröva igen om 10 minuter.",
                    this.visaMeddelande = !0,
                    this.meddelandeTyp = "danger") : a == "LAST_TILL_MORG" ? (this.meddelande = "Denna användare är tillfälligt utlåst. Pröva igen imorgon.",
                    this.visaMeddelande = !0,
                    this.meddelandeTyp = "danger") : (Pe().startsida = !0,
                    this.$router.push({
                        name: "minauppgifter"
                    }))
                }
                ).catch(a => {
                    this.meddelande = a,
                    this.meddelandeTyp = "danger",
                    this.visaMeddelande = !0
                }
                )
            }
            )
        }
        )
    }
}
;
$h = cle([Ct({
    components: {
        Meddelande: Ft
    }
})], $h);
const fle = Et($h);
const wv = t => ($t("data-v-7531e6f2"),
t = t(),
Tt(),
t)
  , ple = {
    class: "page"
}
  , hle = {
    class: "row justify-content-md-center"
}
  , mle = {
    class: "col-md-6"
}
  , vle = wv( () => c("div", {
    class: "loggain"
}, [c("h1", {
    class: "py-3"
}, "Logga in")], -1))
  , gle = {
    class: "allt"
}
  , ble = {
    class: "formfield"
}
  , yle = wv( () => c("label", {
    for: "inloggnamn"
}, "Användarnamn", -1))
  , kle = {
    class: "formfield mt-3"
}
  , _le = wv( () => c("label", {
    for: "losenord"
}, "Lösenord", -1))
  , wle = {
    class: "row"
}
  , xle = {
    class: "col-5 col-md-6 mt-3"
}
  , Sle = {
    class: "col-7 col-md-6 mt-3 text-end mt-3 pt-1"
};
function $le(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("b-button")
      , o = ue("router-link");
    return g(),
    _("div", ple, [c("div", hle, [c("div", mle, [vle, c("div", null, [x(l, {
        meddelande: "För att kunna logga in måste du vara registrerad som användare i Post- och Inrikes Tidningar.",
        meddelandeTyp: "info"
    })]), c("div", gle, [t.visaMeddelande ? (g(),
    de(l, {
        key: 0,
        meddelande: t.meddelande,
        meddelandeTyp: t.meddelandeTyp
    }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0), c("div", ble, [yle, ft(c("input", {
        class: "form-control",
        id: "inloggnamn",
        "onUpdate:modelValue": e[0] || (e[0] = u => t.inloggnamn = u)
    }, null, 512), [[cg, t.inloggnamn]])]), c("div", kle, [_le, ft(c("input", {
        class: "form-control",
        id: "losenord",
        "onUpdate:modelValue": e[1] || (e[1] = u => t.losenord = u),
        type: "password"
    }, null, 512), [[cg, t.losenord]])])]), c("div", wle, [c("div", xle, [x(i, {
        class: "blv-color",
        variant: "primary",
        onClick: e[2] || (e[2] = u => t.loggain())
    }, {
        default: N( () => [ve("Logga in")]),
        _: 1
    })]), c("div", Sle, [ve(" Har du "), x(o, {
        class: "btn-link",
        to: {
            name: "glomtlosenord"
        }
    }, {
        default: N( () => [ve(" glömt ditt lösenord?")]),
        _: 1
    })])]), x(i, {
        class: "blv-color mt-3",
        variant: "primary",
        onClick: e[3] || (e[3] = u => t.bankId())
    }, {
        default: N( () => [ve(" Logga in med e-legitimation ")]),
        _: 1
    })])])])
}
const Tle = rt(fle, [["render", $le], ["__scopeId", "data-v-7531e6f2"]]);
var Cle = Object.defineProperty
  , Ele = Object.getOwnPropertyDescriptor
  , Ale = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Ele(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Cle(e, n, a),
    a
}
;
let Th = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "email", "");
        V(this, "visaMeddelande", !1);
        V(this, "meddelande", "");
        V(this, "meddelandeTyp", "info");
        V(this, "felmeddelande", "");
        V(this, "anvandareSaknas", !1)
    }
    emailGiltigt() {
        return this.anvandareSaknas ? (this.felmeddelande = "Det finns ingen användare med den här e-postadressen.",
        !1) : null
    }
    disableSkicka() {
        return this.email == null || this.email.length < 5 || !this.email.includes("@") || !this.email.match(".[a-zA-Z]{2,}")
    }
    tillbaka() {
        this.$router.go(-1)
    }
    emailChanged() {
        this.anvandareSaknas = !1,
        this.visaMeddelande = !1
    }
    glomtLosenord() {
        var e = {
            email: this.email
        };
        dt().glomtLosenord(e).then(n => {
            n == "OK" ? (this.meddelande = "Vi har skickat ett nytt lösenord till din e-postadress.",
            this.meddelandeTyp = "success",
            this.visaMeddelande = !0) : n == "ANVANDARE_SAKNAS" ? (this.anvandareSaknas = !0,
            this.visaMeddelande = !1) : (this.meddelande = n,
            this.meddelandeTyp = "danger",
            this.visaMeddelande = !0)
        }
        ).catch(n => {
            this.meddelande = n,
            this.meddelandeTyp = "danger",
            this.visaMeddelande = !0
        }
        )
    }
}
;
Th = Ale([Ct({
    components: {
        Meddelande: Ft,
        FormGroup: Na,
        IBiX: _l
    }
})], Th);
const Mle = Et(Th);
const WS = t => ($t("data-v-f44e221f"),
t = t(),
Tt(),
t)
  , Ole = {
    class: "page"
}
  , Nle = {
    class: "row justify-content-md-center"
}
  , Dle = {
    class: "col-md-6"
}
  , Ple = {
    class: "glomtlosenord"
}
  , Fle = WS( () => c("h1", {
    class: "py-3"
}, "Har du glömt ditt lösenord?", -1))
  , Ble = WS( () => c("p", null, "Fyll i din e-postadress så skickar vi ett nytt lösenord till dig.", -1))
  , Vle = {
    class: "row d-flex flex-wrap justify-content-between"
}
  , Ile = {
    class: "col-12"
};
function Rle(t, e, n, r, a, s) {
    const l = ue("meddelande")
      , i = ue("b-form-input")
      , o = ue("form-group")
      , u = ue("b-button")
      , d = ue("i-bi-x")
      , f = ue("b-form");
    return g(),
    _("div", Ole, [c("div", Nle, [c("div", Dle, [c("div", Ple, [Fle, t.visaMeddelande ? (g(),
    de(l, {
        key: 0,
        meddelande: t.meddelande,
        meddelandeTyp: t.meddelandeTyp
    }, null, 8, ["meddelande", "meddelandeTyp"])) : q("", !0), Ble]), x(f, {
        class: "mt-3"
    }, {
        default: N( () => [x(o, {
            label: "E-postadress:",
            labelFor: "email",
            invalidFeedback: t.felmeddelande
        }, {
            default: N( () => [x(i, {
                id: "email",
                type: "email",
                modelValue: t.email,
                "onUpdate:modelValue": e[0] || (e[0] = p => t.email = p),
                state: t.emailGiltigt(),
                onInput: e[1] || (e[1] = p => t.emailChanged())
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }, 8, ["invalidFeedback"]), c("div", Vle, [c("div", Ile, [x(u, {
            class: "blv-color",
            disabled: t.disableSkicka(),
            onClick: e[2] || (e[2] = p => t.glomtLosenord())
        }, {
            default: N( () => [ve("Skicka")]),
            _: 1
        }, 8, ["disabled"]), x(u, {
            class: "btn blv-btn-abort ms-2",
            variant: "light",
            onClick: e[3] || (e[3] = p => t.tillbaka())
        }, {
            default: N( () => [x(d, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "x",
                focusable: "false"
            }), ve(" Avbryt ")]),
            _: 1
        })])])]),
        _: 1
    })])])])
}
const Lle = rt(Mle, [["render", Rle], ["__scopeId", "data-v-f44e221f"]])
  , jle = Lr("bliKund", {
    state: () => ({
        kunduppgifter: null
    }),
    actions: {
        async skickaMeddelande(t) {
            try {
                const e = "/poit/rest/SkickaMeddelande";
                await Pt.post(e, t)
            } catch {
                throw "Fel när meddelande skulle skickas"
            }
        },
        setKunduppgifter(t) {
            this.kunduppgifter = t
        }
    }
})
  , Ule = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Hle = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M14.763.075A.5.5 0 0 1 15 .5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V14h-1v1.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V10a.5.5 0 0 1 .342-.474L6 7.64V4.5a.5.5 0 0 1 .276-.447l8-4a.5.5 0 0 1 .487.022M6 8.694L1 10.36V15h5zM7 15h2v-1.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5V15h2V1.309l-7 3.5z"
}), c("path", {
    d: "M2 11h1v1H2zm2 0h1v1H4zm-2 2h1v1H2zm2 0h1v1H4zm4-4h1v1H8zm2 0h1v1h-1zm-2 2h1v1H8zm2 0h1v1h-1zm2-2h1v1h-1zm0 2h1v1h-1zM8 7h1v1H8zm2 0h1v1h-1zm2 0h1v1h-1zM8 5h1v1H8zm2 0h1v1h-1zm2 0h1v1h-1zm0-2h1v1h-1z"
})], -1)
  , Kle = [Hle];
function zle(t, e) {
    return g(),
    _("svg", Ule, [...Kle])
}
const qle = {
    name: "bi-buildings",
    render: zle
}
  , Wle = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Gle = c("g", {
    fill: "currentColor"
}, [c("path", {
    d: "M1 14s-1 0-1-1s1-4 6-4s6 3 6 4s-1 1-1 1zm5-6a3 3 0 1 0 0-6a3 3 0 0 0 0 6"
}), c("path", {
    "fill-rule": "evenodd",
    d: "M13.5 5a.5.5 0 0 1 .5.5V7h1.5a.5.5 0 0 1 0 1H14v1.5a.5.5 0 0 1-1 0V8h-1.5a.5.5 0 0 1 0-1H13V5.5a.5.5 0 0 1 .5-.5"
})], -1)
  , Yle = [Gle];
function Jle(t, e) {
    return g(),
    _("svg", Wle, [...Yle])
}
const Xle = {
    name: "bi-person-plus-fill",
    render: Jle
};
var Qle = Object.defineProperty
  , Zle = Object.getOwnPropertyDescriptor
  , eie = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Zle(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Qle(e, n, a),
    a
}
;
let Ch = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "visaMeddelande", !1);
        V(this, "avsandare", "");
        V(this, "personnummer", "");
        V(this, "namn", "");
        V(this, "adress", "");
        V(this, "postnummer", "");
        V(this, "ort", "");
        V(this, "vatnummer", "");
        V(this, "externreferens", "");
        V(this, "lopnummer", "");
        V(this, "telefon", "");
        V(this, "epost", "");
        V(this, "kontaktuppgifter", "");
        V(this, "land", "");
        V(this, "coadress", "");
        V(this, "fakturacoadress", "");
        V(this, "fakturaadress", "");
        V(this, "fakturapostnummer", "");
        V(this, "fakturaort", "");
        V(this, "fakturaland", "");
        V(this, "visafakturaadress", !1);
        V(this, "faktureringssatt", "SF");
        V(this, "meddelandePoIT", "");
        V(this, "webkunder", []);
        V(this, "visaWebkund", !0);
        V(this, "steg", 1);
        V(this, "gatuadress", "");
        V(this, "gatunummer", "");
        V(this, "fakturagatuadress", "");
        V(this, "webkunderfe", []);
        V(this, "webfornamn", "");
        V(this, "felMeddelande", "");
        V(this, "felMeddelande2", "");
        V(this, "inputChk", !1);
        V(this, "skickar", !1)
    }
    get lander() {
        return St().lander
    }
    skickaMeddelande() {
        if (this.valideraAnvandarForm()) {
            this.skickar = !0,
            this.saveWebkunder();
            var n = {
                avsandare: this.avsandare,
                kontaktuppgifter: this.kontaktuppgifter,
                personnummer: this.personnummer,
                lopnummer: this.lopnummer,
                kundnamn: this.namn,
                adress: (this.coadress != "" ? "c/o " + this.coadress + ", " : "") + this.gatuadress + " " + this.gatunummer + ", " + this.postnummer + ", " + this.ort + ", " + this.land,
                faktureringsadress: this.visafakturaadress == !1 ? this.gatuadress + ", " + this.postnummer + ", " + this.ort + ", " + this.land : this.fakturacoadress + ", " + this.fakturagatuadress + ", " + this.fakturapostnummer + ", " + this.fakturaort + ", " + this.fakturaland,
                telefon: this.telefon,
                epost: this.epost,
                externReferens: this.externreferens,
                vatnummer: this.vatnummer,
                faktureringssatt: this.faktureringssatt,
                meddelandePoIT: this.meddelandePoIT,
                webkunder: this.webkunder
            };
            jle().skickaMeddelande(n),
            this.steg = this.steg + 1,
            this.visaMeddelande = !0
        }
    }
    laggTillAnvandare() {
        this.webkunderfe.push({
            namn: "",
            personnummer: "",
            epost: ""
        })
    }
    taBortAnvandare(n) {
        this.webkunderfe.splice(n, 1)
    }
    visaFakturaAdress() {
        this.visafakturaadress = !this.visafakturaadress
    }
    showDelete() {
        return this.webkunderfe.length > 1
    }
    valideraKundForm() {
        return this.felMeddelande = "",
        this.inputChk = !0,
        !(this.skickar || (this.namn == "" && (this.felMeddelande += "• Namn måste fyllas i.<br/>"),
        this.gatuadress == "" && (this.felMeddelande += "• Adress måste fyllas i.<br/>"),
        this.postnummer == "" && (this.felMeddelande += "• Postnummer måste fyllas i.<br/>"),
        this.ort == "" && (this.felMeddelande += "• Ort måste fyllas i.<br/>"),
        this.land == "" && (this.felMeddelande += "• Land måste fyllas i.<br/>"),
        (this.epost == "" || !this.isEpostGiltigt(this.epost)) && (this.felMeddelande += "• E-postadress måste fyllas i.<br/>"),
        this.externreferens == "" && (this.felMeddelande += "• Kontaktperson måste fyllas i.<br/>"),
        this.felMeddelande != ""))
    }
    valideraAnvandarForm() {
        this.felMeddelande2 = "",
        this.inputChk = !0;
        for (let n = 0; n < this.webkunderfe.length; n++)
            this.webkunderfe[n].namn == "" && (this.felMeddelande2 += "• Användare nummer: " + (n + 1) + " saknar namn.<br/>"),
            (this.webkunderfe[n].epost == "" || this.isEpostGiltigt(this.webkunderfe[n].epost) != !0) && (this.felMeddelande2 += "• Användare nummer: " + (n + 1) + " saknar E-postadress.<br/>"),
            this.webkunderfe[n].personnummer != "" && this.personOrgnummerGiltigt(this.webkunderfe[n].personnummer) != !0 && (this.felMeddelande2 += "• Användare nummer: " + (n + 1) + " har ogiltigt personnummer.<br/>");
        return this.felMeddelande2 == ""
    }
    emptyCheck(n) {
        return n == "" && !this.inputChk ? null : n != ""
    }
    personOrgnummerGiltigt(n) {
        return n == "" && !this.inputChk ? null : n == "" ? !1 : Ht(n)
    }
    personOrgnummerGiltigtNotReq(n) {
        return n == "" ? null : Ht(n)
    }
    isEpostGiltigt(n) {
        return n == "" && !this.inputChk ? null : lw(n)
    }
    tillAnv() {
        this.valideraKundForm() && (this.steg += 1,
        this.inputChk = !1)
    }
    backa() {
        this.steg = this.steg - 1,
        this.inputChk = !1
    }
    saveWebkunder() {
        for (let n = 0; n < this.webkunderfe.length; n++)
            this.webkunder.push({
                namn: this.webkunderfe[n].namn,
                personnummer: this.webkunderfe[n].personnummer,
                epost: this.webkunderfe[n].epost
            }),
            this.webkunder[n].epost = this.webkunderfe[n].epost,
            console.log(this.webkunder)
    }
    created() {
        St().getLander(),
        this.land = "Sverige",
        this.fakturaland = "Sverige"
    }
    mounted() {}
}
;
Ch = eie([Ct({
    components: {
        Meddelande: Ft,
        BFormCheckbox: $s,
        BFormSelect: yl,
        BFormRadio: Tm,
        BFormTextarea: Em,
        IBiBuildings: qle,
        IBiPersonPlusFill: Xle,
        IBiReceipt: qS,
        IBiX: _l,
        IBiPlus: qx
    }
})], Ch);
const tie = Et(Ch);
const Hr = t => ($t("data-v-57654e27"),
t = t(),
Tt(),
t)
  , nie = {
    class: "page"
}
  , rie = Hr( () => c("div", {
    class: "row justify-content-md-center"
}, [c("div", {
    class: "col-12 col-md-10"
}, [c("h1", {
    class: "py-3"
}, [ve("Bli kund"), c("span", null, " i Post- och Inrikes Tidningar")])])], -1))
  , aie = {
    class: "row justify-content-md-center"
}
  , sie = {
    class: "col-12 col-md-10 my-1 my-md-3"
}
  , lie = {
    class: "steps-form"
}
  , iie = {
    class: "row"
}
  , oie = {
    class: "col-4 steps-step text-start"
}
  , uie = Hr( () => c("p", {
    class: "text-small"
}, "1. Kund", -1))
  , die = {
    class: "col-4 steps-step text-center"
}
  , cie = Hr( () => c("p", {
    class: "text-small"
}, "2. Användare", -1))
  , fie = {
    class: "col-4 steps-step text-end"
}
  , pie = Hr( () => c("p", {
    class: "text-small"
}, "3. Kvittens", -1))
  , hie = {
    class: "row justify-content-md-center"
}
  , mie = Hr( () => c("div", {
    class: "col-12 col-md-10"
}, [c("p", {
    class: "alert blv-alert-info"
}, "Fält markerade med * måste du fylla i.")], -1))
  , vie = [mie]
  , gie = {
    class: "row justify-content-md-center"
}
  , bie = {
    class: "col-12 col-md-10"
}
  , yie = Hr( () => c("h2", null, "Kunduppgifter", -1))
  , kie = {
    class: "row"
}
  , _ie = {
    class: "col-12 col-lg-6"
}
  , wie = {
    class: "col-12 col-lg-6"
}
  , xie = {
    class: "row"
}
  , Sie = {
    class: "col-12 col-lg-6"
}
  , $ie = Hr( () => c("div", {
    class: "col-12 col-lg-6"
}, null, -1))
  , Tie = {
    class: "row"
}
  , Cie = {
    class: "col-12 col-lg-6"
}
  , Eie = {
    class: "col-12 col-lg-6"
}
  , Aie = {
    class: "row"
}
  , Mie = {
    class: "col-12 col-lg-6"
}
  , Oie = {
    class: "col-12 col-lg-6"
}
  , Nie = {
    class: "row"
}
  , Die = {
    class: "col-12 col-lg-6"
}
  , Pie = {
    class: "col-12 col-lg-6"
}
  , Fie = {
    class: "row"
}
  , Bie = {
    class: "col-12 col-lg-6"
}
  , Vie = {
    class: "col-12 col-lg-6"
}
  , Iie = {
    class: "row"
}
  , Rie = {
    class: "col-12 col-lg-6"
}
  , Lie = Hr( () => c("div", {
    class: "col-12 col-lg-6"
}, null, -1))
  , jie = {
    class: "row"
}
  , Uie = {
    class: "col-12 col-lg-6"
}
  , Hie = {
    key: 0
}
  , Kie = Hr( () => c("h3", {
    class: "mb-2 mt-2"
}, "Fakturaadress", -1))
  , zie = {
    class: "row"
}
  , qie = {
    class: "col-12 col-lg-6"
}
  , Wie = {
    class: "col-12 col-lg-6"
}
  , Gie = {
    class: "row"
}
  , Yie = {
    class: "col-12 col-lg-6"
}
  , Jie = {
    class: "col-12 col-lg-6"
}
  , Xie = {
    class: "row justify-content-md-center"
}
  , Qie = {
    class: "col-12 col-md-10"
}
  , Zie = Hr( () => c("h2", null, "Användare", -1))
  , eoe = Hr( () => c("p", null, " Lägg till den eller de personer som ska kunna registrera kungörelser. Fyll i personnummer om de ska kunna logga in med e-legitimation. ", -1))
  , toe = {
    class: "card pt-2 px-3 mb-3"
}
  , noe = {
    class: "mb-3"
}
  , roe = {
    class: "row"
}
  , aoe = {
    class: "col-12 col-lg-4"
}
  , soe = {
    class: "col-12 col-lg-4"
}
  , loe = {
    class: "col-12 col-lg-4"
}
  , ioe = {
    class: "row"
}
  , ooe = {
    class: "col-12"
}
  , uoe = {
    class: "row"
}
  , doe = {
    class: "col-12 col-lg-6"
}
  , coe = {
    class: "row"
}
  , foe = {
    class: "col-12 col-lg-12"
}
  , poe = {
    class: "row"
}
  , hoe = {
    class: "col-12 col-lg-12"
}
  , moe = {
    class: "row"
}
  , voe = {
    class: "col-12 col-lg-12"
}
  , goe = {
    class: "mb-3"
}
  , boe = {
    class: "row justify-content-md-center"
}
  , yoe = {
    class: "col-12 col-md-10"
};
function koe(t, e, n, r, a, s) {
    const l = ue("i-bi-buildings")
      , i = ue("i-bi-person-plus-fill")
      , o = ue("i-bi-receipt")
      , u = ue("b-form-input")
      , d = ue("form-group")
      , f = ue("b-form-select")
      , p = ue("b-form-checkbox")
      , h = ue("b-form-radio")
      , v = ue("meddelande")
      , y = ue("b-button")
      , k = ue("i-bi-x")
      , w = ue("i-bi-plus")
      , $ = ue("b-form-textarea")
      , M = ue("b-form");
    return g(),
    _("div", nie, [rie, x(M, null, {
        default: N( () => [c("div", aie, [c("div", sie, [c("div", lie, [c("div", iie, [c("div", oie, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.steg == 1
            }])
        }, [x(l, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "buildings",
            focusable: "false"
        })], 2), uie]), c("div", die, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.steg == 2
            }])
        }, [x(i, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "person plus fill",
            focusable: "false"
        })], 2), cie]), c("div", fie, [c("span", {
            class: ye(["btn-circle mb-2", {
                active: t.steg == 3
            }])
        }, [x(o, {
            role: "img",
            class: "b-icon bi",
            "aria-label": "receipt",
            focusable: "false"
        })], 2), pie])])])])]), ft(c("div", hie, vie, 512), [[jn, t.steg != 3]]), ft(c("div", gie, [c("div", bie, [yie, c("div", kie, [c("div", _ie, [x(d, {
            class: "input-width label-style",
            label: "Företagsnamn / förnamn och efternamn *",
            "label-for": "namn",
            invalidFeedback: "Ange namn"
        }, {
            default: N( () => [x(u, {
                id: "namn",
                modelValue: t.namn,
                "onUpdate:modelValue": e[0] || (e[0] = S => t.namn = S),
                state: t.emptyCheck(t.namn),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), c("div", wie, [x(d, {
            class: "input-width label-style",
            label: "Löpnummer (Om du är enskild näringsidkare)",
            "label-for": "lopnummer"
        }, {
            default: N( () => [x(u, {
                id: "lopnummer",
                modelValue: t.lopnummer,
                "onUpdate:modelValue": e[1] || (e[1] = S => t.lopnummer = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })])]), c("div", xie, [c("div", Sie, [x(d, {
            class: "input-width label-style",
            label: "Organisationnummer / personnummer",
            "label-for": "organisationsnr",
            invalidFeedback: "Ange personnummer i format ÅÅÅÅMMDD-XXXX"
        }, {
            default: N( () => [x(u, {
                id: "organisationsnr",
                modelValue: t.personnummer,
                "onUpdate:modelValue": e[2] || (e[2] = S => t.personnummer = S),
                state: t.personOrgnummerGiltigtNotReq(t.personnummer)
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), $ie]), c("div", Tie, [c("div", Cie, [x(d, {
            class: "input-width label-style",
            label: "Adress *",
            "label-for": "gatuadress",
            invalidFeedback: "Ange gatuadress"
        }, {
            default: N( () => [x(u, {
                id: "gatuadress",
                modelValue: t.gatuadress,
                "onUpdate:modelValue": e[3] || (e[3] = S => t.gatuadress = S),
                state: t.emptyCheck(t.gatuadress),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), c("div", Eie, [x(d, {
            class: "input-width label-style",
            label: "C/o",
            "label-for": "coadress"
        }, {
            default: N( () => [x(u, {
                id: "coadress",
                modelValue: t.coadress,
                "onUpdate:modelValue": e[4] || (e[4] = S => t.coadress = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })])]), c("div", Aie, [c("div", Mie, [x(d, {
            class: "input-width label-style",
            label: "Postnummer *",
            "label-for": "postnummer",
            invalidFeedback: "Ange postnummer"
        }, {
            default: N( () => [x(u, {
                id: "postnummer",
                modelValue: t.postnummer,
                "onUpdate:modelValue": e[5] || (e[5] = S => t.postnummer = S),
                state: t.emptyCheck(t.postnummer),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), c("div", Oie, [x(d, {
            class: "input-width label-style",
            label: "Postort *",
            "label-for": "ort",
            invalidFeedback: "Ange ort"
        }, {
            default: N( () => [x(u, {
                id: "ort",
                modelValue: t.ort,
                "onUpdate:modelValue": e[6] || (e[6] = S => t.ort = S),
                state: t.emptyCheck(t.ort),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })])]), c("div", Nie, [c("div", Die, [x(d, {
            class: "input-width label-style",
            label: "Land",
            "label-for": "land"
        }, {
            default: N( () => [x(f, {
                id: "land",
                modelValue: t.land,
                "onUpdate:modelValue": e[7] || (e[7] = S => t.land = S),
                options: t.lander,
                "text-field": "namn",
                "value-field": "namn"
            }, null, 8, ["modelValue", "options"])]),
            _: 1
        })]), ft(c("div", Pie, [x(d, {
            class: "input-width label-style",
            label: "Momsregistreringsnummer (VAT-nummer) (valfritt)",
            "label-for": "vatnummer"
        }, {
            default: N( () => [x(u, {
                id: "vatnummer",
                modelValue: t.vatnummer,
                "onUpdate:modelValue": e[8] || (e[8] = S => t.vatnummer = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })], 512), [[jn, t.land !== "Sverige"]])]), c("div", Fie, [c("div", Bie, [x(d, {
            class: "input-width label-style",
            label: "Telefonnummer",
            "label-for": "telefon"
        }, {
            default: N( () => [x(u, {
                type: "tel",
                id: "telefon",
                modelValue: t.telefon,
                "onUpdate:modelValue": e[9] || (e[9] = S => t.telefon = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })]), c("div", Vie, [x(d, {
            class: "input-width label-style",
            label: "E-postadress *",
            "label-for": "epost",
            invalidFeedback: "Ange giltig e-postadress"
        }, {
            default: N( () => [x(u, {
                id: "epost",
                modelValue: t.epost,
                "onUpdate:modelValue": e[10] || (e[10] = S => t.epost = S),
                state: t.isEpostGiltigt(t.epost),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })])]), c("div", Iie, [c("div", Rie, [x(d, {
            class: "input-width label-style",
            label: "Kontaktperson *",
            "label-for": "kontaktperson",
            invalidFeedback: "Ange kontaktperson"
        }, {
            default: N( () => [x(u, {
                id: "kontaktperson",
                modelValue: t.externreferens,
                "onUpdate:modelValue": e[11] || (e[11] = S => t.externreferens = S),
                state: t.emptyCheck(t.externreferens),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        })]), Lie]), c("div", jie, [c("div", Uie, [x(p, {
            class: "mb-3",
            id: "visafakturaadress",
            modelValue: t.visafakturaadress,
            "onUpdate:modelValue": e[12] || (e[12] = S => t.visafakturaadress = S),
            name: "visafakturaadress"
        }, {
            default: N( () => [ve(" Jag vill ange en annan fakturaadress. ")]),
            _: 1
        }, 8, ["modelValue"])])]), t.visafakturaadress ? (g(),
        _("div", Hie, [Kie, c("div", zie, [c("div", qie, [x(d, {
            class: "input-width label-style",
            label: "Adress",
            "label-for": "fakturagatuadress"
        }, {
            default: N( () => [x(u, {
                id: "fakturagatuadress",
                modelValue: t.fakturagatuadress,
                "onUpdate:modelValue": e[13] || (e[13] = S => t.fakturagatuadress = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })]), c("div", Wie, [x(d, {
            class: "input-width label-style",
            label: "C/o",
            "label-for": "fakturacoadress"
        }, {
            default: N( () => [x(u, {
                id: "fakturacoadress",
                modelValue: t.fakturacoadress,
                "onUpdate:modelValue": e[14] || (e[14] = S => t.fakturacoadress = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })])]), c("div", Gie, [c("div", Yie, [x(d, {
            class: "input-width label-style",
            label: "Postnummer",
            "label-for": "fakturapostnummer"
        }, {
            default: N( () => [x(u, {
                id: "fakturapostnummer",
                modelValue: t.fakturapostnummer,
                "onUpdate:modelValue": e[15] || (e[15] = S => t.fakturapostnummer = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })]), c("div", Jie, [x(d, {
            class: "input-width label-style",
            label: "Postort",
            "label-for": "fakturaort"
        }, {
            default: N( () => [x(u, {
                id: "fakturaort",
                modelValue: t.fakturaort,
                "onUpdate:modelValue": e[16] || (e[16] = S => t.fakturaort = S)
            }, null, 8, ["modelValue"])]),
            _: 1
        })])]), x(d, {
            class: "input-width label-style",
            label: "Land",
            "label-for": "fakturaland"
        }, {
            default: N( () => [x(f, {
                modelValue: t.fakturaland,
                "onUpdate:modelValue": e[17] || (e[17] = S => t.fakturaland = S),
                id: "fakturaland",
                options: t.lander,
                "text-field": "namn",
                "value-field": "namn"
            }, null, 8, ["modelValue", "options"])]),
            _: 1
        })])) : q("", !0), x(d, {
            label: "Faktureringssätt"
        }, {
            default: N( ({ariaDescribedby: S}) => [x(h, {
                modelValue: t.faktureringssatt,
                "onUpdate:modelValue": e[18] || (e[18] = T => t.faktureringssatt = T),
                name: "faktureringssatt",
                value: "SF",
                "aria-describedby": S
            }, {
                default: N( () => [ve("Samlingsfaktura")]),
                _: 2
            }, 1032, ["modelValue", "aria-describedby"]), x(h, {
                modelValue: t.faktureringssatt,
                "onUpdate:modelValue": e[19] || (e[19] = T => t.faktureringssatt = T),
                name: "faktureringssatt",
                value: "DF",
                "aria-describedby": S
            }, {
                default: N( () => [ve("Direktfaktura")]),
                _: 2
            }, 1032, ["modelValue", "aria-describedby"])]),
            _: 1
        }), t.felMeddelande != "" ? (g(),
        de(v, {
            key: 1,
            meddelande: t.felMeddelande,
            meddelandeTyp: "danger"
        }, null, 8, ["meddelande"])) : q("", !0), x(y, {
            class: "blv-color mb-1",
            variant: "primary",
            onClick: e[20] || (e[20] = S => t.tillAnv())
        }, {
            default: N( () => [ve("Nästa »")]),
            _: 1
        })])], 512), [[jn, t.steg == 1]]), ft(c("div", Xie, [c("div", Qie, [Zie, eoe, (g(!0),
        _(we, null, Ne(t.webkunderfe, (S, T) => (g(),
        _("div", {
            key: T
        }, [c("div", toe, [c("fieldset", noe, [c("legend", null, " Användare " + Q(T + 1), 1), c("div", roe, [c("div", aoe, [x(d, {
            class: "input-width label-style",
            label: "Namn *",
            "label-for": t.webfornamn + T,
            invalidFeedback: "Ange namn"
        }, {
            default: N( () => [x(u, {
                id: t.webfornamn + T,
                modelValue: S.namn,
                "onUpdate:modelValue": E => S.namn = E,
                name: `webkunderfe[${T}][namn]`,
                state: t.emptyCheck(S.namn),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "name", "state"])]),
            _: 2
        }, 1032, ["label-for"])]), c("div", soe, [x(d, {
            class: "input-width label-style",
            label: "E-postadress *",
            "label-for": "webepost",
            invalidFeedback: "Ange giltig e-postadress"
        }, {
            default: N( () => [x(u, {
                id: "webepost",
                modelValue: S.epost,
                "onUpdate:modelValue": E => S.epost = E,
                name: `webkunderfe[${T}][epost]`,
                state: t.isEpostGiltigt(S.epost),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "state"])]),
            _: 2
        }, 1024)]), c("div", loe, [x(d, {
            class: "input-width label-style",
            label: "Personnummer",
            "label-for": "webpersonnummer",
            description: "För att kunna logga in med e-legitimation",
            invalidFeedback: "Ange personnummer i format ÅÅÅÅMMDD-XXXX"
        }, {
            default: N( () => [x(u, {
                modelValue: S.personnummer,
                "onUpdate:modelValue": E => S.personnummer = E,
                id: "webpersonnummer",
                name: `webkunderfe[${T}][personnummer]`,
                state: t.personOrgnummerGiltigtNotReq(S.personnummer)
            }, null, 8, ["modelValue", "onUpdate:modelValue", "name", "state"])]),
            _: 2
        }, 1024)])]), ft(c("div", ioe, [c("div", ooe, [c("div", null, [x(y, {
            class: "btn blv-btn-danger blv-border-0",
            onClick: E => t.taBortAnvandare(T)
        }, {
            default: N( () => [x(k, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "x",
                focusable: "false"
            }), ve(" Ta bort användare " + Q(T + 1), 1)]),
            _: 2
        }, 1032, ["onClick"])])])], 512), [[jn, t.showDelete()]])])])]))), 128)), c("div", uoe, [c("div", doe, [x(y, {
            class: "blv-color mb-5 mt-2",
            variant: "primary",
            onClick: e[21] || (e[21] = S => t.laggTillAnvandare())
        }, {
            default: N( () => [x(w, {
                role: "img",
                class: "b-icon bi",
                "aria-label": "plus",
                focusable: "false"
            }), ve(" Lägg till fler användare")]),
            _: 1
        })])]), c("div", coe, [c("div", foe, [x(d, {
            class: "input-width label-style",
            id: "meddelandePoIT",
            label: "Meddelande till redaktionen",
            "label-for": "meddelandePoIT"
        }, {
            default: N( () => [x($, {
                modelValue: t.meddelandePoIT,
                "onUpdate:modelValue": e[22] || (e[22] = S => t.meddelandePoIT = S),
                id: "meddelandePoIT",
                placeholder: "Skriv ditt meddelande här...",
                rows: "3"
            }, null, 8, ["modelValue"])]),
            _: 1
        })])]), c("div", poe, [c("div", hoe, [t.felMeddelande2 != "" ? (g(),
        de(v, {
            key: 0,
            meddelande: t.felMeddelande2,
            meddelandeTyp: "danger"
        }, null, 8, ["meddelande"])) : q("", !0)])]), c("div", moe, [c("div", voe, [c("div", goe, [x(y, {
            variant: "primary",
            class: "blv-color",
            onClick: e[23] || (e[23] = S => t.backa())
        }, {
            default: N( () => [ve("« Föregående")]),
            _: 1
        }), x(y, {
            class: "blv-color ms-1",
            variant: "primary",
            onClick: e[24] || (e[24] = S => t.skickaMeddelande())
        }, {
            default: N( () => [ve("Skicka")]),
            _: 1
        })])])])])], 512), [[jn, t.steg == 2]]), ft(c("div", boe, [c("div", yoe, [t.visaMeddelande ? (g(),
        de(v, {
            key: 0,
            meddelande: `Bolagsverket har tagit emot din anmälan om att bli kund i Post- och Inrikes Tidningar (PoIT). 
När vi har registrerat din anmälan skickar vi ett mejl till användarna med användarnamn och lösenord. Då kan de logga in i e-tjänsten och registrera kungörelser.`,
            meddelandeTyp: "success"
        })) : q("", !0)])], 512), [[jn, t.steg == 3]])]),
        _: 1
    })])
}
const _oe = rt(tie, [["render", koe], ["__scopeId", "data-v-57654e27"]])
  , woe = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , xoe = c("path", {
    fill: "currentColor",
    "fill-rule": "evenodd",
    d: "M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5"
}, null, -1)
  , Soe = [xoe];
function $oe(t, e) {
    return g(),
    _("svg", woe, [...Soe])
}
const xv = {
    name: "bi-arrow-up",
    render: $oe
}
  , Toe = Se({
    name: "OmTjansten",
    components: {
        IBiArrowUp: xv
    }
});
const Sl = t => ($t("data-v-5a9c83f4"),
t = t(),
Tt(),
t)
  , Coe = {
    class: "page"
}
  , Eoe = {
    class: "row justify-content-md-center"
}
  , Aoe = {
    class: "col-md-8"
}
  , Moe = Sl( () => c("h1", null, "Om tjänsten", -1))
  , Ooe = Sl( () => c("h2", {
    id: "seochsoka"
}, "Se och söka kungörelser", -1))
  , Noe = Sl( () => c("p", null, " Kungörelserna är tillgängliga dygnet runt utan kostnad. De uppdateras varje vardag utom midsommarafton, julafton och nyårsafton. De är sökbara i e-tjänsten i två år från publiceringsdatumet med undantag för arvskungörelser som är sökbara i sex år. ", -1))
  , Doe = Sl( () => c("p", null, " Äldre kungörelser är allmänna handlingar och enligt offentlighetsprincipen kan du beställa kopior av kungörelserna. Det kostar 2 kronor per sida. ", -1))
  , Poe = Sl( () => c("h2", {
    id: "saharkungordu"
}, "Så här kungör du", -1))
  , Foe = Sl( () => c("h3", {
    id: "blikundforst"
}, "Bli kund först", -1))
  , Boe = Ci('<p data-v-5a9c83f4> När vi har registrerat anmälan skickar vi ett mejl till användarna med användarnamn och lösenord. Sedan kan de logga in i e-tjänsten och registrera kungörelser. </p><p data-v-5a9c83f4>Se till att anmäla i god tid så att allt är klart när du ska registrera en kungörelse.</p><h3 id="registrerakungorelsen" data-v-5a9c83f4>Registrera kungörelsen enkelt via webbformulär</h3><p data-v-5a9c83f4> Använd våra webbformulär för att registrera en kungörelse. Formulären hittar du när du loggat in i e-tjänsten. Du kan också lämna in kungörelsen via mejl eller brev men det kostar mer. </p><h3 id="registrerakungorelsenitid" data-v-5a9c83f4>Registrera kungörelsen i tid</h3><p data-v-5a9c83f4> En kungörelse ska vara hos oss två arbetsdagar innan vi ska publicera den. Du som registrerar kungörelsen via våra webbformulär har på dig fram till klockan 24. Om du lämnar kungörelsen på annat sätt måste du lämna den före klockan 16. </p><div class="exempel" data-v-5a9c83f4><p class="bold" data-v-5a9c83f4>Exempel:</p><p data-v-5a9c83f4> Kungörelsen ska publiceras en måndag. Då måste du lämna kungörelsen till oss senast torsdag veckan innan den ska publiceras. </p></div><h3 id="villduandra" data-v-5a9c83f4>Vill du ändra en inlämnad kungörelse?</h3>', 8)
  , Voe = Ci('<h3 id="villduratta" data-v-5a9c83f4>Vill du rätta en publicerad kungörelse?</h3><p data-v-5a9c83f4> Du kan rätta en kungörelse som du har publicerat. Det gör du genom att logga in i e-tjänsten och välja Sök eller rätta publicerade kungörelser i menyn. </p><h2 id="priser" data-v-5a9c83f4>Priser</h2><p data-v-5a9c83f4> Det kostar 14 kronor plus moms om du registrerar en kungörelse elektroniskt via våra webbformulär, oavsett vad du kungör och hur lång din kungörelsetext är. </p><p data-v-5a9c83f4> Om du lämnar in en kungörelse via mejl eller brev kostar det 70 kronor plus moms för varje påbörjat hundratal tecken i kungörelsetexten. Priset blir alltså högre ju längre din text är. </p><h2 data-v-5a9c83f4>Rekommenderade webbläsare</h2><p data-v-5a9c83f4> Vi rekommenderar den senaste versionen av någon av de vanligaste webbläsarna - Microsoft Edge, Microsoft Edge Chromium, Google Chrome, Safari och Mozilla Firefox. </p><h2 id="sverigesofficiella" data-v-5a9c83f4>Sveriges officiella kungörelseorgan</h2><p data-v-5a9c83f4> Post- och Inrikes Tidningar (PoIT) är ett officiellt kungörelseorgan på internet. PoIT innehåller kungörelser från myndigheter och andra som enligt lag eller förordning ska kungöra i PoIT för att informationen ska komma till allmänhetens kännedom. I PoIT kungörs också sådant som regleras av bolagsordningar, stadgar eller liknande förordnanden. </p><p data-v-5a9c83f4> PoIT är en publikation med gamla anor som startades 1645 av Drottning Kristina. Den 1 januari 2007 upphörde papperstidningen och ersattes av en e-tjänst hos Bolagsverket. E-tjänsten saknar redaktionellt innehåll, men ger annonsörer möjlighet att lämna in kungörelser elektroniskt och ger allmänheten möjlighet att fritt söka information om kungörelser. </p><h2 id="lagarochregler" data-v-5a9c83f4>Lagar och regler</h2><ul data-v-5a9c83f4><li class="mb-2 mb-md-1" data-v-5a9c83f4><a href="https://www.riksdagen.se/sv/dokument-lagar/dokument/svensk-forfattningssamling/forordning-20061226-om-post--och-inrikes_sfs-2006-1226" data-v-5a9c83f4>Förordning om Post- och Inrikes Tidningar, SFS 2006:1226</a></li><li class="mb-2 mb-md-1" data-v-5a9c83f4><a href="https://www.riksdagen.se/sv/dokument-lagar/dokument/svensk-forfattningssamling/lag-2006385-om-avgift-for-annonsering-i-post-_sfs-2006-385" data-v-5a9c83f4>Lag om avgift för annonsering i Post- och Inrikes Tidningar, SFS 2006:385</a></li><li class="mb-2 mb-md-1" data-v-5a9c83f4><a href="https://bolagsverket.se/download/18.6535432417e0f20712756ea7/1643114956751/bolfs_2007_1.pdf" data-v-5a9c83f4>Bolagsverkets föreskrifter om elektronisk ingivning och betalning av kungörelser i Post- och Inrikes Tidningar, BOLFS 2007:1</a></li><li class="mb-2 mb-md-1" data-v-5a9c83f4><a href="https://bolagsverket.se/download/18.6535432417e0f20712756e8f/1643114942819/elektronisk-ingivning-betalning-poit.pdf" data-v-5a9c83f4>Föreskrifter om ändring i Bolagsverkets föreskrifter (BOLFS 2007:1) om elektronisk ingivning och betalning av kungörelser i Post- och Inrikes Tidningar.</a></li></ul>', 12)
  , Ioe = {
    class: "row justify-content-md-center"
}
  , Roe = {
    class: "col-md-8 text-start text-md-end"
}
  , Loe = Sl( () => c("hr", {
    class: "separator"
}, null, -1))
  , joe = {
    class: "btn btn-link",
    href: "#poit"
};
function Uoe(t, e, n, r, a, s) {
    const l = ue("router-link")
      , i = ue("i-bi-arrow-up");
    return g(),
    _("div", Coe, [c("div", Eoe, [c("div", Aoe, [Moe, Ooe, Noe, Doe, Poe, Foe, c("p", null, [ve(" För att kungöra i Post- och Inrikes Tidningar måste företaget, myndigheten eller kommunen först "), x(l, {
        to: "bli-kund",
        title: "Länk till sidan Bli kund"
    }, {
        default: N( () => [ve("bli kund")]),
        _: 1
    }), ve(". Varje kund kan ha en eller flera användare som har rätt att registrera kungörelser. ")]), Boe, c("p", null, [ve(" Du kan göra ändringar i en inlämnad kungörelse till och med arbetsdagen innan vi publicerar kungörelsen. "), x(l, {
        to: "kontakta-oss",
        title: "Länk till sidan kontakta oss"
    }, {
        default: N( () => [ve("Kontakta oss")]),
        _: 1
    }), ve(" så hjälper vi dig. Vi finns oftast på plats måndag-fredag 9-12 och 13-15. ")]), Voe])]), c("div", Ioe, [c("div", Roe, [Loe, c("a", joe, [x(i, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "arrow up",
        focusable: "false"
    }), ve(" Till toppen ")])])])])
}
const Hoe = rt(Toe, [["render", Uoe], ["__scopeId", "data-v-5a9c83f4"]])
  , Koe = Se({
    name: "InEnglish",
    components: {
        IBiArrowUp: xv
    }
});
const zoe = t => ($t("data-v-b46113bc"),
t = t(),
Tt(),
t)
  , qoe = {
    lang: "en",
    class: "page"
}
  , Woe = Ci('<div class="row justify-content-md-center" data-v-b46113bc><div class="col-md-8" data-v-b46113bc><h1 id="sweden" data-v-b46113bc>Sweden’s official announcement organ</h1><p data-v-b46113bc> The Official Swedish Gazette (Post- och Inrikes Tidningar, PoIT) is Sweden’s official announcement organ. PoIT contains announcements from authorities and others who have an obligation, in accordance with laws or ordinances, to announce in The Official Gazette in order for the information to come to the knowledge of the public. Information stipulated in articles of association, statutes or similar regulations must also be announced in PoIT. </p><p data-v-b46113bc> A typical announcer is Bolagsverket, the Swedish Companies Registration Office. All registrations in the Trade and Industry Register (Näringslivsregistret) must be announced, these announcements represent 90 per cent of all announcements. Other common announcements are the courts’ announcements of receiving orders (adjudication) in bankruptcy and all public limited companies announcing the summons to the shareholders’ meeting. </p><h2 id="readfree" data-v-b46113bc>Read free of charge</h2><p data-v-b46113bc> The announcements are accessible for two years as of the publication date except for the announcements of inheritance which are accessible for six years. </p><h2 id="paymentfornotice" data-v-b46113bc>Payment for notice in Post och Inrikes Tidningar</h2><p data-v-b46113bc> To be able to announce in the PoIT you must register as a customer. We charge a service fee for notices. If you submit your notice by using our e-service (in Swedish only) the cost is 14 Swedish kronor. If you submit your notice by email or post the fee is 70 Swedish kronor for each 100 characters. The text can be in English but the same text must be translated and published in Swedish. </p><h3 id="paymentbybank" data-v-b46113bc>Payment by bank giro</h3><p data-v-b46113bc> Bankgiro: <span aria-label="5 0 5 3 - 0 9 8 9" data-v-b46113bc>5053-0989</span> <br data-v-b46113bc> BIC/SWIFT: DABASESX <br data-v-b46113bc> IBAN: SE 21 1200 0000 0128 1011 2428 <br data-v-b46113bc><br data-v-b46113bc> Address to our bank, Danske Bank is:<br data-v-b46113bc> Danske Bank <br data-v-b46113bc> Norrmalmstorg 1 <br data-v-b46113bc> SE-103 92 Stockholm </p><h2 id="contactus" data-v-b46113bc>Contact us</h2><p data-v-b46113bc>Telephone: <span aria-label="+ 4 6 7 7 1 6 7 0 6 7 0" data-v-b46113bc>+46 771 670 670</span></p><h3 id="adress" data-v-b46113bc>Address</h3><address data-v-b46113bc><p data-v-b46113bc> Post- och Inrikes Tidningar<br data-v-b46113bc> Bolagsverket<br data-v-b46113bc> SE-851 81 Sundsvall <br data-v-b46113bc> Sweden </p></address></div></div>', 1)
  , Goe = {
    class: "row justify-content-md-center"
}
  , Yoe = {
    class: "col-md-8 text-start text-md-end"
}
  , Joe = zoe( () => c("hr", {
    class: "separator"
}, null, -1))
  , Xoe = {
    class: "btn btn-link",
    href: "#poit",
    title: "To the top of the page"
};
function Qoe(t, e, n, r, a, s) {
    const l = ue("i-bi-arrow-up");
    return g(),
    _("div", qoe, [Woe, c("div", Goe, [c("div", Yoe, [Joe, c("a", Xoe, [x(l, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "arrow up",
        focusable: "false"
    }), ve(" To the top ")])])])])
}
const Zoe = rt(Koe, [["render", Qoe], ["__scopeId", "data-v-b46113bc"]])
  , eue = Lr("kontaktaOss", {
    state: () => ({
        kontaktuppgifter: null
    }),
    actions: {
        async skickaMeddelande(t) {
            try {
                const e = "/poit/rest/KontaktaOss";
                await Pt.post(e, t)
            } catch {
                throw "Fel när meddelande skulle skickas"
            }
        },
        setKontaktuppgifter(t) {
            this.kontaktuppgifter = t
        }
    }
})
  , tue = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , nue = c("g", {
    fill: "currentColor",
    "fill-rule": "evenodd"
}, [c("path", {
    d: "M8.636 3.5a.5.5 0 0 0-.5-.5H1.5A1.5 1.5 0 0 0 0 4.5v10A1.5 1.5 0 0 0 1.5 16h10a1.5 1.5 0 0 0 1.5-1.5V7.864a.5.5 0 0 0-1 0V14.5a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h6.636a.5.5 0 0 0 .5-.5"
}), c("path", {
    d: "M16 .5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0 0 1h3.793L6.146 9.146a.5.5 0 1 0 .708.708L15 1.707V5.5a.5.5 0 0 0 1 0z"
})], -1)
  , rue = [nue];
function aue(t, e) {
    return g(),
    _("svg", tue, [...rue])
}
const GS = {
    name: "bi-box-arrow-up-right",
    render: aue
};
var sue = Object.defineProperty
  , lue = Object.getOwnPropertyDescriptor
  , iue = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? lue(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && sue(e, n, a),
    a
}
;
let Eh = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "avsandare", "");
        V(this, "epost", "");
        V(this, "meddelande", "");
        V(this, "telefonnummer", "");
        V(this, "amne", "");
        V(this, "visaKvittens", !1);
        V(this, "visaMeddelande", !1);
        V(this, "kvittensmeddelande", "Meddelande har skickats till POIT-redaktionen");
        V(this, "inputChk", !1)
    }
    skickaMeddelande() {
        var e = {
            avsandare: this.avsandare,
            epost: this.epost,
            meddelande: this.meddelande,
            telefonnummer: this.telefonnummer,
            amne: this.amne
        };
        this.avsandare = "",
        this.epost = "",
        this.meddelande = "",
        this.telefonnummer = "",
        this.amne = "",
        eue().skickaMeddelande(e),
        this.visaKvittens = !0,
        this.visaMeddelande = !0
    }
    get disabledSkicka() {
        return this.amne == "" || this.meddelande == "" || this.avsandare == "" || this.epost == "" || !this.isEpostGiltigt(this.epost)
    }
    isEpostGiltigt(e) {
        return e == "" && !this.inputChk ? null : lw(e)
    }
    isTelelphoneGiltigt() {
        return !0
    }
}
;
Eh = iue([Ct({
    components: {
        BFormTextarea: Em,
        BCard: $m,
        Meddelande: Ft,
        IBiBoxArrowUpRight: GS
    }
})], Eh);
const oue = Et(Eh)
  , uue = {
    class: "page"
}
  , due = c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("h1", {
    class: "py-3"
}, "Kontakta oss")])], -1)
  , cue = {
    class: "row"
}
  , fue = {
    class: "col-12 col-md-9"
}
  , pue = c("h2", null, "Skicka meddelande till oss", -1)
  , hue = {
    class: "btn-link",
    rel: "noopener",
    target: "_blank",
    title: "Länk öppnas i nytt fönster",
    href: "https://bolagsverket.se/om/oss/verksamhet/sa-behandlar-vi-dina-personuppgifter/dina-personuppgifter/kontakta-oss-formular-sa-behandlar-vi-personuppgifter-1.16670"
}
  , mue = c("p", {
    class: "alert blv-alert-info"
}, "Fält markerade med * måste du fylla i.", -1)
  , vue = c("div", {
    class: "col-12 col-md-3 order-md-first"
}, [c("h2", {
    class: "pt-2 pt-md-0"
}, "Ring oss"), ve(" Telefon: 0771-670 670"), c("br"), c("h2", {
    class: "mt-2"
}, "Adress"), ve(" Bolagsverket"), c("br"), ve(" Post- och Inrikes Tidningar "), c("br"), ve("851 81 Sundsvall ")], -1);
function gue(t, e, n, r, a, s) {
    const l = ue("i-bi-box-arrow-up-right")
      , i = ue("b-form-input")
      , o = ue("form-group")
      , u = ue("b-form-textarea")
      , d = ue("b-button")
      , f = ue("meddelande")
      , p = ue("b-form");
    return g(),
    _("div", uue, [due, c("div", cue, [c("div", fue, [pue, c("p", null, [c("a", hue, [ve("Så här behandlar vi dina personuppgifter när du kontaktar oss via vårt formulär "), x(l, {
        role: "img",
        class: "ms-2 b-icon bi",
        "aria-label": "box arrow up right",
        focusable: "false"
    })])]), mue, x(p, null, {
        default: N( () => [x(o, {
            class: "input-width label-style mt-3",
            label: "Ämne *",
            "label-for": "amne"
        }, {
            default: N( () => [x(i, {
                id: "amne",
                modelValue: t.amne,
                "onUpdate:modelValue": e[0] || (e[0] = h => t.amne = h),
                placeholder: "",
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(o, {
            class: "input-width label-style",
            label: "Meddelande *",
            "label-for": "meddelande"
        }, {
            default: N( () => [x(u, {
                id: "meddelande",
                modelValue: t.meddelande,
                "onUpdate:modelValue": e[1] || (e[1] = h => t.meddelande = h),
                placeholder: "",
                rows: "3",
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(o, {
            class: "input-width label-style",
            label: "Namn *",
            "label-for": "avsandare"
        }, {
            default: N( () => [x(i, {
                id: "avsandare",
                modelValue: t.avsandare,
                "onUpdate:modelValue": e[2] || (e[2] = h => t.avsandare = h),
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue"])]),
            _: 1
        }), x(o, {
            class: "input-width label-style",
            label: "E-postadress *",
            "label-for": "epost",
            invalidFeedback: "Ange giltig e-postadress"
        }, {
            default: N( () => [x(i, {
                type: "email",
                id: "epost",
                modelValue: t.epost,
                "onUpdate:modelValue": e[3] || (e[3] = h => t.epost = h),
                "aria-label": "Obligatoriskt fält",
                state: t.isEpostGiltigt(t.epost)
            }, null, 8, ["modelValue", "state"])]),
            _: 1
        }), x(o, {
            class: "input-width label-style",
            label: "Telefonnummer",
            "label-for": "telefonnummer",
            state: t.isTelelphoneGiltigt(),
            invalidFeedback: "Ange telefonnummer i format 0701234567"
        }, {
            default: N( () => [x(i, {
                type: "tel",
                id: "telefonnummer",
                modelValue: t.telefonnummer,
                "onUpdate:modelValue": e[4] || (e[4] = h => t.telefonnummer = h),
                placeholder: "",
                "aria-label": "Obligatoriskt fält"
            }, null, 8, ["modelValue"])]),
            _: 1
        }, 8, ["state"]), x(d, {
            class: "mb-5",
            variant: t.disabledSkicka ? "secondary" : "primary",
            disabled: t.disabledSkicka,
            onClick: e[5] || (e[5] = h => t.skickaMeddelande())
        }, {
            default: N( () => [ve("Skicka")]),
            _: 1
        }, 8, ["variant", "disabled"]), ft(c("div", null, [x(f, {
            meddelande: t.kvittensmeddelande,
            meddelandeTyp: "success"
        }, null, 8, ["meddelande"])], 512), [[jn, t.visaKvittens]])]),
        _: 1
    })]), vue])])
}
const bue = rt(oue, [["render", gue]])
  , yue = Se({
    name: "Hjälp",
    components: {
        IBiArrowUp: xv
    }
});
const kue = {
    class: "page"
}
  , _ue = Ci('<div class="row" data-v-a52f0e48><div class="col" data-v-a52f0e48><h1 id="omtjansten-titel" class="py-3" data-v-a52f0e48>Hjälp</h1></div></div><div class="row" data-v-a52f0e48><div class="col-md-4" data-v-a52f0e48><nav class="nav nav-pills flex-column sidindex mb-4" data-v-a52f0e48><a class="nav-link" href="#sweden" data-v-a52f0e48>Logga in</a><a class="nav-link" href="#read" data-v-a52f0e48>Sök kungörelse</a><a class="nav-link" href="#paymentf" data-v-a52f0e48>Lista kungörelse</a><a class="nav-link" href="#paymentb" data-v-a52f0e48>Registrera kungörelse</a><a class="nav-link" href="#contact" data-v-a52f0e48>Godkänn kungörelse</a><a class="nav-link" href="#adress" data-v-a52f0e48>Skicka kungörelse </a><a class="nav-link" href="#adress" data-v-a52f0e48>Rätta kungörelse </a><a class="nav-link" href="#adress" data-v-a52f0e48>Demo: Sök kungörelse </a><a class="nav-link" href="#adress" data-v-a52f0e48>Demo: Ingivning</a></nav></div><div class="col-md-8" data-v-a52f0e48><h1 id="sweden" data-v-a52f0e48>Logga in</h1><p data-v-a52f0e48> För att logga in i tjänsten måste du vara registrerad som kund hos Post- och Inrikes Tidningar. Det räcker inte med att vara kund i någon annan av Bolagsverkets tjänster t.ex. Näringslivsregistret eller EBR för att kunna kungöra </p><h3 id="read" data-v-a52f0e48>Användarnamn och lösenord</h3><p data-v-a52f0e48> Du loggar in med det användarnamn och lösenord som du, i samband med registreringen, fick i ett e-postmeddelande från Bolagsverket. Användarnamnet är den e-postadress som du registrerade för användaren. </p><h3 id="paymentf" data-v-a52f0e48>E-legitimation</h3><p data-v-a52f0e48> Om du registrerat dig med personnummer kan du logga in med din e-legitimation. </p><h1 id="paymentb" data-v-a52f0e48>Sök kungörelse</h1><h2 id="paymentb" data-v-a52f0e48>Enkel sökning</h2><p data-v-a52f0e48> I den enkla sökningen kan du söka på tidsperiod och kungörelsetext. I fältet Tidsperiod kan du i en rullgardinslista välja Senaste veckan, Senaste månaden eller Annan period. När du väljer Annan period får du ange två datum som du vill söka mellan.<br data-v-a52f0e48><br data-v-a52f0e48> I fältet Kungörelsetext söker du på ord som ska ingå i kungörelsetexten. I sökfältet anger du ett eller flera ord som ska ingå i texten. Du kan också skriva delar av ord. Till exempel ger sökning på kall en träfflista med förekomst av Kalle, kallelse, kallade osv. <br data-v-a52f0e48><br data-v-a52f0e48> OBS! När du söker på kungörelsetext får tidsperioden du söker på inte överstiga en månad. Du är inte begränsad till den senaste månaden men vill du leta bland äldre kungörelser måste du välja Annan period på tidsperiod och begränsa sökperioden till en månad. <br data-v-a52f0e48><br data-v-a52f0e48></p><h2 id="contact" data-v-a52f0e48>Avancerad sökning</h2><p data-v-a52f0e48> Börja din sökning genom att fylla i de olika fälten i sökformuläret. Du väljer själv hur många sökkriterier du vill använda. Klicka på &quot;Sök&quot; längst ner på sidan. Att söka på kungörelseobjektets namn eller nummer samt sökning på län ger bara träff i de fall kungörelsen innehåller en fysisk/juridisk person eller uppgift om län. De övriga sökkriterierna går alltid att använda. </p><h2 id="adress" data-v-a52f0e48>Resultaten i en träfflista</h2><p data-v-a52f0e48> Resultatet av sökningen visas i en träfflista som matchar sökkriterierna. Öppna den kungörelse du vill läsa genom att klicka på länken i kolumnen kungörelse-id. Du kan alltid ta dig tillbaka till träfflistan genom att klicka på &quot;Tillbaka&quot; längst ned på sidan. Sweden </p><h2 id="adress" data-v-a52f0e48>Dagens kungörelser</h2><p data-v-a52f0e48> På startsidan finns ett urval av dagens kungörelser. Rubrikerna är länkade och tar dig direkt till kungörelserna. </p><h2 id="adress" data-v-a52f0e48>Lista kungörelse</h2><p data-v-a52f0e48> När du söker efter kungörelser presenteras en lista på de kungörelser som matchar dina sökkriterier. Varje rad motsvarar en träff i kungörelseregistret. I grundläget är de sorterade efter publiceringsdatum med de äldsta kungörelserna överst. Genom att klicka på de olika rubrikerna kan du själv välja vilken av rubrikerna kungörelserna ska sorteras efter. </p><h2 id="adress" data-v-a52f0e48>Dagens kungörelser</h2><p data-v-a52f0e48> På startsidan finns ett urval av dagens kungörelser. Rubrikerna är länkade och tar dig direkt till kungörelserna.<br data-v-a52f0e48><br data-v-a52f0e48> När du vill läsa en kungörelse i listan klickar du på numret i kolumnen &quot;Kungörelse-id&quot; för att få upp den kungörelsen på skärmen. När du läst kungörelsen klickar du på knappen &quot;Tillbaka&quot; för att komma tillbaka till träfflistan.<br data-v-a52f0e48><br data-v-a52f0e48> Observera att samma kungörelse kan generera flera träffar och alltså visas på flera rader i träfflistan, men med hjälp av kungörelse-id kan du alltid avgöra om det är samma kungörelse.<br data-v-a52f0e48><br data-v-a52f0e48> På varje sida visas max 20 träffar och som mest visas 25 sidor, alltså 500 träffar. Vill du minska antalet träffar kan du ange fler sökkriterier och därigenom avgränsa sökningen. </p><h1 id="adress" data-v-a52f0e48>Registrera kungörelse</h1><h2 id="adress" data-v-a52f0e48>Välj uppdragsgivare</h2><p data-v-a52f0e48> Om du är registrerad som användare på flera kundkonton måste du först välja vilken kund du ska kungöra åt vid detta tillfälle. Det gör du i den rullgardinslista som finns under &quot;Välj uppdragsgivare&quot;. </p><h2 id="adress" data-v-a52f0e48>Välj alternativ faktureringsadress</h2><p data-v-a52f0e48> Därefter kontrollerar du att uppgifterna om uppgiftslämnaren stämmer. Om du vill ange en annan faktureringsadress för den aktuella kungörelsen kryssar du i den rutan och anger adressen i de fält som öppnas. </p><h2 id="adress" data-v-a52f0e48>Välj rubrik och hämta formulär</h2><p data-v-a52f0e48> Ange en rubrik och eventuell underrubrik för din kungörelse. Välj därefter &quot;Hämta formulär&quot; för att gå vidare. </p><h2 id="adress" data-v-a52f0e48>Fyll i formuläret</h2><p data-v-a52f0e48> I vissa formulär behöver du bara fylla i de uppgifter som gäller för din kungörelse, sedan genereras texten automatiskt, efter våra mallar. De kungörelser där detta gäller är: konkursbeslut, utdelningsförslag, efterutdelningsförslag, bevakningsförfarande, inledande av skuldsanering, beslut om skuldsanering, ingivande av bodelningshandlingar, anmälan om bodelning, anordnande av förvaltarskap, anordnande av godmanskap, anordnande av begränsat förvaltarskap, anordnande av utökat förvaltarskap, jämkning av förvaltarskap, upphörande av förvaltarskap och gåva mellan makar.<br data-v-a52f0e48><br data-v-a52f0e48> För resterande kungörelser består formuläret endast av ett fåtal fält där du fyller i eventuellt namn och person- eller organisationsnummer på den kungörelsen avser samt eventuellt datum som gäller för kungörelsen. Det finns ett fritextfält där du fyller i din kungörelsetext.<br data-v-a52f0e48><br data-v-a52f0e48> OBS! Det är endast det du skriver i fritextfältet som kommer att synas i kungörelsen. Du måste själv se till att alla uppgifter kommer med i din text. </p><h2 id="adress" data-v-a52f0e48>Lägg till kungörelse</h2><p data-v-a52f0e48> För att godkänna kungörelsen klickar du först på &quot;Lägg till kungörelse&quot;. Kungörelsen visas i en blå ram innehållande nummer, namn, referens och tre symboler. Symbolerna ger dig möjlighet att radera (krysset), förhandsgranska (förstoringsglaset) eller redigera (symbolen längst till höger) kungörelsen.<br data-v-a52f0e48><br data-v-a52f0e48> När du är klar med detta steg klickar du på &quot;Granska och godkänn&quot; för att gå vidare. </p><h1 id="adress" data-v-a52f0e48>Godkänn kungörelse</h1><p data-v-a52f0e48> Läs igenom texten och kontrollera att allt stämmer. Du ansvarar själv för att uppgifterna är korrekta.<br data-v-a52f0e48><br data-v-a52f0e48> Välj antingen att godkänna och skicka kungörelsen eller att gå tillbaka för att redigera eller radera den. </p><h1 id="adress" data-v-a52f0e48>Skicka kungörelse</h1><p data-v-a52f0e48> Läs igenom texten och kontrollera att allt stämmer. Du ansvarar själv för att uppgifterna är korrekta. Välj antingen att godkänna och skicka kungörelsen eller att gå tillbaka för att redigera eller radera den.<br data-v-a52f0e48><br data-v-a52f0e48> Välj antingen att godkänna och skicka kungörelsen eller att gå tillbaka för att redigera eller radera den.<br data-v-a52f0e48><br data-v-a52f0e48> Efter att du har godkänt och skickat kungörelsen kommer den till Post- och Inrikes Tidningars redaktion som tar hand om och publicerar den. </p><h2 id="adress" data-v-a52f0e48>Skriv ut</h2><p data-v-a52f0e48> Om du väljer ”Skriv ut” får du en papperskopia på din kungörelse. </p><h1 id="adress" data-v-a52f0e48>Rätta kungörelse</h1><p data-v-a52f0e48> Du kan rätta en kungörelse som du har publicerat. Det gör du genom att logga in i tjänsten och klicka på Publicerade kungörelser eller Sök kungörelse. När du hittat den kungörelse du vill rätta, klickar du på det Kungörelse-id som rättelsen gäller. </p><h2 id="adress" data-v-a52f0e48>Steg 1 Rättelse – uppgiftslämnare och kungörelsetyp</h2><p data-v-a52f0e48> I det här steget kan du ändra faktureringsadress och kungörelsetyp. Du går vidare genom att klicka på Hämta formulär. </p><h2 id="adress" data-v-a52f0e48>Steg 2 Rätta kungörelse</h2><p data-v-a52f0e48> Här ser du uppgifterna från ursprungskungörelsen. Du kan ändra alla uppgifter.<br data-v-a52f0e48><br data-v-a52f0e48> Om du vill ändra något under rubriken Kungörelsen avser, lägger du till den nya uppgiften och tar bort den felaktiga genom att klicka på krysset. När du är klar klickar du på Granska och godkänn rättning. </p><h2 id="adress" data-v-a52f0e48>Steg 3, Godkänn kungörelse</h2><p data-v-a52f0e48> Här ser du din rättade kungörelse. Om du vill skicka in din rättelse klickar du på Godkänn och skicka. </p><h2 id="adress" data-v-a52f0e48>Steg 4, Din registrering är nu klar e</h2><p data-v-a52f0e48> Här ser du en bekräftelse på rättelsen och ditt nya kungörelse-id. </p><h1 id="adress" data-v-a52f0e48>Demo: Sök kungörelse</h1><h2 id="adress" data-v-a52f0e48>Fyll i sökkriterier</h2><p data-v-a52f0e48> När du vill söka en kungörelse går du in under rubriken &quot;Sök kungörelse&quot; i vänstermenyn och fyller i sökformuläret på sidan. Du väljer själv hur många sökkriterier du vill använda.<br data-v-a52f0e48><br data-v-a52f0e48> Använd rullgardinslistorna för att ange dina sökkriterier. Efter att du har fyllt i formuläret klickar du på &quot;Sök&quot;.<br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Resultaten i en träfflista</h2><p data-v-a52f0e48> Resultaten av sökningen visas i en träfflista som matchar sökkriterierna. Öppna den kungörelse du vill läsa genom att klicka på länken i kolumnen kungörelse-id.<br data-v-a52f0e48><br data-v-a52f0e48> Du kan alltid ta dig tillbaka till träfflistan genom att klicka på &quot;Tillbaka&quot; längst ner på sidan.<br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Kungörelsen visas</h2><p data-v-a52f0e48> När du klickat på den kungörelse du vill läsa visas den på skärmen.<br data-v-a52f0e48><br data-v-a52f0e48> Backa tillbaka till träfflistan genom att klicka på &quot;Tillbaka&quot;. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h1 id="adress" data-v-a52f0e48>Demo: Ingivning</h1><h2 id="adress" data-v-a52f0e48>Logga in</h2><p data-v-a52f0e48> Som kund startar du din ingivning genom att logga in med det användarnamn (din registrerade e-postadress) och lösenord du fått från Bolagsverket. Du kan även logga in med en e-legitimation. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Välj kungörelserubrik</h2><p data-v-a52f0e48> Välj rubriken ”Registrera kungörelse” i menyraden till vänster. I rullgardinslistan väljer du lämplig kungörelserubrik med eventuell underrubrik. Klicka på ”Hämta formulär” för att gå vidare. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Registrera kungörelse, steg 1, specifikt formulär</h2><h2 id="adress" data-v-a52f0e48>Fyll i formuläret</h2><p data-v-a52f0e48> Du får upp ett formulär där du ska fylla i de uppgifter som behövs för din kungörelse. Fält med en asterisk är obligatoriska fält. <br data-v-a52f0e48><br data-v-a52f0e48> Efter att formuläret är ifyllt avslutar du med att klicka på ”Lägg till kungörelse”.<br data-v-a52f0e48><br data-v-a52f0e48> Kungörelsen visas längst ner på sidan i en blå ram innehållande nummer, namn, referens och tre symboler. Symbolerna ger möjlighet att radera (krysset), förhandsgranska (förstoringsglaset) eller redigera kungörelsen (symbolen längst till höger).<br data-v-a52f0e48><br data-v-a52f0e48> Om du vill registrera fler kungörelser med samma rubrik kan du fylla i nya uppgifter i formuläret som nu är blankt.<br data-v-a52f0e48><br data-v-a52f0e48> När du är klar med kungörelsen/kungörelserna klickar du på knappen ”Granska och godkänn”. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Specifikt formulär</h2><p data-v-a52f0e48> När du fyller i ett specifikt formulär fyller du bara i de uppgifter som ska ingå i kungörelsetexten. Själva texten genereras automatiskt enligt våra mallar. När du registrerat din kungörelse ser du hela texten i en förhandsgranskning och kan då se att allt har blivit rätt. <br data-v-a52f0e48><br data-v-a52f0e48> Specifika formulär används vid registrering av följande kungörelserubriker: konkursbeslut, utdelningsförslag, efterutdelningsförslag, bevakningsförfarande, inledande av skuldsanering, beslut om skuldsanering, ingivande av bodelningshandlingar, anmälan om bodelning, anordnande av förvaltarskap, anordnande av godmanskap, anordnande av begränsat förvaltarskap, anordnande av utökat förvaltarskap, jämkning av förvaltarskap, upphörande av förvaltarskap och gåva mellan makar. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Registrera kungörelse, steg 1, generellt formulär</h2><h2 id="adress" data-v-a52f0e48>Fyll i formuläret</h2><p data-v-a52f0e48> Du får upp ett formulär där du ska fylla i de uppgifter som behövs för din kungörelse. Fält med en asterisk är obligatoriska fält.<br data-v-a52f0e48><br data-v-a52f0e48> Efter att formuläret är ifyllt avslutar du med att klicka på ”Lägg till kungörelse”.<br data-v-a52f0e48><br data-v-a52f0e48> Kungörelsen visas längst ner på sidan i en blå ram innehållande nummer, namn, referens och tre symboler. Symbolerna ger möjlighet att radera (krysset), förhandsgranska (förstoringsglaset) eller redigera kungörelsen (symbolen längst till höger).<br data-v-a52f0e48><br data-v-a52f0e48> Om du vill registrera en till kungörelse av samma rubrik kan du fylla i nya uppgifter i formuläret som nu är blankt.<br data-v-a52f0e48><br data-v-a52f0e48> När du är klar med kungörelsen/kungörelserna klickar du på knappen ”Granska och godkänn”.<br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Generellt formulär</h2><p data-v-a52f0e48> I generella formuläret skriver du själv hela texten som ska ingå i kungörelsen. Det gör du i det stora fritextfältet som finns i formuläret. Det är bara det du skriver i det fältet som syns i den slutliga kungörelsen så det är viktigt att du får med all information i texten.<br data-v-a52f0e48><br data-v-a52f0e48> Det generella formuläret används för alla kungörelserubriker utom de som använder det specifika formuläret (se ovan).<br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Godkänn kungörelse</h2><h2 id="adress" data-v-a52f0e48>Granska din kungörelse</h2><p data-v-a52f0e48> Kungörelsetexten visas nu som den kommer att visas på webbsidan. Om du har lagt in flera kungörelser visas de under varandra, numrerade som &quot;Kungörelse nr 1&quot; osv. Du väljer om du vill godkänna och skicka kungörelsen/kungörelserna för publicering eller gå tillbaka för att redigera eller radera den/dem. <br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p><h2 id="adress" data-v-a52f0e48>Registreringen klar</h2><p data-v-a52f0e48> På skärmen visas hur hela kungörelsen kommer att se ut när den publiceras. </p><h2 id="adress" data-v-a52f0e48>Registrera ny kungörelse</h2><p data-v-a52f0e48> Väljer du &quot;Registrera ny kungörelse&quot; kommer du tillbaka till Steg 1, Välj kungörelsetyp och får välja ny kungörelserubrik och kan registrera nya kungörelser. </p><h2 id="adress" data-v-a52f0e48>Skriv ut kungörelsen</h2><p data-v-a52f0e48> Väljer du &quot;Skriv ut&quot; får du en pappersutskrift av kungörelsen.<br data-v-a52f0e48><br data-v-a52f0e48> Du har nu lämnat in din registrering till Post- och Inrikes Tidningar och den tas om hand av redaktionen på Bolagsverket.<br data-v-a52f0e48><br data-v-a52f0e48> (bild?) </p></div></div>', 2)
  , wue = {
    class: "row"
}
  , xue = {
    class: "col"
}
  , Sue = {
    class: "btn btn-link",
    href: "#poit"
};
function $ue(t, e, n, r, a, s) {
    const l = ue("i-bi-arrow-up");
    return g(),
    _("div", kue, [_ue, c("div", wue, [c("div", xue, [c("a", Sue, [x(l, {
        role: "img",
        class: "b-icon bi",
        "aria-label": "arrow up",
        focusable: "false"
    }), ve(" Till toppen ")])])])])
}
const Tue = rt(yue, [["render", $ue], ["__scopeId", "data-v-a52f0e48"]])
  , Cue = Se({
    title: "Villkor"
})
  , Eue = {
    class: "page"
}
  , Aue = Ci('<div class="row"></div><div class="row justify-content-md-center"><div class="col-md-8"><h1 id="vilkor">Villkor för Post- och Inrikes Tidningar</h1><h2>Skyldigheter vid användning av e-tjänsten</h2><p> Du får bara spara information från Post– och Inrikes Tidningar (PoIT) i en begränsad omfattning och endast för din egen eller yrkesmässiga användning. </p><p> Du får bara vidarebefordra information från PoIT om det görs som en del av din näringsverksamhet och avser en begränsad mängd information. </p><p> Du ansvarar för att du använder informationen som du fått genom PoIT i enlighet med dataskyddsförordningen och lagen (1960:729) om upphovsrätt till litterära och konstnärliga verk eller andra författningar. </p><p> Om du använder tjänsten på ett otillåtet sätt eller med syfte att överbelasta den innebär det att du gör dig skyldig till dataintrång. Det är ett brott som kan leda till böter eller fängelse. </p><h2>Vi kan neka dig att använda e-tjänsten</h2><p> För att hålla PoIT öppet för alla kan Bolagsverket utan meddelande stänga av en användare som utnyttjar tjänsten så att det riskerar tillgängligheten för andra. Det gäller även om en användare antas använda tjänsten på ett otillåtet sätt. Bolagsverket kan också begränsa antalet sökningar som en användare kan göra under en viss tid. </p><h2>Vi loggar all användning</h2><p> Vi loggar all användning av tjänsten. Vi kan komma att kontrollera loggarna i förebyggande syfte och vid misstanke om brott. </p></div></div>', 2)
  , Mue = [Aue];
function Oue(t, e, n, r, a, s) {
    return g(),
    _("div", Eue, Mue)
}
const Nue = rt(Cue, [["render", Oue]]);
var Due = Object.defineProperty
  , Pue = Object.getOwnPropertyDescriptor
  , Fue = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Pue(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Due(e, n, a),
    a
}
;
let Ah = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "kungorelsetyp", {})
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    get savedKungorelse() {
        return Pe().savedKungorelse
    }
    formateraPersOrgNr(n) {
        return n && qn(n)
    }
    fixLink(n) {
        return n.replaceAll("/", "-")
    }
    showTillbaka() {
        return window.history.length > 1
    }
    tillbaka() {
        this.$router.back()
    }
    print() {
        window.print()
    }
    loadKungorelsetyp(n) {
        Pe().getKungorelsetyp(n).then( () => {
            this.kungorelsetyp = Pe().loadedKungorelsetyp
        }
        )
    }
    created() {
        this.loadKungorelsetyp(Pe().savedKungorelse.rubrikExternKod)
    }
}
;
Ah = Fue([Ct({
    components: {
        Meddelande: Ft,
        BSpinner: er
    }
})], Ah);
const Bue = Et(Ah);
const $l = t => ($t("data-v-9af859eb"),
t = t(),
Tt(),
t)
  , Vue = {
    class: "page"
}
  , Iue = {
    key: 0
}
  , Rue = {
    class: "d-flex justify-content-center mb-3"
}
  , Lue = {
    key: 1
}
  , jue = {
    class: "alert blv-alert-info blv-alert-print"
}
  , Uue = {
    key: 0,
    class: "row"
}
  , Hue = {
    class: "col-md-12"
}
  , Kue = {
    class: "py-3"
}
  , zue = {
    class: "d-md-inline py-1 me-md-3"
}
  , que = {
    key: 0,
    class: "mt-3"
}
  , Wue = {
    class: "row"
}
  , Gue = {
    class: "col-12 col-lg-10 col-xl-8 pt-4"
}
  , Yue = {
    key: 0,
    class: "row"
}
  , Jue = $l( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Namn/fastighetsbeteckning")], -1))
  , Xue = {
    class: "col-md-8"
}
  , Que = {
    class: "nowrap"
}
  , Zue = {
    key: 1,
    class: "row"
}
  , ede = {
    class: "col-md-4"
}
  , tde = {
    class: "label"
}
  , nde = {
    class: "col-md-8"
}
  , rde = {
    id: "datum"
}
  , ade = {
    key: 2,
    class: "row"
}
  , sde = $l( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Län")], -1))
  , lde = {
    class: "col-md-8"
}
  , ide = {
    id: "lan"
}
  , ode = {
    key: 3,
    class: "row"
}
  , ude = $l( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Publiceringsdatum")], -1))
  , dde = {
    class: "col-md-8"
}
  , cde = {
    id: "publiceringsdatum"
}
  , fde = {
    key: 4,
    class: "row"
}
  , pde = $l( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Kungörelse-id")], -1))
  , hde = {
    class: "col-md-8"
}
  , mde = {
    id: "kungorelseid"
}
  , vde = {
    class: "row"
}
  , gde = $l( () => c("div", {
    class: "col-md-4"
}, [c("p", {
    class: "label"
}, "Uppgiftslämnare")], -1))
  , bde = {
    class: "col-md-8"
}
  , yde = {
    id: "kund"
}
  , kde = {
    class: "col-12"
}
  , _de = {
    class: "mt-3"
}
  , wde = {
    class: "infobox p-4 border blv-border-light bg-white"
}
  , xde = $l( () => c("h4", null, "Kungörelsetext", -1))
  , Sde = ["innerHTML"]
  , $de = $l( () => c("div", {
    class: "row"
}, [c("div", {
    class: "col"
}, [c("hr")])], -1))
  , Tde = {
    class: "d-flex mb-2"
}
  , Cde = {
    key: 0
}
  , Ede = {
    key: 1
};
function Ade(t, e, n, r, a, s) {
    const l = ue("b-spinner")
      , i = ue("meddelande")
      , o = ue("router-link")
      , u = ue("b-form");
    return g(),
    _("div", Vue, [t.savedKungorelse == null ? (g(),
    _("div", Iue, [c("div", Rue, [x(l, {
        label: "Laddar..."
    })])])) : (g(),
    _("div", Lue, [c("div", null, [x(i, {
        meddelande: "Din rättning är nu sparad",
        meddelandeTyp: "info"
    })]), c("div", null, [c("p", jue, [ve(" Rättelse av tidigare kungörelse: "), x(o, {
        to: {
            name: "kungorelse",
            params: {
                kungorelseid: t.fixLink(t.savedKungorelse.ersatter)
            }
        }
    }, {
        default: N( () => [ve(Q(t.savedKungorelse.ersatter), 1)]),
        _: 1
    }, 8, ["to"])])]), Object.keys(t.kungorelsetyp).length && Object.keys(t.kungorelsetyp.amnesOmrade).length && t.kungorelsetyp.amnesOmrade.namn != null ? (g(),
    _("div", Uue, [c("div", Hue, [c("h1", Kue, Q(t.kungorelsetyp.amnesOmrade.namn), 1), c("h2", zue, Q(t.savedKungorelse.rubrik), 1), t.savedKungorelse.underrubrik != null && t.savedKungorelse.underrubrik != "" ? (g(),
    _("h3", que, Q(t.savedKungorelse.underrubrik), 1)) : q("", !0)])])) : q("", !0), x(u, null, {
        default: N( () => [c("div", Wue, [c("div", Gue, [t.savedKungorelse.fysiskaJuridiskaPersoner != null && t.savedKungorelse.fysiskaJuridiskaPersoner.length > 0 ? (g(),
        _("div", Yue, [Jue, c("div", Xue, [(g(!0),
        _(we, null, Ne(t.savedKungorelse.fysiskaJuridiskaPersoner, (d, f) => (g(),
        _("p", {
            id: "fysjur",
            key: f
        }, [ve(Q(d.namn) + ", ", 1), c("span", Que, Q(t.formateraPersOrgNr(d.nummer)), 1)]))), 128))])])) : q("", !0), Object.keys(t.kungorelsetyp).length && t.savedKungorelse.typDatum != null && t.savedKungorelse.typDatum != "" ? (g(),
        _("div", Zue, [c("div", ede, [c("p", tde, Q(t.kungorelsetyp.datumTyp), 1)]), c("div", nde, [c("p", rde, Q(t.savedKungorelse.typDatum), 1)])])) : q("", !0), t.savedKungorelse.lan != null && t.savedKungorelse.lan != "" ? (g(),
        _("div", ade, [sde, c("div", lde, [c("p", ide, Q(t.savedKungorelse.lan), 1)])])) : q("", !0), t.savedKungorelse.publiceringsDatum != null && t.savedKungorelse.publiceringsDatum != "" ? (g(),
        _("div", ode, [ude, c("div", dde, [c("p", cde, Q(t.savedKungorelse.publiceringsDatum), 1)])])) : q("", !0), t.savedKungorelse.kungorelseid != null && t.savedKungorelse.kungorelseid != "" ? (g(),
        _("div", fde, [pde, c("div", hde, [c("p", mde, Q(t.savedKungorelse.kungorelseid), 1)])])) : q("", !0), c("div", vde, [gde, c("div", bde, [c("p", yde, Q(t.savedKungorelse.uppgiftslamnare), 1)])])]), c("div", kde, [c("div", _de, [c("div", wde, [xde, c("div", {
            innerHTML: t.savedKungorelse.kungorelseText
        }, null, 8, Sde)])])])]), $de, c("div", Tde, [t.showTillbaka() ? (g(),
        _("div", Cde, [c("button", {
            type: "button",
            class: "btn btn-link",
            onClick: e[0] || (e[0] = d => t.tillbaka())
        }, "« Tillbaka")])) : q("", !0), t.savedKungorelse.kungorelseid && t.savedKungorelse.kungorelseid != "" ? (g(),
        _("div", Ede, [c("button", {
            type: "button",
            class: "btn blv-color btn-primary ms-2",
            onClick: e[1] || (e[1] = d => t.print())
        }, "Skriv ut")])) : q("", !0)])]),
        _: 1
    })]))])
}
const Mde = rt(Bue, [["render", Ade], ["__scopeId", "data-v-9af859eb"]])
  , ba = (t, e, n) => {
    dt().isLoggedin || n({
        name: "loggain"
    }),
    n()
}
  , Ode = NA({
    history: iA("/poit-app"),
    scrollBehavior(t, e, n) {
        return t.meta.savedPosition = n,
        !1
    },
    routes: [{
        path: "/:pathMatch(.*)*",
        name: "404",
        component: NF,
        meta: {
            title: "404, sidan kan inte hittas"
        }
    }, {
        path: "/sok",
        name: "sok",
        component: TF,
        meta: {
            title: "Sök"
        }
    }, {
        path: "/sok-arsredovisning",
        name: "sok-arsredovisning",
        component: TB,
        meta: {
            title: "Sök Årsredovisning"
        }
    }, {
        path: "/",
        name: "home",
        component: W3,
        meta: {
            title: "Start"
        }
    }, {
        path: "/mina-uppgifter",
        name: "minauppgifter",
        component: S6,
        beforeEnter: ba,
        meta: {
            title: "Mina uppgifter"
        }
    }, {
        path: "/mina-kunder",
        name: "minakunder",
        component: X6,
        beforeEnter: ba,
        meta: {
            title: "Mina kunder"
        }
    }, {
        path: "/publicerade-kungorelser",
        name: "publiceradekungorelser",
        component: vV,
        beforeEnter: ba,
        meta: {
            title: "Publicerade kungörelser"
        }
    }, {
        path: "/mina-uppgifter/byt-losenord",
        name: "bytlosenord",
        component: DV,
        beforeEnter: ba,
        meta: {
            title: "Byt lösenord"
        }
    }, {
        path: "/sok-faktura",
        name: "sokfaktura",
        component: JV,
        beforeEnter: ba,
        meta: {
            title: "Sök faktura"
        }
    }, {
        path: "/sok-faktura/visa-faktura",
        name: "visafaktura",
        component: l8,
        beforeEnter: ba,
        meta: {
            title: "Visa faktura"
        }
    }, {
        path: "/granska-kungorelse",
        name: "granskakungorelse",
        component: Yb,
        beforeEnter: ba,
        meta: {
            title: "Granska kungörelse"
        }
    }, {
        path: "/kungorelse/:kungorelseid",
        name: "kungorelse",
        component: Yb,
        meta: {
            title: "Kungörelse"
        }
    }, {
        path: "/enskild/:kungorelseid",
        name: "enskild",
        component: _R,
        meta: {
            title: "Enskild"
        }
    }, {
        path: "/arsredovisning/:orgnummer",
        name: "arsredovisning",
        component: gL,
        meta: {
            title: "årsredovisning"
        }
    }, {
        path: "/urval-senaste-publiceringar/:amnesomrade/:kungorelsetyp?",
        name: "visasenastepubliceringar",
        component: ML,
        meta: {
            title: "Urval senaste publicerade kungörelser"
        }
    }, {
        path: "/urval-senaste-arsredovisningar",
        name: "visasenastearsredovisningar",
        component: KL,
        meta: {
            title: "Urval senaste publicerade årsredovisningar"
        }
    }, {
        path: "/registrera",
        name: "registrera",
        component: hse,
        beforeEnter: ba,
        meta: {
            title: "Registrera kungörelse"
        }
    }, {
        path: "/andra",
        name: "editera",
        component: ole,
        beforeEnter: ba,
        meta: {
            title: "Ändra kungörelse"
        }
    }, {
        path: "/logga-in",
        name: "loggain",
        component: Tle,
        meta: {
            title: "Logga in"
        }
    }, {
        path: "/logga-in/glomt-losenord",
        name: "glomtlosenord",
        component: Lle,
        meta: {
            title: "Glömt lösenord"
        }
    }, {
        path: "/bli-kund",
        name: "blikund",
        component: _oe,
        meta: {
            title: "Bli kund"
        }
    }, {
        path: "/om-tjansten",
        name: "omtjansten",
        component: Hoe,
        meta: {
            title: "Om tjänsten"
        }
    }, {
        path: "/in-english",
        name: "inenglish",
        component: Zoe,
        meta: {
            title: "In English"
        }
    }, {
        path: "/kontakta-oss",
        name: "kontaktaoss",
        component: bue,
        meta: {
            title: "Kontakta oss"
        }
    }, {
        path: "/hjalp",
        name: "hjalp",
        component: Tue,
        meta: {
            title: "Hjälp"
        }
    }, {
        path: "/villkor",
        name: "villkor",
        component: Nue,
        meta: {
            title: "Villkor"
        }
    }, {
        path: "/kvittoRattalse",
        name: "kvittorattelse",
        component: Mde,
        meta: {
            title: "Kvitto Rattelse"
        }
    }]
})
  , Nde = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Dde = c("path", {
    fill: "currentColor",
    "fill-rule": "evenodd",
    d: "M2.5 12a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5m0-4a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1-.5-.5"
}, null, -1)
  , Pde = [Dde];
function Fde(t, e) {
    return g(),
    _("svg", Nde, [...Pde])
}
const Bde = {
    name: "bi-list",
    render: Fde
}
  , Vde = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Ide = c("g", {
    fill: "currentColor",
    "fill-rule": "evenodd"
}, [c("path", {
    d: "M6 3.5a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-2a.5.5 0 0 0-1 0v2A1.5 1.5 0 0 0 6.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 14.5 2h-8A1.5 1.5 0 0 0 5 3.5v2a.5.5 0 0 0 1 0z"
}), c("path", {
    d: "M11.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H1.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708z"
})], -1)
  , Rde = [Ide];
function Lde(t, e) {
    return g(),
    _("svg", Vde, [...Rde])
}
const jde = {
    name: "bi-box-arrow-in-right",
    render: Lde
}
  , Ude = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em"
}
  , Hde = c("g", {
    fill: "currentColor",
    "fill-rule": "evenodd"
}, [c("path", {
    d: "M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0z"
}), c("path", {
    d: "M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708z"
})], -1)
  , Kde = [Hde];
function zde(t, e) {
    return g(),
    _("svg", Ude, [...Kde])
}
const qde = {
    name: "bi-box-arrow-in-left",
    render: zde
};
var Wde = Object.defineProperty
  , Gde = Object.getOwnPropertyDescriptor
  , YS = (t, e, n, r) => {
    for (var a = r > 1 ? void 0 : r ? Gde(e, n) : e, s = t.length - 1, l; s >= 0; s--)
        (l = t[s]) && (a = (r ? l(e, n, a) : l(a)) || a);
    return r && a && Wde(e, n, a),
    a
}
;
let Od = class extends Jt {
    constructor() {
        super(...arguments);
        V(this, "wrapActive", !1);
        V(this, "secondwrapActive", !1)
    }
    get kundanvandare() {
        return dt().kundanvandare
    }
    setRensaSokHistorik(e) {
        Pe().setRensaSokHistorik(e)
    }
    propertyWatcher(e, n) {
        document.title = e.meta.title + " | Post- och Inrikes Tidningar (PoIT) - Bolagsverket"
    }
    get layout() {
        return "default-layout"
    }
    get() {
        return "default-layout"
    }
    toggleMenu() {
        this.wrapActive = !this.wrapActive
    }
    closeMenu() {
        this.wrapActive = !1,
        this.setRensaSokHistorik(!0)
    }
    loggaut() {
        dt().loggaUt(),
        this.$router.push({
            name: "home"
        }),
        window.location.reload()
    }
}
;
YS([V2("$route", {
    immediate: !0
})], Od.prototype, "propertyWatcher", 1);
Od = YS([Ct({
    components: {
        IBiX: _l,
        IBiList: Bde,
        IBiBoxArrowUpRight: GS,
        IBiBoxArrowInRight: jde,
        IBiBoxArrowInLeft: qde
    }
})], Od);
const Yde = Et(Od)
  , Jde = "/poit-app/assets/poit-logo-d6ad7fef.png"
  , Xde = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKYAAAAkCAYAAAAD8EGkAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QzY4NEUxQkFFQkVDMTFFM0ExMzNFRTJFRThCODJENkMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QzY4NEUxQkJFQkVDMTFFM0ExMzNFRTJFRThCODJENkMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpDNjg0RTFCOEVCRUMxMUUzQTEzM0VFMkVFOEI4MkQ2QyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpDNjg0RTFCOUVCRUMxMUUzQTEzM0VFMkVFOEI4MkQ2QyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqWJQOYAAAvkSURBVHja7FwNWFbVHb/IhxhMsaVm5me6Gm7ONsRMLZ0uzbCZ1trQ1Ky0t7X82qrJMLMe+1gfTiNsTk3H0jHBWDimhWa25Yy5mKHLLDGHOjVAUORDYL//y+/m8XTu5UXwUfP+n+f/nPee73vO7/y/zoWg2tpayyOPzjdq5i2BRx4wPfLIA6ZHFzIFuRXWbo2S8h+DbwZXgVcHxRZnecvm0dki2+epD5i/RXKflp0AcM7zltCjcwJMgLI3kn8Zik6CrwA4D3vL6NHZAmYIQRiOZIQADpwD0G1B+h2HttImGm02I/0B+GrwR+A30a7GW1qPmsTGBMA6I30L3F3JTwEvBm9yaHcNeAm4v5L3N7FFAc5Sb1kvbOrYsYNgYQB46759BTvOlcRcqIFSaBx4PTiLjo9Ki8ATNVBafE4AP+rwstOQTHOQwNXgT8AZ4FewGOVNtMD5SKLQX5QHtwaRgHIZeDp4x7mYQAjVsYmGgm8DPwwebnvl4JfB/3BoM8RlLAGHSOd94ELwUTkgLLsMfAN4MHgSADUEYDri4eMrL5l/hyQGPBD7XaoDswjc3tCuGGq5AukTZNUxKnYY62gA85mNSbxqmGQ7mge3gOdTanv01abu9GWC9QIJsCcbGlQRJE70skN+0pnOEGD9H5J48HHwGAC1ubdvFy+JxJxHgE4FtwbvFFsQ0vLfjh5TbPEaSM1J+DkXfCX4vyIJJb8xkwE4SwDInRTvIkE/O4/VUDDmW93ANi255iVoe7IJ59ICSRfa6nvQd5VDvSiaVAfFjsdzR7YTrbkDeTUBjNUKSVdRnKif6zCX68GXgkXYbEG9Sq1OJKVlJLO+jbxSmnj+PQ8JWpYikxGVXQb+mqhwWTjLihOVLZN+iXao1EkVg1g8b7Qro3QTEmelUtoEQK1cXlriqhKyquFi6eWhSHzg0eBONB02gp/Dy+9v4GZGIJlBO/oqsPR9mNGFZ9HfBw7t7qFT0BO/xUb+J/gR8OOywLqjxY2aBb4b3IHZlciXdkuFBRB4/it+DxM7G89vG8ZdadXdwo1CeQbzLkHyPJ3RcNucQr44tHMMB2cOBdA9qDMe6Y1K2Q7k3Y42O13WTMZbB+4LngnO1crvR/IMuKWSfRj5D6LfVCUvhvtm0ztMl/Nd/JIyEfwUF01Ocz8JH/VJXNATaTZtvjCCVjZlpeXLlJjnKqsuhmnbCinI/2EgISqXsmkEZoZuDBNIsmG/AX/TqoudhhEk21H+PUN/1U7Sju8mEr8FD5wY4h9z87eizgBDuxms141tkmkfCah6ORw6cRh/xfkm8jAsoaR6in1Z9IKFfuIghUaCxSH8C/OaEST3M4Iykb8/4ngrXNY5iRLtQbAANBN8DLzfTUMg+QNB+SL25wWt/C6uh0i8O8GyH5Mo0P6I8hFK9RzwtTzUFh1feZ6tqvKphnlEDLki73Fl0VS6JTK0POJYVbhp/g8x5ONGN2KSep6A/vvgQeA88AOGdo9RRcimPmCrBznl/sOCg4Hf0chXPzAVcH/dYDJUo67YyW9Kv6oKQ/4YgukJRgns/OYE1gk5vLYao5RfQomob6YY9rIhaah/uwHk7ZG/h1mvU1vdgbKfaervVtkTGUdR0+MY1hHp/ojm6b4h9jp+S+jtHcNafgq+DmVlbCNx63A8n3BxYkUgjKJAmqm9i+DoaXCBzAn92O23oWwj9/TX9qFCuRyCD1B2jPW2I69Yd35aG/VtaFk7F5HX1iUkVB/Jy72o8VyCUhbql5jkQe3Fm1FaF6qg5Euu5kmWoP9Aw3iRDvbsCnCiblfhOQ3JIXBvQ2xP3i9Vta14EBId3rUT01zD+OUKKOW5gu/RmipdpR8pqs6msXXmk/Wkfuh4iE3St8yWmDYo7XdQQGkpYbwIrv/PkfzUqruImaAdfotaVjTdYgWUdt/5PHTR6OcbBifb0fl517ShuYWdRPL1N6jezyuqQwT50Yb+NgUAzCRKJJVCaXeIKv8zXsCHF1qklHeh6lmjG9Ik/4KxD11CBJ+BP3HA+vKV7NWKGtJBVoA57+fmqLSdmyw2ndiu72kA0OlVAmAspZ7tbIg5lYe225S6vak2g+nUqLTXdiq0fHvt8gNch1D0fQelnVCCw/r3Umxn/UCHKeMKMHcpZcedzDsB5hTaW2osc9WqPf1eWDnIH/15Vmkop2xCZU3IZoK5r9JmGyVffbTbZNyLWqVKkWjAfPxOR71DSgDeovdvIts2atsA5yecJsMwRgBULXKNi+QtcuiySAemSAuMM4uRj2yOe5Tz/VDWGXXSlfo5KJf8W8VzpcoTNd5ck5b2mrR1mY+jtiBYAiGRhHKTJxrscvACzKu/wamynZ15ZCe61MUhLjpdlSfHiRcmNzZp9EhFNdyF/Bp438/x1E2nYd0DeWtRBq/dfxsk9+mbaWPdhPxil0mdCCBctI/qTDZiaAOkXo0ieQMBZRgdqec51kaqG+F0mgw6nVQOs4mCHd7paTqHPh7yNEpkkYJptDVVWkaHzHYk4/l+KQbp9xmjCjqPon18byMjUTeJhgTHcm36Egs6HVOc164unB54HNOXGUuvzvYo+/vZlzkcQKsEEPNovJ4iX2Y7ArIHcwb6geTLvB5tnDy7igDndMRwuuzT1K6ek1gY4BijucgLAJypBuCONoxlz6G9Q5+XuRw4cTYWaWN0o6oXz1j1cFMYchmLOlk8oOvRxwGt2wKOmWGw+ZqKRACNEIEhIR8KsLn4LWN+rNSzTYMo2pSNJlFbCw1hjsEmL1Oh2QoobeqsGN2Nob4Gtf0JY6X96AXrFMM0L8AxbFW91qH8ckOeHdccZAByTzdguoA1X3c+ab6sZezYRwm93NDF29y3YS7hncZSku3oiR3NeK1I86V0SG16l4JnnOnGTi4WqKWcNF24CZh9HCYVS+nYBjwaHAeOPK3Mqc2Z3V4EgR+iiSB22AZls8R7+5NU42bpkmcyQy3rtW4LWecqg7SxGH7S5yHxwjYOwJQY4TDUmWIfEKQCyFcc3kluNLLBvQxlwxmPNX2MvZSAnE2pZQrBvcSNXYy+rlUjGGARKruRxjYSmLqjs4jm3gCGBu39KWKZmCyruSf2XCSI/57Y2AbQ2tGKX6DsSsaqv7CX9is3Eqdvni/zTsXm8UfxkXcbpVmMixPiRvEGzy2CAdmuXOwpcj2p1UmgFElCe7li+jvnHc846Hg1BEJKo/SXRRHTIwt1XiPIxVF7DPl96IhU0Z6Ooz0ZokmyWtQVZymLmzAHz59zM0rpCXfWxh9KCZuLugLsnRQG3fm+xQy465TFkJU4N8tNnrzcTEm8kxpP4oV5NDd60AzJD8Sub6CUlzW4j4d0Hn6vVVT6oxQcYgbFoayIkrAFneaFDInph2scA/GTeABH1RnsfeIrGATWJU0iQxbhGoDk+8yH2WEzTSxPtnJe22t0u1q1vI7SsANDHSpHsy+5QbkbL7DuS8ZOSWkJ+kiljXczDfMYgkrarDGMmcNT/y3wd8VZQD/Z4HKUZRBIg8k3EJwz+Z5hqDdfm8MetgvlulTQKRhP+6sLyp9EvVrW34LndAJdNq0nD18Jbcnxmq1mj1ODdrV0zJ7Bc4HRACwpfR/13mD/rTmnXQzJ3Uv1q65HFOe8Hm0POAEQ9S5hJOYt1NutjXkE5fl04Grx/CHzT4JTUbbBqrvaPcibHXFmJ5siMah/AvXFcf4PfZbs6dNn7DoVP/JlTqBobsM43Sxu+u9d7EA5CXOsunvmT/0SKDlug4uqbq5IXp3KG/JxMO0VkSZH9avLMzQjwhv7cTL6kHCZqNSQhn7c4ZES2a/3ryR9mWMMgfBTAdXkuO3eMn4ByhaUEocAym7eijQemG7/8GAdxbFO71N9XowAbAM2XXsmUP2/7kGracj178ohNcUmWkH7TEiu/iZCWhZcpMDcRI9UPmTYRAdJ7OaRDGnFQmIWerA6m6r8dIC29TsGyXFFF7nK7mLVfXQy0jp101NJ73+G/vGJR2cbmB7pAJXwlHw5JKu4F4A87q1KEwPT+/+YHp2P5P23N488YHrkkQdMjy5o+r8AAwBOX3LEzHhZHgAAAABJRU5ErkJggg=="
  , Qde = "/poit-app/assets/logo-bolagsverket-vit-5de182f7.svg";
const su = t => ($t("data-v-f586e3e1"),
t = t(),
Tt(),
t)
  , Zde = {
    class: "poit",
    id: "poit"
}
  , ece = {
    class: "poit__header py-3"
}
  , tce = {
    class: "container"
}
  , nce = {
    class: "col-xs-12 col-md-underline text-md-end"
}
  , rce = {
    class: "container d-flex flex-wrap justify-content-between"
}
  , ace = {
    class: "col-xs-12 d-flex align-items-center mb-3 mb-md-0 mx-auto mx-md-0 me-md-auto"
}
  , sce = su( () => c("img", {
    alt: "PoIT logo",
    src: Jde
}, null, -1))
  , lce = su( () => c("div", {
    class: "col-xs-12 mx-auto mx-md-0 mb-3 mb-md-1"
}, [c("a", {
    href: "https://bolagsverket.se/"
}, [c("img", {
    alt: "Bolagsverket logo",
    src: Xde
})])], -1))
  , ice = {
    class: "navbar navbar-expand-lg"
}
  , oce = {
    class: "container"
}
  , uce = su( () => c("span", {
    class: "offscreen",
    "aria-hidden": "false"
}, "Visa/dölj meny", -1))
  , dce = {
    class: "nav navbar"
}
  , cce = {
    class: "nav__item"
}
  , fce = {
    class: "nav__item"
}
  , pce = {
    class: "nav__item"
}
  , hce = {
    class: "flex-row justify-content-between ms-auto"
}
  , mce = {
    class: "actions order-2 order-md-1"
}
  , vce = {
    class: "container bg-light"
}
  , gce = {
    class: "row"
}
  , bce = {
    class: "col-12"
}
  , yce = {
    key: 0,
    class: "navbar navbar-expand nav-inloggad justify-content-center"
}
  , kce = {
    class: "poit__main bg-light p-4"
}
  , _ce = {
    class: "container"
}
  , wce = {
    class: "poit__footer"
}
  , xce = {
    class: "container d-flex flex-wrap justify-content-between"
}
  , Sce = su( () => c("div", {
    class: "col-xs-12 col-md-4 text-md-start"
}, [c("div", {
    class: "poit__footer__number"
}, [c("a", {
    href: "tel:+46-771-670670",
    class: "link__phonenumber"
}, "0771-670 670")]), c("p", null, [ve(" Bolagsverket "), c("br"), ve(" Post- och Inrikes Tidningar "), c("br"), ve(" 851 81 Sundsvall ")])], -1))
  , $ce = {
    class: "poit__footer-links col-xs-12 col-md-4"
}
  , Tce = {
    class: "mb-3 mb-md-1"
}
  , Cce = {
    class: "mb-3 mb-md-1"
}
  , Ece = {
    class: "mb-3 mb-md-1"
}
  , Ace = {
    target: "_blank",
    class: "poit__footer-link",
    rel: "noopener",
    href: "https://bolagsverket.se/om/webbplatsen/tillganglighet/post-och-inrikes-tidningar-tillganglighetsredogorelse-1.16923"
}
  , Mce = {
    class: "mb-3 mb-md-1"
}
  , Oce = {
    target: "_blank",
    class: "poit__footer-link",
    rel: "noopener",
    href: "https://bolagsverket.se/om/oss/verksamhet/sa-behandlar-vi-dina-personuppgifter/dina-personuppgifter/kundregister-for-post-och-inrikes-tidningar-sa-behandlar-vi-personuppgifter-1.16707"
}
  , Nce = {
    class: "mb-3 mb-md-1"
}
  , Dce = su( () => c("div", {
    class: "col-xs-12 col-md-4 mt-2 mt-md-0 text-md-center align-self-end"
}, [c("img", {
    alt: "Bolagsverketvitlogo",
    style: {
        width: "188px"
    },
    src: Qde
})], -1));
function Pce(t, e, n, r, a, s) {
    const l = ue("router-link")
      , i = ue("i-bi-x")
      , o = ue("i-bi-list")
      , u = ue("i-bi-box-arrow-in-right")
      , d = ue("i-bi-box-arrow-in-left")
      , f = ue("i-bi-box-arrow-up-right");
    return g(),
    _("div", Zde, [c("header", ece, [c("div", tce, [c("div", nce, [c("p", null, [x(l, {
        class: "header__navlink",
        to: {
            name: "inenglish"
        }
    }, {
        default: N( () => [ve("In English")]),
        _: 1
    })])])]), c("div", rce, [c("div", ace, [x(l, {
        to: {
            name: "home"
        },
        title: "Till startsidan, PoIT"
    }, {
        default: N( () => [sce]),
        _: 1
    })]), lce])]), c("nav", ice, [c("div", oce, [c("button", {
        class: "navbar-toggler border-0 rounded-0 py-2 ms-3",
        onClick: e[0] || (e[0] = (...p) => t.toggleMenu && t.toggleMenu(...p)),
        type: "button",
        "data-toggle": "collapse",
        "data-target": "#exCollapsingNavbar"
    }, [t.wrapActive ? (g(),
    de(i, {
        key: 0,
        role: "img",
        class: "b-icon bi",
        "aria-label": "x",
        focusable: "false"
    })) : (g(),
    de(o, {
        key: 1,
        role: "img",
        class: "b-icon bi",
        "aria-label": "list",
        focusable: "false"
    })), uce]), c("div", {
        class: ye(["collapse navbar-collapse", [t.wrapActive ? "mainNav__wrap--active" : ""]]),
        id: "exCollapsingNavbar"
    }, [c("ul", dce, [c("li", cce, [x(l, {
        onClick: t.closeMenu,
        class: "nav__link",
        to: {
            name: "home"
        }
    }, {
        default: N( () => [ve("Start")]),
        _: 1
    }, 8, ["onClick"])]), c("li", fce, [x(l, {
        onClick: t.closeMenu,
        class: "nav__link",
        to: {
            name: "sok"
        }
    }, {
        default: N( () => [ve("Sök kungörelse")]),
        _: 1
    }, 8, ["onClick"])]), c("li", pce, [x(l, {
        onClick: t.closeMenu,
        class: "nav__link",
        to: {
            name: "sok-arsredovisning"
        }
    }, {
        default: N( () => [ve("Sök kungörelse av årsredovisning")]),
        _: 1
    }, 8, ["onClick"])])])], 2), c("div", hce, [c("span", mce, [t.kundanvandare == null ? (g(),
    de(l, {
        key: 0,
        class: "actions__blikund",
        to: {
            name: "blikund"
        }
    }, {
        default: N( () => [ve("Bli kund")]),
        _: 1
    })) : q("", !0), t.kundanvandare == null ? (g(),
    de(l, {
        key: 1,
        class: "actions__loggain",
        to: {
            name: "loggain"
        }
    }, {
        default: N( () => [x(u, {
            role: "img",
            class: "b-icon bi me-2",
            "aria-label": "box arrow in right",
            focusable: "false"
        }), ve(" Logga in ")]),
        _: 1
    })) : q("", !0), t.kundanvandare != null ? (g(),
    _("button", {
        key: 2,
        class: "actions__loggaut",
        onClick: e[1] || (e[1] = (...p) => t.loggaut && t.loggaut(...p))
    }, [x(d, {
        role: "img",
        class: "b-icon bi me-2",
        "aria-label": "box arrow in left",
        focusable: "false"
    }), ve(" Logga ut ")])) : q("", !0)])])])]), c("div", vce, [c("div", gce, [c("div", bce, [t.kundanvandare != null ? (g(),
    _("nav", yce, [x(l, {
        class: "nav-link",
        onClick: e[2] || (e[2] = () => t.setRensaSokHistorik(!0)),
        to: {
            name: "publiceradekungorelser"
        }
    }, {
        default: N( () => [ve("Sök eller rätta publicerade kungörelser")]),
        _: 1
    }), x(l, {
        class: "nav-link",
        to: {
            name: "registrera"
        }
    }, {
        default: N( () => [ve("Registrera kungörelse")]),
        _: 1
    }), x(l, {
        class: "nav-link",
        to: {
            name: "sokfaktura"
        }
    }, {
        default: N( () => [ve("Sök faktura")]),
        _: 1
    }), x(l, {
        class: "nav-link",
        to: {
            name: "minakunder"
        }
    }, {
        default: N( () => [ve("Mina kunder")]),
        _: 1
    }), x(l, {
        class: "nav-link",
        to: {
            name: "minauppgifter"
        }
    }, {
        default: N( () => [ve("Mina uppgifter")]),
        _: 1
    })])) : q("", !0)])])]), c("main", kce, [c("div", _ce, [Z(t.$slots, "default", {}, void 0, !0)])]), c("footer", wce, [c("div", xce, [Sce, c("div", $ce, [c("p", Tce, [x(l, {
        class: "poit__footer-link",
        to: {
            name: "kontaktaoss"
        }
    }, {
        default: N( () => [ve("Kontakta oss")]),
        _: 1
    })]), c("p", Cce, [x(l, {
        class: "poit__footer-link",
        to: {
            name: "omtjansten"
        }
    }, {
        default: N( () => [ve("Om tjänsten")]),
        _: 1
    })]), c("p", Ece, [c("a", Ace, [ve("Tillgänglighet "), x(f, {
        role: "img",
        class: "b-icon bi ms-2",
        "aria-label": "box arrow up right",
        focusable: "false"
    })])]), c("p", Mce, [c("a", Oce, [ve("Personuppgifter "), x(f, {
        role: "img",
        class: "b-icon bi ms-2",
        "aria-label": "box arrow up right",
        focusable: "false"
    })])]), c("p", Nce, [x(l, {
        class: "poit__footer-link",
        to: {
            name: "villkor"
        }
    }, {
        default: N( () => [ve("Villkor")]),
        _: 1
    })])]), Dce])])])
}
const Fce = rt(Yde, [["render", Pce], ["__scopeId", "data-v-f586e3e1"]])
  , Bce = hE()
  , Di = Q1(ME);
Di.component("FormGroup", Na);
Di.use(k4);
Di.use(Bce);
Di.use(Ode);
Di.component("default-layout", Fce);
Di.mount("#app");
Pe().getKoppling();
